################################################################################
# FULL PROJECT DUMP (NO TRUNCATION)
# FORMAT FOR LLM:
#   1) PROJECT TREE — общая структура проекта.
#   2) FILES INDEX — плоский список файлов с путём и языком.
#   3) FILES CONTENT — для каждого файла:
#        ===== FILE START =====
#        FILE_INDEX: <N>
#        PATH: <relative/path>
#        LANG: <language>
#        ===== CONTENT START =====
#        <raw file content>
#        ===== CONTENT END =====
#        ===== FILE END =====
#   Файлы идут в том же порядке, что и в индексе.
################################################################################
# Root: C:\Users\Sultan\Downloads\parkshare_ru_part1
# Generated at: 2025-12-07 03:37:57
# Files listed: 223
# Max single file size: NONE
# Max total dump size: NONE
# Code compression enabled: False
################################################################################
PROJECT TREE:
--------------------------------------------------------------------------------
parkshare_ru_part1/
    .env
    .env.example
    .env.prod
    .gitattributes
    .gitignore
    Dockerfile
    README.md
    api_server.py
    app.js
    celerybeat-schedule.bak
    celerybeat-schedule.dat
    celerybeat-schedule.dir
    database.py
    docker-compose.prod.yml
    docker-compose.yml
    dump_project.py
    entrypoint.sh
    index.html
    model_training.py
    project_dump.txt
    requirements.txt
    run_dev.bat
    run_dev.py
    run_dev.sh
    accounts/
        __init__.py
        admin.py
        apps.py
        auth.py
        forms.py
        models.py
        serializers.py
        urls.py
        utils.py
        views.py
        migrations/
            0001_initial.py
            0002_user_email_hash_user_phone_hash_logincode.py
            0003_userlevel_userbadge_promoreward.py
            __init__.py
    ai/
        __init__.py
        admin.py
        apps.py
        features.py
        models.py
        orchestrator.py
        pricing.py
        serializers.py
        tasks.py
        views.py
        chat/
            __init__.py
            parking_assistant.py
        management/
            __init__.py
            commands/
                __init__.py
                train_chat_intents_from_logs.py
        migrations/
            0001_initial.py
            __init__.py
    ai_models/
    ai_services/
        __init__.py
        ai_pricing_service/
            __init__.py
            main.py
        cv_service/
            __init__.py
            main.py
    backend/
        __init__.py
        manage.py
        backend/
            __init__.py
            config/
                __init__.py
                asgi.py
                celery.py
                urls.py
                wsgi.py
            settings/
                __init__.py
                base.py
                local.py
                production.py
                regions.py
        rest_framework_simplejwt/
            __init__.py
            authentication.py
            tokens.py
            views.py
        tests/
            __init__.py
            test_auth_api.py
            test_booking_model.py
            test_ui_theme_chat.py
    core/
        __init__.py
        admin.py
        apps.py
        context_processors.py
        integrations.py
        middleware.py
        models.py
        pagination.py
        permissions.py
        utils.py
    drf_spectacular/
        __init__.py
        openapi.py
        views.py
    frontend/
        next-app/
            .env.local
            .eslintrc.json
            Dockerfile
            jest.config.js
            jest.setup.ts
            next-env.d.ts
            next.config.mjs
            package.json
            postcss.config.js
            tailwind.config.ts
            tsconfig.json
            app/
                globals.css
                layout.tsx
                (site)/
                    layout.tsx
                    page.tsx
                    auth/
                        page.tsx
                api/
                    chat/
                        route.ts
                embed/
                    page.tsx
            components/
                header.tsx
                providers.tsx
                theme-provider.tsx
                theme-toggle.tsx
                chat/
                    chat-panel.tsx
                    compact-chat-panel.tsx
                    conversation-list.tsx
                    markdown-message.tsx
                    suggested-prompts.tsx
                    types.ts
                pwa/
                    register-service-worker.tsx
                widget/
                    chat-widget.tsx
            context/
                AuthContext.tsx
            hooks/
                useAuth.ts
            lib/
                aiProvider.ts
                authClient.ts
                chatClient.ts
                llmClient.ts
            public/
                manifest.webmanifest
                offline.html
                service-worker.js
                icons/
            __tests__/
                chat-client.test.ts
                conversation-list.test.tsx
        parkmate/
            parkmate.types.ts
    nginx/
        nginx.conf
    parking/
        __init__.py
        admin.py
        apps.py
        models.py
        push.py
        serializers.py
        tasks.py
        urls.py
        views.py
        management/
            commands/
                seed_demo_parking.py
        migrations/
            0001_initial.py
            0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
            0003_booking_ai_fields.py
            0004_favoriteparkingspot_savedplace.py
            0005_pushsubscription.py
            __init__.py
        tests/
            __init__.py
            test_pwa_endpoints.py
    payments/
        __init__.py
        admin.py
        apps.py
        models.py
        providers.py
        serializers.py
        tasks.py
        views.py
        migrations/
            0001_initial.py
            0002_alter_payment_provider.py
            0003_paymentmethod.py
            __init__.py
        providers/
            __init__.py
            base.py
            registry.py
            stripe.py
            yookassa.py
    regions/
        global.yml
        ru.yml
    services/
        __init__.py
        llm.py
        llm_service/
            Dockerfile
            main.py
            requirements.txt
    static/
        manifest.webmanifest
        service-worker.js
        css/
            app.css
            cinematic-ui.css
        icons/
        js/
            app.js
            chat.js
            map.js
            parkmate-ai.ts
            quantum-theme-manager.js
            theme.js
        pwa/
            api-client.js
            app.js
            router.js
            spots-view.js
            state-store.js
            ui-kit.js
    templates/
        base.html
        offline.html
        accounts/
            login.html
            password_change.html
            password_change_done.html
            password_reset.html
            password_reset_complete.html
            password_reset_confirm.html
            password_reset_done.html
            password_reset_email.txt
            password_reset_subject.txt
            profile.html
            register.html
        ai/
            concierge.html
        parking/
            landing.html
            map_fullscreen.html
            owner_dashboard.html
            pwa_install.html
            user_dashboard.html
    vehicles/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py


FILES INDEX:
--------------------------------------------------------------------------------
1. PATH=.env | LANG=text
2. PATH=.env.example | LANG=text
3. PATH=.env.prod | LANG=text
4. PATH=.gitattributes | LANG=text
5. PATH=.gitignore | LANG=text
6. PATH=Dockerfile | LANG=text
7. PATH=README.md | LANG=markdown
8. PATH=api_server.py | LANG=python
9. PATH=app.js | LANG=javascript
10. PATH=celerybeat-schedule.bak | LANG=text
11. PATH=celerybeat-schedule.dat | LANG=text
12. PATH=celerybeat-schedule.dir | LANG=text
13. PATH=database.py | LANG=python
14. PATH=docker-compose.prod.yml | LANG=yaml
15. PATH=docker-compose.yml | LANG=yaml
16. PATH=dump_project.py | LANG=python
17. PATH=entrypoint.sh | LANG=bash
18. PATH=index.html | LANG=html
19. PATH=model_training.py | LANG=python
20. PATH=project_dump.txt | LANG=text
21. PATH=requirements.txt | LANG=text
22. PATH=run_dev.bat | LANG=batch
23. PATH=run_dev.py | LANG=python
24. PATH=run_dev.sh | LANG=bash
25. PATH=accounts\__init__.py | LANG=python
26. PATH=accounts\admin.py | LANG=python
27. PATH=accounts\apps.py | LANG=python
28. PATH=accounts\auth.py | LANG=python
29. PATH=accounts\forms.py | LANG=python
30. PATH=accounts\models.py | LANG=python
31. PATH=accounts\serializers.py | LANG=python
32. PATH=accounts\urls.py | LANG=python
33. PATH=accounts\utils.py | LANG=python
34. PATH=accounts\views.py | LANG=python
35. PATH=accounts\migrations\0001_initial.py | LANG=python
36. PATH=accounts\migrations\0002_user_email_hash_user_phone_hash_logincode.py | LANG=python
37. PATH=accounts\migrations\0003_userlevel_userbadge_promoreward.py | LANG=python
38. PATH=accounts\migrations\__init__.py | LANG=python
39. PATH=ai\__init__.py | LANG=python
40. PATH=ai\admin.py | LANG=python
41. PATH=ai\apps.py | LANG=python
42. PATH=ai\features.py | LANG=python
43. PATH=ai\models.py | LANG=python
44. PATH=ai\orchestrator.py | LANG=python
45. PATH=ai\pricing.py | LANG=python
46. PATH=ai\serializers.py | LANG=python
47. PATH=ai\tasks.py | LANG=python
48. PATH=ai\views.py | LANG=python
49. PATH=ai\chat\__init__.py | LANG=python
50. PATH=ai\chat\parking_assistant.py | LANG=python
51. PATH=ai\management\__init__.py | LANG=python
52. PATH=ai\management\commands\__init__.py | LANG=python
53. PATH=ai\management\commands\train_chat_intents_from_logs.py | LANG=python
54. PATH=ai\migrations\0001_initial.py | LANG=python
55. PATH=ai\migrations\__init__.py | LANG=python
56. PATH=ai_services\__init__.py | LANG=python
57. PATH=ai_services\ai_pricing_service\__init__.py | LANG=python
58. PATH=ai_services\ai_pricing_service\main.py | LANG=python
59. PATH=ai_services\cv_service\__init__.py | LANG=python
60. PATH=ai_services\cv_service\main.py | LANG=python
61. PATH=backend\__init__.py | LANG=python
62. PATH=backend\manage.py | LANG=python
63. PATH=backend\backend\__init__.py | LANG=python
64. PATH=backend\backend\config\__init__.py | LANG=python
65. PATH=backend\backend\config\asgi.py | LANG=python
66. PATH=backend\backend\config\celery.py | LANG=python
67. PATH=backend\backend\config\urls.py | LANG=python
68. PATH=backend\backend\config\wsgi.py | LANG=python
69. PATH=backend\backend\settings\__init__.py | LANG=python
70. PATH=backend\backend\settings\base.py | LANG=python
71. PATH=backend\backend\settings\local.py | LANG=python
72. PATH=backend\backend\settings\production.py | LANG=python
73. PATH=backend\backend\settings\regions.py | LANG=python
74. PATH=backend\rest_framework_simplejwt\__init__.py | LANG=python
75. PATH=backend\rest_framework_simplejwt\authentication.py | LANG=python
76. PATH=backend\rest_framework_simplejwt\tokens.py | LANG=python
77. PATH=backend\rest_framework_simplejwt\views.py | LANG=python
78. PATH=backend\tests\__init__.py | LANG=python
79. PATH=backend\tests\test_auth_api.py | LANG=python
80. PATH=backend\tests\test_booking_model.py | LANG=python
81. PATH=backend\tests\test_ui_theme_chat.py | LANG=python
82. PATH=core\__init__.py | LANG=python
83. PATH=core\admin.py | LANG=python
84. PATH=core\apps.py | LANG=python
85. PATH=core\context_processors.py | LANG=python
86. PATH=core\integrations.py | LANG=python
87. PATH=core\middleware.py | LANG=python
88. PATH=core\models.py | LANG=python
89. PATH=core\pagination.py | LANG=python
90. PATH=core\permissions.py | LANG=python
91. PATH=core\utils.py | LANG=python
92. PATH=drf_spectacular\__init__.py | LANG=python
93. PATH=drf_spectacular\openapi.py | LANG=python
94. PATH=drf_spectacular\views.py | LANG=python
95. PATH=frontend\next-app\.env.local | LANG=text
96. PATH=frontend\next-app\.eslintrc.json | LANG=json
97. PATH=frontend\next-app\Dockerfile | LANG=text
98. PATH=frontend\next-app\jest.config.js | LANG=javascript
99. PATH=frontend\next-app\jest.setup.ts | LANG=typescript
100. PATH=frontend\next-app\next-env.d.ts | LANG=typescript
101. PATH=frontend\next-app\next.config.mjs | LANG=text
102. PATH=frontend\next-app\package.json | LANG=json
103. PATH=frontend\next-app\postcss.config.js | LANG=javascript
104. PATH=frontend\next-app\tailwind.config.ts | LANG=typescript
105. PATH=frontend\next-app\tsconfig.json | LANG=json
106. PATH=frontend\next-app\app\globals.css | LANG=css
107. PATH=frontend\next-app\app\layout.tsx | LANG=tsx
108. PATH=frontend\next-app\app\(site)\layout.tsx | LANG=tsx
109. PATH=frontend\next-app\app\(site)\page.tsx | LANG=tsx
110. PATH=frontend\next-app\app\(site)\auth\page.tsx | LANG=tsx
111. PATH=frontend\next-app\app\api\chat\route.ts | LANG=typescript
112. PATH=frontend\next-app\app\embed\page.tsx | LANG=tsx
113. PATH=frontend\next-app\components\header.tsx | LANG=tsx
114. PATH=frontend\next-app\components\providers.tsx | LANG=tsx
115. PATH=frontend\next-app\components\theme-provider.tsx | LANG=tsx
116. PATH=frontend\next-app\components\theme-toggle.tsx | LANG=tsx
117. PATH=frontend\next-app\components\chat\chat-panel.tsx | LANG=tsx
118. PATH=frontend\next-app\components\chat\compact-chat-panel.tsx | LANG=tsx
119. PATH=frontend\next-app\components\chat\conversation-list.tsx | LANG=tsx
120. PATH=frontend\next-app\components\chat\markdown-message.tsx | LANG=tsx
121. PATH=frontend\next-app\components\chat\suggested-prompts.tsx | LANG=tsx
122. PATH=frontend\next-app\components\chat\types.ts | LANG=typescript
123. PATH=frontend\next-app\components\pwa\register-service-worker.tsx | LANG=tsx
124. PATH=frontend\next-app\components\widget\chat-widget.tsx | LANG=tsx
125. PATH=frontend\next-app\context\AuthContext.tsx | LANG=tsx
126. PATH=frontend\next-app\hooks\useAuth.ts | LANG=typescript
127. PATH=frontend\next-app\lib\aiProvider.ts | LANG=typescript
128. PATH=frontend\next-app\lib\authClient.ts | LANG=typescript
129. PATH=frontend\next-app\lib\chatClient.ts | LANG=typescript
130. PATH=frontend\next-app\lib\llmClient.ts | LANG=typescript
131. PATH=frontend\next-app\public\manifest.webmanifest | LANG=text
132. PATH=frontend\next-app\public\offline.html | LANG=html
133. PATH=frontend\next-app\public\service-worker.js | LANG=javascript
134. PATH=frontend\next-app\__tests__\chat-client.test.ts | LANG=typescript
135. PATH=frontend\next-app\__tests__\conversation-list.test.tsx | LANG=tsx
136. PATH=frontend\parkmate\parkmate.types.ts | LANG=typescript
137. PATH=nginx\nginx.conf | LANG=text
138. PATH=parking\__init__.py | LANG=python
139. PATH=parking\admin.py | LANG=python
140. PATH=parking\apps.py | LANG=python
141. PATH=parking\models.py | LANG=python
142. PATH=parking\push.py | LANG=python
143. PATH=parking\serializers.py | LANG=python
144. PATH=parking\tasks.py | LANG=python
145. PATH=parking\urls.py | LANG=python
146. PATH=parking\views.py | LANG=python
147. PATH=parking\management\commands\seed_demo_parking.py | LANG=python
148. PATH=parking\migrations\0001_initial.py | LANG=python
149. PATH=parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py | LANG=python
150. PATH=parking\migrations\0003_booking_ai_fields.py | LANG=python
151. PATH=parking\migrations\0004_favoriteparkingspot_savedplace.py | LANG=python
152. PATH=parking\migrations\0005_pushsubscription.py | LANG=python
153. PATH=parking\migrations\__init__.py | LANG=python
154. PATH=parking\tests\__init__.py | LANG=python
155. PATH=parking\tests\test_pwa_endpoints.py | LANG=python
156. PATH=payments\__init__.py | LANG=python
157. PATH=payments\admin.py | LANG=python
158. PATH=payments\apps.py | LANG=python
159. PATH=payments\models.py | LANG=python
160. PATH=payments\providers.py | LANG=python
161. PATH=payments\serializers.py | LANG=python
162. PATH=payments\tasks.py | LANG=python
163. PATH=payments\views.py | LANG=python
164. PATH=payments\migrations\0001_initial.py | LANG=python
165. PATH=payments\migrations\0002_alter_payment_provider.py | LANG=python
166. PATH=payments\migrations\0003_paymentmethod.py | LANG=python
167. PATH=payments\migrations\__init__.py | LANG=python
168. PATH=payments\providers\__init__.py | LANG=python
169. PATH=payments\providers\base.py | LANG=python
170. PATH=payments\providers\registry.py | LANG=python
171. PATH=payments\providers\stripe.py | LANG=python
172. PATH=payments\providers\yookassa.py | LANG=python
173. PATH=regions\global.yml | LANG=yaml
174. PATH=regions\ru.yml | LANG=yaml
175. PATH=services\__init__.py | LANG=python
176. PATH=services\llm.py | LANG=python
177. PATH=services\llm_service\Dockerfile | LANG=text
178. PATH=services\llm_service\main.py | LANG=python
179. PATH=services\llm_service\requirements.txt | LANG=text
180. PATH=static\manifest.webmanifest | LANG=text
181. PATH=static\service-worker.js | LANG=javascript
182. PATH=static\css\app.css | LANG=css
183. PATH=static\css\cinematic-ui.css | LANG=css
184. PATH=static\js\app.js | LANG=javascript
185. PATH=static\js\chat.js | LANG=javascript
186. PATH=static\js\map.js | LANG=javascript
187. PATH=static\js\parkmate-ai.ts | LANG=typescript
188. PATH=static\js\quantum-theme-manager.js | LANG=javascript
189. PATH=static\js\theme.js | LANG=javascript
190. PATH=static\pwa\api-client.js | LANG=javascript
191. PATH=static\pwa\app.js | LANG=javascript
192. PATH=static\pwa\router.js | LANG=javascript
193. PATH=static\pwa\spots-view.js | LANG=javascript
194. PATH=static\pwa\state-store.js | LANG=javascript
195. PATH=static\pwa\ui-kit.js | LANG=javascript
196. PATH=templates\base.html | LANG=html
197. PATH=templates\offline.html | LANG=html
198. PATH=templates\accounts\login.html | LANG=html
199. PATH=templates\accounts\password_change.html | LANG=html
200. PATH=templates\accounts\password_change_done.html | LANG=html
201. PATH=templates\accounts\password_reset.html | LANG=html
202. PATH=templates\accounts\password_reset_complete.html | LANG=html
203. PATH=templates\accounts\password_reset_confirm.html | LANG=html
204. PATH=templates\accounts\password_reset_done.html | LANG=html
205. PATH=templates\accounts\password_reset_email.txt | LANG=text
206. PATH=templates\accounts\password_reset_subject.txt | LANG=text
207. PATH=templates\accounts\profile.html | LANG=html
208. PATH=templates\accounts\register.html | LANG=html
209. PATH=templates\ai\concierge.html | LANG=html
210. PATH=templates\parking\landing.html | LANG=html
211. PATH=templates\parking\map_fullscreen.html | LANG=html
212. PATH=templates\parking\owner_dashboard.html | LANG=html
213. PATH=templates\parking\pwa_install.html | LANG=html
214. PATH=templates\parking\user_dashboard.html | LANG=html
215. PATH=vehicles\__init__.py | LANG=python
216. PATH=vehicles\admin.py | LANG=python
217. PATH=vehicles\apps.py | LANG=python
218. PATH=vehicles\models.py | LANG=python
219. PATH=vehicles\serializers.py | LANG=python
220. PATH=vehicles\urls.py | LANG=python
221. PATH=vehicles\views.py | LANG=python
222. PATH=vehicles\migrations\0001_initial.py | LANG=python
223. PATH=vehicles\migrations\__init__.py | LANG=python


================================================================================
FILES CONTENT:
================================================================================

===== FILE START =====
FILE_INDEX: 1
PATH: .env
LANG: text
===== CONTENT START =====
DEBUG=1
SECRET_KEY=django-insecure-test-secret-key-for-dev-only
ALLOWED_HOSTS=127.0.0.1,localhost
DATABASE_NAME=db.sqlite3

YOOKASSA_SHOP_ID=
YOOKASSA_SECRET_KEY=

EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend

# Карты / регион
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc


# Старый токен Mapbox
MAPBOX_TOKEN=your_actual_token_here

# OpenAI - ВРЕМЕННО ОТКЛЮЧИТЬ (невалидный ключ)
# OPENAI_API_KEY=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

# LLM Service
LLM_SERVICE_URL=http://localhost:8002
LLM_DEFAULT_MODEL=groq/llama-3.1-8b-instant
LLM_FALLBACK_MODELS='["groq/llama-3.1-8b-instant"]'

# Groq API (основной провайдер)
LLM_GROQ_API_KEY=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

# Настройки LLM
LLM_CACHE_ENABLED=true
LLM_CACHE_TTL_SECONDS=30
LLM_REQUESTS_PER_MINUTE=60

# Django Settings
DJANGO_SETTINGS_MODULE=backend.backend.settings.local

# Redis & Celery
REDIS_URL=redis://localhost:6379/0
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0

# Database
DATABASE_URL=sqlite:///db.sqlite3
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 2
PATH: .env.example
LANG: text
===== CONTENT START =====
# Базовые настройки Django
DEBUG=False
SECRET_KEY=change_me_to_random_long_secret_key
ALLOWED_HOSTS=localhost,127.0.0.1,0.0.0.0
PLATFORM_MODE=RU

# База данных
# Для продакшена: postgres://user:password@db:5432/parkshare
# Django-environ автоматически распарсит URL.
DATABASE_URL=postgres://parkshare:parkshare@db:5432/parkshare

# Payments
PAYMENT_PROVIDER=yookassa
YOOKASSA_SHOP_ID=YOUR_SHOP_ID
YOOKASSA_SECRET_KEY=YOUR_SECRET
YOOKASSA_RETURN_URL=https://SERVER_HOST/payments/return/
YOOKASSA_WEBHOOK_SECRET=YOUR_WEBHOOK_SECRET
STRIPE_SECRET_KEY=YOUR_STRIPE_KEY
STRIPE_WEBHOOK_SECRET=YOUR_STRIPE_WEBHOOK_SECRET

# Redis (брокер/кэш)
REDIS_URL=redis://redis:6379/0

# Таймзона и язык
TIME_ZONE=Europe/Moscow
LANGUAGE_CODE=ru-ru

# Соль для хэширования цифр номеров
VEHICLE_PLATE_SALT=change_me_vehicle_plate_salt

# Настройки CORS (если нужен доступ с другого домена, например, моб. WebView)
CORS_ALLOWED_ORIGINS=http://localhost:8000

# Настройки Celery
CELERY_BROKER_URL=${REDIS_URL}
CELERY_RESULT_BACKEND=${REDIS_URL}

# Настройки YooKassa (пример)
YOOKASSA_SHOP_ID=your_shop_id_here
YOOKASSA_SECRET_KEY=your_secret_key_here
YOOKASSA_RETURN_URL=https://example.com/payments/return/
YOOKASSA_WEBHOOK_SECRET=change_me_webhook_secret

# Комиссия сервиса (процент, будет использована в бизнес-логике)
SERVICE_COMMISSION_PERCENT=10

# Безопасность для продакшена
SECURE_SSL_REDIRECT=False
SESSION_COOKIE_SECURE=False
CSRF_COOKIE_SECURE=False

# Регион / карты
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc


# Next.js Auth (frontend/next-app)
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=change_me_nextauth_secret
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# AI Provider
OPENAI_API_KEY=your_openai_api_key
AI_MODEL=gpt-3.5-turbo

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 3
PATH: .env.prod
LANG: text
===== CONTENT START =====
# -----------------------------
# DJANGO SETTINGS (PROD)
# -----------------------------
DEBUG=0
SECRET_KEY=django-insecure-поставь_сюда_очень_длинную_строку_символов
ALLOWED_HOSTS=your-domain.ru,your-domain.com,127.0.0.1

DJANGO_SETTINGS_MODULE=backend.settings.production

# -----------------------------
# DATABASE (PostgreSQL / PostGIS)
# -----------------------------
DATABASE_NAME=parkshare
DATABASE_USER=parkshare
DATABASE_PASSWORD=сильный_пароль_к_бд
DATABASE_HOST=db
DATABASE_PORT=5432

# -----------------------------
# YOOKASSA PAYMENTS (боевые реквизиты)
# -----------------------------
YOOKASSA_SHOP_ID=твой_shop_id
YOOKASSA_SECRET_KEY=твой_secret_key

# -----------------------------
# EMAIL SETTINGS
# -----------------------------
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.yandex.ru
EMAIL_PORT=465
EMAIL_USE_SSL=1
EMAIL_HOST_USER=no-reply@your-domain.ru
EMAIL_HOST_PASSWORD=пароль_от_почты

# -----------------------------
# MAP / REGION
# -----------------------------
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc
MAPBOX_TOKEN=your_actual_token_here

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 4
PATH: .gitattributes
LANG: text
===== CONTENT START =====
# Auto detect text files and perform LF normalization
* text=auto

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 5
PATH: .gitignore
LANG: text
===== CONTENT START =====
db.sqlite3
__pycache__/
*.pyc
.env
staticfiles/
frontend/next-app/node_modules/
.next/
node_modules/

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 6
PATH: Dockerfile
LANG: text
===== CONTENT START =====
# Production-ready Dockerfile
FROM python:3.12-slim AS builder
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    gdal-bin \
    libgdal-dev \
    binutils \
    libproj-dev \
    libgeos-dev \
    libspatialindex-dev \
    gettext \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt
COPY . /app/

RUN python backend/manage.py collectstatic --noinput --settings=backend.backend.settings.production || true

FROM python:3.12-slim AS runtime
ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1
WORKDIR /app

COPY --from=builder /usr/local/lib/python3.12 /usr/local/lib/python3.12
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app /app

EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD curl -f http://localhost:8000/health/ || exit 1
CMD ["gunicorn", "backend.config.wsgi:application", "--bind", "0.0.0.0:8000"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 7
PATH: README.md
LANG: markdown
===== CONTENT START =====
# ParkShare Global Platform

Унифицированная архитектура для ParkShare с профилями RU/GLOBAL, защищёнными настройками и PWA фронтендом.

## Запуск
```bash
docker-compose up --build
```
ENVIRONMENT выбирается через переменные окружения и файлы `.env.<profile>`.

Для локальной разработки без зависимостей PostGIS/GDAL установите `USE_GIS=False` и задайте
`DATABASE_URL=sqlite:///db.sqlite3`, чтобы Django использовал SQLite и не требовал GDAL.

## Контейнеры
- PostGIS (db)
- Redis (cache/rate limit/Celery)
- Gunicorn web (Django)
- Celery worker/beat
- Nginx как TLS-терминатор

## Безопасность
- JWT + refresh токены (`/api/auth/token`, `/api/auth/token/refresh`)
- Rate limiting, CSP, HSTS, Referrer/Permissions Policy (`core/middleware.py`, `backend/settings`)
- Provider registry (`providers/`)
- Транзакционные блокировки бронирований (`parking/views.py`)

## PWA
- Сервис-воркер с разными стратегиями кэширования (`static/service-worker.js`)
- Offline fallback (`templates/offline.html`)

## AI
- Динамическое ценообразование, рекомендации, CV и антифрод (`ai/engines.py`, `services/ai.py`)

## Frontend (Next.js AI Concierge)
- Apple-стиль витрина в `frontend/next-app` на Next.js + Tailwind + PWA
- Мульти-провайдерный AI (LLM_PROVIDER/LLM_API_URL/LLM_API_KEY) с потоковыми ответами, копированием, перегенерацией и сохранённой историей по пользователю
- Поддержка светлой/тёмной темы, липкого ввода, пресетов, избранных подсказок и онбординга
- Соц/OAuth (VK/Яндекс/Google) + телефон OTP + почта/пароль, история чатов привязывается к профилю; гостевой режим хранит историю в браузере
- Встроенный PWA (манифест + сервис-воркер) с кешем оболочки, offline fallback и безопасными заголовками

### Auth setup
1. Скопируйте `.env.example` в `.env.local` рядом с frontend: заполните `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, `NEXTAUTH_SECRET`, `NEXTAUTH_URL`.
2. Укажите бэкенд для экранов `/auth`: `NEXT_PUBLIC_AUTH_API_URL` (или `NEXT_PUBLIC_AUTH_API_BASE`), `NEXT_PUBLIC_VK_CLIENT_ID`, `NEXT_PUBLIC_VK_REDIRECT_URI`, `NEXT_PUBLIC_YANDEX_CLIENT_ID`, `NEXT_PUBLIC_YANDEX_REDIRECT_URI`. Телефонный OTP ожидает `/auth/otp/request` и `/auth/otp/verify`; почта/пароль — `/auth/email/login` и `/auth/email/register`.
3. Настройте LLM: `LLM_PROVIDER` (`openai`|`proxy`|`custom`), `LLM_API_URL`, `LLM_API_KEY`, по желанию `LLM_AUTH_HEADER`/`LLM_AUTH_SCHEME` и `LLM_MODEL`. Без ключей чат вернёт демо-ответ.
4. В каталоге `frontend/next-app` установите зависимости (`npm install`) и запустите дев-сервер: `npm run dev` (порт 3000 по умолчанию).
5. PWA: манифест `public/manifest.webmanifest`, сервис-воркер `public/service-worker.js` (стратегия SWR для статики, offline fallback). Регистрация — `components/pwa/register-service-worker.tsx` (только в продакшене).

### PWA / offline
- Манифест: `public/manifest.webmanifest`, иконки в `public/icons/`
- Сервис-воркер: `public/service-worker.js` кэширует shell, статику и отдает `offline.html` для навигации без сети.
- Регистрация происходит на клиенте в продакшене (`components/pwa/register-service-worker.tsx`).
- Проверка установки: откройте Lighthouse/Chrome DevTools → Application → Manifest/Service Workers; включите offline и обновите страницу.

### Next.js AI Concierge – Docker & CI
- Сборка образа: `cd frontend/next-app && docker build -t parkshare-next .`
- Запуск локально: `docker run -p 3000:3000 --env-file .env.local parkshare-next`
- CI: GitHub Actions workflow `.github/workflows/frontend-next.yml` валидирует `npm test`, `npm run lint`, `npm run build` и сборку Docker.

### Frontend testing
- Тесты лежат в `frontend/next-app/__tests__` и используют Jest + React Testing Library.
- Запуск всех тестов: `cd frontend/next-app && npm test -- --runInBand` (при необходимости добавьте `NODE_OPTIONS=--experimental-vm-modules` для старых Node).

### Безопасность и CSP для фронтенда
- CSP настраивается в `frontend/next-app/next.config.mjs` и по умолчанию запрещает внешние подключения, кроме Google OAuth и AI API.
- В `script-src` оставлен `unsafe-inline` для скриптов и стилей, генерируемых Next.js при гидрации. Перед ужесточением политики добавьте nonce/hashed-скрипты, чтобы не сломать загрузку приложения.
- При добавлении новых внешних ресурсов в чат или сервис-воркер добавляйте их в `connect-src`/`worker-src`/`img-src` в том же файле.

### Docker/compose
- В `docker-compose.yml` и `docker-compose.prod.yml` добавлен сервис `frontend` (Next.js, порт 3000), совместимый с существующим Django стеком.
- Совместный запуск всей платформы: `docker-compose up --build` (Next.js будет доступен на 3000, backend на 8000, фронт можно проксировать через nginx по необходимости).
- Запуск только фронтенда для локальной разработки: `cd frontend/next-app && npm install && npm run dev`.

## Продакшен-старт (Ubuntu/Debian)
```bash
cp .env.example .env.prod  # заполнить секреты/хосты
docker-compose -f docker-compose.prod.yml up -d --build
```

Домен и TLS настраиваются через `nginx/nginx.conf` (добавьте сертификаты Let's Encrypt). ALLOWED_HOSTS и переменные карты/платежей берутся из `.env.prod`.
#   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 8
PATH: api_server.py
LANG: python
===== CONTENT START =====
# api_server.py
from __future__ import annotations

import datetime as dt
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

import joblib
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from database import get_connection

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"

# --- Загрузка моделей ---

occ_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "occupancy_model.pkl")
OCC_PIPE = occ_bundle["pipeline"]
OCC_FEATURE_COLS = occ_bundle["feature_cols"]

NLP_PIPE = joblib.load(MODELS_DIR / "nlp_intent.pkl")

rec_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "recommender.pkl")
USER_ITEM: pd.DataFrame = rec_bundle["user_item"]
ITEM_SIM: pd.DataFrame = rec_bundle["item_sim"]
LOT_FEATURES: pd.DataFrame = rec_bundle["lot_features"]

# --- FastAPI ---

app = FastAPI(title="ParkShare Local AI", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # при желании ограничить доменом PWA
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ---------- Схемы ----------


class Lot(BaseModel):
    id: int
    name: str
    latitude: float
    longitude: float
    near_metro: bool
    price_level: int
    has_covered: bool
    has_ev_charging: bool
    predicted_occupancy: float


class SearchResult(BaseModel):
    query: str
    intent: str
    time_of_day: Optional[str]
    near_metro: Optional[bool]
    max_price_level: Optional[int]
    has_ev_charging: Optional[bool]
    has_covered: Optional[bool]
    lots: List[Lot]


class OccupancyPredictionResponse(BaseModel):
    lot_id: int
    ts: dt.datetime
    predicted_occupancy: float


class Recommendation(BaseModel):
    lot: Lot
    score: float


class RecommendationsResponse(BaseModel):
    user_id: Optional[int]
    variant: str  # 'A' или 'B' для A/B теста
    recommendations: List[Recommendation]


# ---------- Утилиты ----------


def parse_dt_iso(value: Optional[str]) -> dt.datetime:
    if not value:
        return dt.datetime.now()
    try:
        return dt.datetime.fromisoformat(value)
    except Exception as exc:
        raise HTTPException(status_code=400, detail=f"Неверный формат datetime: {value}") from exc


def nlp_extract_entities(text: str) -> Dict[str, Any]:
    s = text.lower()

    time_of_day = None
    if "утр" in s:
        time_of_day = "morning"
    elif "днем" in s or "днём" in s:
        time_of_day = "day"
    elif "вечер" in s:
        time_of_day = "evening"
    elif "ноч" in s:
        time_of_day = "night"

    near_metro = "метро" in s

    max_price_level: Optional[int] = None
    if "дешев" in s or "недорог" in s:
        max_price_level = 1
    elif "средн" in s:
        max_price_level = 2
    elif "дорог" in s:
        max_price_level = 3

    has_ev = "электро" in s or "зарядк" in s or "ev" in s
    has_covered = "крыт" in s or "подзем" in s or "паркинг" in s

    return {
        "time_of_day": time_of_day,
        "near_metro": near_metro if near_metro else None,
        "max_price_level": max_price_level,
        "has_ev_charging": has_ev if has_ev else None,
        "has_covered": has_covered if has_covered else None,
    }


def build_occ_feature_df(lot_row: Dict[str, Any], ts: dt.datetime) -> pd.DataFrame:
    return pd.DataFrame(
        [
            {
                "hour": ts.hour,
                "dow": ts.weekday(),
                "temperature": 15.0,  # без реальной погоды
                "is_rain": 0,
                "is_event": 0,
                "near_metro": lot_row["near_metro"],
                "price_level": lot_row["price_level"],
                "has_covered": lot_row["has_covered"],
                "has_ev_charging": lot_row["has_ev_charging"],
                "lot_id_str": str(lot_row["id"]),
            }
        ]
    )[OCC_FEATURE_COLS]


def predict_occupancy_for_lot(lot_row: Dict[str, Any], ts: dt.datetime) -> float:
    df = build_occ_feature_df(lot_row, ts)
    pred = float(OCC_PIPE.predict(df)[0])
    return max(0.0, min(pred, 1.0))


def fetch_lots(filters: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
    conn = get_connection()
    cur = conn.cursor()

    base_query = """
        SELECT
            id, name, latitude, longitude,
            near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE 1=1
    """
    params: List[Any] = []

    if filters:
        if filters.get("near_metro") is not None:
            base_query += " AND near_metro = ?"
            params.append(1 if filters["near_metro"] else 0)
        if filters.get("max_price_level") is not None:
            base_query += " AND price_level <= ?"
            params.append(int(filters["max_price_level"]))
        if filters.get("has_ev_charging") is not None:
            base_query += " AND has_ev_charging = ?"
            params.append(1 if filters["has_ev_charging"] else 0)
        if filters.get("has_covered") is not None:
            base_query += " AND has_covered = ?"
            params.append(1 if filters["has_covered"] else 0)

    base_query += " ORDER BY price_level ASC, near_metro DESC"

    cur.execute(base_query, params)
    rows = [dict(r) for r in cur.fetchall()]
    conn.close()
    return rows


# ---------- Эндпоинты ----------


@app.get("/health")
def health() -> Dict[str, Any]:
    return {"status": "ok"}


@app.get("/api/lots", response_model=List[Lot])
def api_list_lots(
    ts: Optional[str] = Query(default=None, description="ISO datetime, по умолчанию — сейчас"),
) -> List[Lot]:
    dt_value = parse_dt_iso(ts)
    lots = fetch_lots()

    result: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        result.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )
    return result


@app.get("/api/occupancy/predict", response_model=OccupancyPredictionResponse)
def api_predict_occupancy(
    lot_id: int = Query(...),
    ts: Optional[str] = Query(default=None),
) -> OccupancyPredictionResponse:
    dt_value = parse_dt_iso(ts)
    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id = ?
        """,
        (lot_id,),
    )
    row = cur.fetchone()
    conn.close()
    if row is None:
        raise HTTPException(status_code=404, detail="Парковка не найдена")
    d = dict(row)
    occ = predict_occupancy_for_lot(d, dt_value)
    return OccupancyPredictionResponse(
        lot_id=lot_id,
        ts=dt_value,
        predicted_occupancy=occ,
    )


@app.get("/api/search", response_model=SearchResult)
def api_search(
    query: str = Query(..., min_length=1),
    ts: Optional[str] = Query(default=None),
    limit: int = Query(default=15, ge=1, le=100),
) -> SearchResult:
    dt_value = parse_dt_iso(ts)

    intent = NLP_PIPE.predict([query])[0]
    entities = nlp_extract_entities(query)

    filters: Dict[str, Any] = {}
    if entities["near_metro"]:
        filters["near_metro"] = True
    if entities["max_price_level"] is not None:
        filters["max_price_level"] = entities["max_price_level"]
    if entities["has_ev_charging"] is not None:
        filters["has_ev_charging"] = entities["has_ev_charging"]
    if entities["has_covered"] is not None:
        filters["has_covered"] = entities["has_covered"]

    if intent == "near_metro":
        filters["near_metro"] = True
    if intent == "cheap" and "max_price_level" not in filters:
        filters["max_price_level"] = 1

    lots = fetch_lots(filters)
    lots = lots[:limit]

    lot_models: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        lot_models.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )

    return SearchResult(
        query=query,
        intent=intent,
        time_of_day=entities["time_of_day"],
        near_metro=filters.get("near_metro"),
        max_price_level=filters.get("max_price_level"),
        has_ev_charging=filters.get("has_ev_charging"),
        has_covered=filters.get("has_covered"),
        lots=lot_models,
    )


def _recommend_item_based(user_id: int, top_n: int = 10) -> List[int]:
    if user_id not in USER_ITEM.index:
        return []

    user_ratings = USER_ITEM.loc[user_id]
    rated_items = user_ratings[user_ratings > 0].index.tolist()
    if not rated_items:
        return []

    scores = pd.Series(0.0, index=USER_ITEM.columns)

    for item_id in rated_items:
        sim_vec = ITEM_SIM.loc[item_id]
        scores += sim_vec * float(user_ratings[item_id])

    scores = scores.drop(rated_items)
    scores = scores.sort_values(ascending=False)
    return scores.head(top_n).index.tolist()


def _recommend_content_based(top_n: int = 10) -> List[int]:
    df = LOT_FEATURES.copy()
    df["score"] = 0.0

    df["score"] += (1 - (df["price_level"] - 1) / 2)  # дешёвые выше
    df["score"] += df["near_metro"] * 0.5
    df["score"] += df["has_ev_charging"] * 0.3
    df["score"] += df["has_covered"] * 0.2

    df = df.sort_values("score", ascending=False)
    return df.head(top_n).index.tolist()


@app.get("/api/recommendations", response_model=RecommendationsResponse)
def api_recommendations(
    user_id: Optional[int] = Query(default=None),
    variant: Optional[str] = Query(
        default=None,
        description="A или B — для A/B тестирования (A=collab, B=content)",
    ),
    limit: int = Query(default=10, ge=1, le=50),
    ts: Optional[str] = Query(default=None),
) -> RecommendationsResponse:
    dt_value = parse_dt_iso(ts)

    chosen_variant = variant or ("A" if user_id else "B")

    if chosen_variant == "A" and user_id is not None:
        item_ids = _recommend_item_based(user_id, top_n=limit)
        if not item_ids:
            chosen_variant = "B"
    if chosen_variant == "B" or user_id is None:
        item_ids = _recommend_content_based(top_n=limit)

    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        f"""
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id IN ({",".join(["?"] * len(item_ids))})
        """,
        item_ids,
    )
    rows = {r["id"]: dict(r) for r in cur.fetchall()}
    conn.close()

    recs: List[Recommendation] = []
    for lot_id in item_ids:
        row = rows.get(lot_id)
        if not row:
            continue
        occ = predict_occupancy_for_lot(row, dt_value)
        lot = Lot(
            id=row["id"],
            name=row["name"],
            latitude=row["latitude"],
            longitude=row["longitude"],
            near_metro=bool(row["near_metro"]),
            price_level=row["price_level"],
            has_covered=bool(row["has_covered"]),
            has_ev_charging=bool(row["has_ev_charging"]),
            predicted_occupancy=occ,
        )
        # простая метрика: обратная занятость + бонус за метро и цену
        score = (1.0 - occ) + (1 - (row["price_level"] - 1) / 2) + (0.3 if row["near_metro"] else 0.0)
        recs.append(Recommendation(lot=lot, score=float(score)))

    return RecommendationsResponse(
        user_id=user_id,
        variant=chosen_variant,
        recommendations=recs,
    )


if __name__ == "__main__":
    import os
    import uvicorn

    host = os.environ.get("AI_API_HOST", "0.0.0.0")
    try:
        port = int(os.environ.get("AI_API_PORT", "8001"))
    except (TypeError, ValueError):
        port = 8001

    uvicorn.run("api_server:app", host=host, port=port, reload=True)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 9
PATH: app.js
LANG: javascript
===== CONTENT START =====
// app.js

// Базовый URL FastAPI-сервера
// Если сервер крутится на другом порту/домене — поправь здесь.
const API_BASE = "http://localhost:8001";

let map;
let markersLayer;
let lotsCache = [];
let lotsById = new Map();

function pickBestLot(lots) {
  if (!lots || lots.length === 0) return null;
  const ranked = [...lots].sort((a, b) => {
    const occA = a.predicted_occupancy ?? 1;
    const occB = b.predicted_occupancy ?? 1;
    return occA - occB;
  });
  return ranked[0];
}

function updateAIOracleCard(lots) {
  const nameEl = document.getElementById("aiOracleName");
  const etaEl = document.getElementById("aiOracleETA");
  const confEl = document.getElementById("aiOracleConfidence");
  const metaEl = document.getElementById("aiOracleMeta");
  const reasoningEl = document.getElementById("aiOracleReason");

  if (!nameEl || !etaEl || !confEl || !metaEl || !reasoningEl) return;

  if (!lots || lots.length === 0) {
    nameEl.textContent = "—";
    etaEl.textContent = "—";
    confEl.textContent = "—";
    metaEl.textContent = "—";
    reasoningEl.textContent = "AI готовит инсайт…";
    return;
  }

  const bestLot = pickBestLot(lots);
  if (!bestLot) return;

  const occ = bestLot.predicted_occupancy ?? 0;
  const occPercent = Math.round(occ * 100);
  const eta = Math.max(2, Math.min(15, Math.round((1 - occ) * 12)));
  const confidence = Math.max(68, Math.min(99, 96 - Math.round(occPercent / 2)));
  const ev = bestLot.has_ev_charging ? "EV" : "обычная";
  const covered = bestLot.has_covered ? "крытая" : "открытая";

  nameEl.textContent = bestLot.name;
  etaEl.textContent = `${eta} мин`;
  confEl.textContent = `${confidence}%`;
  metaEl.textContent = `${ev} · ${covered}`;
  reasoningEl.textContent =
    "Учитывая вашу историю: быстрый выезд, EV и близость к метро — этот слот даст наивысший WOW-эффект.";
}

// ----------------- ИНИЦИАЛИЗАЦИЯ КАРТЫ -----------------

function occupancyColor(value) {
  if (value <= 0.4) return "#22c55e"; // green
  if (value <= 0.7) return "#eab308"; // yellow
  return "#ef4444"; // red
}

function initMap() {
  map = L.map("map", {
    zoomControl: true,
    attributionControl: false,
  }).setView([55.7558, 37.6173], 12);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
  }).addTo(map);

  markersLayer = L.layerGroup().addTo(map);
}

// ----------------- API HELPERS -----------------

async function apiGet(path, params = {}) {
  const url = new URL(API_BASE + path);
  Object.entries(params).forEach(([k, v]) => {
    if (v !== undefined && v !== null) {
      url.searchParams.set(k, v);
    }
  });

  const res = await fetch(url.toString());
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`API error ${res.status}: ${text}`);
  }
  return res.json();
}

// ----------------- ОТРИСОВКА ЛОТОВ -----------------

function renderLotsOnMap(lots) {
  markersLayer.clearLayers();

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const color = occupancyColor(occ);

    const marker = L.circleMarker([lot.latitude, lot.longitude], {
      radius: 8,
      fillColor: color,
      fillOpacity: 0.9,
      color: "#020617",
      weight: 1,
    });

    const occPercent = Math.round(occ * 100);

    const html = `
      <div style="font-size: 12px;">
        <strong>${lot.name}</strong><br />
        Загрузка: <strong>${occPercent}%</strong><br />
        Метро: ${lot.near_metro ? "рядом" : "нет"}<br />
        Уровень цены: ${lot.price_level}<br />
        Крытая: ${lot.has_covered ? "да" : "нет"}<br />
        Зарядка EV: ${lot.has_ev_charging ? "есть" : "нет"}
      </div>
    `;

    marker.bindPopup(html);
    marker.addTo(markersLayer);
  });

  if (lots.length > 0) {
    const bounds = L.latLngBounds(
      lots.map((lot) => [lot.latitude, lot.longitude])
    );
    map.fitBounds(bounds.pad(0.2));
  }
}

function renderLotsList(containerId, lots, clickHandler) {
  const container = document.getElementById(containerId);
  container.innerHTML = "";

  if (!lots || lots.length === 0) {
    container.innerHTML =
      '<div style="font-size: 0.75rem; color: #6b7280;">Нет данных.</div>';
    return;
  }

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const occPercent = Math.round(occ * 100);

    const div = document.createElement("div");
    div.className = "lot-item";
    div.innerHTML = `
      <div class="lot-main">
        <div class="lot-name">${lot.name}</div>
        <div class="lot-meta">
          <span>Цена: L${lot.price_level}</span>
          <span>Метро: ${lot.near_metro ? "рядом" : "нет"}</span>
          <span>EV: ${lot.has_ev_charging ? "есть" : "нет"}</span>
          <span>Крытая: ${lot.has_covered ? "да" : "нет"}</span>
        </div>
      </div>
      <div class="lot-occ">${occPercent}%</div>
    `;

    div.addEventListener("click", () => clickHandler(lot));
    container.appendChild(div);
  });
}

// ----------------- ЛОГИКА UI -----------------

async function loadAllLots() {
  const status = document.getElementById("statusText");
  try {
    const lots = await apiGet("/api/lots");
    lotsCache = lots;
    lotsById.clear();
    lots.forEach((lot) => lotsById.set(lot.id, lot));

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = "AI-сервер подключён";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка подключения к AI-серверу";
  }
}

async function handleSearch() {
  const input = document.getElementById("searchInput");
  const status = document.getElementById("searchStatus");
  const text = input.value.trim();
  if (!text) return;

  status.textContent = "Обрабатываю запрос (локальный NLP)…";

  try {
    const data = await apiGet("/api/search", { query: text });
    const lots = data.lots || [];

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    const parts = [];
    parts.push(`Интент: ${data.intent}`);
    if (data.near_metro !== null) {
      parts.push(`рядом с метро: ${data.near_metro ? "да" : "нет"}`);
    }
    if (data.max_price_level !== null) {
      parts.push(`макс. уровень цены: L${data.max_price_level}`);
    }
    if (data.has_ev_charging !== null) {
      parts.push(`EV: ${data.has_ev_charging ? "нужна" : "не нужна"}`);
    }
    if (data.has_covered !== null) {
      parts.push(`крытая: ${data.has_covered ? "нужна" : "не нужна"}`);
    }
    if (data.time_of_day) {
      parts.push(`время суток: ${data.time_of_day}`);
    }
    status.textContent = parts.join(" · ") || "Фильтры не распознаны.";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка обработки запроса";
  }
}

async function initUsersSelect() {
  const select = document.getElementById("userSelect");
  // Пользователи не отдаются API, но user_id есть в тренировочных данных.
  // Для демо предположим, что есть пользователи с id 1..20.
  for (let i = 1; i <= 20; i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `Пользователь #${i}`;
    select.appendChild(opt);
  }
}

async function handleRecommendations(variant) {
  const select = document.getElementById("userSelect");
  const status = document.getElementById("recStatus");
  const listContainerId = "recList";

  const userId = parseInt(select.value, 10) || undefined;

  status.textContent =
    variant === "A"
      ? "Рассчитываю рекомендации (collaborative)…"
      : "Рассчитываю рекомендации (content-based)…";

  try {
    const params = { limit: 10, variant };
    if (variant === "A" && userId) {
      params.user_id = userId;
    }
    const data = await apiGet("/api/recommendations", params);
    const recs = data.recommendations || [];

    const lots = recs.map((r) => r.lot);
    renderLotsOnMap(lots);
    renderLotsList(listContainerId, lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = `Вариант ${data.variant}, получено ${recs.length} рекомендаций.`;
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка получения рекомендаций";
  }
}

// ----------------- СТАРТ -----------------

window.addEventListener("DOMContentLoaded", async () => {
  initMap();
  await initUsersSelect();
  await loadAllLots();

  document
    .getElementById("searchBtn")
    .addEventListener("click", () => handleSearch());

  document
    .getElementById("searchInput")
    .addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        handleSearch();
      }
    });

  document.getElementById("recBtn").addEventListener("click", () => {
    handleRecommendations("A");
  });

  document
    .getElementById("recContentBtn")
    .addEventListener("click", () => {
      handleRecommendations("B");
    });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 10
PATH: celerybeat-schedule.bak
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 11
PATH: celerybeat-schedule.dat
LANG: text
===== CONTENT START =====
�}�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ��	       �5.5.3�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��       �
Europe/Moscow�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ��.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��L      }�(�expire_unpaid_bookings��celery.beat��
ScheduleEntry���(�expire_unpaid_bookings��$parking.tasks.expire_unpaid_bookings��datetime��datetime���C
�-�E��builtins��getattr����zoneinfo��ZoneInfo����	_unpickle���R��
Europe/Moscow�K��R���R�K�celery.schedules��schedule���h�	timedelta���K MXK ��R��N��R�)}�}�t�R��update_ai_models�h(�update_ai_models��ai.tasks.update_models�h	C
�-	3Ӕh��R�KhhK MK ��R��N��R�)}�}�t�R��check_stale_payments�h(�check_stale_payments��#payments.tasks.check_stale_payments�h	C
�-	;��h��R�KhhK M�K ��R��N��R�)}�}�t�R�u.
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 12
PATH: celerybeat-schedule.dir
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 13
PATH: database.py
LANG: python
===== CONTENT START =====
# database.py
from __future__ import annotations

import random
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import List

DB_PATH = Path(__file__).parent / "ai_data.db"


def get_connection() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db() -> None:
    conn = get_connection()
    cur = conn.cursor()

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS parking_lot (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            latitude REAL NOT NULL,
            longitude REAL NOT NULL,
            near_metro INTEGER NOT NULL,
            price_level INTEGER NOT NULL,
            has_covered INTEGER NOT NULL,
            has_ev_charging INTEGER NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS occupancy_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            lot_id INTEGER NOT NULL,
            ts TEXT NOT NULL,
            occupancy REAL NOT NULL,
            temperature REAL NOT NULL,
            is_rain INTEGER NOT NULL,
            is_event INTEGER NOT NULL,
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS app_user (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS user_rating (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            lot_id INTEGER NOT NULL,
            rating REAL NOT NULL,
            FOREIGN KEY (user_id) REFERENCES app_user(id),
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    conn.commit()
    conn.close()


@dataclass
class LotSpec:
    name: str
    base_lat: float
    base_lon: float
    near_metro: int
    price_level: int
    has_covered: int
    has_ev_charging: int


def generate_synthetic_data(
    num_lots: int = 30,
    num_users: int = 50,
    days_back: int = 30,
) -> None:
    """
    Генерация синтетических:
    - парковок
    - истории занятости
    - пользователей
    - оценок пользователей
    """
    random.seed(42)

    conn = get_connection()
    cur = conn.cursor()

    # Чистим старые данные
    cur.execute("DELETE FROM user_rating;")
    cur.execute("DELETE FROM app_user;")
    cur.execute("DELETE FROM occupancy_history;")
    cur.execute("DELETE FROM parking_lot;")
    conn.commit()

    # Базовые точки вокруг Москвы
    center_lat, center_lon = 55.7558, 37.6173

    lots: List[int] = []
    for i in range(num_lots):
        near_metro = 1 if random.random() < 0.5 else 0
        price_level = random.choice([1, 2, 3])  # 1 — дешево, 3 — дорого
        has_covered = 1 if random.random() < 0.4 else 0
        has_ev = 1 if random.random() < 0.3 else 0

        # Немного раскидываем точки вокруг центра
        lat = center_lat + random.uniform(-0.05, 0.05)
        lon = center_lon + random.uniform(-0.1, 0.1)

        cur.execute(
            """
            INSERT INTO parking_lot (
                name, latitude, longitude, near_metro,
                price_level, has_covered, has_ev_charging
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """,
            (
                f"Лот #{i+1}",
                lat,
                lon,
                near_metro,
                price_level,
                has_covered,
                has_ev,
            ),
        )
        lots.append(cur.lastrowid)

    # История занятости — каждые 2 часа за days_back дней
    now = datetime.now()
    start_ts = now - timedelta(days=days_back)

    weather_states = ["sunny", "cloudy", "rainy"]

    for lot_id in lots:
        ts = start_ts
        while ts < now:
            dow = ts.weekday()
            hour = ts.hour

            is_event = 1 if (dow in (4, 5) and hour >= 18 and random.random() < 0.3) else 0
            weather = random.choice(weather_states)
            is_rain = 1 if weather == "rainy" else 0
            temperature = random.uniform(-10, 30)

            # Базовая занятость зависит от часа и дня недели
            base_occ = 0.2
            if 8 <= hour <= 11:
                base_occ = 0.6
            elif 17 <= hour <= 20:
                base_occ = 0.7
            elif 0 <= hour <= 5:
                base_occ = 0.1

            if dow >= 5:
                base_occ += 0.1

            if is_event:
                base_occ += 0.2
            if is_rain:
                base_occ += 0.1

            base_occ = max(0.0, min(base_occ + random.uniform(-0.1, 0.1), 1.0))

            cur.execute(
                """
                INSERT INTO occupancy_history (
                    lot_id, ts, occupancy, temperature, is_rain, is_event
                ) VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    lot_id,
                    ts.isoformat(),
                    base_occ,
                    temperature,
                    is_rain,
                    is_event,
                ),
            )

            ts += timedelta(hours=2)

    # Пользователи
    users = []
    for i in range(num_users):
        cur.execute(
            "INSERT INTO app_user (name) VALUES (?);",
            (f"user_{i+1}",),
        )
        users.append(cur.lastrowid)

    # Оценки пользователей парковок
    for user_id in users:
        # Каждый пользователь оценит 5–15 парковок
        k = random.randint(5, min(15, len(lots)))
        rated_lots = random.sample(lots, k)
        for lot_id in rated_lots:
            # Рейтинг зависит от price_level и случайности
            base_rating = 4.5 - 0.5 * (random.randint(1, 3) - 1)
            rating = max(1.0, min(5.0, base_rating + random.uniform(-1.0, 1.0)))
            cur.execute(
                """
                INSERT INTO user_rating (user_id, lot_id, rating)
                VALUES (?, ?, ?)
                """,
                (user_id, lot_id, rating),
            )

    conn.commit()
    conn.close()
    print("Синтетические данные сгенерированы в", DB_PATH)


if __name__ == "__main__":
    init_db()
    generate_synthetic_data()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 14
PATH: docker-compose.prod.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: gunicorn backend.config.wsgi:application --bind 0.0.0.0:8000
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config worker -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config beat -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    restart: always
    environment:
      NEXTAUTH_URL: ${NEXTAUTH_URL:-http://localhost:3000}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:-change_me_frontend}
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID:-dummy}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET:-dummy}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-dummy}
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:1.27-alpine
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 15
PATH: docker-compose.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    container_name: parkshare_db
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: parkshare
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    container_name: parkshare_redis
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_web
    restart: always
    env_file:
      - .env  # можно потом заменить на .env.prod
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_worker
    restart: always
    env_file:
      - .env
    command: celery -A backend.config worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_beat
    restart: always
    env_file:
      - .env
    command: celery -A backend.config beat -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  ai_pricing_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_ai_pricing
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.ai_pricing_service.main:app --host 0.0.0.0 --port 8100
    depends_on:
      - redis
    networks:
      - parkshare_net

  llm_service:
    build:
      context: .
      dockerfile: services/llm_service/Dockerfile
    container_name: parkshare_llm_service
    restart: always
    env_file:
      - .env
    ports:
      - "8002:8002"
    networks:
      - parkshare_net

  cv_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_cv_service
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.cv_service.main:app --host 0.0.0.0 --port 8200
    depends_on:
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    container_name: parkshare_frontend
    restart: always
    environment:
      NEXTAUTH_URL: http://localhost:3000
      NEXTAUTH_SECRET: dev_secret
      GOOGLE_CLIENT_ID: dummy
      GOOGLE_CLIENT_SECRET: dummy
      OPENAI_API_KEY: dummy
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:alpine
    container_name: parkshare_nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 16
PATH: dump_project.py
LANG: python
===== CONTENT START =====
import os
from datetime import datetime

# Какие папки игнорировать (расширенный список)
EXCLUDED_DIRS = {
    ".git", ".venv", "venv", "__pycache__", "node_modules",
    "dist", "build", "staticfiles", "media", ".idea", ".vscode",
    "static/icons",      # иконки не нужны в дампе
    "logs", "cache", "temp",  # временные файлы и логи
}

# Какие расширения файлов пропускать (расширенный список)
IGNORED_EXTENSIONS = {
    ".pyc", ".pyo", ".pyd", ".sqlite3", ".sqlite", ".db",
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp",
    ".pdf", ".zip", ".rar", ".7z", ".tar", ".gz",
    ".exe", ".dll", ".so", ".pkl", ".h5", ".model", ".pt",
    ".mp4", ".mp3", ".wav", ".avi", ".mov",
    ".log", ".tmp", ".cache",
}

# Файлы, которые нужно полностью игнорировать
EXCLUDED_FILES = {
    "CODEX_LOG1.txt", "CODEX__LOGS.txt",
    "package-lock.json", "yarn.lock",
}

# Никакого лимита на размер файла и дампа
MAX_FILE_SIZE = None  # не используется
MAX_TOTAL_DUMP_SIZE = None  # не используется

# Сжатие кода выключено, содержимое пишется как есть
COMPRESS_CODE = False


def is_binary_file(filename: str) -> bool:
    _, ext = os.path.splitext(filename.lower())
    return ext in IGNORED_EXTENSIONS


def should_exclude_file(filename: str) -> bool:
    return filename in EXCLUDED_FILES


def compress_content(content: str, filepath: str) -> str:
    # Оставлено для совместимости, по факту возвращает исходный контент
    if not COMPRESS_CODE:
        return content
    return content


def detect_language(filepath: str) -> str:
    """
    Определение "языка" для ИИ по расширению файла,
    чтобы он лучше понимал, что за содержимое перед ним.
    """
    _, ext = os.path.splitext(filepath.lower())
    mapping = {
        ".py": "python",
        ".js": "javascript",
        ".ts": "typescript",
        ".tsx": "tsx",
        ".jsx": "jsx",
        ".html": "html",
        ".htm": "html",
        ".css": "css",
        ".scss": "scss",
        ".sass": "sass",
        ".json": "json",
        ".yml": "yaml",
        ".yaml": "yaml",
        ".md": "markdown",
        ".sh": "bash",
        ".bat": "batch",
        ".ps1": "powershell",
        ".toml": "toml",
        ".ini": "ini",
        ".cfg": "ini",
        ".txt": "text",
        ".sql": "sql",
        ".csv": "csv",
        ".xml": "xml",
    }
    return mapping.get(ext, "text")


def build_tree_and_collect_files(root: str):
    """
    Обходит проект, строит дерево директорий и собирает список файлов.
    Фильтр только по директориям/расширениям/именам.
    """
    tree_lines = []
    file_paths = []

    root = os.path.abspath(root)
    root_name = os.path.basename(root.rstrip(os.sep))

    tree_lines.append(f"{root_name}/")

    for current_root, dirs, files in os.walk(root):
        # Фильтр директорий
        dirs[:] = [
            d for d in dirs
            if d not in EXCLUDED_DIRS and not d.startswith(".")
        ]

        rel_root = os.path.relpath(current_root, root)
        if rel_root == ".":
            depth = 0
        else:
            depth = rel_root.count(os.sep) + 1

        indent = "    " * depth

        if rel_root != ".":
            tree_lines.append(f"{indent}{os.path.basename(current_root)}/")

        for name in sorted(files):
            if is_binary_file(name) or should_exclude_file(name):
                continue

            file_rel_path = os.path.join(rel_root, name) if rel_root != "." else name
            file_abs_path = os.path.join(current_root, name)

            tree_lines.append(f"{indent}    {name}")
            file_paths.append((file_rel_path, file_abs_path))

    return tree_lines, file_paths


def dump_project(root: str, output_filename: str = "project_dump.txt"):
    tree_lines, file_paths = build_tree_and_collect_files(root)

    root = os.path.abspath(root)

    # Индекс файлов для ИИ, чтобы он мог быстро увидеть структуру и прыгать по пути
    files_index_lines = []
    for idx, (rel_path, abs_path) in enumerate(file_paths, 1):
        lang = detect_language(abs_path)
        files_index_lines.append(
            f"{idx}. PATH={rel_path} | LANG={lang}"
        )

    header = [
        "#" * 80,
        "# FULL PROJECT DUMP (NO TRUNCATION)",
        "# FORMAT FOR LLM:",
        "#   1) PROJECT TREE — общая структура проекта.",
        "#   2) FILES INDEX — плоский список файлов с путём и языком.",
        "#   3) FILES CONTENT — для каждого файла:",
        "#        ===== FILE START =====",
        "#        FILE_INDEX: <N>",
        "#        PATH: <relative/path>",
        "#        LANG: <language>",
        "#        ===== CONTENT START =====",
        "#        <raw file content>",
        "#        ===== CONTENT END =====",
        "#        ===== FILE END =====",
        "#   Файлы идут в том же порядке, что и в индексе.",
        "#" * 80,
        f"# Root: {root}",
        f"# Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Files listed: {len(file_paths)}",
        f"# Max single file size: NONE",
        f"# Max total dump size: NONE",
        f"# Code compression enabled: {COMPRESS_CODE}",
        "#" * 80,
        "",
    ]

    with open(output_filename, "w", encoding="utf-8", errors="replace") as f:
        # Шапка
        f.write("\n".join(header))

        # Дерево проекта
        f.write("PROJECT TREE:\n")
        f.write("-" * 80 + "\n")
        for line in tree_lines:
            f.write(line + "\n")

        # Индекс файлов
        f.write("\n\n")
        f.write("FILES INDEX:\n")
        f.write("-" * 80 + "\n")
        for line in files_index_lines:
            f.write(line + "\n")

        # Разделитель
        f.write("\n\n")
        f.write("=" * 80 + "\n")
        f.write("FILES CONTENT:\n")
        f.write("=" * 80 + "\n\n")

        total_files = len(file_paths)

        for i, (rel_path, abs_path) in enumerate(file_paths, 1):
            lang = detect_language(abs_path)

            # Явные маркеры для ИИ
            f.write("===== FILE START =====\n")
            f.write(f"FILE_INDEX: {i}\n")
            f.write(f"PATH: {rel_path}\n")
            f.write(f"LANG: {lang}\n")
            f.write("===== CONTENT START =====\n")

            try:
                with open(abs_path, "r", encoding="utf-8", errors="replace") as src:
                    content = src.read()

                content = compress_content(content, abs_path)
                f.write(content)

            except Exception as e:
                f.write(f"<< ERROR READING FILE: {e} >>\n")

            f.write("\n===== CONTENT END =====\n")
            f.write("===== FILE END =====\n\n")

            if i % 10 == 0:
                print(f"Processed {i}/{total_files} files...")

    file_size_bytes = os.path.getsize(output_filename)
    file_size_kb = file_size_bytes / 1024
    file_size_mb = file_size_bytes / (1024 * 1024)

    print(f"Готово! Файл с дампом проекта: {output_filename}")
    print(f"Размер дампа: {file_size_kb:.0f}KB (~{file_size_mb:.2f}MB)")
    print(f"Файлов в обходе (включено в дамп): {len(file_paths)}")


if __name__ == "__main__":
    project_root = os.path.dirname(os.path.abspath(__file__))
    dump_project(project_root)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 17
PATH: entrypoint.sh
LANG: bash
===== CONTENT START =====
#!/bin/sh
set -e

# Если DJANGO_SETTINGS_MODULE не задан, по умолчанию считаем, что это прод.
: "${DJANGO_SETTINGS_MODULE:=backend.backend.settings.production}"
export DJANGO_SETTINGS_MODULE

echo "Using DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE}"

# Миграции
python backend/manage.py migrate --noinput

# Сбор статики
python backend/manage.py collectstatic --noinput

# Запуск gunicorn
exec gunicorn backend.config.wsgi:application \
    --bind 0.0.0.0:8000 \
    --workers "${GUNICORN_WORKERS:-3}" \
    --timeout "${GUNICORN_TIMEOUT:-60}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 18
PATH: index.html
LANG: html
===== CONTENT START =====
<!-- index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ParkShare AI Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <link rel="stylesheet" href="./static/css/cinematic-ui.css" />

  <style>
    :root {
      --primary: #0d6efd;
      --bg: #050816;
      --bg-card: #111827;
      --text: #e5e7eb;
      --accent: #22c55e;
      --danger: #ef4444;
      --warning: #f59e0b;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827, #020617 40%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      z-index: 1000;
      position: sticky;
      top: 0;
    }

    header h1 {
      font-size: 1.1rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .header-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.3fr);
      min-height: 0;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .sidebar {
      border-left: 1px solid rgba(148, 163, 184, 0.2);
      background: radial-gradient(circle at top, #020617, #020617 40%);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 280px;
      max-width: 480px;
    }

    .card {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 0.75rem 0.8rem;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.6);
    }

    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .input-row {
      display: flex;
      gap: 0.4rem;
      margin-top: 0.3rem;
    }

    input[type="text"],
    select {
      flex: 1;
      padding: 0.4rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      font-size: 0.85rem;
      outline: none;
    }

    input::placeholder {
      color: rgba(148, 163, 184, 0.9);
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 0.45rem 0.9rem;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      background: linear-gradient(135deg, #0ea5e9, #22c55e);
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      white-space: nowrap;
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: rgba(209, 213, 219, 0.95);
    }

    .pill {
      font-size: 0.72rem;
      border-radius: 999px;
      padding: 0.16rem 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      color: rgba(209, 213, 219, 0.95);
    }

    .pill-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
    }

    .pill-dot.green {
      background: var(--accent);
    }
    .pill-dot.yellow {
      background: var(--warning);
    }
    .pill-dot.red {
      background: var(--danger);
    }

    .lots-list {
      max-height: 220px;
      overflow-y: auto;
      margin-top: 0.4rem;
      padding-right: 0.2rem;
    }

    .lot-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.4rem 0.2rem;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      cursor: pointer;
    }

    .lot-item:last-child {
      border-bottom: none;
    }

    .lot-main {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      font-size: 0.75rem;
    }

    .lot-name {
      font-weight: 500;
      font-size: 0.8rem;
    }

    .lot-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      font-size: 0.7rem;
      color: rgba(156, 163, 175, 0.95);
    }

    .lot-occ {
      font-size: 0.8rem;
      font-weight: 500;
      min-width: 80px;
      text-align: right;
    }

    .status {
      font-size: 0.7rem;
      color: rgba(148, 163, 184, 0.9);
      margin-top: 0.3rem;
    }

    .ai-oracle-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.18rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(59, 130, 246, 0.45);
      background: linear-gradient(120deg, rgba(37, 99, 235, 0.35), rgba(14, 165, 233, 0.15));
      color: #e5edff;
      font-size: 0.75rem;
      letter-spacing: 0.02em;
      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.25);
    }

    .ai-orchestrator-card {
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.92), rgba(17, 24, 39, 0.94));
    }

    .ai-orchestrator-card .card-title {
      align-items: center;
    }

    .ai-orchestrator-card .card-title span {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .quantum-toggle {
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: #e2e8f0;
      font-weight: 600;
      letter-spacing: 0.01em;
      min-width: 150px;
      justify-content: space-between;
    }

    .quantum-toggle__dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.7);
      background: radial-gradient(circle at 35% 35%, #38bdf8, #0ea5e9);
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.45);
    }

    .quantum-toggle__label {
      flex: 1;
      text-align: right;
      font-size: 0.8rem;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
      .sidebar {
        max-width: 100%;
        border-left: none;
        border-top: 1px solid rgba(148, 163, 184, 0.2);
      }
    }
  </style>
</head>
<body>
  <header class="cinematic-surface">
    <h1>
      <span>ParkShare AI Map</span>
      <span class="badge">local ML</span>
    </h1>
    <div class="header-meta">
      <div class="ai-crest">
        <span>🧠</span>
        <span class="quantum-toggle__label">AI Orchestrator</span>
      </div>
      <button id="themeToggle" class="quantum-toggle cinematic-button" data-theme="dark">
        <span class="quantum-toggle__dot"></span>
        <span class="quantum-toggle__label">Dark Matter</span>
      </button>
      <div class="pill">
        <span class="pill-dot green"></span>
        <span id="statusText">Подключение к AI-серверу…</span>
      </div>
    </div>
  </header>

  <main>
    <div id="map"></div>
    <aside class="sidebar">
      <section class="card cinematic-surface ai-orchestrator-card">
        <div class="card-title">
          <span>AI-Оркестратор</span>
          <span class="ai-oracle-chip">Quantum boost</span>
        </div>
        <div class="ai-forecast">
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Лучшая ставка</span>
            <span class="ai-forecast-value" id="aiOracleName">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Освободится через</span>
            <span class="ai-forecast-value" id="aiOracleETA">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Уверенность AI</span>
            <span class="ai-forecast-value" id="aiOracleConfidence">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">EV/крытая</span>
            <span class="ai-forecast-value" id="aiOracleMeta">—</span>
          </div>
        </div>
        <div class="ai-reasoning" id="aiOracleReason">AI готовит инсайт…</div>
      </section>
      <section class="card">
        <div class="card-title">
          <span>Поиск парковок (NLP)</span>
        </div>
        <div class="input-row">
          <input
            type="text"
            id="searchInput"
            placeholder='Например: "рядом с метро", "дешевые утром"'
          />
          <button id="searchBtn">Искать</button>
        </div>
        <div class="status" id="searchStatus">Запрос еще не выполнен.</div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Рекомендации (коллаб. фильтрация)</span>
          <select id="userSelect"></select>
        </div>
        <div class="input-row">
          <button id="recBtn">Получить рекомендации</button>
          <button id="recContentBtn" class="secondary">Вариант B (content)</button>
        </div>
        <div class="status" id="recStatus">Нет рекомендаций.</div>
        <div class="lots-list" id="recList"></div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Все парковки</span>
        </div>
        <div class="lots-list" id="lotsList"></div>
      </section>
    </aside>
  </main>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="./static/js/quantum-theme-manager.js"></script>
  <script src="app.js"></script>
  <script>
    // Запускаем квантовый менеджер темы, чтобы анимации и эмоции были синхронизированы.
    window.psThemeManager = window.initQuantumThemeManager();
  </script>
</body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 19
PATH: model_training.py
LANG: python
===== CONTENT START =====
# model_training.py
from __future__ import annotations

import joblib
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Dict, Any

from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.svm import LinearSVC

from database import DB_PATH, get_connection, init_db, generate_synthetic_data

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"
# Создаём папку для моделей заранее, чтобы не упасть на сохранении
MODELS_DIR.mkdir(parents=True, exist_ok=True)


# ---------- 1. Модель предсказания загруженности парковок ----------


def load_occupancy_dataframe() -> pd.DataFrame:
    conn = get_connection()
    try:
        query = """
            SELECT
                oh.lot_id,
                oh.ts,
                oh.occupancy,
                oh.temperature,
                oh.is_rain,
                oh.is_event,
                pl.near_metro,
                pl.price_level,
                pl.has_covered,
                pl.has_ev_charging
            FROM occupancy_history oh
            JOIN parking_lot pl ON pl.id = oh.lot_id
        """
        df = pd.read_sql_query(query, conn)
    finally:
        conn.close()

    if df.empty:
        return df

    df["ts"] = pd.to_datetime(df["ts"], errors="coerce")
    df = df.dropna(subset=["ts"])
    df["hour"] = df["ts"].dt.hour
    df["dow"] = df["ts"].dt.weekday
    df["lot_id_str"] = df["lot_id"].astype(str)

    return df


def train_occupancy_model() -> None:
    df = load_occupancy_dataframe()
    if df.empty:
        raise RuntimeError("Нет данных для обучения occupancy-модели")

    feature_cols = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
        "lot_id_str",
    ]

    X = df[feature_cols].copy()
    y = df["occupancy"].astype(float)

    numeric_features = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
    ]
    categorical_features = ["lot_id_str"]

    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), numeric_features),
            ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_features),
        ]
    )

    model = RandomForestRegressor(
        n_estimators=80,
        random_state=42,
        n_jobs=-1,
    )

    pipe = Pipeline(
        steps=[
            ("preprocess", preprocessor),
            ("model", model),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "occupancy_model.pkl"
    joblib.dump(
        {
            "pipeline": pipe,
            "feature_cols": feature_cols,
        },
        model_path,
    )
    print("occupancy_model.pkl сохранён в", model_path)


# ---------- 2. NLP: интенты и парсинг пользовательских запросов ----------


def build_nlp_training_data() -> pd.DataFrame:
    data = [
        ("рядом с метро", "near_metro"),
        ("парковка около метро", "near_metro"),
        ("парковка возле метро", "near_metro"),
        ("где припарковаться у метро курская", "near_metro"),
        ("найди парковку у метро", "near_metro"),
        ("самая дешевая парковка", "cheap"),
        ("дешевые парковки утром", "cheap"),
        ("недорогая парковка рядом", "cheap"),
        ("дешево припарковаться", "cheap"),
        ("недорогие места для машины", "cheap"),
        ("парковка с зарядкой для электромобиля", "ev"),
        ("нужна зарядка для электрокара", "ev"),
        ("парковка с ev charging", "ev"),
        ("крытая парковка", "covered"),
        ("подземная парковка", "covered"),
        ("парковка в паркинге", "covered"),
        ("парковка ночью", "time_night"),
        ("парковка утром", "time_morning"),
        ("парковка вечером", "time_evening"),
        ("парковка днем", "time_day"),
        ("найди парковку", "general"),
        ("показать все парковки", "general"),
        ("где можно припарковаться", "general"),
        ("парковка в центре", "general"),
        ("парковка возле офиса", "general"),
    ]
    return pd.DataFrame(data, columns=["text", "intent"])


def train_nlp_model() -> None:
    df = build_nlp_training_data()
    X = df["text"].values
    y = df["intent"].values

    pipe = Pipeline(
        steps=[
            (
                "vec",
                CountVectorizer(
                    ngram_range=(1, 2),
                    analyzer="word",
                ),
            ),
            ("clf", LinearSVC()),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "nlp_intent.pkl"
    joblib.dump(pipe, model_path)
    print("nlp_intent.pkl сохранён в", model_path)


# ---------- 3. Рекомендательная система (collab + content) ----------


def train_recommender() -> None:
    """
    Простейшая item-based collaborative filtering + content-based фолбэк.
    """
    conn = get_connection()

    ratings = pd.read_sql_query("SELECT * FROM user_rating;", conn)
    lots = pd.read_sql_query("SELECT * FROM parking_lot;", conn)

    if ratings.empty or lots.empty:
        raise RuntimeError("Нет данных для обучения рекомендера")

    # user-item матрица
    user_item = (
        ratings.pivot(index="user_id", columns="lot_id", values="rating")
        .fillna(0.0)
        .astype(float)
    )

    # Нормируем по пользователям
    user_norms = np.linalg.norm(user_item.values, axis=1, keepdims=True)
    user_norms[user_norms == 0] = 1.0
    user_item_norm = user_item.values / user_norms

    # item-item similarity (cosine)
    sim_matrix = cosine_similarity(user_item_norm.T)
    item_ids = user_item.columns.tolist()
    item_sim = pd.DataFrame(sim_matrix, index=item_ids, columns=item_ids)

    # Content-features
    lot_features = lots.set_index("id")[
        ["near_metro", "price_level", "has_covered", "has_ev_charging", "latitude", "longitude"]
    ].copy()

    model_path = MODELS_DIR / "recommender.pkl"
    joblib.dump(
        {
            "user_item": user_item,
            "item_sim": item_sim,
            "lot_features": lot_features,
        },
        model_path,
    )
    print("recommender.pkl сохранён в", model_path)
    conn.close()


def _dataset_is_empty() -> bool:
    conn = get_connection()
    try:
        cur = conn.cursor()
        counts = {}
        for table in ["parking_lot", "occupancy_history", "user_rating"]:
            try:
                cur.execute(f"SELECT COUNT(*) FROM {table};")
                counts[table] = cur.fetchone()[0]
            except Exception:
                counts[table] = 0
        return any(value == 0 for value in counts.values())
    finally:
        conn.close()


def _safe_call(name: str, fn) -> None:
    try:
        fn()
    except Exception as exc:
        # Логируем и выбрасываем дальше, чтобы CI увидел сбой
        print(f"[!] Ошибка во время '{name}': {exc}")
        raise


def main() -> None:
    # На случай чистой установки
    init_db()

    try:
        if _dataset_is_empty():
            print("База пуста — генерируем синтетические данные...")
            generate_synthetic_data()
        else:
            print("Используем существующие данные в БД", DB_PATH)
    except Exception as exc:
        print(f"[!] Не удалось подготовить данные: {exc}")
        raise

    print("=== Обучение occupancy-модели ===")
    _safe_call("occupancy", train_occupancy_model)

    print("=== Обучение NLP-модели ===")
    _safe_call("nlp", train_nlp_model)

    print("=== Обучение рекомендательной системы ===")
    _safe_call("recommender", train_recommender)

    print("Готово: все модели обучены и сохранены в", MODELS_DIR)


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 20
PATH: project_dump.txt
LANG: text
===== CONTENT START =====
################################################################################
# FULL PROJECT DUMP (NO TRUNCATION)
# FORMAT FOR LLM:
#   1) PROJECT TREE — общая структура проекта.
#   2) FILES INDEX — плоский список файлов с путём и языком.
#   3) FILES CONTENT — для каждого файла:
#        ===== FILE START =====
#        FILE_INDEX: <N>
#        PATH: <relative/path>
#        LANG: <language>
#        ===== CONTENT START =====
#        <raw file content>
#        ===== CONTENT END =====
#        ===== FILE END =====
#   Файлы идут в том же порядке, что и в индексе.
################################################################################
# Root: C:\Users\Sultan\Downloads\parkshare_ru_part1
# Generated at: 2025-12-07 03:37:57
# Files listed: 223
# Max single file size: NONE
# Max total dump size: NONE
# Code compression enabled: False
################################################################################
PROJECT TREE:
--------------------------------------------------------------------------------
parkshare_ru_part1/
    .env
    .env.example
    .env.prod
    .gitattributes
    .gitignore
    Dockerfile
    README.md
    api_server.py
    app.js
    celerybeat-schedule.bak
    celerybeat-schedule.dat
    celerybeat-schedule.dir
    database.py
    docker-compose.prod.yml
    docker-compose.yml
    dump_project.py
    entrypoint.sh
    index.html
    model_training.py
    project_dump.txt
    requirements.txt
    run_dev.bat
    run_dev.py
    run_dev.sh
    accounts/
        __init__.py
        admin.py
        apps.py
        auth.py
        forms.py
        models.py
        serializers.py
        urls.py
        utils.py
        views.py
        migrations/
            0001_initial.py
            0002_user_email_hash_user_phone_hash_logincode.py
            0003_userlevel_userbadge_promoreward.py
            __init__.py
    ai/
        __init__.py
        admin.py
        apps.py
        features.py
        models.py
        orchestrator.py
        pricing.py
        serializers.py
        tasks.py
        views.py
        chat/
            __init__.py
            parking_assistant.py
        management/
            __init__.py
            commands/
                __init__.py
                train_chat_intents_from_logs.py
        migrations/
            0001_initial.py
            __init__.py
    ai_models/
    ai_services/
        __init__.py
        ai_pricing_service/
            __init__.py
            main.py
        cv_service/
            __init__.py
            main.py
    backend/
        __init__.py
        manage.py
        backend/
            __init__.py
            config/
                __init__.py
                asgi.py
                celery.py
                urls.py
                wsgi.py
            settings/
                __init__.py
                base.py
                local.py
                production.py
                regions.py
        rest_framework_simplejwt/
            __init__.py
            authentication.py
            tokens.py
            views.py
        tests/
            __init__.py
            test_auth_api.py
            test_booking_model.py
            test_ui_theme_chat.py
    core/
        __init__.py
        admin.py
        apps.py
        context_processors.py
        integrations.py
        middleware.py
        models.py
        pagination.py
        permissions.py
        utils.py
    drf_spectacular/
        __init__.py
        openapi.py
        views.py
    frontend/
        next-app/
            .env.local
            .eslintrc.json
            Dockerfile
            jest.config.js
            jest.setup.ts
            next-env.d.ts
            next.config.mjs
            package.json
            postcss.config.js
            tailwind.config.ts
            tsconfig.json
            app/
                globals.css
                layout.tsx
                (site)/
                    layout.tsx
                    page.tsx
                    auth/
                        page.tsx
                api/
                    chat/
                        route.ts
                embed/
                    page.tsx
            components/
                header.tsx
                providers.tsx
                theme-provider.tsx
                theme-toggle.tsx
                chat/
                    chat-panel.tsx
                    compact-chat-panel.tsx
                    conversation-list.tsx
                    markdown-message.tsx
                    suggested-prompts.tsx
                    types.ts
                pwa/
                    register-service-worker.tsx
                widget/
                    chat-widget.tsx
            context/
                AuthContext.tsx
            hooks/
                useAuth.ts
            lib/
                aiProvider.ts
                authClient.ts
                chatClient.ts
                llmClient.ts
            public/
                manifest.webmanifest
                offline.html
                service-worker.js
                icons/
            __tests__/
                chat-client.test.ts
                conversation-list.test.tsx
        parkmate/
            parkmate.types.ts
    nginx/
        nginx.conf
    parking/
        __init__.py
        admin.py
        apps.py
        models.py
        push.py
        serializers.py
        tasks.py
        urls.py
        views.py
        management/
            commands/
                seed_demo_parking.py
        migrations/
            0001_initial.py
            0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
            0003_booking_ai_fields.py
            0004_favoriteparkingspot_savedplace.py
            0005_pushsubscription.py
            __init__.py
        tests/
            __init__.py
            test_pwa_endpoints.py
    payments/
        __init__.py
        admin.py
        apps.py
        models.py
        providers.py
        serializers.py
        tasks.py
        views.py
        migrations/
            0001_initial.py
            0002_alter_payment_provider.py
            0003_paymentmethod.py
            __init__.py
        providers/
            __init__.py
            base.py
            registry.py
            stripe.py
            yookassa.py
    regions/
        global.yml
        ru.yml
    services/
        __init__.py
        llm.py
        llm_service/
            Dockerfile
            main.py
            requirements.txt
    static/
        manifest.webmanifest
        service-worker.js
        css/
            app.css
            cinematic-ui.css
        icons/
        js/
            app.js
            chat.js
            map.js
            parkmate-ai.ts
            quantum-theme-manager.js
            theme.js
        pwa/
            api-client.js
            app.js
            router.js
            spots-view.js
            state-store.js
            ui-kit.js
    templates/
        base.html
        offline.html
        accounts/
            login.html
            password_change.html
            password_change_done.html
            password_reset.html
            password_reset_complete.html
            password_reset_confirm.html
            password_reset_done.html
            password_reset_email.txt
            password_reset_subject.txt
            profile.html
            register.html
        ai/
            concierge.html
        parking/
            landing.html
            map_fullscreen.html
            owner_dashboard.html
            pwa_install.html
            user_dashboard.html
    vehicles/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py


FILES INDEX:
--------------------------------------------------------------------------------
1. PATH=.env | LANG=text
2. PATH=.env.example | LANG=text
3. PATH=.env.prod | LANG=text
4. PATH=.gitattributes | LANG=text
5. PATH=.gitignore | LANG=text
6. PATH=Dockerfile | LANG=text
7. PATH=README.md | LANG=markdown
8. PATH=api_server.py | LANG=python
9. PATH=app.js | LANG=javascript
10. PATH=celerybeat-schedule.bak | LANG=text
11. PATH=celerybeat-schedule.dat | LANG=text
12. PATH=celerybeat-schedule.dir | LANG=text
13. PATH=database.py | LANG=python
14. PATH=docker-compose.prod.yml | LANG=yaml
15. PATH=docker-compose.yml | LANG=yaml
16. PATH=dump_project.py | LANG=python
17. PATH=entrypoint.sh | LANG=bash
18. PATH=index.html | LANG=html
19. PATH=model_training.py | LANG=python
20. PATH=project_dump.txt | LANG=text
21. PATH=requirements.txt | LANG=text
22. PATH=run_dev.bat | LANG=batch
23. PATH=run_dev.py | LANG=python
24. PATH=run_dev.sh | LANG=bash
25. PATH=accounts\__init__.py | LANG=python
26. PATH=accounts\admin.py | LANG=python
27. PATH=accounts\apps.py | LANG=python
28. PATH=accounts\auth.py | LANG=python
29. PATH=accounts\forms.py | LANG=python
30. PATH=accounts\models.py | LANG=python
31. PATH=accounts\serializers.py | LANG=python
32. PATH=accounts\urls.py | LANG=python
33. PATH=accounts\utils.py | LANG=python
34. PATH=accounts\views.py | LANG=python
35. PATH=accounts\migrations\0001_initial.py | LANG=python
36. PATH=accounts\migrations\0002_user_email_hash_user_phone_hash_logincode.py | LANG=python
37. PATH=accounts\migrations\0003_userlevel_userbadge_promoreward.py | LANG=python
38. PATH=accounts\migrations\__init__.py | LANG=python
39. PATH=ai\__init__.py | LANG=python
40. PATH=ai\admin.py | LANG=python
41. PATH=ai\apps.py | LANG=python
42. PATH=ai\features.py | LANG=python
43. PATH=ai\models.py | LANG=python
44. PATH=ai\orchestrator.py | LANG=python
45. PATH=ai\pricing.py | LANG=python
46. PATH=ai\serializers.py | LANG=python
47. PATH=ai\tasks.py | LANG=python
48. PATH=ai\views.py | LANG=python
49. PATH=ai\chat\__init__.py | LANG=python
50. PATH=ai\chat\parking_assistant.py | LANG=python
51. PATH=ai\management\__init__.py | LANG=python
52. PATH=ai\management\commands\__init__.py | LANG=python
53. PATH=ai\management\commands\train_chat_intents_from_logs.py | LANG=python
54. PATH=ai\migrations\0001_initial.py | LANG=python
55. PATH=ai\migrations\__init__.py | LANG=python
56. PATH=ai_services\__init__.py | LANG=python
57. PATH=ai_services\ai_pricing_service\__init__.py | LANG=python
58. PATH=ai_services\ai_pricing_service\main.py | LANG=python
59. PATH=ai_services\cv_service\__init__.py | LANG=python
60. PATH=ai_services\cv_service\main.py | LANG=python
61. PATH=backend\__init__.py | LANG=python
62. PATH=backend\manage.py | LANG=python
63. PATH=backend\backend\__init__.py | LANG=python
64. PATH=backend\backend\config\__init__.py | LANG=python
65. PATH=backend\backend\config\asgi.py | LANG=python
66. PATH=backend\backend\config\celery.py | LANG=python
67. PATH=backend\backend\config\urls.py | LANG=python
68. PATH=backend\backend\config\wsgi.py | LANG=python
69. PATH=backend\backend\settings\__init__.py | LANG=python
70. PATH=backend\backend\settings\base.py | LANG=python
71. PATH=backend\backend\settings\local.py | LANG=python
72. PATH=backend\backend\settings\production.py | LANG=python
73. PATH=backend\backend\settings\regions.py | LANG=python
74. PATH=backend\rest_framework_simplejwt\__init__.py | LANG=python
75. PATH=backend\rest_framework_simplejwt\authentication.py | LANG=python
76. PATH=backend\rest_framework_simplejwt\tokens.py | LANG=python
77. PATH=backend\rest_framework_simplejwt\views.py | LANG=python
78. PATH=backend\tests\__init__.py | LANG=python
79. PATH=backend\tests\test_auth_api.py | LANG=python
80. PATH=backend\tests\test_booking_model.py | LANG=python
81. PATH=backend\tests\test_ui_theme_chat.py | LANG=python
82. PATH=core\__init__.py | LANG=python
83. PATH=core\admin.py | LANG=python
84. PATH=core\apps.py | LANG=python
85. PATH=core\context_processors.py | LANG=python
86. PATH=core\integrations.py | LANG=python
87. PATH=core\middleware.py | LANG=python
88. PATH=core\models.py | LANG=python
89. PATH=core\pagination.py | LANG=python
90. PATH=core\permissions.py | LANG=python
91. PATH=core\utils.py | LANG=python
92. PATH=drf_spectacular\__init__.py | LANG=python
93. PATH=drf_spectacular\openapi.py | LANG=python
94. PATH=drf_spectacular\views.py | LANG=python
95. PATH=frontend\next-app\.env.local | LANG=text
96. PATH=frontend\next-app\.eslintrc.json | LANG=json
97. PATH=frontend\next-app\Dockerfile | LANG=text
98. PATH=frontend\next-app\jest.config.js | LANG=javascript
99. PATH=frontend\next-app\jest.setup.ts | LANG=typescript
100. PATH=frontend\next-app\next-env.d.ts | LANG=typescript
101. PATH=frontend\next-app\next.config.mjs | LANG=text
102. PATH=frontend\next-app\package.json | LANG=json
103. PATH=frontend\next-app\postcss.config.js | LANG=javascript
104. PATH=frontend\next-app\tailwind.config.ts | LANG=typescript
105. PATH=frontend\next-app\tsconfig.json | LANG=json
106. PATH=frontend\next-app\app\globals.css | LANG=css
107. PATH=frontend\next-app\app\layout.tsx | LANG=tsx
108. PATH=frontend\next-app\app\(site)\layout.tsx | LANG=tsx
109. PATH=frontend\next-app\app\(site)\page.tsx | LANG=tsx
110. PATH=frontend\next-app\app\(site)\auth\page.tsx | LANG=tsx
111. PATH=frontend\next-app\app\api\chat\route.ts | LANG=typescript
112. PATH=frontend\next-app\app\embed\page.tsx | LANG=tsx
113. PATH=frontend\next-app\components\header.tsx | LANG=tsx
114. PATH=frontend\next-app\components\providers.tsx | LANG=tsx
115. PATH=frontend\next-app\components\theme-provider.tsx | LANG=tsx
116. PATH=frontend\next-app\components\theme-toggle.tsx | LANG=tsx
117. PATH=frontend\next-app\components\chat\chat-panel.tsx | LANG=tsx
118. PATH=frontend\next-app\components\chat\compact-chat-panel.tsx | LANG=tsx
119. PATH=frontend\next-app\components\chat\conversation-list.tsx | LANG=tsx
120. PATH=frontend\next-app\components\chat\markdown-message.tsx | LANG=tsx
121. PATH=frontend\next-app\components\chat\suggested-prompts.tsx | LANG=tsx
122. PATH=frontend\next-app\components\chat\types.ts | LANG=typescript
123. PATH=frontend\next-app\components\pwa\register-service-worker.tsx | LANG=tsx
124. PATH=frontend\next-app\components\widget\chat-widget.tsx | LANG=tsx
125. PATH=frontend\next-app\context\AuthContext.tsx | LANG=tsx
126. PATH=frontend\next-app\hooks\useAuth.ts | LANG=typescript
127. PATH=frontend\next-app\lib\aiProvider.ts | LANG=typescript
128. PATH=frontend\next-app\lib\authClient.ts | LANG=typescript
129. PATH=frontend\next-app\lib\chatClient.ts | LANG=typescript
130. PATH=frontend\next-app\lib\llmClient.ts | LANG=typescript
131. PATH=frontend\next-app\public\manifest.webmanifest | LANG=text
132. PATH=frontend\next-app\public\offline.html | LANG=html
133. PATH=frontend\next-app\public\service-worker.js | LANG=javascript
134. PATH=frontend\next-app\__tests__\chat-client.test.ts | LANG=typescript
135. PATH=frontend\next-app\__tests__\conversation-list.test.tsx | LANG=tsx
136. PATH=frontend\parkmate\parkmate.types.ts | LANG=typescript
137. PATH=nginx\nginx.conf | LANG=text
138. PATH=parking\__init__.py | LANG=python
139. PATH=parking\admin.py | LANG=python
140. PATH=parking\apps.py | LANG=python
141. PATH=parking\models.py | LANG=python
142. PATH=parking\push.py | LANG=python
143. PATH=parking\serializers.py | LANG=python
144. PATH=parking\tasks.py | LANG=python
145. PATH=parking\urls.py | LANG=python
146. PATH=parking\views.py | LANG=python
147. PATH=parking\management\commands\seed_demo_parking.py | LANG=python
148. PATH=parking\migrations\0001_initial.py | LANG=python
149. PATH=parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py | LANG=python
150. PATH=parking\migrations\0003_booking_ai_fields.py | LANG=python
151. PATH=parking\migrations\0004_favoriteparkingspot_savedplace.py | LANG=python
152. PATH=parking\migrations\0005_pushsubscription.py | LANG=python
153. PATH=parking\migrations\__init__.py | LANG=python
154. PATH=parking\tests\__init__.py | LANG=python
155. PATH=parking\tests\test_pwa_endpoints.py | LANG=python
156. PATH=payments\__init__.py | LANG=python
157. PATH=payments\admin.py | LANG=python
158. PATH=payments\apps.py | LANG=python
159. PATH=payments\models.py | LANG=python
160. PATH=payments\providers.py | LANG=python
161. PATH=payments\serializers.py | LANG=python
162. PATH=payments\tasks.py | LANG=python
163. PATH=payments\views.py | LANG=python
164. PATH=payments\migrations\0001_initial.py | LANG=python
165. PATH=payments\migrations\0002_alter_payment_provider.py | LANG=python
166. PATH=payments\migrations\0003_paymentmethod.py | LANG=python
167. PATH=payments\migrations\__init__.py | LANG=python
168. PATH=payments\providers\__init__.py | LANG=python
169. PATH=payments\providers\base.py | LANG=python
170. PATH=payments\providers\registry.py | LANG=python
171. PATH=payments\providers\stripe.py | LANG=python
172. PATH=payments\providers\yookassa.py | LANG=python
173. PATH=regions\global.yml | LANG=yaml
174. PATH=regions\ru.yml | LANG=yaml
175. PATH=services\__init__.py | LANG=python
176. PATH=services\llm.py | LANG=python
177. PATH=services\llm_service\Dockerfile | LANG=text
178. PATH=services\llm_service\main.py | LANG=python
179. PATH=services\llm_service\requirements.txt | LANG=text
180. PATH=static\manifest.webmanifest | LANG=text
181. PATH=static\service-worker.js | LANG=javascript
182. PATH=static\css\app.css | LANG=css
183. PATH=static\css\cinematic-ui.css | LANG=css
184. PATH=static\js\app.js | LANG=javascript
185. PATH=static\js\chat.js | LANG=javascript
186. PATH=static\js\map.js | LANG=javascript
187. PATH=static\js\parkmate-ai.ts | LANG=typescript
188. PATH=static\js\quantum-theme-manager.js | LANG=javascript
189. PATH=static\js\theme.js | LANG=javascript
190. PATH=static\pwa\api-client.js | LANG=javascript
191. PATH=static\pwa\app.js | LANG=javascript
192. PATH=static\pwa\router.js | LANG=javascript
193. PATH=static\pwa\spots-view.js | LANG=javascript
194. PATH=static\pwa\state-store.js | LANG=javascript
195. PATH=static\pwa\ui-kit.js | LANG=javascript
196. PATH=templates\base.html | LANG=html
197. PATH=templates\offline.html | LANG=html
198. PATH=templates\accounts\login.html | LANG=html
199. PATH=templates\accounts\password_change.html | LANG=html
200. PATH=templates\accounts\password_change_done.html | LANG=html
201. PATH=templates\accounts\password_reset.html | LANG=html
202. PATH=templates\accounts\password_reset_complete.html | LANG=html
203. PATH=templates\accounts\password_reset_confirm.html | LANG=html
204. PATH=templates\accounts\password_reset_done.html | LANG=html
205. PATH=templates\accounts\password_reset_email.txt | LANG=text
206. PATH=templates\accounts\password_reset_subject.txt | LANG=text
207. PATH=templates\accounts\profile.html | LANG=html
208. PATH=templates\accounts\register.html | LANG=html
209. PATH=templates\ai\concierge.html | LANG=html
210. PATH=templates\parking\landing.html | LANG=html
211. PATH=templates\parking\map_fullscreen.html | LANG=html
212. PATH=templates\parking\owner_dashboard.html | LANG=html
213. PATH=templates\parking\pwa_install.html | LANG=html
214. PATH=templates\parking\user_dashboard.html | LANG=html
215. PATH=vehicles\__init__.py | LANG=python
216. PATH=vehicles\admin.py | LANG=python
217. PATH=vehicles\apps.py | LANG=python
218. PATH=vehicles\models.py | LANG=python
219. PATH=vehicles\serializers.py | LANG=python
220. PATH=vehicles\urls.py | LANG=python
221. PATH=vehicles\views.py | LANG=python
222. PATH=vehicles\migrations\0001_initial.py | LANG=python
223. PATH=vehicles\migrations\__init__.py | LANG=python


================================================================================
FILES CONTENT:
================================================================================

===== FILE START =====
FILE_INDEX: 1
PATH: .env
LANG: text
===== CONTENT START =====
DEBUG=1
SECRET_KEY=django-insecure-test-secret-key-for-dev-only
ALLOWED_HOSTS=127.0.0.1,localhost
DATABASE_NAME=db.sqlite3

YOOKASSA_SHOP_ID=
YOOKASSA_SECRET_KEY=

EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend

# Карты / регион
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc


# Старый токен Mapbox
MAPBOX_TOKEN=your_actual_token_here

# OpenAI - ВРЕМЕННО ОТКЛЮЧИТЬ (невалидный ключ)
# OPENAI_API_KEY=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

# LLM Service
LLM_SERVICE_URL=http://localhost:8002
LLM_DEFAULT_MODEL=groq/llama-3.1-8b-instant
LLM_FALLBACK_MODELS='["groq/llama-3.1-8b-instant"]'

# Groq API (основной провайдер)
LLM_GROQ_API_KEY=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

# Настройки LLM
LLM_CACHE_ENABLED=true
LLM_CACHE_TTL_SECONDS=30
LLM_REQUESTS_PER_MINUTE=60

# Django Settings
DJANGO_SETTINGS_MODULE=backend.backend.settings.local

# Redis & Celery
REDIS_URL=redis://localhost:6379/0
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0

# Database
DATABASE_URL=sqlite:///db.sqlite3
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 2
PATH: .env.example
LANG: text
===== CONTENT START =====
# Базовые настройки Django
DEBUG=False
SECRET_KEY=change_me_to_random_long_secret_key
ALLOWED_HOSTS=localhost,127.0.0.1,0.0.0.0
PLATFORM_MODE=RU

# База данных
# Для продакшена: postgres://user:password@db:5432/parkshare
# Django-environ автоматически распарсит URL.
DATABASE_URL=postgres://parkshare:parkshare@db:5432/parkshare

# Payments
PAYMENT_PROVIDER=yookassa
YOOKASSA_SHOP_ID=YOUR_SHOP_ID
YOOKASSA_SECRET_KEY=YOUR_SECRET
YOOKASSA_RETURN_URL=https://SERVER_HOST/payments/return/
YOOKASSA_WEBHOOK_SECRET=YOUR_WEBHOOK_SECRET
STRIPE_SECRET_KEY=YOUR_STRIPE_KEY
STRIPE_WEBHOOK_SECRET=YOUR_STRIPE_WEBHOOK_SECRET

# Redis (брокер/кэш)
REDIS_URL=redis://redis:6379/0

# Таймзона и язык
TIME_ZONE=Europe/Moscow
LANGUAGE_CODE=ru-ru

# Соль для хэширования цифр номеров
VEHICLE_PLATE_SALT=change_me_vehicle_plate_salt

# Настройки CORS (если нужен доступ с другого домена, например, моб. WebView)
CORS_ALLOWED_ORIGINS=http://localhost:8000

# Настройки Celery
CELERY_BROKER_URL=${REDIS_URL}
CELERY_RESULT_BACKEND=${REDIS_URL}

# Настройки YooKassa (пример)
YOOKASSA_SHOP_ID=your_shop_id_here
YOOKASSA_SECRET_KEY=your_secret_key_here
YOOKASSA_RETURN_URL=https://example.com/payments/return/
YOOKASSA_WEBHOOK_SECRET=change_me_webhook_secret

# Комиссия сервиса (процент, будет использована в бизнес-логике)
SERVICE_COMMISSION_PERCENT=10

# Безопасность для продакшена
SECURE_SSL_REDIRECT=False
SESSION_COOKIE_SECURE=False
CSRF_COOKIE_SECURE=False

# Регион / карты
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc


# Next.js Auth (frontend/next-app)
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=change_me_nextauth_secret
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# AI Provider
OPENAI_API_KEY=your_openai_api_key
AI_MODEL=gpt-3.5-turbo

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 3
PATH: .env.prod
LANG: text
===== CONTENT START =====
# -----------------------------
# DJANGO SETTINGS (PROD)
# -----------------------------
DEBUG=0
SECRET_KEY=django-insecure-поставь_сюда_очень_длинную_строку_символов
ALLOWED_HOSTS=your-domain.ru,your-domain.com,127.0.0.1

DJANGO_SETTINGS_MODULE=backend.settings.production

# -----------------------------
# DATABASE (PostgreSQL / PostGIS)
# -----------------------------
DATABASE_NAME=parkshare
DATABASE_USER=parkshare
DATABASE_PASSWORD=сильный_пароль_к_бд
DATABASE_HOST=db
DATABASE_PORT=5432

# -----------------------------
# YOOKASSA PAYMENTS (боевые реквизиты)
# -----------------------------
YOOKASSA_SHOP_ID=твой_shop_id
YOOKASSA_SECRET_KEY=твой_secret_key

# -----------------------------
# EMAIL SETTINGS
# -----------------------------
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.yandex.ru
EMAIL_PORT=465
EMAIL_USE_SSL=1
EMAIL_HOST_USER=no-reply@your-domain.ru
EMAIL_HOST_PASSWORD=пароль_от_почты

# -----------------------------
# MAP / REGION
# -----------------------------
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc
MAPBOX_TOKEN=your_actual_token_here

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 4
PATH: .gitattributes
LANG: text
===== CONTENT START =====
# Auto detect text files and perform LF normalization
* text=auto

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 5
PATH: .gitignore
LANG: text
===== CONTENT START =====
db.sqlite3
__pycache__/
*.pyc
.env
staticfiles/
frontend/next-app/node_modules/
.next/
node_modules/

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 6
PATH: Dockerfile
LANG: text
===== CONTENT START =====
# Production-ready Dockerfile
FROM python:3.12-slim AS builder
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    gdal-bin \
    libgdal-dev \
    binutils \
    libproj-dev \
    libgeos-dev \
    libspatialindex-dev \
    gettext \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt
COPY . /app/

RUN python backend/manage.py collectstatic --noinput --settings=backend.backend.settings.production || true

FROM python:3.12-slim AS runtime
ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1
WORKDIR /app

COPY --from=builder /usr/local/lib/python3.12 /usr/local/lib/python3.12
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app /app

EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD curl -f http://localhost:8000/health/ || exit 1
CMD ["gunicorn", "backend.config.wsgi:application", "--bind", "0.0.0.0:8000"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 7
PATH: README.md
LANG: markdown
===== CONTENT START =====
# ParkShare Global Platform

Унифицированная архитектура для ParkShare с профилями RU/GLOBAL, защищёнными настройками и PWA фронтендом.

## Запуск
```bash
docker-compose up --build
```
ENVIRONMENT выбирается через переменные окружения и файлы `.env.<profile>`.

Для локальной разработки без зависимостей PostGIS/GDAL установите `USE_GIS=False` и задайте
`DATABASE_URL=sqlite:///db.sqlite3`, чтобы Django использовал SQLite и не требовал GDAL.

## Контейнеры
- PostGIS (db)
- Redis (cache/rate limit/Celery)
- Gunicorn web (Django)
- Celery worker/beat
- Nginx как TLS-терминатор

## Безопасность
- JWT + refresh токены (`/api/auth/token`, `/api/auth/token/refresh`)
- Rate limiting, CSP, HSTS, Referrer/Permissions Policy (`core/middleware.py`, `backend/settings`)
- Provider registry (`providers/`)
- Транзакционные блокировки бронирований (`parking/views.py`)

## PWA
- Сервис-воркер с разными стратегиями кэширования (`static/service-worker.js`)
- Offline fallback (`templates/offline.html`)

## AI
- Динамическое ценообразование, рекомендации, CV и антифрод (`ai/engines.py`, `services/ai.py`)

## Frontend (Next.js AI Concierge)
- Apple-стиль витрина в `frontend/next-app` на Next.js + Tailwind + PWA
- Мульти-провайдерный AI (LLM_PROVIDER/LLM_API_URL/LLM_API_KEY) с потоковыми ответами, копированием, перегенерацией и сохранённой историей по пользователю
- Поддержка светлой/тёмной темы, липкого ввода, пресетов, избранных подсказок и онбординга
- Соц/OAuth (VK/Яндекс/Google) + телефон OTP + почта/пароль, история чатов привязывается к профилю; гостевой режим хранит историю в браузере
- Встроенный PWA (манифест + сервис-воркер) с кешем оболочки, offline fallback и безопасными заголовками

### Auth setup
1. Скопируйте `.env.example` в `.env.local` рядом с frontend: заполните `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, `NEXTAUTH_SECRET`, `NEXTAUTH_URL`.
2. Укажите бэкенд для экранов `/auth`: `NEXT_PUBLIC_AUTH_API_URL` (или `NEXT_PUBLIC_AUTH_API_BASE`), `NEXT_PUBLIC_VK_CLIENT_ID`, `NEXT_PUBLIC_VK_REDIRECT_URI`, `NEXT_PUBLIC_YANDEX_CLIENT_ID`, `NEXT_PUBLIC_YANDEX_REDIRECT_URI`. Телефонный OTP ожидает `/auth/otp/request` и `/auth/otp/verify`; почта/пароль — `/auth/email/login` и `/auth/email/register`.
3. Настройте LLM: `LLM_PROVIDER` (`openai`|`proxy`|`custom`), `LLM_API_URL`, `LLM_API_KEY`, по желанию `LLM_AUTH_HEADER`/`LLM_AUTH_SCHEME` и `LLM_MODEL`. Без ключей чат вернёт демо-ответ.
4. В каталоге `frontend/next-app` установите зависимости (`npm install`) и запустите дев-сервер: `npm run dev` (порт 3000 по умолчанию).
5. PWA: манифест `public/manifest.webmanifest`, сервис-воркер `public/service-worker.js` (стратегия SWR для статики, offline fallback). Регистрация — `components/pwa/register-service-worker.tsx` (только в продакшене).

### PWA / offline
- Манифест: `public/manifest.webmanifest`, иконки в `public/icons/`
- Сервис-воркер: `public/service-worker.js` кэширует shell, статику и отдает `offline.html` для навигации без сети.
- Регистрация происходит на клиенте в продакшене (`components/pwa/register-service-worker.tsx`).
- Проверка установки: откройте Lighthouse/Chrome DevTools → Application → Manifest/Service Workers; включите offline и обновите страницу.

### Next.js AI Concierge – Docker & CI
- Сборка образа: `cd frontend/next-app && docker build -t parkshare-next .`
- Запуск локально: `docker run -p 3000:3000 --env-file .env.local parkshare-next`
- CI: GitHub Actions workflow `.github/workflows/frontend-next.yml` валидирует `npm test`, `npm run lint`, `npm run build` и сборку Docker.

### Frontend testing
- Тесты лежат в `frontend/next-app/__tests__` и используют Jest + React Testing Library.
- Запуск всех тестов: `cd frontend/next-app && npm test -- --runInBand` (при необходимости добавьте `NODE_OPTIONS=--experimental-vm-modules` для старых Node).

### Безопасность и CSP для фронтенда
- CSP настраивается в `frontend/next-app/next.config.mjs` и по умолчанию запрещает внешние подключения, кроме Google OAuth и AI API.
- В `script-src` оставлен `unsafe-inline` для скриптов и стилей, генерируемых Next.js при гидрации. Перед ужесточением политики добавьте nonce/hashed-скрипты, чтобы не сломать загрузку приложения.
- При добавлении новых внешних ресурсов в чат или сервис-воркер добавляйте их в `connect-src`/`worker-src`/`img-src` в том же файле.

### Docker/compose
- В `docker-compose.yml` и `docker-compose.prod.yml` добавлен сервис `frontend` (Next.js, порт 3000), совместимый с существующим Django стеком.
- Совместный запуск всей платформы: `docker-compose up --build` (Next.js будет доступен на 3000, backend на 8000, фронт можно проксировать через nginx по необходимости).
- Запуск только фронтенда для локальной разработки: `cd frontend/next-app && npm install && npm run dev`.

## Продакшен-старт (Ubuntu/Debian)
```bash
cp .env.example .env.prod  # заполнить секреты/хосты
docker-compose -f docker-compose.prod.yml up -d --build
```

Домен и TLS настраиваются через `nginx/nginx.conf` (добавьте сертификаты Let's Encrypt). ALLOWED_HOSTS и переменные карты/платежей берутся из `.env.prod`.
#   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 8
PATH: api_server.py
LANG: python
===== CONTENT START =====
# api_server.py
from __future__ import annotations

import datetime as dt
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

import joblib
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from database import get_connection

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"

# --- Загрузка моделей ---

occ_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "occupancy_model.pkl")
OCC_PIPE = occ_bundle["pipeline"]
OCC_FEATURE_COLS = occ_bundle["feature_cols"]

NLP_PIPE = joblib.load(MODELS_DIR / "nlp_intent.pkl")

rec_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "recommender.pkl")
USER_ITEM: pd.DataFrame = rec_bundle["user_item"]
ITEM_SIM: pd.DataFrame = rec_bundle["item_sim"]
LOT_FEATURES: pd.DataFrame = rec_bundle["lot_features"]

# --- FastAPI ---

app = FastAPI(title="ParkShare Local AI", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # при желании ограничить доменом PWA
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ---------- Схемы ----------


class Lot(BaseModel):
    id: int
    name: str
    latitude: float
    longitude: float
    near_metro: bool
    price_level: int
    has_covered: bool
    has_ev_charging: bool
    predicted_occupancy: float


class SearchResult(BaseModel):
    query: str
    intent: str
    time_of_day: Optional[str]
    near_metro: Optional[bool]
    max_price_level: Optional[int]
    has_ev_charging: Optional[bool]
    has_covered: Optional[bool]
    lots: List[Lot]


class OccupancyPredictionResponse(BaseModel):
    lot_id: int
    ts: dt.datetime
    predicted_occupancy: float


class Recommendation(BaseModel):
    lot: Lot
    score: float


class RecommendationsResponse(BaseModel):
    user_id: Optional[int]
    variant: str  # 'A' или 'B' для A/B теста
    recommendations: List[Recommendation]


# ---------- Утилиты ----------


def parse_dt_iso(value: Optional[str]) -> dt.datetime:
    if not value:
        return dt.datetime.now()
    try:
        return dt.datetime.fromisoformat(value)
    except Exception as exc:
        raise HTTPException(status_code=400, detail=f"Неверный формат datetime: {value}") from exc


def nlp_extract_entities(text: str) -> Dict[str, Any]:
    s = text.lower()

    time_of_day = None
    if "утр" in s:
        time_of_day = "morning"
    elif "днем" in s or "днём" in s:
        time_of_day = "day"
    elif "вечер" in s:
        time_of_day = "evening"
    elif "ноч" in s:
        time_of_day = "night"

    near_metro = "метро" in s

    max_price_level: Optional[int] = None
    if "дешев" in s or "недорог" in s:
        max_price_level = 1
    elif "средн" in s:
        max_price_level = 2
    elif "дорог" in s:
        max_price_level = 3

    has_ev = "электро" in s or "зарядк" in s or "ev" in s
    has_covered = "крыт" in s or "подзем" in s or "паркинг" in s

    return {
        "time_of_day": time_of_day,
        "near_metro": near_metro if near_metro else None,
        "max_price_level": max_price_level,
        "has_ev_charging": has_ev if has_ev else None,
        "has_covered": has_covered if has_covered else None,
    }


def build_occ_feature_df(lot_row: Dict[str, Any], ts: dt.datetime) -> pd.DataFrame:
    return pd.DataFrame(
        [
            {
                "hour": ts.hour,
                "dow": ts.weekday(),
                "temperature": 15.0,  # без реальной погоды
                "is_rain": 0,
                "is_event": 0,
                "near_metro": lot_row["near_metro"],
                "price_level": lot_row["price_level"],
                "has_covered": lot_row["has_covered"],
                "has_ev_charging": lot_row["has_ev_charging"],
                "lot_id_str": str(lot_row["id"]),
            }
        ]
    )[OCC_FEATURE_COLS]


def predict_occupancy_for_lot(lot_row: Dict[str, Any], ts: dt.datetime) -> float:
    df = build_occ_feature_df(lot_row, ts)
    pred = float(OCC_PIPE.predict(df)[0])
    return max(0.0, min(pred, 1.0))


def fetch_lots(filters: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
    conn = get_connection()
    cur = conn.cursor()

    base_query = """
        SELECT
            id, name, latitude, longitude,
            near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE 1=1
    """
    params: List[Any] = []

    if filters:
        if filters.get("near_metro") is not None:
            base_query += " AND near_metro = ?"
            params.append(1 if filters["near_metro"] else 0)
        if filters.get("max_price_level") is not None:
            base_query += " AND price_level <= ?"
            params.append(int(filters["max_price_level"]))
        if filters.get("has_ev_charging") is not None:
            base_query += " AND has_ev_charging = ?"
            params.append(1 if filters["has_ev_charging"] else 0)
        if filters.get("has_covered") is not None:
            base_query += " AND has_covered = ?"
            params.append(1 if filters["has_covered"] else 0)

    base_query += " ORDER BY price_level ASC, near_metro DESC"

    cur.execute(base_query, params)
    rows = [dict(r) for r in cur.fetchall()]
    conn.close()
    return rows


# ---------- Эндпоинты ----------


@app.get("/health")
def health() -> Dict[str, Any]:
    return {"status": "ok"}


@app.get("/api/lots", response_model=List[Lot])
def api_list_lots(
    ts: Optional[str] = Query(default=None, description="ISO datetime, по умолчанию — сейчас"),
) -> List[Lot]:
    dt_value = parse_dt_iso(ts)
    lots = fetch_lots()

    result: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        result.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )
    return result


@app.get("/api/occupancy/predict", response_model=OccupancyPredictionResponse)
def api_predict_occupancy(
    lot_id: int = Query(...),
    ts: Optional[str] = Query(default=None),
) -> OccupancyPredictionResponse:
    dt_value = parse_dt_iso(ts)
    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id = ?
        """,
        (lot_id,),
    )
    row = cur.fetchone()
    conn.close()
    if row is None:
        raise HTTPException(status_code=404, detail="Парковка не найдена")
    d = dict(row)
    occ = predict_occupancy_for_lot(d, dt_value)
    return OccupancyPredictionResponse(
        lot_id=lot_id,
        ts=dt_value,
        predicted_occupancy=occ,
    )


@app.get("/api/search", response_model=SearchResult)
def api_search(
    query: str = Query(..., min_length=1),
    ts: Optional[str] = Query(default=None),
    limit: int = Query(default=15, ge=1, le=100),
) -> SearchResult:
    dt_value = parse_dt_iso(ts)

    intent = NLP_PIPE.predict([query])[0]
    entities = nlp_extract_entities(query)

    filters: Dict[str, Any] = {}
    if entities["near_metro"]:
        filters["near_metro"] = True
    if entities["max_price_level"] is not None:
        filters["max_price_level"] = entities["max_price_level"]
    if entities["has_ev_charging"] is not None:
        filters["has_ev_charging"] = entities["has_ev_charging"]
    if entities["has_covered"] is not None:
        filters["has_covered"] = entities["has_covered"]

    if intent == "near_metro":
        filters["near_metro"] = True
    if intent == "cheap" and "max_price_level" not in filters:
        filters["max_price_level"] = 1

    lots = fetch_lots(filters)
    lots = lots[:limit]

    lot_models: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        lot_models.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )

    return SearchResult(
        query=query,
        intent=intent,
        time_of_day=entities["time_of_day"],
        near_metro=filters.get("near_metro"),
        max_price_level=filters.get("max_price_level"),
        has_ev_charging=filters.get("has_ev_charging"),
        has_covered=filters.get("has_covered"),
        lots=lot_models,
    )


def _recommend_item_based(user_id: int, top_n: int = 10) -> List[int]:
    if user_id not in USER_ITEM.index:
        return []

    user_ratings = USER_ITEM.loc[user_id]
    rated_items = user_ratings[user_ratings > 0].index.tolist()
    if not rated_items:
        return []

    scores = pd.Series(0.0, index=USER_ITEM.columns)

    for item_id in rated_items:
        sim_vec = ITEM_SIM.loc[item_id]
        scores += sim_vec * float(user_ratings[item_id])

    scores = scores.drop(rated_items)
    scores = scores.sort_values(ascending=False)
    return scores.head(top_n).index.tolist()


def _recommend_content_based(top_n: int = 10) -> List[int]:
    df = LOT_FEATURES.copy()
    df["score"] = 0.0

    df["score"] += (1 - (df["price_level"] - 1) / 2)  # дешёвые выше
    df["score"] += df["near_metro"] * 0.5
    df["score"] += df["has_ev_charging"] * 0.3
    df["score"] += df["has_covered"] * 0.2

    df = df.sort_values("score", ascending=False)
    return df.head(top_n).index.tolist()


@app.get("/api/recommendations", response_model=RecommendationsResponse)
def api_recommendations(
    user_id: Optional[int] = Query(default=None),
    variant: Optional[str] = Query(
        default=None,
        description="A или B — для A/B тестирования (A=collab, B=content)",
    ),
    limit: int = Query(default=10, ge=1, le=50),
    ts: Optional[str] = Query(default=None),
) -> RecommendationsResponse:
    dt_value = parse_dt_iso(ts)

    chosen_variant = variant or ("A" if user_id else "B")

    if chosen_variant == "A" and user_id is not None:
        item_ids = _recommend_item_based(user_id, top_n=limit)
        if not item_ids:
            chosen_variant = "B"
    if chosen_variant == "B" or user_id is None:
        item_ids = _recommend_content_based(top_n=limit)

    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        f"""
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id IN ({",".join(["?"] * len(item_ids))})
        """,
        item_ids,
    )
    rows = {r["id"]: dict(r) for r in cur.fetchall()}
    conn.close()

    recs: List[Recommendation] = []
    for lot_id in item_ids:
        row = rows.get(lot_id)
        if not row:
            continue
        occ = predict_occupancy_for_lot(row, dt_value)
        lot = Lot(
            id=row["id"],
            name=row["name"],
            latitude=row["latitude"],
            longitude=row["longitude"],
            near_metro=bool(row["near_metro"]),
            price_level=row["price_level"],
            has_covered=bool(row["has_covered"]),
            has_ev_charging=bool(row["has_ev_charging"]),
            predicted_occupancy=occ,
        )
        # простая метрика: обратная занятость + бонус за метро и цену
        score = (1.0 - occ) + (1 - (row["price_level"] - 1) / 2) + (0.3 if row["near_metro"] else 0.0)
        recs.append(Recommendation(lot=lot, score=float(score)))

    return RecommendationsResponse(
        user_id=user_id,
        variant=chosen_variant,
        recommendations=recs,
    )


if __name__ == "__main__":
    import os
    import uvicorn

    host = os.environ.get("AI_API_HOST", "0.0.0.0")
    try:
        port = int(os.environ.get("AI_API_PORT", "8001"))
    except (TypeError, ValueError):
        port = 8001

    uvicorn.run("api_server:app", host=host, port=port, reload=True)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 9
PATH: app.js
LANG: javascript
===== CONTENT START =====
// app.js

// Базовый URL FastAPI-сервера
// Если сервер крутится на другом порту/домене — поправь здесь.
const API_BASE = "http://localhost:8001";

let map;
let markersLayer;
let lotsCache = [];
let lotsById = new Map();

function pickBestLot(lots) {
  if (!lots || lots.length === 0) return null;
  const ranked = [...lots].sort((a, b) => {
    const occA = a.predicted_occupancy ?? 1;
    const occB = b.predicted_occupancy ?? 1;
    return occA - occB;
  });
  return ranked[0];
}

function updateAIOracleCard(lots) {
  const nameEl = document.getElementById("aiOracleName");
  const etaEl = document.getElementById("aiOracleETA");
  const confEl = document.getElementById("aiOracleConfidence");
  const metaEl = document.getElementById("aiOracleMeta");
  const reasoningEl = document.getElementById("aiOracleReason");

  if (!nameEl || !etaEl || !confEl || !metaEl || !reasoningEl) return;

  if (!lots || lots.length === 0) {
    nameEl.textContent = "—";
    etaEl.textContent = "—";
    confEl.textContent = "—";
    metaEl.textContent = "—";
    reasoningEl.textContent = "AI готовит инсайт…";
    return;
  }

  const bestLot = pickBestLot(lots);
  if (!bestLot) return;

  const occ = bestLot.predicted_occupancy ?? 0;
  const occPercent = Math.round(occ * 100);
  const eta = Math.max(2, Math.min(15, Math.round((1 - occ) * 12)));
  const confidence = Math.max(68, Math.min(99, 96 - Math.round(occPercent / 2)));
  const ev = bestLot.has_ev_charging ? "EV" : "обычная";
  const covered = bestLot.has_covered ? "крытая" : "открытая";

  nameEl.textContent = bestLot.name;
  etaEl.textContent = `${eta} мин`;
  confEl.textContent = `${confidence}%`;
  metaEl.textContent = `${ev} · ${covered}`;
  reasoningEl.textContent =
    "Учитывая вашу историю: быстрый выезд, EV и близость к метро — этот слот даст наивысший WOW-эффект.";
}

// ----------------- ИНИЦИАЛИЗАЦИЯ КАРТЫ -----------------

function occupancyColor(value) {
  if (value <= 0.4) return "#22c55e"; // green
  if (value <= 0.7) return "#eab308"; // yellow
  return "#ef4444"; // red
}

function initMap() {
  map = L.map("map", {
    zoomControl: true,
    attributionControl: false,
  }).setView([55.7558, 37.6173], 12);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
  }).addTo(map);

  markersLayer = L.layerGroup().addTo(map);
}

// ----------------- API HELPERS -----------------

async function apiGet(path, params = {}) {
  const url = new URL(API_BASE + path);
  Object.entries(params).forEach(([k, v]) => {
    if (v !== undefined && v !== null) {
      url.searchParams.set(k, v);
    }
  });

  const res = await fetch(url.toString());
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`API error ${res.status}: ${text}`);
  }
  return res.json();
}

// ----------------- ОТРИСОВКА ЛОТОВ -----------------

function renderLotsOnMap(lots) {
  markersLayer.clearLayers();

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const color = occupancyColor(occ);

    const marker = L.circleMarker([lot.latitude, lot.longitude], {
      radius: 8,
      fillColor: color,
      fillOpacity: 0.9,
      color: "#020617",
      weight: 1,
    });

    const occPercent = Math.round(occ * 100);

    const html = `
      <div style="font-size: 12px;">
        <strong>${lot.name}</strong><br />
        Загрузка: <strong>${occPercent}%</strong><br />
        Метро: ${lot.near_metro ? "рядом" : "нет"}<br />
        Уровень цены: ${lot.price_level}<br />
        Крытая: ${lot.has_covered ? "да" : "нет"}<br />
        Зарядка EV: ${lot.has_ev_charging ? "есть" : "нет"}
      </div>
    `;

    marker.bindPopup(html);
    marker.addTo(markersLayer);
  });

  if (lots.length > 0) {
    const bounds = L.latLngBounds(
      lots.map((lot) => [lot.latitude, lot.longitude])
    );
    map.fitBounds(bounds.pad(0.2));
  }
}

function renderLotsList(containerId, lots, clickHandler) {
  const container = document.getElementById(containerId);
  container.innerHTML = "";

  if (!lots || lots.length === 0) {
    container.innerHTML =
      '<div style="font-size: 0.75rem; color: #6b7280;">Нет данных.</div>';
    return;
  }

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const occPercent = Math.round(occ * 100);

    const div = document.createElement("div");
    div.className = "lot-item";
    div.innerHTML = `
      <div class="lot-main">
        <div class="lot-name">${lot.name}</div>
        <div class="lot-meta">
          <span>Цена: L${lot.price_level}</span>
          <span>Метро: ${lot.near_metro ? "рядом" : "нет"}</span>
          <span>EV: ${lot.has_ev_charging ? "есть" : "нет"}</span>
          <span>Крытая: ${lot.has_covered ? "да" : "нет"}</span>
        </div>
      </div>
      <div class="lot-occ">${occPercent}%</div>
    `;

    div.addEventListener("click", () => clickHandler(lot));
    container.appendChild(div);
  });
}

// ----------------- ЛОГИКА UI -----------------

async function loadAllLots() {
  const status = document.getElementById("statusText");
  try {
    const lots = await apiGet("/api/lots");
    lotsCache = lots;
    lotsById.clear();
    lots.forEach((lot) => lotsById.set(lot.id, lot));

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = "AI-сервер подключён";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка подключения к AI-серверу";
  }
}

async function handleSearch() {
  const input = document.getElementById("searchInput");
  const status = document.getElementById("searchStatus");
  const text = input.value.trim();
  if (!text) return;

  status.textContent = "Обрабатываю запрос (локальный NLP)…";

  try {
    const data = await apiGet("/api/search", { query: text });
    const lots = data.lots || [];

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    const parts = [];
    parts.push(`Интент: ${data.intent}`);
    if (data.near_metro !== null) {
      parts.push(`рядом с метро: ${data.near_metro ? "да" : "нет"}`);
    }
    if (data.max_price_level !== null) {
      parts.push(`макс. уровень цены: L${data.max_price_level}`);
    }
    if (data.has_ev_charging !== null) {
      parts.push(`EV: ${data.has_ev_charging ? "нужна" : "не нужна"}`);
    }
    if (data.has_covered !== null) {
      parts.push(`крытая: ${data.has_covered ? "нужна" : "не нужна"}`);
    }
    if (data.time_of_day) {
      parts.push(`время суток: ${data.time_of_day}`);
    }
    status.textContent = parts.join(" · ") || "Фильтры не распознаны.";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка обработки запроса";
  }
}

async function initUsersSelect() {
  const select = document.getElementById("userSelect");
  // Пользователи не отдаются API, но user_id есть в тренировочных данных.
  // Для демо предположим, что есть пользователи с id 1..20.
  for (let i = 1; i <= 20; i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `Пользователь #${i}`;
    select.appendChild(opt);
  }
}

async function handleRecommendations(variant) {
  const select = document.getElementById("userSelect");
  const status = document.getElementById("recStatus");
  const listContainerId = "recList";

  const userId = parseInt(select.value, 10) || undefined;

  status.textContent =
    variant === "A"
      ? "Рассчитываю рекомендации (collaborative)…"
      : "Рассчитываю рекомендации (content-based)…";

  try {
    const params = { limit: 10, variant };
    if (variant === "A" && userId) {
      params.user_id = userId;
    }
    const data = await apiGet("/api/recommendations", params);
    const recs = data.recommendations || [];

    const lots = recs.map((r) => r.lot);
    renderLotsOnMap(lots);
    renderLotsList(listContainerId, lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = `Вариант ${data.variant}, получено ${recs.length} рекомендаций.`;
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка получения рекомендаций";
  }
}

// ----------------- СТАРТ -----------------

window.addEventListener("DOMContentLoaded", async () => {
  initMap();
  await initUsersSelect();
  await loadAllLots();

  document
    .getElementById("searchBtn")
    .addEventListener("click", () => handleSearch());

  document
    .getElementById("searchInput")
    .addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        handleSearch();
      }
    });

  document.getElementById("recBtn").addEventListener("click", () => {
    handleRecommendations("A");
  });

  document
    .getElementById("recContentBtn")
    .addEventListener("click", () => {
      handleRecommendations("B");
    });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 10
PATH: celerybeat-schedule.bak
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 11
PATH: celerybeat-schedule.dat
LANG: text
===== CONTENT START =====
�}�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ��	       �5.5.3�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��       �
Europe/Moscow�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ��.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��L      }�(�expire_unpaid_bookings��celery.beat��
ScheduleEntry���(�expire_unpaid_bookings��$parking.tasks.expire_unpaid_bookings��datetime��datetime���C
�-�E��builtins��getattr����zoneinfo��ZoneInfo����	_unpickle���R��
Europe/Moscow�K��R���R�K�celery.schedules��schedule���h�	timedelta���K MXK ��R��N��R�)}�}�t�R��update_ai_models�h(�update_ai_models��ai.tasks.update_models�h	C
�-	3Ӕh��R�KhhK MK ��R��N��R�)}�}�t�R��check_stale_payments�h(�check_stale_payments��#payments.tasks.check_stale_payments�h	C
�-	;��h��R�KhhK M�K ��R��N��R�)}�}�t�R�u.
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 12
PATH: celerybeat-schedule.dir
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 13
PATH: database.py
LANG: python
===== CONTENT START =====
# database.py
from __future__ import annotations

import random
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import List

DB_PATH = Path(__file__).parent / "ai_data.db"


def get_connection() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db() -> None:
    conn = get_connection()
    cur = conn.cursor()

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS parking_lot (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            latitude REAL NOT NULL,
            longitude REAL NOT NULL,
            near_metro INTEGER NOT NULL,
            price_level INTEGER NOT NULL,
            has_covered INTEGER NOT NULL,
            has_ev_charging INTEGER NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS occupancy_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            lot_id INTEGER NOT NULL,
            ts TEXT NOT NULL,
            occupancy REAL NOT NULL,
            temperature REAL NOT NULL,
            is_rain INTEGER NOT NULL,
            is_event INTEGER NOT NULL,
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS app_user (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS user_rating (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            lot_id INTEGER NOT NULL,
            rating REAL NOT NULL,
            FOREIGN KEY (user_id) REFERENCES app_user(id),
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    conn.commit()
    conn.close()


@dataclass
class LotSpec:
    name: str
    base_lat: float
    base_lon: float
    near_metro: int
    price_level: int
    has_covered: int
    has_ev_charging: int


def generate_synthetic_data(
    num_lots: int = 30,
    num_users: int = 50,
    days_back: int = 30,
) -> None:
    """
    Генерация синтетических:
    - парковок
    - истории занятости
    - пользователей
    - оценок пользователей
    """
    random.seed(42)

    conn = get_connection()
    cur = conn.cursor()

    # Чистим старые данные
    cur.execute("DELETE FROM user_rating;")
    cur.execute("DELETE FROM app_user;")
    cur.execute("DELETE FROM occupancy_history;")
    cur.execute("DELETE FROM parking_lot;")
    conn.commit()

    # Базовые точки вокруг Москвы
    center_lat, center_lon = 55.7558, 37.6173

    lots: List[int] = []
    for i in range(num_lots):
        near_metro = 1 if random.random() < 0.5 else 0
        price_level = random.choice([1, 2, 3])  # 1 — дешево, 3 — дорого
        has_covered = 1 if random.random() < 0.4 else 0
        has_ev = 1 if random.random() < 0.3 else 0

        # Немного раскидываем точки вокруг центра
        lat = center_lat + random.uniform(-0.05, 0.05)
        lon = center_lon + random.uniform(-0.1, 0.1)

        cur.execute(
            """
            INSERT INTO parking_lot (
                name, latitude, longitude, near_metro,
                price_level, has_covered, has_ev_charging
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """,
            (
                f"Лот #{i+1}",
                lat,
                lon,
                near_metro,
                price_level,
                has_covered,
                has_ev,
            ),
        )
        lots.append(cur.lastrowid)

    # История занятости — каждые 2 часа за days_back дней
    now = datetime.now()
    start_ts = now - timedelta(days=days_back)

    weather_states = ["sunny", "cloudy", "rainy"]

    for lot_id in lots:
        ts = start_ts
        while ts < now:
            dow = ts.weekday()
            hour = ts.hour

            is_event = 1 if (dow in (4, 5) and hour >= 18 and random.random() < 0.3) else 0
            weather = random.choice(weather_states)
            is_rain = 1 if weather == "rainy" else 0
            temperature = random.uniform(-10, 30)

            # Базовая занятость зависит от часа и дня недели
            base_occ = 0.2
            if 8 <= hour <= 11:
                base_occ = 0.6
            elif 17 <= hour <= 20:
                base_occ = 0.7
            elif 0 <= hour <= 5:
                base_occ = 0.1

            if dow >= 5:
                base_occ += 0.1

            if is_event:
                base_occ += 0.2
            if is_rain:
                base_occ += 0.1

            base_occ = max(0.0, min(base_occ + random.uniform(-0.1, 0.1), 1.0))

            cur.execute(
                """
                INSERT INTO occupancy_history (
                    lot_id, ts, occupancy, temperature, is_rain, is_event
                ) VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    lot_id,
                    ts.isoformat(),
                    base_occ,
                    temperature,
                    is_rain,
                    is_event,
                ),
            )

            ts += timedelta(hours=2)

    # Пользователи
    users = []
    for i in range(num_users):
        cur.execute(
            "INSERT INTO app_user (name) VALUES (?);",
            (f"user_{i+1}",),
        )
        users.append(cur.lastrowid)

    # Оценки пользователей парковок
    for user_id in users:
        # Каждый пользователь оценит 5–15 парковок
        k = random.randint(5, min(15, len(lots)))
        rated_lots = random.sample(lots, k)
        for lot_id in rated_lots:
            # Рейтинг зависит от price_level и случайности
            base_rating = 4.5 - 0.5 * (random.randint(1, 3) - 1)
            rating = max(1.0, min(5.0, base_rating + random.uniform(-1.0, 1.0)))
            cur.execute(
                """
                INSERT INTO user_rating (user_id, lot_id, rating)
                VALUES (?, ?, ?)
                """,
                (user_id, lot_id, rating),
            )

    conn.commit()
    conn.close()
    print("Синтетические данные сгенерированы в", DB_PATH)


if __name__ == "__main__":
    init_db()
    generate_synthetic_data()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 14
PATH: docker-compose.prod.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: gunicorn backend.config.wsgi:application --bind 0.0.0.0:8000
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config worker -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config beat -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    restart: always
    environment:
      NEXTAUTH_URL: ${NEXTAUTH_URL:-http://localhost:3000}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:-change_me_frontend}
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID:-dummy}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET:-dummy}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-dummy}
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:1.27-alpine
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 15
PATH: docker-compose.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    container_name: parkshare_db
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: parkshare
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    container_name: parkshare_redis
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_web
    restart: always
    env_file:
      - .env  # можно потом заменить на .env.prod
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_worker
    restart: always
    env_file:
      - .env
    command: celery -A backend.config worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_beat
    restart: always
    env_file:
      - .env
    command: celery -A backend.config beat -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  ai_pricing_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_ai_pricing
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.ai_pricing_service.main:app --host 0.0.0.0 --port 8100
    depends_on:
      - redis
    networks:
      - parkshare_net

  llm_service:
    build:
      context: .
      dockerfile: services/llm_service/Dockerfile
    container_name: parkshare_llm_service
    restart: always
    env_file:
      - .env
    ports:
      - "8002:8002"
    networks:
      - parkshare_net

  cv_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_cv_service
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.cv_service.main:app --host 0.0.0.0 --port 8200
    depends_on:
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    container_name: parkshare_frontend
    restart: always
    environment:
      NEXTAUTH_URL: http://localhost:3000
      NEXTAUTH_SECRET: dev_secret
      GOOGLE_CLIENT_ID: dummy
      GOOGLE_CLIENT_SECRET: dummy
      OPENAI_API_KEY: dummy
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:alpine
    container_name: parkshare_nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 16
PATH: dump_project.py
LANG: python
===== CONTENT START =====
import os
from datetime import datetime

# Какие папки игнорировать (расширенный список)
EXCLUDED_DIRS = {
    ".git", ".venv", "venv", "__pycache__", "node_modules",
    "dist", "build", "staticfiles", "media", ".idea", ".vscode",
    "static/icons",      # иконки не нужны в дампе
    "logs", "cache", "temp",  # временные файлы и логи
}

# Какие расширения файлов пропускать (расширенный список)
IGNORED_EXTENSIONS = {
    ".pyc", ".pyo", ".pyd", ".sqlite3", ".sqlite", ".db",
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp",
    ".pdf", ".zip", ".rar", ".7z", ".tar", ".gz",
    ".exe", ".dll", ".so", ".pkl", ".h5", ".model", ".pt",
    ".mp4", ".mp3", ".wav", ".avi", ".mov",
    ".log", ".tmp", ".cache",
}

# Файлы, которые нужно полностью игнорировать
EXCLUDED_FILES = {
    "CODEX_LOG1.txt", "CODEX__LOGS.txt",
    "package-lock.json", "yarn.lock",
}

# Никакого лимита на размер файла и дампа
MAX_FILE_SIZE = None  # не используется
MAX_TOTAL_DUMP_SIZE = None  # не используется

# Сжатие кода выключено, содержимое пишется как есть
COMPRESS_CODE = False


def is_binary_file(filename: str) -> bool:
    _, ext = os.path.splitext(filename.lower())
    return ext in IGNORED_EXTENSIONS


def should_exclude_file(filename: str) -> bool:
    return filename in EXCLUDED_FILES


def compress_content(content: str, filepath: str) -> str:
    # Оставлено для совместимости, по факту возвращает исходный контент
    if not COMPRESS_CODE:
        return content
    return content


def detect_language(filepath: str) -> str:
    """
    Определение "языка" для ИИ по расширению файла,
    чтобы он лучше понимал, что за содержимое перед ним.
    """
    _, ext = os.path.splitext(filepath.lower())
    mapping = {
        ".py": "python",
        ".js": "javascript",
        ".ts": "typescript",
        ".tsx": "tsx",
        ".jsx": "jsx",
        ".html": "html",
        ".htm": "html",
        ".css": "css",
        ".scss": "scss",
        ".sass": "sass",
        ".json": "json",
        ".yml": "yaml",
        ".yaml": "yaml",
        ".md": "markdown",
        ".sh": "bash",
        ".bat": "batch",
        ".ps1": "powershell",
        ".toml": "toml",
        ".ini": "ini",
        ".cfg": "ini",
        ".txt": "text",
        ".sql": "sql",
        ".csv": "csv",
        ".xml": "xml",
    }
    return mapping.get(ext, "text")


def build_tree_and_collect_files(root: str):
    """
    Обходит проект, строит дерево директорий и собирает список файлов.
    Фильтр только по директориям/расширениям/именам.
    """
    tree_lines = []
    file_paths = []

    root = os.path.abspath(root)
    root_name = os.path.basename(root.rstrip(os.sep))

    tree_lines.append(f"{root_name}/")

    for current_root, dirs, files in os.walk(root):
        # Фильтр директорий
        dirs[:] = [
            d for d in dirs
            if d not in EXCLUDED_DIRS and not d.startswith(".")
        ]

        rel_root = os.path.relpath(current_root, root)
        if rel_root == ".":
            depth = 0
        else:
            depth = rel_root.count(os.sep) + 1

        indent = "    " * depth

        if rel_root != ".":
            tree_lines.append(f"{indent}{os.path.basename(current_root)}/")

        for name in sorted(files):
            if is_binary_file(name) or should_exclude_file(name):
                continue

            file_rel_path = os.path.join(rel_root, name) if rel_root != "." else name
            file_abs_path = os.path.join(current_root, name)

            tree_lines.append(f"{indent}    {name}")
            file_paths.append((file_rel_path, file_abs_path))

    return tree_lines, file_paths


def dump_project(root: str, output_filename: str = "project_dump.txt"):
    tree_lines, file_paths = build_tree_and_collect_files(root)

    root = os.path.abspath(root)

    # Индекс файлов для ИИ, чтобы он мог быстро увидеть структуру и прыгать по пути
    files_index_lines = []
    for idx, (rel_path, abs_path) in enumerate(file_paths, 1):
        lang = detect_language(abs_path)
        files_index_lines.append(
            f"{idx}. PATH={rel_path} | LANG={lang}"
        )

    header = [
        "#" * 80,
        "# FULL PROJECT DUMP (NO TRUNCATION)",
        "# FORMAT FOR LLM:",
        "#   1) PROJECT TREE — общая структура проекта.",
        "#   2) FILES INDEX — плоский список файлов с путём и языком.",
        "#   3) FILES CONTENT — для каждого файла:",
        "#        ===== FILE START =====",
        "#        FILE_INDEX: <N>",
        "#        PATH: <relative/path>",
        "#        LANG: <language>",
        "#        ===== CONTENT START =====",
        "#        <raw file content>",
        "#        ===== CONTENT END =====",
        "#        ===== FILE END =====",
        "#   Файлы идут в том же порядке, что и в индексе.",
        "#" * 80,
        f"# Root: {root}",
        f"# Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Files listed: {len(file_paths)}",
        f"# Max single file size: NONE",
        f"# Max total dump size: NONE",
        f"# Code compression enabled: {COMPRESS_CODE}",
        "#" * 80,
        "",
    ]

    with open(output_filename, "w", encoding="utf-8", errors="replace") as f:
        # Шапка
        f.write("\n".join(header))

        # Дерево проекта
        f.write("PROJECT TREE:\n")
        f.write("-" * 80 + "\n")
        for line in tree_lines:
            f.write(line + "\n")

        # Индекс файлов
        f.write("\n\n")
        f.write("FILES INDEX:\n")
        f.write("-" * 80 + "\n")
        for line in files_index_lines:
            f.write(line + "\n")

        # Разделитель
        f.write("\n\n")
        f.write("=" * 80 + "\n")
        f.write("FILES CONTENT:\n")
        f.write("=" * 80 + "\n\n")

        total_files = len(file_paths)

        for i, (rel_path, abs_path) in enumerate(file_paths, 1):
            lang = detect_language(abs_path)

            # Явные маркеры для ИИ
            f.write("===== FILE START =====\n")
            f.write(f"FILE_INDEX: {i}\n")
            f.write(f"PATH: {rel_path}\n")
            f.write(f"LANG: {lang}\n")
            f.write("===== CONTENT START =====\n")

            try:
                with open(abs_path, "r", encoding="utf-8", errors="replace") as src:
                    content = src.read()

                content = compress_content(content, abs_path)
                f.write(content)

            except Exception as e:
                f.write(f"<< ERROR READING FILE: {e} >>\n")

            f.write("\n===== CONTENT END =====\n")
            f.write("===== FILE END =====\n\n")

            if i % 10 == 0:
                print(f"Processed {i}/{total_files} files...")

    file_size_bytes = os.path.getsize(output_filename)
    file_size_kb = file_size_bytes / 1024
    file_size_mb = file_size_bytes / (1024 * 1024)

    print(f"Готово! Файл с дампом проекта: {output_filename}")
    print(f"Размер дампа: {file_size_kb:.0f}KB (~{file_size_mb:.2f}MB)")
    print(f"Файлов в обходе (включено в дамп): {len(file_paths)}")


if __name__ == "__main__":
    project_root = os.path.dirname(os.path.abspath(__file__))
    dump_project(project_root)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 17
PATH: entrypoint.sh
LANG: bash
===== CONTENT START =====
#!/bin/sh
set -e

# Если DJANGO_SETTINGS_MODULE не задан, по умолчанию считаем, что это прод.
: "${DJANGO_SETTINGS_MODULE:=backend.backend.settings.production}"
export DJANGO_SETTINGS_MODULE

echo "Using DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE}"

# Миграции
python backend/manage.py migrate --noinput

# Сбор статики
python backend/manage.py collectstatic --noinput

# Запуск gunicorn
exec gunicorn backend.config.wsgi:application \
    --bind 0.0.0.0:8000 \
    --workers "${GUNICORN_WORKERS:-3}" \
    --timeout "${GUNICORN_TIMEOUT:-60}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 18
PATH: index.html
LANG: html
===== CONTENT START =====
<!-- index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ParkShare AI Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <link rel="stylesheet" href="./static/css/cinematic-ui.css" />

  <style>
    :root {
      --primary: #0d6efd;
      --bg: #050816;
      --bg-card: #111827;
      --text: #e5e7eb;
      --accent: #22c55e;
      --danger: #ef4444;
      --warning: #f59e0b;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827, #020617 40%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      z-index: 1000;
      position: sticky;
      top: 0;
    }

    header h1 {
      font-size: 1.1rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .header-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.3fr);
      min-height: 0;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .sidebar {
      border-left: 1px solid rgba(148, 163, 184, 0.2);
      background: radial-gradient(circle at top, #020617, #020617 40%);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 280px;
      max-width: 480px;
    }

    .card {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 0.75rem 0.8rem;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.6);
    }

    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .input-row {
      display: flex;
      gap: 0.4rem;
      margin-top: 0.3rem;
    }

    input[type="text"],
    select {
      flex: 1;
      padding: 0.4rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      font-size: 0.85rem;
      outline: none;
    }

    input::placeholder {
      color: rgba(148, 163, 184, 0.9);
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 0.45rem 0.9rem;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      background: linear-gradient(135deg, #0ea5e9, #22c55e);
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      white-space: nowrap;
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: rgba(209, 213, 219, 0.95);
    }

    .pill {
      font-size: 0.72rem;
      border-radius: 999px;
      padding: 0.16rem 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      color: rgba(209, 213, 219, 0.95);
    }

    .pill-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
    }

    .pill-dot.green {
      background: var(--accent);
    }
    .pill-dot.yellow {
      background: var(--warning);
    }
    .pill-dot.red {
      background: var(--danger);
    }

    .lots-list {
      max-height: 220px;
      overflow-y: auto;
      margin-top: 0.4rem;
      padding-right: 0.2rem;
    }

    .lot-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.4rem 0.2rem;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      cursor: pointer;
    }

    .lot-item:last-child {
      border-bottom: none;
    }

    .lot-main {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      font-size: 0.75rem;
    }

    .lot-name {
      font-weight: 500;
      font-size: 0.8rem;
    }

    .lot-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      font-size: 0.7rem;
      color: rgba(156, 163, 175, 0.95);
    }

    .lot-occ {
      font-size: 0.8rem;
      font-weight: 500;
      min-width: 80px;
      text-align: right;
    }

    .status {
      font-size: 0.7rem;
      color: rgba(148, 163, 184, 0.9);
      margin-top: 0.3rem;
    }

    .ai-oracle-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.18rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(59, 130, 246, 0.45);
      background: linear-gradient(120deg, rgba(37, 99, 235, 0.35), rgba(14, 165, 233, 0.15));
      color: #e5edff;
      font-size: 0.75rem;
      letter-spacing: 0.02em;
      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.25);
    }

    .ai-orchestrator-card {
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.92), rgba(17, 24, 39, 0.94));
    }

    .ai-orchestrator-card .card-title {
      align-items: center;
    }

    .ai-orchestrator-card .card-title span {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .quantum-toggle {
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: #e2e8f0;
      font-weight: 600;
      letter-spacing: 0.01em;
      min-width: 150px;
      justify-content: space-between;
    }

    .quantum-toggle__dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.7);
      background: radial-gradient(circle at 35% 35%, #38bdf8, #0ea5e9);
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.45);
    }

    .quantum-toggle__label {
      flex: 1;
      text-align: right;
      font-size: 0.8rem;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
      .sidebar {
        max-width: 100%;
        border-left: none;
        border-top: 1px solid rgba(148, 163, 184, 0.2);
      }
    }
  </style>
</head>
<body>
  <header class="cinematic-surface">
    <h1>
      <span>ParkShare AI Map</span>
      <span class="badge">local ML</span>
    </h1>
    <div class="header-meta">
      <div class="ai-crest">
        <span>🧠</span>
        <span class="quantum-toggle__label">AI Orchestrator</span>
      </div>
      <button id="themeToggle" class="quantum-toggle cinematic-button" data-theme="dark">
        <span class="quantum-toggle__dot"></span>
        <span class="quantum-toggle__label">Dark Matter</span>
      </button>
      <div class="pill">
        <span class="pill-dot green"></span>
        <span id="statusText">Подключение к AI-серверу…</span>
      </div>
    </div>
  </header>

  <main>
    <div id="map"></div>
    <aside class="sidebar">
      <section class="card cinematic-surface ai-orchestrator-card">
        <div class="card-title">
          <span>AI-Оркестратор</span>
          <span class="ai-oracle-chip">Quantum boost</span>
        </div>
        <div class="ai-forecast">
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Лучшая ставка</span>
            <span class="ai-forecast-value" id="aiOracleName">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Освободится через</span>
            <span class="ai-forecast-value" id="aiOracleETA">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Уверенность AI</span>
            <span class="ai-forecast-value" id="aiOracleConfidence">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">EV/крытая</span>
            <span class="ai-forecast-value" id="aiOracleMeta">—</span>
          </div>
        </div>
        <div class="ai-reasoning" id="aiOracleReason">AI готовит инсайт…</div>
      </section>
      <section class="card">
        <div class="card-title">
          <span>Поиск парковок (NLP)</span>
        </div>
        <div class="input-row">
          <input
            type="text"
            id="searchInput"
            placeholder='Например: "рядом с метро", "дешевые утром"'
          />
          <button id="searchBtn">Искать</button>
        </div>
        <div class="status" id="searchStatus">Запрос еще не выполнен.</div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Рекомендации (коллаб. фильтрация)</span>
          <select id="userSelect"></select>
        </div>
        <div class="input-row">
          <button id="recBtn">Получить рекомендации</button>
          <button id="recContentBtn" class="secondary">Вариант B (content)</button>
        </div>
        <div class="status" id="recStatus">Нет рекомендаций.</div>
        <div class="lots-list" id="recList"></div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Все парковки</span>
        </div>
        <div class="lots-list" id="lotsList"></div>
      </section>
    </aside>
  </main>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="./static/js/quantum-theme-manager.js"></script>
  <script src="app.js"></script>
  <script>
    // Запускаем квантовый менеджер темы, чтобы анимации и эмоции были синхронизированы.
    window.psThemeManager = window.initQuantumThemeManager();
  </script>
</body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 19
PATH: model_training.py
LANG: python
===== CONTENT START =====
# model_training.py
from __future__ import annotations

import joblib
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Dict, Any

from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.svm import LinearSVC

from database import DB_PATH, get_connection, init_db, generate_synthetic_data

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"
# Создаём папку для моделей заранее, чтобы не упасть на сохранении
MODELS_DIR.mkdir(parents=True, exist_ok=True)


# ---------- 1. Модель предсказания загруженности парковок ----------


def load_occupancy_dataframe() -> pd.DataFrame:
    conn = get_connection()
    try:
        query = """
            SELECT
                oh.lot_id,
                oh.ts,
                oh.occupancy,
                oh.temperature,
                oh.is_rain,
                oh.is_event,
                pl.near_metro,
                pl.price_level,
                pl.has_covered,
                pl.has_ev_charging
            FROM occupancy_history oh
            JOIN parking_lot pl ON pl.id = oh.lot_id
        """
        df = pd.read_sql_query(query, conn)
    finally:
        conn.close()

    if df.empty:
        return df

    df["ts"] = pd.to_datetime(df["ts"], errors="coerce")
    df = df.dropna(subset=["ts"])
    df["hour"] = df["ts"].dt.hour
    df["dow"] = df["ts"].dt.weekday
    df["lot_id_str"] = df["lot_id"].astype(str)

    return df


def train_occupancy_model() -> None:
    df = load_occupancy_dataframe()
    if df.empty:
        raise RuntimeError("Нет данных для обучения occupancy-модели")

    feature_cols = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
        "lot_id_str",
    ]

    X = df[feature_cols].copy()
    y = df["occupancy"].astype(float)

    numeric_features = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
    ]
    categorical_features = ["lot_id_str"]

    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), numeric_features),
            ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_features),
        ]
    )

    model = RandomForestRegressor(
        n_estimators=80,
        random_state=42,
        n_jobs=-1,
    )

    pipe = Pipeline(
        steps=[
            ("preprocess", preprocessor),
            ("model", model),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "occupancy_model.pkl"
    joblib.dump(
        {
            "pipeline": pipe,
            "feature_cols": feature_cols,
        },
        model_path,
    )
    print("occupancy_model.pkl сохранён в", model_path)


# ---------- 2. NLP: интенты и парсинг пользовательских запросов ----------


def build_nlp_training_data() -> pd.DataFrame:
    data = [
        ("рядом с метро", "near_metro"),
        ("парковка около метро", "near_metro"),
        ("парковка возле метро", "near_metro"),
        ("где припарковаться у метро курская", "near_metro"),
        ("найди парковку у метро", "near_metro"),
        ("самая дешевая парковка", "cheap"),
        ("дешевые парковки утром", "cheap"),
        ("недорогая парковка рядом", "cheap"),
        ("дешево припарковаться", "cheap"),
        ("недорогие места для машины", "cheap"),
        ("парковка с зарядкой для электромобиля", "ev"),
        ("нужна зарядка для электрокара", "ev"),
        ("парковка с ev charging", "ev"),
        ("крытая парковка", "covered"),
        ("подземная парковка", "covered"),
        ("парковка в паркинге", "covered"),
        ("парковка ночью", "time_night"),
        ("парковка утром", "time_morning"),
        ("парковка вечером", "time_evening"),
        ("парковка днем", "time_day"),
        ("найди парковку", "general"),
        ("показать все парковки", "general"),
        ("где можно припарковаться", "general"),
        ("парковка в центре", "general"),
        ("парковка возле офиса", "general"),
    ]
    return pd.DataFrame(data, columns=["text", "intent"])


def train_nlp_model() -> None:
    df = build_nlp_training_data()
    X = df["text"].values
    y = df["intent"].values

    pipe = Pipeline(
        steps=[
            (
                "vec",
                CountVectorizer(
                    ngram_range=(1, 2),
                    analyzer="word",
                ),
            ),
            ("clf", LinearSVC()),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "nlp_intent.pkl"
    joblib.dump(pipe, model_path)
    print("nlp_intent.pkl сохранён в", model_path)


# ---------- 3. Рекомендательная система (collab + content) ----------


def train_recommender() -> None:
    """
    Простейшая item-based collaborative filtering + content-based фолбэк.
    """
    conn = get_connection()

    ratings = pd.read_sql_query("SELECT * FROM user_rating;", conn)
    lots = pd.read_sql_query("SELECT * FROM parking_lot;", conn)

    if ratings.empty or lots.empty:
        raise RuntimeError("Нет данных для обучения рекомендера")

    # user-item матрица
    user_item = (
        ratings.pivot(index="user_id", columns="lot_id", values="rating")
        .fillna(0.0)
        .astype(float)
    )

    # Нормируем по пользователям
    user_norms = np.linalg.norm(user_item.values, axis=1, keepdims=True)
    user_norms[user_norms == 0] = 1.0
    user_item_norm = user_item.values / user_norms

    # item-item similarity (cosine)
    sim_matrix = cosine_similarity(user_item_norm.T)
    item_ids = user_item.columns.tolist()
    item_sim = pd.DataFrame(sim_matrix, index=item_ids, columns=item_ids)

    # Content-features
    lot_features = lots.set_index("id")[
        ["near_metro", "price_level", "has_covered", "has_ev_charging", "latitude", "longitude"]
    ].copy()

    model_path = MODELS_DIR / "recommender.pkl"
    joblib.dump(
        {
            "user_item": user_item,
            "item_sim": item_sim,
            "lot_features": lot_features,
        },
        model_path,
    )
    print("recommender.pkl сохранён в", model_path)
    conn.close()


def _dataset_is_empty() -> bool:
    conn = get_connection()
    try:
        cur = conn.cursor()
        counts = {}
        for table in ["parking_lot", "occupancy_history", "user_rating"]:
            try:
                cur.execute(f"SELECT COUNT(*) FROM {table};")
                counts[table] = cur.fetchone()[0]
            except Exception:
                counts[table] = 0
        return any(value == 0 for value in counts.values())
    finally:
        conn.close()


def _safe_call(name: str, fn) -> None:
    try:
        fn()
    except Exception as exc:
        # Логируем и выбрасываем дальше, чтобы CI увидел сбой
        print(f"[!] Ошибка во время '{name}': {exc}")
        raise


def main() -> None:
    # На случай чистой установки
    init_db()

    try:
        if _dataset_is_empty():
            print("База пуста — генерируем синтетические данные...")
            generate_synthetic_data()
        else:
            print("Используем существующие данные в БД", DB_PATH)
    except Exception as exc:
        print(f"[!] Не удалось подготовить данные: {exc}")
        raise

    print("=== Обучение occupancy-модели ===")
    _safe_call("occupancy", train_occupancy_model)

    print("=== Обучение NLP-модели ===")
    _safe_call("nlp", train_nlp_model)

    print("=== Обучение рекомендательной системы ===")
    _safe_call("recommender", train_recommender)

    print("Готово: все модели обучены и сохранены в", MODELS_DIR)


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 21
PATH: requirements.txt
LANG: text
===== CONTENT START =====
Django==5.2.8
djangorestframework==3.16.1
django-environ==0.12.0
django-cors-headers==4.9.0
django-cryptography-django5==2.2
psycopg[binary]==3.2.12
celery==5.5.3
redis==7.0.1
Pillow==11.1.0
numpy==2.3.0
pandas==2.2.3
scikit-learn==1.7.2
gunicorn==23.0.0
yookassa
drf-spectacular==0.27.2
django-ratelimit==4.1.0
djangorestframework-simplejwt==5.3.1
httpx==0.27.2
asgiref==3.8.1

# LLM Gateway
litellm==1.51.0
cachetools==5.5.0
aiolimiter==1.1.0

# AI‑микросервисы (ParkMate AI)
fastapi
uvicorn[standard]==0.32.1
colorama==0.4.6

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 22
PATH: run_dev.bat
LANG: batch
===== CONTENT START =====
@echo off
echo 🎯 ParkShare Development Launcher (Windows)

REM Активируем виртуальное окружение если есть
if exist venv (
    echo 🔧 Активация виртуального окружения...
    call venv\Scripts\activate
)

REM Запускаем основной скрипт
python run_dev.py
pause
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 23
PATH: run_dev.py
LANG: python
===== CONTENT START =====
#!/usr/bin/env python3
"""
Единый скрипт для запуска всей системы ParkShare Development
Запускает: Django, LLM сервис, AI API сервер, Celery worker
"""
import os
import sys
import time
import subprocess
import signal
import threading
from pathlib import Path
from typing import Optional, Tuple

try:
    from colorama import Fore, Style, init as colorama_init
except ImportError:  # pragma: no cover - dev helper
    Fore = Style = None

    def colorama_init():
        return None


colorama_init()

# Добавляем корень проекта в Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))


def _color(msg: str, color: Optional[str]) -> str:
    if not color or not Fore:
        return msg
    return f"{color}{msg}{Style.RESET_ALL if Style else ''}"


def run_command(command, cwd=None, shell=False, env=None):
    """Запускает команду и возвращает процесс"""
    if env is None:
        env = os.environ.copy()

    print(_color(f"🚀 Запуск: {command}", Fore.CYAN if Fore else None))
    process = subprocess.Popen(
        command,
        cwd=cwd or project_root,
        shell=shell,
        env=env,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        universal_newlines=True,
        bufsize=1
    )
    return process


def log_output(process, name):
    """Логирует вывод процесса"""

    def log_thread():
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(_color(f"[{name}] {output.strip()}", Fore.WHITE if Fore else None))
        process.poll()

    thread = threading.Thread(target=log_thread)
    thread.daemon = True
    thread.start()
    return thread


def setup_environment():
    """Настраивает окружение для разработки"""
    env = os.environ.copy()
    env['PYTHONPATH'] = str(project_root)
    env['DJANGO_SETTINGS_MODULE'] = env.get('DJANGO_SETTINGS_MODULE', 'backend.backend.settings.local')
    env['DEBUG'] = env.get('DEBUG', '1')
    return env


def wait_for_service(port, timeout=30):
    """Ожидает пока сервис на порту станет доступен"""
    import socket
    import time

    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                result = sock.connect_ex(('localhost', port))
                if result == 0:
                    print(f"✅ Сервис на порту {port} готов")
                    return True
        except:
            pass
        time.sleep(1)

    print(f"❌ Таймаут ожидания порта {port}")
    return False


def start_django(port: int):
    """Запускает Django development server"""
    print("\n" + "=" * 50)
    print("🔄 Запуск Django сервера...")
    print("=" * 50)

    # Применяем миграции
    print("📦 Применяем миграции...")
    migrate_process = run_command([
        sys.executable, "backend/manage.py", "migrate"
    ])
    migrate_process.wait()

    # Собираем статику
    print("📦 Собираем статику...")
    collectstatic_process = run_command([
        sys.executable, "backend/manage.py", "collectstatic", "--noinput"
    ])
    collectstatic_process.wait()

    # Запускаем сервер
    return run_command([
        sys.executable, "backend/manage.py", "runserver", str(port)
    ])


def start_llm_service(host: str, port: int):
    """Запускает LLM микросервис"""
    print("\n" + "=" * 50)
    print("🧠 Запуск LLM сервиса...")
    print("=" * 50)

    return run_command([
        sys.executable, "-m", "uvicorn",
        "services.llm_service.main:app",
        "--host", host,
        "--port", str(port),
        "--reload"
    ])


def start_ai_api(host: str, port: int):
    """Запускает AI API сервер"""
    print("\n" + "=" * 50)
    print("🤖 Запуск AI API сервера...")
    print("=" * 50)

    env = setup_environment()
    env['AI_API_HOST'] = host
    env['AI_API_PORT'] = str(port)
    return run_command([
        sys.executable, "-m", "uvicorn", "api_server:app", "--host", host, "--port", str(port)
    ], env=env)


def start_celery_worker(env: Optional[dict] = None):
    """Запускает Celery worker."""
    print("\n" + "=" * 50)
    print("🔧 Запуск Celery worker...")
    print("=" * 50)

    # На Windows prefork вызывает PermissionError (WinError 5) из-за семафоров.
    # Переходим на однопроцессный режим solo, который официально поддерживается на Windows.
    is_windows = os.name == "nt"
    command = [
        sys.executable, "-m", "celery",
        "-A", "backend.backend.config.celery",
        "worker",
        "--loglevel=info",
    ]

    if is_windows:
        command.extend(["--pool", "solo", "--concurrency", "1"])
    else:
        command.extend(["--concurrency", "2"])

    return run_command(command, env=env)


def start_celery_beat(env: Optional[dict] = None):
    """Запускает Celery beat"""
    print("\n" + "=" * 50)
    print("⏰ Запуск Celery beat...")
    print("=" * 50)

    return run_command([
        sys.executable, "-m", "celery",
        "-A", "backend.backend.config.celery",
        "beat",
        "--loglevel=info"
    ], env=env)


def pick_port(preferred: int, env_name: str) -> int:
    """Возвращает доступный порт, если предпочтительный занят."""
    import socket

    try:
        override = int(os.environ.get(env_name, preferred))
    except (TypeError, ValueError):
        override = preferred

    def is_free(port_value: int) -> bool:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            return sock.connect_ex(("127.0.0.1", port_value)) != 0

    if is_free(override):
        return override

    print(f"⚠️ Порт {override} занят. Подбираем свободный...")
    for candidate in range(override + 1, override + 20):
        if is_free(candidate):
            print(f"➡️  Используем альтернативный порт {candidate} для {env_name}")
            return candidate

    raise RuntimeError(f"Не удалось найти свободный порт рядом с {override}")


def check_dependencies():
    """Проверяет наличие всех зависимостей"""
    print("🔍 Проверка зависимостей...")

    try:
        import django  # noqa: F401
        import fastapi  # noqa: F401
        import uvicorn  # noqa: F401
        import celery  # noqa: F401
        import redis  # noqa: F401
    except ImportError as e:
        print(f"❌ Отсутствует зависимость: {e}")
        print("Установите зависимости: pip install -r requirements.txt")
        return False

    # Проверяем доступность Redis для Celery/кэшей
    import socket

    redis_url = os.environ.get("REDIS_URL", "redis://localhost:6379/0")
    try:
        host_port = redis_url.split("//", 1)[-1].split("/", 1)[0]
        host, port = host_port.split(":")
        with socket.create_connection((host, int(port)), timeout=2):
            print("✅ Redis доступен")
    except Exception as exc:
        print(f"⚠️  Redis недоступен ({redis_url}): {exc}. Продолжаем запуск без гарантии Celery")
    return True


def monitor_process(name: str, starter, max_restarts: int = 2) -> Tuple[subprocess.Popen, int]:
    """Стартует процесс и возвращает пару (process, оставшиеся рестарты)."""

    process = starter()
    return process, max_restarts


def main():
    """Основная функция запуска"""
    print("🎯 ParkShare Development Launcher")
    print("Запуск всех компонентов системы...")

    # Проверяем зависимости
    if not check_dependencies():
        sys.exit(1)

    # Настраиваем окружение
    env = setup_environment()

    django_port = pick_port(8000, "DJANGO_PORT")
    ai_api_port = pick_port(8001, "AI_API_PORT")
    llm_port = pick_port(8002, "LLM_PORT")

    env["DJANGO_PORT"] = str(django_port)
    env["AI_API_PORT"] = str(ai_api_port)
    env["LLM_SERVICE_PORT"] = str(llm_port)
    env["LLM_PORT"] = str(llm_port)

    os.environ.update(env)

    processes: list[tuple[str, subprocess.Popen, int]] = []

    try:
        # Запускаем сервисы
        services = [
            ("LLM Service", lambda: start_llm_service("0.0.0.0", llm_port), llm_port),
            ("AI API", lambda: start_ai_api("0.0.0.0", ai_api_port), ai_api_port),
            ("Celery Worker", lambda: start_celery_worker(env), None),
            ("Celery Beat", lambda: start_celery_beat(env), None),
            ("Django", lambda: start_django(django_port), django_port),
        ]

        threads = []
        for name, starter, port in services:
            process, restarts = monitor_process(name, starter)
            processes.append((name, process, restarts))
            thread = log_output(process, name)
            threads.append(thread)

            if port:
                # Даем время сервису начать запуск
                time.sleep(2)
                if not wait_for_service(port, timeout=10):
                    print(f"⚠️  Сервис {name} медленно запускается...")

        print("\n" + "🎉 Все сервисы запущены!")
        print("📊 Статус сервисов:")
        print(f"   • Django: http://localhost:{django_port}")
        print(f"   • LLM Service: http://localhost:{llm_port}")
        print(f"   • AI API: http://localhost:{ai_api_port}")
        print("   • Celery Worker: ✅")
        print("   • Celery Beat: ✅")
        print("\n🛑 Для остановки нажмите Ctrl+C")

        # Ожидаем завершения
        while True:
            time.sleep(1)
            # Проверяем, что все процессы еще работают
            for idx, (name, process, restarts) in enumerate(list(processes)):
                if process.poll() is not None:
                    print(_color(f"❌ Процесс {name} завершился с кодом {process.returncode}", Fore.RED if Fore else None))
                    if restarts > 0:
                        print(_color(f"🔁 Перезапуск {name} (осталось {restarts})", Fore.YELLOW if Fore else None))
                        new_process, _ = monitor_process(name, services[idx][1])
                        processes[idx] = (name, new_process, restarts - 1)
                        log_output(new_process, name)
                    else:
                        print(_color(f"🛑 Достигнут лимит рестартов для {name}", Fore.RED if Fore else None))

    except KeyboardInterrupt:
        print("\n🛑 Остановка сервисов...")

        # Останавливаем процессы
        for name, process, _ in processes:
            if process.poll() is None:
                print(f"⏹️  Останавливаем {name}...")
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    print(f"❌ Принудительная остановка {name}...")
                    process.kill()

        print("👋 Все сервисы остановлены")


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 24
PATH: run_dev.sh
LANG: bash
===== CONTENT START =====
#!/bin/bash
# Скрипт запуска для Unix систем

echo "🎯 ParkShare Development Launcher (Unix)"

# Активируем виртуальное окружение если есть
if [ -d "venv" ]; then
    echo "🔧 Активация виртуального окружения..."
    source venv/bin/activate
fi

# Запускаем основной скрипт
python run_dev.py
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 25
PATH: accounts\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 26
PATH: accounts\admin.py
LANG: python
===== CONTENT START =====
# accounts/admin.py

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as DjangoUserAdmin

from .models import User


@admin.register(User)
class UserAdmin(DjangoUserAdmin):
    """
    Кастомная админка для пользователя с UUID-ID и ролями.
    """

    fieldsets = DjangoUserAdmin.fieldsets + (
        (
            "Дополнительно",
            {
                "fields": (
                    "role",
                    "email_encrypted",
                    "phone_encrypted",
                    "owner_request_pending",
                )
            },
        ),
    )

    list_display = (
        "username",
        "role",
        "is_active",
        "is_staff",
        "is_superuser",
        "date_joined",
    )
    list_filter = ("role", "is_active", "is_staff", "is_superuser")
    search_fields = ("username",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 27
PATH: accounts\apps.py
LANG: python
===== CONTENT START =====
# accounts/apps.py

from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "accounts"
    verbose_name = "Пользователи ParkShare"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 28
PATH: accounts\auth.py
LANG: python
===== CONTENT START =====
# accounts/auth.py

from __future__ import annotations

from typing import Optional

from django.contrib.auth import get_user_model

from core.utils import normalize_phone
from .utils import normalize_email, hash_email, hash_phone

User = get_user_model()


def _get_first_or_none(qs):
    try:
        return qs.first()
    except Exception:
        return None


def find_user_by_identifier(identifier: str) -> Optional[User]:
    """
    Ищем пользователя по:
    1) username (регистронезависимо);
    2) email (нормализованный, через email_hash);
    3) телефону (нормализованный, через phone_hash).

    В БД никогда не фильтруем по зашифрованным полям.
    """
    if not identifier:
        return None

    ident = identifier.strip()
    qs = User.objects.filter(is_active=True)

    # 1) Логин (username)
    try:
        return qs.get(username__iexact=ident)
    except User.DoesNotExist:
        pass
    except User.MultipleObjectsReturned:
        return _get_first_or_none(qs.filter(username__iexact=ident).order_by("date_joined"))

    # 2) Email
    if "@" in ident:
        email = normalize_email(ident)
        if not email:
            return None
        email_hash = hash_email(email)
        if not email_hash:
            return None
        try:
            return qs.get(email_hash=email_hash)
        except User.DoesNotExist:
            pass
        except User.MultipleObjectsReturned:
            return _get_first_or_none(qs.filter(email_hash=email_hash).order_by("date_joined"))
        return None

    # 3) Телефон
    phone = normalize_phone(ident)
    if not phone:
        return None
    phone_hash = hash_phone(phone)
    if not phone_hash:
        return None

    try:
        return qs.get(phone_hash=phone_hash)
    except User.DoesNotExist:
        return None
    except User.MultipleObjectsReturned:
        return _get_first_or_none(qs.filter(phone_hash=phone_hash).order_by("date_joined"))

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 29
PATH: accounts\forms.py
LANG: python
===== CONTENT START =====
# accounts/forms.py

from typing import Any

from django import forms
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm
from django.utils.translation import gettext_lazy as _

from core.utils import normalize_phone
from .models import User


class LoginForm(AuthenticationForm):
    """
    Форма входа: одно поле для логина / email / телефона + пароль.
    """

    username = forms.CharField(
        label=_("Логин / Email / Телефон"),
        widget=forms.TextInput(attrs={"autofocus": True, "class": "ps-input"}),
    )

    def clean(self):
        """
        Подменяем username на реальный логин пользователя, чтобы
        AuthenticationForm могла вызвать authenticate() как обычно.
        """
        from .auth import find_user_by_identifier  # локальный импорт

        identifier = self.cleaned_data.get("username")
        password = self.cleaned_data.get("password")

        if identifier and password:
            user = find_user_by_identifier(identifier)
            if user is not None:
                self.cleaned_data["username"] = user.get_username()

        return super().clean()


class RegisterForm(UserCreationForm):
    """
    Регистрация через HTML-форму.
    Email и телефон — опциональные, сохраняются в зашифрованном виде.
    """

    email = forms.EmailField(
        label=_("Email (опционально)"),
        required=False,
        widget=forms.EmailInput(attrs={"class": "ps-input"}),
    )
    phone = forms.CharField(
        label=_("Телефон (опционально)"),
        required=False,
        widget=forms.TextInput(attrs={"class": "ps-input"}),
    )

    class Meta(UserCreationForm.Meta):
        model = User
        fields = ("username", "email", "phone")
        widgets = {
            "username": forms.TextInput(attrs={"class": "ps-input"}),
        }

    def clean_email(self) -> str:
        """
        Просто нормализуем email, без запросов к БД.
        """
        email = (self.cleaned_data.get("email") or "").strip().lower()
        return email

    def clean_phone(self) -> str:
        """
        Только нормализуем номер, без проверки уникальности.
        """
        phone = self.cleaned_data.get("phone") or ""
        if not phone:
            return ""

        phone = normalize_phone(phone)
        if not phone:
            raise forms.ValidationError(_("Некорректный формат телефона."))
        return phone

    def save(self, commit: bool = True) -> User:
        """
        Сохраняем пользователя и дублируем нормализованные значения
        в email_plain / phone_plain, чтобы их можно было показывать в UI.
        """
        user: User = super().save(commit=False)

        email = (self.cleaned_data.get("email") or "").strip().lower()
        phone = self.cleaned_data.get("phone") or ""

        user.email_plain = email or ""
        user.phone_plain = normalize_phone(phone or "") if phone else ""

        if commit:
            user.save()
        return user


class ProfileForm(forms.ModelForm):
    """
    Редактирование профиля пользователя (email/phone + базовые поля).
    """

    email = forms.EmailField(
        label=_("Email"),
        required=False,
        widget=forms.EmailInput(attrs={"class": "ps-input"}),
    )
    phone = forms.CharField(
        label=_("Телефон"),
        required=False,
        widget=forms.TextInput(attrs={"class": "ps-input"}),
    )

    class Meta:
        model = User
        fields = ("first_name", "last_name", "email", "phone")
        widgets = {
            "first_name": forms.TextInput(attrs={"class": "ps-input"}),
            "last_name": forms.TextInput(attrs={"class": "ps-input"}),
        }

    def clean_email(self) -> str:
        email = (self.cleaned_data.get("email") or "").strip().lower()
        return email

    def clean_phone(self) -> str:
        phone = self.cleaned_data.get("phone") or ""
        if not phone:
            return ""

        phone = normalize_phone(phone)
        if not phone:
            raise forms.ValidationError(_("Некорректный формат телефона."))
        # Больше НИКАКИХ запросов к User.objects.filter(phone_encrypted=...)
        return phone

    def save(self, commit: bool = True) -> Any:
        user: User = super().save(commit=False)

        email = (self.cleaned_data.get("email") or "").strip().lower()
        phone = self.cleaned_data.get("phone") or ""

        user.email_plain = email or ""
        user.phone_plain = normalize_phone(phone or "") if phone else ""

        if commit:
            user.save()
        return user

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 30
PATH: accounts\models.py
LANG: python
===== CONTENT START =====
# accounts/models.py

import uuid

from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django_cryptography.fields import encrypt

from core.models import TimeStampedUUIDModel
from .utils import hash_email, hash_phone


class User(AbstractUser):
    """
    Кастомный пользователь:
    - UUID как первичный ключ;
    - роль (driver / owner / admin);
    - email/телефон в зашифрованном виде (django-cryptography-django5);
    - отдельные хэши email/телефона для безопасного поиска/уникальности.
    """

    class Role(models.TextChoices):
        DRIVER = "driver", _("Водитель")
        OWNER = "owner", _("Владелец парковки")
        ADMIN = "admin", _("Администратор")

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    role = models.CharField(
        _("Роль"),
        max_length=16,
        choices=Role.choices,
        default=Role.DRIVER,
        help_text=_("Определяет права доступа в системе."),
    )

    # Шифрованные контактные поля
    email_encrypted = encrypt(
        models.EmailField(
            _("Email (зашифрованный)"),
            blank=True,
            null=True,
            help_text=_("Опциональный email, хранится в зашифрованном виде."),
        )
    )

    phone_encrypted = encrypt(
        models.CharField(
            _("Телефон (зашифрованный)"),
            max_length=32,
            blank=True,
            null=True,
            help_text=_("Опциональный телефон, хранится в зашифрованном виде."),
        )
    )

    # Отдельные хэши для поиска и проверки уникальности
    email_hash = models.CharField(
        _("Хэш нормализованного email"),
        max_length=64,
        blank=True,
        db_index=True,
        help_text=_("Используется только для поиска и проверки уникальности email."),
    )

    phone_hash = models.CharField(
        _("Хэш нормализованного телефона"),
        max_length=64,
        blank=True,
        db_index=True,
        help_text=_("Используется только для поиска и проверки уникальности телефона."),
    )

    owner_request_pending = models.BooleanField(
        _("Запрошено повышение до владельца"),
        default=False,
        help_text=_("Пользователь подал заявку на роль владельца парковки."),
    )

    # username + password остаются стандартными полями AbstractUser
    REQUIRED_FIELDS: list[str] = []

    class Meta:
        verbose_name = _("Пользователь")
        verbose_name_plural = _("Пользователи")

    def __str__(self) -> str:
        return self.username

    # Удобные свойства для расшифрованных контактов

    @property
    def email_plain(self) -> str:
        """
        Доступ к расшифрованному email.
        В коде (и в админке) можно использовать user.email_plain.
        """
        return self.email_encrypted or ""

    @email_plain.setter
    def email_plain(self, value: str) -> None:
        self.email_encrypted = value or None

    @property
    def phone_plain(self) -> str:
        return self.phone_encrypted or ""

    @phone_plain.setter
    def phone_plain(self, value: str) -> None:
        self.phone_encrypted = value or None

    # Ролевые флаги

    @property
    def is_driver(self) -> bool:
        return self.role == self.Role.DRIVER

    @property
    def is_owner(self) -> bool:
        return self.role in (self.Role.OWNER, self.Role.ADMIN)

    @property
    def is_admin(self) -> bool:
        return self.role == self.Role.ADMIN or self.is_superuser

    # Служебные методы

    def update_contact_hashes(self) -> None:
        """
        Пересчитывает email_hash / phone_hash на основе текущих значений
        email_plain / phone_plain.
        """
        self.email_hash = hash_email(self.email_plain)
        self.phone_hash = hash_phone(self.phone_plain)

    def save(self, *args, **kwargs) -> None:
        # Перед сохранением всегда обновляем хэши контактов
        self.update_contact_hashes()
        super().save(*args, **kwargs)


class LoginCode(TimeStampedUUIDModel):
    """
    Одноразовый код для подтверждения email/телефона и входа.
    """

    class Channel(models.TextChoices):
        EMAIL = "email", _("Email")
        PHONE = "phone", _("Телефон")

    class Purpose(models.TextChoices):
        REGISTER = "register", _("Регистрация")
        LOGIN = "login", _("Вход")
        RESET_PASSWORD = "reset_password", _("Сброс пароля")

    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name="login_codes",
    )
    channel = models.CharField(
        _("Канал"),
        max_length=16,
        choices=Channel.choices,
    )
    purpose = models.CharField(
        _("Назначение"),
        max_length=32,
        choices=Purpose.choices,
    )
    code_hash = models.CharField(
        _("Хэш кода"),
        max_length=128,
        db_index=True,
    )
    expires_at = models.DateTimeField(_("Истекает в"))
    is_used = models.BooleanField(_("Использован"), default=False)

    class Meta:
        verbose_name = _("Код подтверждения")
        verbose_name_plural = _("Коды подтверждения")
        indexes = [
            models.Index(fields=["user", "purpose", "is_used"]),
        ]

    def __str__(self) -> str:
        return f"{self.purpose} code for {self.user_id}"

    @property
    def is_expired(self) -> bool:
        return timezone.now() >= self.expires_at


class UserLevel(TimeStampedUUIDModel):
    """Уровень пользователя по количеству завершённых бронирований."""

    name = models.CharField(max_length=64)
    threshold = models.PositiveIntegerField(
        default=0, help_text="Количество завершённых бронирований для уровня"
    )
    description = models.TextField(blank=True)

    class Meta:
        verbose_name = "Уровень пользователя"
        verbose_name_plural = "Уровни пользователей"
        ordering = ("threshold",)

    def __str__(self) -> str:
        return self.name


class UserBadge(TimeStampedUUIDModel):
    """Бейдж за активность/лояльность."""

    user = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="badges", verbose_name="Пользователь"
    )
    title = models.CharField(max_length=128)
    description = models.TextField(blank=True)
    icon = models.CharField(max_length=64, blank=True)
    level = models.ForeignKey(
        UserLevel,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="badges",
    )

    class Meta:
        verbose_name = "Бейдж"
        verbose_name_plural = "Бейджи"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"{self.title} — {self.user}"


class PromoReward(TimeStampedUUIDModel):
    """Заготовка под промо/бонусы."""

    code = models.CharField(max_length=32, unique=True)
    description = models.TextField(blank=True)
    active = models.BooleanField(default=True)
    usage_limit = models.PositiveIntegerField(default=1)

    class Meta:
        verbose_name = "Промо/бонус"
        verbose_name_plural = "Промо/бонусы"

    def __str__(self) -> str:
        return self.code
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 31
PATH: accounts\serializers.py
LANG: python
===== CONTENT START =====
# accounts/serializers.py

from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from django.utils.translation import gettext_lazy as _
from rest_framework import serializers

from core.utils import normalize_phone
from .auth import find_user_by_identifier
from .models import User, LoginCode
from .utils import normalize_email, hash_email, hash_phone


class UserSerializer(serializers.ModelSerializer):
    """
    Базовое представление пользователя для админских API.
    Контактные данные не раскрываются.
    """

    has_email = serializers.SerializerMethodField()
    has_phone = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = (
            "id",
            "username",
            "role",
            "is_active",
            "date_joined",
            "has_email",
            "has_phone",
        )

    def get_has_email(self, obj: User) -> bool:
        return bool(obj.email_plain)

    def get_has_phone(self, obj: User) -> bool:
        return bool(obj.phone_plain)


class UserProfileSerializer(serializers.ModelSerializer):
    """
    Профиль текущего пользователя.
    Здесь можно редактировать email/телефон.
    """

    email = serializers.CharField(
        source="email_plain",
        allow_blank=True,
        required=False,
    )
    phone = serializers.CharField(
        source="phone_plain",
        allow_blank=True,
        required=False,
    )

    class Meta:
        model = User
        fields = ("id", "username", "role", "email", "phone")

    def validate_phone(self, value: str) -> str:
        """
        Валидируем и нормализуем телефон, проверяем уникальность через phone_hash.
        """
        value = value or ""
        if not value:
            return ""

        normalized = normalize_phone(value)
        if not normalized:
            raise serializers.ValidationError(_("Некорректный формат телефона."))

        phone_hash = hash_phone(normalized)
        user = self.instance
        qs = User.objects.filter(phone_hash=phone_hash)
        if user is not None:
            qs = qs.exclude(pk=user.pk)
        if phone_hash and qs.exists():
            raise serializers.ValidationError(
                _("Пользователь с таким телефоном уже существует.")
            )
        return normalized

    def validate_email(self, value: str) -> str:
        """
        Валидируем и нормализуем email, проверяем уникальность через email_hash.
        """
        value = normalize_email(value)
        if not value:
            return ""

        email_hash = hash_email(value)
        user = self.instance
        qs = User.objects.filter(email_hash=email_hash)
        if user is not None:
            qs = qs.exclude(pk=user.pk)
        if email_hash and qs.exists():
            raise serializers.ValidationError(
                _("Пользователь с таким email уже существует.")
            )
        return value


class RegisterSerializer(serializers.Serializer):
    """
    Регистрация через API.
    """

    username = serializers.CharField(max_length=150)
    password = serializers.CharField(write_only=True, min_length=8)
    email = serializers.EmailField(required=False, allow_blank=True)
    phone = serializers.CharField(required=False, allow_blank=True)

    def validate_username(self, value: str) -> str:
        if User.objects.filter(username=value).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким логином уже существует.")
            )
        return value

    def validate_email(self, value: str) -> str:
        email = normalize_email(value)
        if not email:
            return ""
        email_hash = hash_email(email)
        if email_hash and User.objects.filter(email_hash=email_hash).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким email уже зарегистрирован.")
            )
        return email

    def validate_phone(self, value: str) -> str:
        value = value or ""
        if not value:
            return ""
        normalized = normalize_phone(value)
        if not normalized:
            raise serializers.ValidationError(_("Некорректный формат телефона."))
        phone_hash = hash_phone(normalized)
        if phone_hash and User.objects.filter(phone_hash=phone_hash).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким телефоном уже зарегистрирован.")
            )
        return normalized

    def validate_password(self, value: str) -> str:
        validate_password(value)
        return value

    def create(self, validated_data: dict) -> User:
        email = validated_data.pop("email", "")
        phone = validated_data.pop("phone", "")

        user = User(username=validated_data["username"])
        user.set_password(validated_data["password"])

        if email:
            user.email_plain = email
        if phone:
            user.phone_plain = phone

        user.save()
        return user


class LoginSerializer(serializers.Serializer):
    """
    Логин через API (session-based).
    Позволяет использовать логин, email или телефон.
    """

    identifier = serializers.CharField(
        label=_("Логин / Email / Телефон"),
    )
    password = serializers.CharField(write_only=True)

    def validate(self, attrs: dict) -> dict:
        identifier = attrs.get("identifier")
        password = attrs.get("password")

        if not identifier or not password:
            raise serializers.ValidationError(
                _("Необходимо указать логин и пароль."),
                code="authorization",
            )

        user = find_user_by_identifier(identifier)
        if user is None:
            raise serializers.ValidationError(
                _("Неверный логин/email/телефон или пароль."),
                code="authorization",
            )

        # authenticate нужен для проверки пароля и backend'а аутентификации
        auth_user = authenticate(
            username=user.username,
            password=password,
        )
        if auth_user is None:
            raise serializers.ValidationError(
                _("Неверный логин/email/телефон или пароль."),
                code="authorization",
            )

        if not auth_user.is_active:
            raise serializers.ValidationError(
                _("Пользователь деактивирован."),
                code="authorization",
            )

        attrs["user"] = auth_user
        return attrs


class ChangePasswordSerializer(serializers.Serializer):
    """
    Смена пароля текущего пользователя.
    """

    old_password = serializers.CharField(write_only=True)
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate_new_password(self, value: str) -> str:
        user = self.context["request"].user
        validate_password(value, user=user)
        return value

    def validate(self, attrs: dict) -> dict:
        user = self.context["request"].user
        old_password = attrs.get("old_password")
        if not user.check_password(old_password):
            raise serializers.ValidationError(
                {"old_password": _("Неверный текущий пароль.")}
            )
        return attrs

    def save(self, **kwargs) -> User:
        user = self.context["request"].user
        new_password = self.validated_data["new_password"]
        user.set_password(new_password)
        user.save(update_fields=["password"])
        return user


class PasswordResetRequestSerializer(serializers.Serializer):
    """
    Запрос на сброс пароля по email (API).
    """

    email = serializers.EmailField()

    def validate_email(self, value: str) -> str:
        # В целях безопасности не раскрываем, существует ли пользователь.
        return normalize_email(value)


class OTPRequestSerializer(serializers.Serializer):
    """
    Запрос кода подтверждения для email/телефона.
    """

    identifier = serializers.CharField(
        label=_("Email или телефон"),
    )
    purpose = serializers.ChoiceField(
        choices=LoginCode.Purpose.choices,
        default=LoginCode.Purpose.LOGIN,
    )


class OTPVerifySerializer(serializers.Serializer):
    """
    Проверка кода и выдача JWT/сессии.
    """

    identifier = serializers.CharField(label=_("Email или телефон"))
    code = serializers.CharField(label=_("Код"), max_length=8)
    purpose = serializers.ChoiceField(
        choices=LoginCode.Purpose.choices,
        default=LoginCode.Purpose.LOGIN,
    )
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 32
PATH: accounts\urls.py
LANG: python
===== CONTENT START =====
# accounts/urls.py

from django.contrib.auth import views as auth_views
from django.urls import path, reverse_lazy

from .views import CustomLoginView, ProfileView, RegisterView, logout_view

# TODO: интегрировать вход по коду и Госуслуги (ESIA) в отдельные view/urls, когда появятся провайдеры

app_name = "accounts"

urlpatterns = [
    path("login/", CustomLoginView.as_view(), name="login"),
    path("logout/", logout_view, name="logout"),
    path("register/", RegisterView.as_view(), name="register"),
    path("profile/", ProfileView.as_view(), name="profile"),

    # Смена пароля (HTML)
    path(
        "password/change/",
        auth_views.PasswordChangeView.as_view(
            template_name="accounts/password_change.html",
            success_url=reverse_lazy("accounts:password_change_done"),
        ),
        name="password_change",
    ),
    path(
        "password/change/done/",
        auth_views.PasswordChangeDoneView.as_view(
            template_name="accounts/password_change_done.html"
        ),
        name="password_change_done",
    ),

    # Сброс пароля (HTML)
    path(
        "password/reset/",
        auth_views.PasswordResetView.as_view(
            template_name="accounts/password_reset.html",
            email_template_name="accounts/password_reset_email.txt",
            subject_template_name="accounts/password_reset_subject.txt",
            success_url=reverse_lazy("accounts:password_reset_done"),
        ),
        name="password_reset",
    ),
    path(
        "password/reset/done/",
        auth_views.PasswordResetDoneView.as_view(
            template_name="accounts/password_reset_done.html"
        ),
        name="password_reset_done",
    ),
    path(
        "reset/<uidb64>/<token>/",
        auth_views.PasswordResetConfirmView.as_view(
            template_name="accounts/password_reset_confirm.html",
            success_url=reverse_lazy("accounts:password_reset_complete"),
        ),
        name="password_reset_confirm",
    ),
    path(
        "reset/done/",
        auth_views.PasswordResetCompleteView.as_view(
            template_name="accounts/password_reset_complete.html"
        ),
        name="password_reset_complete",
    ),
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 33
PATH: accounts\utils.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from typing import Optional
import hashlib

from django.conf import settings

from core.utils import normalize_phone


def normalize_email(email: Optional[str]) -> str:
    """
    Приводим email к каноничному виду:
    - str.strip()
    - .lower()
    """
    if not email:
        return ""
    return email.strip().lower()


def _hash_value(kind: str, value: str) -> str:
    """
    Внутренняя функция хэширования с солью на базе SECRET_KEY.
    kind: 'email' или 'phone' (на будущее можно расширять).
    """
    if not value:
        return ""
    salted = f"{settings.SECRET_KEY}:{kind}:{value}"
    return hashlib.sha256(salted.encode("utf-8")).hexdigest()


def hash_email(email: str) -> str:
    """
    Хэш нормализованного email.
    В БД хранится только хэш, сам email — в зашифрованном поле.
    """
    normalized = normalize_email(email)
    if not normalized:
        return ""
    return _hash_value("email", normalized)


def hash_phone(phone: str) -> str:
    """
    Хэш нормализованного телефона.
    В БД хранится только хэш, сам телефон — в зашифрованном поле.
    """
    normalized = normalize_phone(phone)
    if not normalized:
        return ""
    return _hash_value("phone", normalized)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 34
PATH: accounts\views.py
LANG: python
===== CONTENT START =====
# accounts/views.py

from typing import Any

from django.contrib.auth import login as auth_login, logout as auth_logout
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.views import LoginView as DjangoLoginView
from django.contrib.auth.forms import PasswordResetForm
from django.http import HttpRequest, HttpResponse
from django.shortcuts import redirect, render
from django.urls import reverse, reverse_lazy
from django.views import View
from django.views.generic import UpdateView
from rest_framework import permissions, status, viewsets
from rest_framework.views import APIView
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenRefreshView

from django.utils import timezone
from django.utils.crypto import get_random_string
from django.contrib.auth import login as auth_login_session
from django.core.mail import send_mail

from core.permissions import IsSelfOrAdmin
from .forms import LoginForm, ProfileForm, RegisterForm
from .models import User, LoginCode
from .serializers import (
    ChangePasswordSerializer,
    LoginSerializer,
    PasswordResetRequestSerializer,
    RegisterSerializer,
    UserProfileSerializer,
    UserSerializer,
    OTPRequestSerializer,
    OTPVerifySerializer,
)
from .auth import find_user_by_identifier
from .utils import hash_email


# ===== HTML-вьюхи (шаблонный интерфейс) =====


class RegisterView(View):
    """
    Регистрация пользователя через HTML-форму.
    """

    template_name = "accounts/register.html"

    def get(self, request: HttpRequest) -> HttpResponse:
        if request.user.is_authenticated:
            return redirect("user_dashboard")
        form = RegisterForm()
        return render(request, self.template_name, {"form": form})

    def post(self, request: HttpRequest) -> HttpResponse:
        if request.user.is_authenticated:
            return redirect("user_dashboard")
        form = RegisterForm(request.POST)
        if form.is_valid():
            user = form.save()
            auth_login(request, user)
            return redirect("user_dashboard")
        return render(request, self.template_name, {"form": form})


class ProfileView(LoginRequiredMixin, UpdateView):
    """
    Редактирование профиля (email/телефон) в HTML-интерфейсе.
    """

    model = User
    form_class = ProfileForm
    template_name = "accounts/profile.html"
    success_url = reverse_lazy("user_dashboard")

    def get_object(self, queryset=None) -> User:
        return self.request.user


class CustomLoginView(DjangoLoginView):
    """
    Обёртка над стандартным LoginView с русским шаблоном и кастомной формой.
    """

    template_name = "accounts/login.html"
    form_class = LoginForm

    def get_success_url(self) -> str:
        return reverse("user_dashboard")


def logout_view(request: HttpRequest) -> HttpResponse:
    auth_logout(request)
    return redirect("landing")


# ===== API (DRF) =====


class UserViewSet(viewsets.ModelViewSet):
    """
    API для работы с пользователями.

    Маршруты:
    - /api/accounts/users/                   (GET)   — список (только админ)
    - /api/accounts/users/{id}/              (GET)   — профиль (сам или админ)
    - /api/accounts/users/me/                (GET)   — профиль текущего пользователя
    - /api/accounts/users/me/                (PATCH) — обновление своего профиля
    - /api/accounts/users/register/          (POST)  — регистрация
    - /api/accounts/users/login/             (POST)  — логин (session-based)
    - /api/accounts/users/logout/            (POST)  — логаут
    - /api/accounts/users/change-password/   (POST)  — смена пароля (API)
    - /api/accounts/users/reset-password/    (POST)  — запрос сброса пароля по email
    """

    queryset = User.objects.all().order_by("-date_joined")
    serializer_class = UserSerializer

    def get_permissions(self) -> list[Any]:
        if self.action in ("register", "login", "reset_password"):
            permission_classes = [permissions.AllowAny]
        elif self.action in ("list", "destroy"):
            permission_classes = [permissions.IsAdminUser]
        elif self.action in ("me", "change_password", "logout"):
            permission_classes = [permissions.IsAuthenticated]
        else:
            # retrieve/update/partial_update — только сам пользователь или админ
            permission_classes = [permissions.IsAuthenticated, IsSelfOrAdmin]
        return [perm() for perm in permission_classes]

    def get_queryset(self):
        user: User = self.request.user
        if not user.is_authenticated:
            return User.objects.none()
        if user.is_superuser or getattr(user, "is_admin", False):
            return User.objects.all().order_by("-date_joined")
        return User.objects.filter(pk=user.pk)

    def perform_destroy(self, instance: User) -> None:
        """
        Удалять пользователей может только админ — контролируется permissions.
        """
        super().perform_destroy(instance)

    @action(detail=False, methods=["get", "patch"], url_path="me")
    def me(self, request):
        """
        Профиль текущего пользователя.
        GET — получить; PATCH — обновить email/телефон.
        """
        if request.method.lower() == "get":
            serializer = UserProfileSerializer(request.user)
            return Response(serializer.data)
        serializer = UserProfileSerializer(
            request.user, data=request.data, partial=True
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    @action(detail=False, methods=["post"], url_path="register")
    def register(self, request):
        """
        Регистрация пользователя через API.
        """
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user: User = serializer.save()
        auth_login(request, user)
        data = UserProfileSerializer(user).data
        return Response(data, status=status.HTTP_201_CREATED)

    @action(detail=False, methods=["post"], url_path="login")
    def login(self, request):
        """
        Логин через API. Используются стандартные Django-сессии.
        """
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user: User = serializer.validated_data["user"]
        auth_login(request, user)
        data = UserProfileSerializer(user).data
        return Response(data, status=status.HTTP_200_OK)

    @action(detail=False, methods=["post"], url_path="logout")
    def logout(self, request):
        """
        Логаут через API (очистка сессии).
        """
        auth_logout(request)
        return Response(
            {"detail": "Вы вышли из системы."}, status=status.HTTP_200_OK
        )

    @action(detail=False, methods=["post"], url_path="change-password")
    def change_password(self, request):
        """
        Смена пароля текущего пользователя (API).
        """
        serializer = ChangePasswordSerializer(
            data=request.data, context={"request": request}
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(
            {"detail": "Пароль успешно изменён."},
            status=status.HTTP_200_OK,
        )

    @action(detail=False, methods=["post"], url_path="reset-password")
    def reset_password(self, request):
        """
        Запрос на сброс пароля по email (API).

        Использует стандартный PasswordResetForm и отправляет письмо
        через настроенный EMAIL_BACKEND.
        """
        serializer = PasswordResetRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        email = serializer.validated_data["email"]

        form = PasswordResetForm(data={"email": email})
        if form.is_valid():
            form.save(
                request=request,
                use_https=request.is_secure(),
                email_template_name="accounts/password_reset_email.txt",
                subject_template_name="accounts/password_reset_subject.txt",
            )

        # Независимо от результата говорим одно и то же, чтобы не раскрывать,
        # существует ли пользователь с таким email.
        return Response(
            {
                "detail": (
                    "Если пользователь с таким email существует, на него отправлена "
                    "инструкция по сбросу пароля."
                )
            },
            status=status.HTTP_200_OK,
        )


class TokenObtainPairView(APIView):
    """JWT-аутентификация по логину/email/телефону.

    Возвращает пару access/refresh токенов и упрощает интеграцию с мобильными
    клиентами и PWA. Валидация и анти-брутфорс остаются в LoginSerializer.
    """

    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data["user"]

        refresh = RefreshToken.for_user(user)
        return Response(
            {
                "access": str(refresh.access_token),
                "refresh": str(refresh),
                "user": UserProfileSerializer(user).data,
            },
            status=status.HTTP_200_OK,
        )


class TokenRefreshSlidingView(TokenRefreshView):
    """Упаковываем refresh endpoint в единый namespace accounts."""

    permission_classes = [permissions.AllowAny]


class AuthOTPRequestView(APIView):
    """
    POST /api/auth/request-code
    identifier: email/phone, purpose: login/register/reset_password
    """

    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = OTPRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        identifier = serializer.validated_data["identifier"]
        purpose = serializer.validated_data["purpose"]

        # Находим или создаём пользователя для регистрации
        user = find_user_by_identifier(identifier)
        if purpose == LoginCode.Purpose.REGISTER and user is None:
            # Создаём "сырого" пользователя с рандомным username
            username = f"user_{get_random_string(8)}"
            user = User.objects.create(username=username, is_active=True)
            if "@" in identifier:
                user.email_plain = identifier
            else:
                user.phone_plain = identifier
            user.save()
        if user is None:
            # Для login/reset_password не раскрываем факт отсутствия аккаунта
            return Response(status=status.HTTP_204_NO_CONTENT)

        # Генерируем код и хэшируем его
        raw_code = get_random_string(6, allowed_chars="0123456789")
        code_hash = hash_email(raw_code)  # переиспользуем хэш (или заменить на свою функцию)

        expires_at = timezone.now() + timezone.timedelta(minutes=10)
        LoginCode.objects.create(
            user=user,
            channel=LoginCode.Channel.EMAIL if "@" in identifier else LoginCode.Channel.PHONE,
            purpose=purpose,
            code_hash=code_hash,
            expires_at=expires_at,
        )

        # Отправка кода (для SMS тут будет интеграция с провайдером)
        if "@" in identifier:
            send_mail(
                subject="Ваш код ParkShare",
                message=f"Ваш код входа: {raw_code} (действителен 10 минут).",
                from_email=None,
                recipient_list=[identifier],
                fail_silently=True,
            )

        # Для демо возвращаем 204 без тела
        return Response(status=status.HTTP_204_NO_CONTENT)


class AuthOTPVerifyView(APIView):
    """
    POST /api/auth/verify-code
    identifier + code → логин (session + JWT).
    """

    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = OTPVerifySerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        identifier = serializer.validated_data["identifier"]
        code = serializer.validated_data["code"]
        purpose = serializer.validated_data["purpose"]

        user = find_user_by_identifier(identifier)
        if user is None:
            return Response({"detail": "Неверный код или идентификатор."}, status=status.HTTP_400_BAD_REQUEST)

        code_hash = hash_email(code)
        qs = LoginCode.objects.filter(
            user=user,
            purpose=purpose,
            is_used=False,
        ).order_by("-created_at")

        code_obj = qs.first()
        if not code_obj or code_obj.code_hash != code_hash or code_obj.is_expired:
            return Response({"detail": "Неверный или просроченный код."}, status=status.HTTP_400_BAD_REQUEST)

        code_obj.is_used = True
        code_obj.save(update_fields=["is_used", "updated_at"])

        # Логиним пользователя (session + JWT)
        auth_login_session(request, user)
        refresh = RefreshToken.for_user(user)
        return Response(
            {
                "access": str(refresh.access_token),
                "refresh": str(refresh),
            },
            status=status.HTTP_200_OK,
        )
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 35
PATH: accounts\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
import django_cryptography.fields
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(choices=[('driver', 'Водитель'), ('owner', 'Владелец парковки'), ('admin', 'Администратор')], default='driver', help_text='Определяет права доступа в системе.', max_length=16, verbose_name='Роль')),
                ('email_encrypted', django_cryptography.fields.encrypt(models.EmailField(blank=True, help_text='Опциональный email, хранится в зашифрованном виде.', max_length=254, null=True, verbose_name='Email (зашифрованный)'))),
                ('phone_encrypted', django_cryptography.fields.encrypt(models.CharField(blank=True, help_text='Опциональный телефон, хранится в зашифрованном виде.', max_length=32, null=True, verbose_name='Телефон (зашифрованный)'))),
                ('owner_request_pending', models.BooleanField(default=False, help_text='Пользователь подал заявку на роль владельца парковки.', verbose_name='Запрошено повышение до владельца')),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'Пользователь',
                'verbose_name_plural': 'Пользователи',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 36
PATH: accounts\migrations\0002_user_email_hash_user_phone_hash_logincode.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-23 15:00

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='user',
            name='email_hash',
            field=models.CharField(blank=True, db_index=True, help_text='Используется только для поиска и проверки уникальности email.', max_length=64, verbose_name='Хэш нормализованного email'),
        ),
        migrations.AddField(
            model_name='user',
            name='phone_hash',
            field=models.CharField(blank=True, db_index=True, help_text='Используется только для поиска и проверки уникальности телефона.', max_length=64, verbose_name='Хэш нормализованного телефона'),
        ),
        migrations.CreateModel(
            name='LoginCode',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('channel', models.CharField(choices=[('email', 'Email'), ('phone', 'Телефон')], max_length=16, verbose_name='Канал')),
                ('purpose', models.CharField(choices=[('register', 'Регистрация'), ('login', 'Вход'), ('reset_password', 'Сброс пароля')], max_length=32, verbose_name='Назначение')),
                ('code_hash', models.CharField(db_index=True, max_length=128, verbose_name='Хэш кода')),
                ('expires_at', models.DateTimeField(verbose_name='Истекает в')),
                ('is_used', models.BooleanField(default=False, verbose_name='Использован')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='login_codes', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Код подтверждения',
                'verbose_name_plural': 'Коды подтверждения',
                'indexes': [models.Index(fields=['user', 'purpose', 'is_used'], name='accounts_lo_user_id_024bc5_idx')],
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 37
PATH: accounts\migrations\0003_userlevel_userbadge_promoreward.py
LANG: python
===== CONTENT START =====
import uuid
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ('accounts', '0002_user_email_hash_user_phone_hash_logincode'),
    ]

    operations = [
        migrations.CreateModel(
            name='UserLevel',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=64)),
                ('threshold', models.PositiveIntegerField(default=0, help_text='Количество завершённых бронирований для уровня')),
                ('description', models.TextField(blank=True)),
            ],
            options={
                'verbose_name': 'Уровень пользователя',
                'verbose_name_plural': 'Уровни пользователей',
                'ordering': ('threshold',),
            },
        ),
        migrations.CreateModel(
            name='PromoReward',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('code', models.CharField(max_length=32, unique=True)),
                ('description', models.TextField(blank=True)),
                ('active', models.BooleanField(default=True)),
                ('usage_limit', models.PositiveIntegerField(default=1)),
            ],
            options={
                'verbose_name': 'Промо/бонус',
                'verbose_name_plural': 'Промо/бонусы',
            },
        ),
        migrations.CreateModel(
            name='UserBadge',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('title', models.CharField(max_length=128)),
                ('description', models.TextField(blank=True)),
                ('icon', models.CharField(blank=True, max_length=64)),
                ('level', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='badges', to='accounts.userlevel')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='badges', to='accounts.user', verbose_name='Пользователь')),
            ],
            options={
                'verbose_name': 'Бейдж',
                'verbose_name_plural': 'Бейджи',
                'ordering': ('-created_at',),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 38
PATH: accounts\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 39
PATH: ai\__init__.py
LANG: python
===== CONTENT START =====
default_app_config = "ai.apps.AiConfig"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 40
PATH: ai\admin.py
LANG: python
===== CONTENT START =====
from django.contrib import admin

from .models import ChatFeedback, ChatMessage, ChatSession, DeviceProfile, UiEvent


@admin.register(DeviceProfile)
class DeviceProfileAdmin(admin.ModelAdmin):
    list_display = ("device_id", "user", "layout_profile", "theme", "created_at")
    search_fields = ("device_id", "user__username")


@admin.register(UiEvent)
class UiEventAdmin(admin.ModelAdmin):
    list_display = ("event_type", "device_profile", "created_at")
    list_filter = ("event_type",)


@admin.register(ChatSession)
class ChatSessionAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "created_at", "last_activity_at")
    search_fields = ("id", "user__username")


@admin.register(ChatMessage)
class ChatMessageAdmin(admin.ModelAdmin):
    list_display = ("session", "role", "created_at")
    list_filter = ("role",)
    search_fields = ("text",)


@admin.register(ChatFeedback)
class ChatFeedbackAdmin(admin.ModelAdmin):
    list_display = ("message", "rating", "created_at")
    list_filter = ("rating",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 41
PATH: ai\apps.py
LANG: python
===== CONTENT START =====
from django.apps import AppConfig


class AiConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    # ВАЖНО: здесь должен быть реальный путь до пакета приложения
    # Папка называется "ai", лежит в корне проекта -> name = "ai"
    name = "ai"
    verbose_name = "AI и рекомендации ParkShare"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 42
PATH: ai\features.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import pandas as pd

from parking.models import Booking


def bookings_dataframe() -> pd.DataFrame:
    """
    Собирает историю бронирований в DataFrame для обучения/аналитики.
    """
    qs = Booking.objects.filter(
        status__in=[
            Booking.Status.CONFIRMED,
            Booking.Status.ACTIVE,
            Booking.Status.COMPLETED,
        ]
    ).select_related("spot", "spot__lot")

    rows = []
    for b in qs:
        rows.append(
            {
                "booking_id": str(b.id),
                "spot_id": str(b.spot_id),
                "lot_id": str(b.spot.lot_id),
                "city": b.spot.lot.city,
                "start": b.start_at,
                "end": b.end_at,
                "duration_hours": (b.end_at - b.start_at).total_seconds() / 3600.0,
                "price": float(b.total_price),
                "dow": b.start_at.weekday(),
                "hour": b.start_at.hour,
            }
        )

    if not rows:
        return pd.DataFrame()

    df = pd.DataFrame(rows)
    df["is_weekend"] = df["dow"] >= 5
    return df

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 43
PATH: ai\models.py
LANG: python
===== CONTENT START =====
# ai/models.py

from __future__ import annotations

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel, TimeStampedUUIDModel


class DeviceProfile(TimeStampedUUIDModel):
    """
    Профиль устройства/клиента для адаптивного UI.

    Связан либо с пользователем, либо с анонимным device_id (из cookies/LS).
    """

    class LayoutProfile(models.TextChoices):
        COMPACT = "compact", _("Компактный")
        COMFORTABLE = "comfortable", _("Комфортный")

    class Theme(models.TextChoices):
        LIGHT = "light", _("Светлая")
        DARK = "dark", _("Тёмная")
        SYSTEM = "system", _("Системная")

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="device_profiles",
    )
    device_id = models.CharField(
        _("ID устройства"),
        max_length=64,
        db_index=True,
    )

    viewport_width = models.IntegerField(_("Ширина viewport"), null=True, blank=True)
    viewport_height = models.IntegerField(_("Высота viewport"), null=True, blank=True)
    pixel_ratio = models.FloatField(_("Pixel ratio"), null=True, blank=True)
    user_agent = models.TextField(_("User‑Agent"), blank=True)

    layout_profile = models.CharField(
        _("Профиль компоновки"),
        max_length=32,
        choices=LayoutProfile.choices,
        default=LayoutProfile.COMPACT,
    )
    theme = models.CharField(
        _("Тема"),
        max_length=16,
        choices=Theme.choices,
        default=Theme.SYSTEM,
    )

    class Meta:
        verbose_name = _("Профиль устройства")
        verbose_name_plural = _("Профили устройств")
        unique_together = ("device_id", "user")

    def __str__(self) -> str:
        return f"DeviceProfile({self.device_id}, {self.layout_profile})"


class UiEvent(TimeStampedUUIDModel):
    """
    Сырые события UI/адаптивности (scroll, resize, layout_probe и т.п.).
    """

    device_profile = models.ForeignKey(
        DeviceProfile,
        on_delete=models.CASCADE,
        related_name="events",
    )
    event_type = models.CharField(_("Тип события"), max_length=64)
    payload = models.JSONField(_("Payload"), null=True, blank=True)

    class Meta:
        verbose_name = _("UI‑событие")
        verbose_name_plural = _("UI‑события")

    def __str__(self) -> str:
        return f"UiEvent({self.event_type})"


class ChatSession(TimeStampedUUIDModel):
    """Сессия чата (cookie ps_chat_sid)."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="chat_sessions",
    )
    client_info = models.JSONField("Данные клиента", null=True, blank=True)
    last_activity_at = models.DateTimeField("Последняя активность", auto_now=True)

    class Meta:
        verbose_name = "Сессия чата"
        verbose_name_plural = "Сессии чата"

    def __str__(self) -> str:
        return f"ChatSession({self.id})"


class ChatMessage(TimeStampedModel):
    """Сообщения в рамках сессии."""

    class Role(models.TextChoices):
        USER = "user", "User"
        ASSISTANT = "assistant", "Assistant"

    session = models.ForeignKey(
        ChatSession,
        on_delete=models.CASCADE,
        related_name="messages",
    )
    role = models.CharField("Роль", max_length=16, choices=Role.choices)
    text = models.TextField("Текст")
    meta = models.JSONField("Метаданные", null=True, blank=True)

    class Meta:
        verbose_name = "Сообщение чата"
        verbose_name_plural = "Сообщения чата"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"[{self.role}] {self.text[:30]}"


class ChatFeedback(TimeStampedModel):
    """Оценки ответов ассистента."""

    message = models.ForeignKey(
        ChatMessage,
        on_delete=models.CASCADE,
        related_name="feedback",
    )
    rating = models.IntegerField("Оценка", default=0)

    class Meta:
        verbose_name = "Фидбек чата"
        verbose_name_plural = "Фидбек чата"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Feedback({self.rating})"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 44
PATH: ai\orchestrator.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from decimal import Decimal
from typing import Any, Dict

from django.utils import timezone

from ai.pricing import recommend_price_for_spot


class PricingDecision:
    def __init__(self, payload: Dict[str, Any]):
        self.payload = payload

    @property
    def price(self) -> Decimal:
        return Decimal(str(self.payload.get("recommended_price", 0)))

    def to_dict(self) -> Dict[str, Any]:
        return self.payload


class AvailabilityDecision:
    def __init__(self, payload: Dict[str, Any]):
        self.payload = payload

    def to_dict(self) -> Dict[str, Any]:
        return self.payload


def apply_ai_pricing(booking) -> PricingDecision | None:
    """Подключает ML/GBM модель динамического ценообразования.

    Для MVP используем существующую recommend_price_for_spot, но сохраняем
    полную структуру для будущих CatBoost/GBM моделей (ParkMate).
    """

    suggestion = recommend_price_for_spot(booking.spot)
    if not suggestion:
        return None

    hours = max(Decimal("1"), Decimal((booking.end_at - booking.start_at).total_seconds()) / Decimal(3600))
    base_total = Decimal(str(booking.total_price))
    ai_hour_price = Decimal(str(suggestion["recommended_price"]))
    ai_total = (ai_hour_price * hours).quantize(Decimal("0.01"))

    booking.total_price = ai_total
    booking.dynamic_pricing_applied = True
    booking.ai_snapshot = {
        "pricing": suggestion,
        "calculated_at": timezone.now().isoformat(),
    }
    return PricingDecision({
        **suggestion,
        "applied_total": str(ai_total),
        "hours": str(hours),
    })


def attach_availability_forecast(booking, forecast: Dict[str, Any] | None = None) -> None:
    if forecast:
        booking.ai_snapshot = {
            **(booking.ai_snapshot or {}),
            "availability": forecast,
        }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 45
PATH: ai\pricing.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, Optional

import joblib
import numpy as np
from django.conf import settings
from django.utils import timezone
from sklearn.ensemble import RandomForestRegressor

from core.utils import round_price
from parking.models import ParkingSpot
from .features import bookings_dataframe

MODEL_PATH = Path(getattr(settings, "BASE_DIR", ".")) / "ai_models" / "pricing_model.pkl"


def train_pricing_model(df=None) -> Optional[RandomForestRegressor]:
    """
    Обучает простую RandomForest-модель для оценки цены за час.
    """
    if df is None:
        df = bookings_dataframe()
    if df.empty or len(df) < 20:
        return None

    df = df.copy()
    df["price_per_hour"] = df["price"] / df["duration_hours"].clip(lower=0.5)
    X = df[["hour", "dow", "is_weekend"]].values
    y = df["price_per_hour"].values

    model = RandomForestRegressor(
        n_estimators=50,
        random_state=42,
        n_jobs=-1,
    )
    model.fit(X, y)

    MODEL_PATH.parent.mkdir(parents=True, exist_ok=True)
    joblib.dump(model, MODEL_PATH)
    return model


def load_pricing_model() -> Optional[RandomForestRegressor]:
    if not MODEL_PATH.exists():
        return None
    try:
        model: RandomForestRegressor = joblib.load(MODEL_PATH)
        return model
    except Exception:
        return None


def recommend_price_for_spot(spot: ParkingSpot) -> Optional[Dict[str, Any]]:
    """
    Возвращает диапазон рекомендованных цен для владельца места.
    Учитывает:
    - базовую цену;
    - загрузку места за 7 дней (occupancy_7d);
    - (по возможности) предсказание ML‑модели.
    """
    base_price = float(spot.hourly_price or 0.0)
    if base_price <= 0:
        return None

    now = timezone.now()
    features = np.array([[now.hour, now.weekday(), 1 if now.weekday() >= 5 else 0]])

    model = load_pricing_model()
    predicted = None
    if model is not None:
        try:
            predicted_value = float(model.predict(features)[0])
            if predicted_value > 0:
                predicted = predicted_value
        except Exception:
            predicted = None

    occupancy = float(getattr(spot, "occupancy_7d", 0.0) or 0.0)
    factor = 1.0
    reason_parts = []

    if occupancy > 0.8:
        factor += 0.15
        reason_parts.append("место часто занято (высокая загрузка)")
    elif occupancy < 0.3:
        factor -= 0.1
        reason_parts.append("место простаивает (низкая загрузка)")

    if predicted is not None:
        ai_price = round_price(predicted, step=5.0)
        reason_parts.append("ML‑модель учитывает исторические цены по району")
    else:
        ai_price = base_price

    recommended = round_price(ai_price * factor, step=5.0)
    min_price = round_price(recommended * 0.9, step=5.0)
    max_price = round_price(recommended * 1.1, step=5.0)

    if not reason_parts:
        reason_parts.append("используется базовая ставка и средняя загрузка")

    reason = "На основе: " + "; ".join(reason_parts) + "."
    return {
        "base_price": base_price,
        "recommended_price": recommended,
        "min_price": min_price,
        "max_price": max_price,
        "reason": reason,
    }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 46
PATH: ai\serializers.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 47
PATH: ai\tasks.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from datetime import timedelta

from celery import shared_task
from django.utils import timezone

from parking.models import Booking, ParkingLot, ParkingSpot
from .features import bookings_dataframe
from .pricing import train_pricing_model


@shared_task
def update_models() -> None:
    """
    Периодически обучает модель цен и обновляет метрики загруженности.

    Делает три вещи:
    1) обучает/переобучает ML‑модель ценообразования;
    2) считает occupancy_7d для активных мест;
    3) считает stress_index для парковок (средняя загрузка мест).
    """
    df = bookings_dataframe()
    train_pricing_model(df)

    now = timezone.now()
    window_start = now - timedelta(days=7)

    # 1–2. Обновляем occupancy_7d для мест
    active_spots = ParkingSpot.objects.filter(
        status=ParkingSpot.SpotStatus.ACTIVE,
        lot__is_active=True,
        lot__is_approved=True,
    ).select_related("lot")

    total_period_hours = 24 * 7

    for spot in active_spots:
        qs = Booking.objects.filter(
            spot=spot,
            start_at__lt=now,
            end_at__gt=window_start,
            status__in=[
                Booking.Status.CONFIRMED,
                Booking.Status.ACTIVE,
                Booking.Status.COMPLETED,
            ],
        )

        booked_hours = 0.0
        for b in qs:
            start = max(b.start_at, window_start)
            end = min(b.end_at, now)
            delta_h = max((end - start).total_seconds() / 3600.0, 0.0)
            booked_hours += delta_h

        occupancy = booked_hours / float(total_period_hours)
        spot.occupancy_7d = max(0.0, min(occupancy, 1.0))
        spot.save(update_fields=["occupancy_7d"])

    # 3. Индекс загруженности по объектам парковки
    lots = ParkingLot.objects.filter(is_active=True, is_approved=True)
    for lot in lots:
        spots = lot.spots.all()
        if not spots:
            lot.stress_index = 0.0
            lot.save(update_fields=["stress_index"])
            continue
        values = [max(0.0, min(s.occupancy_7d, 1.0)) for s in spots]
        lot.stress_index = sum(values) / len(values)
        lot.save(update_fields=["stress_index"])

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 48
PATH: ai\views.py
LANG: python
===== CONTENT START =====
# backend/ai/views.py

from __future__ import annotations

import logging
from typing import Any

from asgiref.sync import async_to_sync
from django.http import StreamingHttpResponse
from django.utils import timezone
from rest_framework import status
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView

from parking.models import ParkingLot, ParkingSpot
from ai.pricing import recommend_price_for_spot
from ai.models import DeviceProfile, UiEvent
from services.llm import check_llm_health
from ai.chat.parking_assistant import generate_chat_reply

logger = logging.getLogger(__name__)



class RecommendationsAPIView(APIView):
    """
    Реальные AI-рекомендации по парковкам.

    Пример:
    GET /api/ai/recommendations/?city=Москва&limit=10
    """

    def get(self, request, *args: Any, **kwargs: Any) -> Response:
        city = request.query_params.get("city")
        limit = int(request.query_params.get("limit", 10))

        qs = ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        ).select_related("lot")

        if city:
            qs = qs.filter(lot__city__iexact=city)

        # Сначала берём самые "менее загруженные" и дешёвые места
        qs = qs.order_by("lot__stress_index", "hourly_price")[: limit * 2]

        recommendations: list[dict[str, Any]] = []
        now = timezone.now()

        for spot in qs[:limit]:
            try:
                pricing = recommend_price_for_spot(spot)
            except Exception:
                pricing = None

            rec: dict[str, Any] = {
                "spot_id": str(spot.id),
                "lot_id": str(spot.lot_id),
                "lot_name": spot.lot.name,
                "city": spot.lot.city,
                "address": spot.lot.address,
                "vehicle_type": spot.get_vehicle_type_display(),
                "hourly_price": float(spot.hourly_price or 0),
                "occupancy_7d": float(spot.occupancy_7d or 0.0),
                "stress_index": float(spot.lot.stress_index or 0.0),
                "is_covered": spot.is_covered,
                "has_ev_charging": spot.has_ev_charging,
                "is_24_7": spot.is_24_7,
                "now": now,
            }

            if pricing:
                rec.update(
                    {
                        "ai_recommended_hourly_price": float(
                            pricing.get("recommended_price", 0.0)
                        ),
                        "ai_base_price": float(pricing.get("base_price", 0.0)),
                        "ai_min_price": float(pricing.get("min_price", 0.0)),
                        "ai_max_price": float(pricing.get("max_price", 0.0)),
                        "ai_reason": pricing.get("reason", ""),
                        "ai_discount_percent": float(
                            pricing.get("discount_percent") or 0.0
                        ),
                        "ai_is_discount": bool(pricing.get("is_discount") or False),
                    }
                )

            recommendations.append(rec)

        return Response(
            {
                "count": len(recommendations),
                "results": recommendations,
            },
            status=status.HTTP_200_OK,
        )


class StressIndexAPIView(APIView):
    """
    Реальный индекс загруженности по городам / парковкам.

    Пример:
    GET /api/ai/stress-index/          # общий срез
    GET /api/ai/stress-index/?city=СПб
    """

    def get(self, request, *args: Any, **kwargs: Any) -> Response:
        city = request.query_params.get("city")

        lots_qs = ParkingLot.objects.filter(is_active=True, is_approved=True)
        if city:
            lots_qs = lots_qs.filter(city__iexact=city)

        lots = list(
            lots_qs.values(
                "id",
                "name",
                "city",
                "address",
                "stress_index",
            )
        )

        if not lots:
            return Response(
                {
                    "stress_index": 0.0,
                    "lots": [],
                    "details": "Нет активных парковок для выбранного фильтра",
                },
                status=status.HTTP_200_OK,
            )

        values = [float(l["stress_index"] or 0.0) for l in lots]
        avg = sum(values) / len(values)
        max_val = max(values)
        min_val = min(values)

        return Response(
            {
                "stress_index": round(avg, 3),
                "min": round(min_val, 3),
                "max": round(max_val, 3),
                "lots": lots,
            },
            status=status.HTTP_200_OK,
        )


class DepartureAssistantAPIView(APIView):
    """
    Простейший помощник по времени выезда (пока без внешних API).

    Принимает:
    POST /api/ai/departure-assistant/
    {
      "desired_arrival_iso": "2025-11-22T19:00:00+03:00",
      "parking_buffer_minutes": 10,
      "traffic_buffer_minutes": 20
    }
    """

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        from datetime import timedelta
        from django.utils.dateparse import parse_datetime

        desired_arrival_iso = request.data.get("desired_arrival_iso")
        parking_buffer = int(request.data.get("parking_buffer_minutes", 10))
        traffic_buffer = int(request.data.get("traffic_buffer_minutes", 20))

        if not desired_arrival_iso:
            return Response(
                {
                    "detail": "Нужен параметр desired_arrival_iso в ISO-формате",
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        desired_arrival = parse_datetime(desired_arrival_iso)
        if desired_arrival is None:
            return Response(
                {
                    "detail": "Не удалось распарсить desired_arrival_iso",
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        total_buffer = timedelta(
            minutes=parking_buffer + traffic_buffer,
        )
        suggested_departure = desired_arrival - total_buffer

        return Response(
            {
                "suggested_departure_time": suggested_departure,
                "desired_arrival_time": desired_arrival,
                "parking_buffer_minutes": parking_buffer,
                "traffic_buffer_minutes": traffic_buffer,
                "message": "Пока без пробок/погоды, но уже считает буферы времени.",
            },
            status=status.HTTP_200_OK,
        )


class LLMServiceHealthAPIView(APIView):
    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        try:
            health = async_to_sync(check_llm_health)()
        except Exception as exc:  # pragma: no cover - сеть/IO
            logger.warning("LLM health check failed", exc_info=exc)
            return Response(
                {"ok": False, "detail": str(exc)},
                status=status.HTTP_503_SERVICE_UNAVAILABLE,
            )
        return Response(health, status=status.HTTP_200_OK if health.get("ok") else status.HTTP_503_SERVICE_UNAVAILABLE)


class ChatStreamAPIView(APIView):
    """
    Минимальный чат‑эндпоинт для AI concierge на Django-страницах.
    Принимает список сообщений в формате [{role, content}] и возвращает потоковый текстовый ответ.
    """

    permission_classes = [AllowAny]

    def post(self, request, *args, **kwargs):
        data = request.data or {}
        messages = data.get("messages") or []
        if not isinstance(messages, list) or not messages:
            return Response({"detail": "messages is required"}, status=status.HTTP_400_BAD_REQUEST)

        last = messages[-1] if isinstance(messages[-1], dict) else {}
        user_text = (last.get("content") or "").strip()
        history = [m for m in messages[:-1] if isinstance(m, dict)]
        reply_text = "Сервис временно недоступен. Попробуйте позже."
        try:
            reply_payload = generate_chat_reply(
                user_text,
                history,
                request.user if request.user.is_authenticated else None,
            )
            reply_text = (reply_payload.get("reply") or reply_text).strip()
        except Exception as exc:  # pragma: no cover - внешние сервисы
            logger.warning("Chat reply failed", exc_info=exc)

        def stream():
            for token in reply_text.split():
                yield (token + " ").encode("utf-8")

        return StreamingHttpResponse(stream(), content_type="text/plain; charset=utf-8")


# ===== ParkMate AI — конфиг и предсказания (price/availability) =====


class ParkMateConfigAPIView(APIView):
    """
    AI‑помощник адаптивности:
    - принимает телеметрию клиента (viewport, pixelRatio, platform);
    - создаёт/обновляет DeviceProfile;
    - записывает UiEvent;
    - возвращает layout_profile / design_mode / theme.
    """

    permission_classes = [AllowAny]

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        data = request.data or {}
        client = data.get("client") or {}
        action = data.get("action") or "adaptive-profile"

        width = int(client.get("width") or 0)
        height = int(client.get("height") or 0)
        pixel_ratio = float(client.get("pixelRatio") or client.get("pixel_ratio") or 1.0)
        platform = (client.get("platform") or "RU")[:8]
        device_id = (request.COOKIES.get("ps_device_id") or client.get("deviceId") or "anonymous")[:64]
        user_agent = request.META.get("HTTP_USER_AGENT", "")[:1024]

        # Эвристика layout‑профиля
        if width < 640:
            layout = DeviceProfile.LayoutProfile.COMPACT
        elif width < 1024:
            layout = DeviceProfile.LayoutProfile.COMFORTABLE
        else:
            layout = DeviceProfile.LayoutProfile.COMFORTABLE

        design_mode = "pwa" if width < 1024 else "desktop"

        user = request.user if request.user.is_authenticated else None
        profile, _ = DeviceProfile.objects.get_or_create(
            device_id=device_id,
            user=user,
            defaults={
                "viewport_width": width,
                "viewport_height": height,
                "pixel_ratio": pixel_ratio,
                "user_agent": user_agent,
                "layout_profile": layout,
            },
        )

        # Обновляем основные параметры
        profile.viewport_width = width
        profile.viewport_height = height
        profile.pixel_ratio = pixel_ratio
        profile.layout_profile = layout
        profile.save(update_fields=["viewport_width", "viewport_height", "pixel_ratio", "layout_profile", "updated_at"])

        UiEvent.objects.create(
            device_profile=profile,
            event_type=action,
            payload={
                "width": width,
                "height": height,
                "pixel_ratio": pixel_ratio,
                "platform": platform,
            },
        )

        return Response(
            {
                "layout_profile": layout,
                "design_mode": design_mode,
                "theme": profile.theme,
            }
        )

    def get(self, request, *args: Any, **kwargs: Any) -> Response:
        """
        Возвращает фронту конфиг ParkMateAI (контракты/URL‑ы сервисов).
        Формат согласован с static/js/parkmate-ai.ts (ParkMateAI).
        """
        data = {
            "voiceCommands": {
                "booking": "Забронировать парковку рядом",
                "navigation": "Построить маршрут до парковки",
                "payment": "Оплатить текущую парковку",
                "support": "Связаться с поддержкой ParkShare",
            },
            "computerVision": {
                "licensePlateRecognition": "/api/ai/cv/license-plate/",
                "parkingSpotDetection": "/api/ai/cv/parking-occupancy/",
                "damageDetection": "/api/ai/cv/vehicle-damage/",  # зарезервировано
                "occupancyAnalytics": "/api/ai/stress-index/",
            },
            "predictions": {
                "arrivalTime": "/api/ai/departure-assistant/",
                "priceForecast": "/api/ai/parkmate/price-forecast/",
                "availability": "/api/ai/parkmate/availability/",
            },
        }
        return Response(data, status=status.HTTP_200_OK)


# Остальные классы (RecommendationsAPIView, StressIndexAPIView, DepartureAssistantAPIView,
# ParkMatePriceForecastAPIView, ParkMateAvailabilityForecastAPIView) остаются без изменений


class ParkMatePriceForecastAPIView(APIView):
    """
    Эндпоинт ParkMate для прогноза цены по конкретному месту.

    POST /api/ai/parkmate/price-forecast/
    {
      "spot_id": "uuid"
    }
    """

    permission_classes = [AllowAny]

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        from django.shortcuts import get_object_or_404

        spot_id = request.data.get("spot_id")
        if not spot_id:
            return Response(
                {"detail": "spot_id is required."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        spot = get_object_or_404(
            ParkingSpot,
            pk=spot_id,
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )

        pricing = recommend_price_for_spot(spot)
        if not pricing:
            return Response(
                {"detail": "AI pricing is not available for this spot."},
                status=status.HTTP_404_NOT_FOUND,
            )

        base_price = float(pricing.get("base_price", 0.0))
        recommended_price = float(pricing.get("recommended_price", base_price))
        min_price = float(pricing.get("min_price", recommended_price))
        max_price = float(pricing.get("max_price", recommended_price))
        discount_percent = float(pricing.get("discount_percent") or 0.0)
        is_discount = bool(pricing.get("is_discount") or False)

        data = {
            "spot_id": str(spot.id),
            "lot_id": str(spot.lot_id),
            "currency": "RUB",
            "base_price": base_price,
            "recommended_price": recommended_price,
            "min_price": min_price,
            "max_price": max_price,
            "discount_percent": discount_percent,
            "is_discount": is_discount,
            "reason": pricing.get("reason", ""),
        }
        return Response(data, status=status.HTTP_200_OK)


class ParkMateAvailabilityForecastAPIView(APIView):
    """
    Эндпоинт ParkMate для прогноза доступности места.

    POST /api/ai/parkmate/availability/
    {
      "spot_id": "uuid"        # либо
      "occupancy_7d": 0.4,
      "stress_index": 0.5
    }
    """

    permission_classes = [AllowAny]

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        from django.shortcuts import get_object_or_404

        spot_id = request.data.get("spot_id")
        occupancy_7d = request.data.get("occupancy_7d")
        stress_index = request.data.get("stress_index")

        spot = None
        if spot_id:
            spot = get_object_or_404(
                ParkingSpot,
                pk=spot_id,
                status=ParkingSpot.SpotStatus.ACTIVE,
                lot__is_active=True,
                lot__is_approved=True,
            )
            occupancy_7d = float(spot.occupancy_7d or 0.0)
            stress_index = float(spot.lot.stress_index or 0.0)
        else:
            try:
                occupancy_7d = float(occupancy_7d or 0.0)
                stress_index = float(stress_index or 0.0)
            except (TypeError, ValueError):
                return Response(
                    {
                        "detail": (
                            "occupancy_7d и stress_index должны быть числами, "
                            "если не передан spot_id."
                        )
                    },
                    status=status.HTTP_400_BAD_REQUEST,
                )

        # Нормализация
        occupancy_7d = max(0.0, min(float(occupancy_7d), 1.0))
        stress_index = max(0.0, min(float(stress_index), 1.0))

        # Простая эвристика: чем выше загрузка/стресс, тем ниже вероятность доступности
        base_avail = 1.0 - 0.7 * occupancy_7d - 0.3 * stress_index
        base_avail = max(0.0, min(base_avail, 1.0))

        next_1h = round(base_avail, 3)
        next_3h = round(max(0.0, base_avail - 0.1), 3)
        next_24h = round(max(0.0, base_avail - 0.2), 3)

        now = timezone.now()

        data = {
            "spot_id": str(spot.id) if spot else None,
            "occupancy_7d": occupancy_7d,
            "stress_index": stress_index,
            "as_of": now,
            "availability": {
                "next_1h": next_1h,
                "next_3h": next_3h,
                "next_24h": next_24h,
            },
        }
        return Response(data, status=status.HTTP_200_OK)


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 49
PATH: ai\chat\__init__.py
LANG: python
===== CONTENT START =====
"""Chat helpers for local parking assistant."""
from .parking_assistant import generate_chat_reply

__all__ = ["generate_chat_reply"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 50
PATH: ai\chat\parking_assistant.py
LANG: python
===== CONTENT START =====
"""
Умный помощник подбирает парковки по текстовому запросу, используя
простые правила и существующие данные модели парковок. При желании сюда
можно подключить обученные NLP-модели.
"""
from __future__ import annotations

import logging
import random
import re
from functools import lru_cache
from typing import Any, Dict, Iterable, List, Optional, Tuple

try:
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.metrics.pairwise import cosine_similarity
except Exception:  # pragma: no cover - безопасный фолбэк без зависимостей
    TfidfVectorizer = None
    cosine_similarity = None

from asgiref.sync import async_to_sync
from django.contrib.auth import get_user_model
from django.db.models import Q

from parking.models import ParkingSpot
from services.llm import LLMClientError, parse_search_query

User = get_user_model()
logger = logging.getLogger(__name__)


def _extract_budget(text: str) -> Optional[int]:
    match = re.search(r"(\d{2,5})\s*(?:₽|р|руб)", text)
    if match:
        try:
            return int(match.group(1))
        except ValueError:
            return None
    return None


def _extract_time_hint(text: str) -> str:
    if "завтра" in text:
        return "на завтра"
    if "ноч" in text:
        return "на ночь"
    if re.search(r"\b(\d{1,2})\s*[-–]\s*(\d{1,2})\b", text):
        return "в указанное окно времени"
    if "сейчас" in text or "прямо сейчас" in text:
        return "на ближайший час"
    return "скоро"


def _extract_time_window(text: str) -> tuple[Optional[int], Optional[int], str]:
    """Парсинг диапазона времени (часы) или быстрых подсказок."""

    match = re.search(r"\b(\d{1,2})\s*[-–]\s*(\d{1,2})\b", text)
    if match:
        start_h, end_h = match.groups()
        try:
            return int(start_h), int(end_h), f"с {start_h}:00 до {end_h}:00"
        except ValueError:
            return None, None, ""

    lowered = text.lower()
    if "сейчас" in lowered or "прямо сейчас" in lowered:
        return None, None, "на ближайший час"
    if "завтра" in lowered:
        return None, None, "на завтра"
    if "ноч" in lowered:
        return None, None, "на ночь"
    return None, None, ""


INTENT_CORPUS: list[tuple[str, str]] = [
    ("ev", "зарядка для электромобиля ev электромобиль tesla leaf"),
    ("budget", "самая дешёвая дёшево бюджет эконом"),
    ("night", "ночь ночевка оставить на ночь круглосуточно"),
    ("covered", "крытая парковка подземная защита от дождя"),
    ("fast", "сейчас ближайшая возле меня рядом срочно прямо сейчас"),
]


@lru_cache(maxsize=1)
def _intent_vectorizer():
    if not TfidfVectorizer:
        return None, None
    labels, texts = zip(*INTENT_CORPUS)
    vect = TfidfVectorizer(stop_words=None)
    matrix = vect.fit_transform(texts)
    return vect, (labels, matrix)


def _detect_intents(text: str) -> list[str]:
    vect, payload = _intent_vectorizer()
    if not vect or not payload:
        return []
    labels, matrix = payload
    query_vec = vect.transform([text])
    sims = cosine_similarity(query_vec, matrix).flatten()
    ranked: list[Tuple[float, str]] = sorted(zip(sims, labels), reverse=True)
    return [lbl for score, lbl in ranked if score > 0.18][:3]


def _build_base_queryset() -> Iterable[ParkingSpot]:
    return (
        ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )
        .select_related("lot")
    )


def _parse_with_llm(text: str) -> dict[str, Any] | None:
    """Try to parse a query using the external LLM service.

    Returns None if the service is unavailable or any error occurs so that we can
    gracefully fallback to the rule-based parsing.
    """

    try:
        logger.info(
            "Invoking LLM parser for chat message",
            extra={"query": text[:200]},
        )
        parsed = async_to_sync(parse_search_query)(text)
        logger.info(
            "LLM parsed query",
            extra={"query": text, "parsed": parsed},
        )
        return parsed
    except (LLMClientError, ValueError) as exc:
        logger.warning(
            "LLM parsing failed, using rule-based fallback",
            extra={"query": text},
            exc_info=exc,
        )
    except Exception as exc:  # pragma: no cover - непредвиденная ошибка
        logger.exception(
            "Unexpected LLM parse error, using fallback", extra={"query": text}
        )
    return None


def _apply_llm_filters(queryset, payload: dict[str, Any]):
    q_filter = Q()
    city = payload.get("city")
    if city:
        q_filter &= Q(lot__city__iexact=city) | Q(lot__address__icontains=city)

    if payload.get("has_ev_charging") is True:
        q_filter &= Q(has_ev_charging=True)
    if payload.get("covered") is True:
        q_filter &= Q(is_covered=True)

    max_price = payload.get("max_price_per_hour")
    if max_price is not None:
        try:
            q_filter &= Q(hourly_price__lte=float(max_price))
        except (TypeError, ValueError):
            logger.debug("Skip invalid max_price_per_hour", extra={"value": max_price})

    near_metro = payload.get("near_metro")
    if near_metro:
        q_filter &= Q(lot__address__icontains="метро") | Q(lot__name__icontains="метро")

    if q_filter:
        queryset = queryset.filter(q_filter)
    return queryset


def _apply_intents(queryset, text: str):
    lowered = text.lower()
    q_filter = Q()
    intents = set(_detect_intents(lowered))
    if "ev" in lowered or "заряд" in lowered or "электро" in lowered or "ev" in intents:
        q_filter &= Q(has_ev_charging=True)
    if "крыт" in lowered or "covered" in intents:
        q_filter &= Q(is_covered=True)
    if "24/7" in lowered or "круглосуточ" in lowered or "night" in intents:
        q_filter &= Q(is_24_7=True)
    if "budget" in intents:
        q_filter &= Q(hourly_price__lte=300)
    metro_match = re.search(r"метро\s+([\wёЁ\-\s]+)", lowered)
    if metro_match:
        station = metro_match.group(1).strip()
        q_filter &= Q(lot__address__icontains=station) | Q(lot__name__icontains=station)
    address_match = re.search(r"(ул\.|улица|проспект|шоссе|пл\.|площадь)\s+([\wёЁ\s\-]+)", lowered)
    if address_match:
        fragment = address_match.group(0)
        q_filter &= Q(lot__address__icontains=fragment)
    budget = _extract_budget(lowered)
    if budget:
        q_filter &= Q(hourly_price__lte=budget)
    if q_filter:
        queryset = queryset.filter(q_filter)
    return queryset, intents


def _spot_payload(spot: ParkingSpot) -> dict[str, Any]:
    tags = []
    if spot.has_ev_charging:
        tags.append("EV")
    if spot.is_covered:
        tags.append("крытая")
    if spot.is_24_7:
        tags.append("24/7")
    if getattr(spot, "allow_dynamic_pricing", False):
        tags.append("AI")
    return {
        "spot_id": str(spot.id),
        "title": f"{spot.lot.name} — {spot.name}",
        "price": float(spot.hourly_price or 0),
        "distance_m": getattr(spot, "distance_km", None) * 1000 if getattr(spot, "distance_km", None) else None,
        "tags": tags,
        "occupancy_now": float(getattr(spot, "occupancy_7d", 0.0) or 0.0),
    }


def _compose_reply(context: dict[str, Any], count: int) -> str:
    templates = [
        "Нашёл для вас {count} вариантов около {area}. Цены от {min_price} до {max_price} ₽/час. Сейчас свободно примерно {availability}%.",
        "Подобрал {count} парковок {time_hint}. Минимальный тариф {min_price} ₽/час, максимальный {max_price} ₽/час.",
        "Есть {count} подходящих мест {area}. Чтобы расширить выбор, можно скорректировать бюджет {budget_hint}.",
    ]
    area = context.get("area") or "рядом"
    min_price = context.get("min_price", 0)
    max_price = context.get("max_price", max(min_price, min_price + 50))
    availability = context.get("availability", 60)
    budget_hint = f"до {context['budget']} ₽" if context.get("budget") else "или радиус"
    time_hint = context.get("time_hint", "")
    template = random.choice(templates)
    return template.format(
        count=count or 0,
        area=area,
        min_price=min_price,
        max_price=max_price,
        availability=availability,
        budget_hint=budget_hint,
        time_hint=time_hint,
    )


def _llm_time_hint(payload: dict[str, Any]) -> str:
    start_at = payload.get("start_at")
    end_at = payload.get("end_at")
    if start_at and end_at:
        return "на выбранный интервал"
    if start_at:
        return "к указанному времени"
    return "скоро"


def _prepare_context(
    spots: list[ParkingSpot], area: Optional[str], budget: Optional[int], time_hint: str
) -> dict[str, Any]:
    prices = [float(s.hourly_price or 0) for s in spots] or [0]
    return {
        "area": area or "рядом",
        "min_price": int(min(prices)),
        "max_price": int(max(prices)),
        "availability": int(
            100
            - (sum([float(getattr(s, "occupancy_7d", 0.0) or 0) for s in spots]) / len(prices))
            * 100
        )
        if spots
        else 0,
        "budget": budget,
        "time_hint": time_hint,
    }


def _reply_payload(spots: list[ParkingSpot], context: dict[str, Any], reasoning: str) -> dict[str, Any]:
    suggestions = [_spot_payload(spot) for spot in spots][:6]
    if not suggestions:
        reply = "Сейчас нет парковок под эти условия. Попробуйте увеличить бюджет или выбрать другой район."
        reasoning = reasoning or "Запрос слишком узкий или в базе пока нет подходящих мест."
    else:
        reply = _compose_reply(context, len(suggestions))
    return {
        "reply": reply,
        "suggestions": suggestions,
        "reason": reasoning,
        "intents": context.get("intents", []),
    }


def _handle_llm_flow(text: str):
    parsed = _parse_with_llm(text)
    if not parsed:
        logger.debug(
            "LLM returned no result; will use rule-based fallback",
            extra={"query": text[:120]},
        )
        return None

    qs = _apply_llm_filters(_build_base_queryset(), parsed)
    qs = qs.order_by("lot__stress_index", "hourly_price")[:12]
    spots = list(qs)

    area_hint = None
    if parsed.get("near_metro"):
        area_hint = "рядом с метро"
    if parsed.get("city"):
        area_hint = parsed["city"]

    budget = parsed.get("max_price_per_hour")
    time_hint = _llm_time_hint(parsed)
    context = _prepare_context(spots, area_hint, budget, time_hint)
    reasoning_parts = ["LLM разобрал намерение пользователя"]
    if parsed.get("has_ev_charging"):
        reasoning_parts.append("учтена EV-зарядка")
    if parsed.get("covered"):
        reasoning_parts.append("оставлены крытые места")
    if budget:
        reasoning_parts.append("отфильтровано по бюджету")
    context["intents"] = []

    return _reply_payload(spots, context, ", ".join(reasoning_parts))


def _handle_rule_based_flow(lowered: str):
    qs, intents = _apply_intents(_build_base_queryset(), lowered)
    budget = _extract_budget(lowered)
    if budget:
        qs = qs.filter(hourly_price__lte=budget)

    qs = qs.order_by("lot__stress_index", "hourly_price")[:12]
    spots = list(qs)

    area_hint = None
    metro_match = re.search(r"метро\s+([\wёЁ\-\s]+)", lowered)
    if metro_match:
        area_hint = f"у метро {metro_match.group(1).strip().title()}"
    start_h, end_h, time_hint_parsed = _extract_time_window(lowered)
    time_hint = time_hint_parsed or _extract_time_hint(lowered)
    context = _prepare_context(spots, area_hint, budget, time_hint)
    context["intents"] = list(intents)
    if start_h is not None and end_h is not None:
        context["time_hint"] = f"с {start_h}:00 до {end_h}:00"

    why = []
    if "ev" in intents:
        why.append("учёл наличие EV-зарядки")
    if "budget" in intents or budget:
        why.append("отсортировал по цене")
    if "night" in intents:
        why.append("оставил только круглосуточные")
    if time_hint_parsed:
        why.append(f"учёл интервал {time_hint_parsed}")
    reasoning = ", ".join(why) if why else "использовал ближайшие и менее загруженные места"
    return _reply_payload(spots, context, reasoning)


def generate_chat_reply(message: str, history: Optional[List[dict]], user: Optional[User]) -> dict[str, Any]:
    text = (message or "").strip()
    logger.info(
        "Incoming parking chat message",
        extra={
            "message": text[:200],
            "history_len": len(history or []),
            "user": getattr(user, "id", None),
        },
    )
    if not text:
        logger.info("Empty chat message, returning friendly prompt")
        return {
            "reply": "Опишите улицу, метро, бюджет и время: например, \"Тверская, с 9 до 11, до 350 ₽/ч, крытая\".",
            "suggestions": [],
            "reason": "empty_message",
        }

    lowered = text.lower()

    try:
        llm_response = _handle_llm_flow(text)
        if llm_response:
            return llm_response
    except Exception as exc:  # pragma: no cover - непредвиденная ошибка
        logger.exception("LLM flow errored, forcing rule-based fallback", exc_info=exc)
        fallback = _handle_rule_based_flow(lowered)
        fallback["reason"] = (fallback.get("reason") or "") + " · AI сервис недоступен, используем эвристику"
        fallback["reply"] = fallback.get("reply") or "Работаю в упрощённом режиме без внешнего AI, но покажу подходящие места."
        return fallback

    logger.info("Falling back to rule-based parser")
    response = _handle_rule_based_flow(lowered)
    if not response.get("suggestions"):
        response["reply"] = (
            "Не очень понял запрос. Попробуйте формат: ‘Курская, парковка с 9 до 11, до 300 ₽/час, с зарядкой EV’."
        )
    return response

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 51
PATH: ai\management\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 52
PATH: ai\management\commands\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 53
PATH: ai\management\commands\train_chat_intents_from_logs.py
LANG: python
===== CONTENT START =====
from django.core.management.base import BaseCommand

from ai.models import ChatMessage


class Command(BaseCommand):
    help = "Проходится по логам чата и подготавливает данные для обучения NLP/intent моделей."

    def handle(self, *args, **options):
        total = ChatMessage.objects.count()
        assistant_messages = ChatMessage.objects.filter(role=ChatMessage.Role.ASSISTANT).count()
        user_messages = total - assistant_messages
        self.stdout.write(self.style.SUCCESS("Всего сообщений: %s" % total))
        self.stdout.write(f"Ответов ассистента: {assistant_messages}")
        self.stdout.write(f"Сообщений пользователей: {user_messages}")
        # TODO: выгружать диалоги и обучать намерения
        self.stdout.write("Подготовка к обучению завершена (заглушка).")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 54
PATH: ai\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated manually to include initial AI models
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ChatSession',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('client_info', models.JSONField(blank=True, null=True, verbose_name='Данные клиента')),
                ('last_activity_at', models.DateTimeField(auto_now=True, verbose_name='Последняя активность')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='chat_sessions', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Сессия чата',
                'verbose_name_plural': 'Сессии чата',
            },
        ),
        migrations.CreateModel(
            name='DeviceProfile',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('device_id', models.CharField(db_index=True, max_length=64, verbose_name='ID устройства')),
                ('viewport_width', models.IntegerField(blank=True, null=True, verbose_name='Ширина viewport')),
                ('viewport_height', models.IntegerField(blank=True, null=True, verbose_name='Высота viewport')),
                ('pixel_ratio', models.FloatField(blank=True, null=True, verbose_name='Pixel ratio')),
                ('user_agent', models.TextField(blank=True, verbose_name='User‑Agent')),
                ('layout_profile', models.CharField(choices=[('compact', 'Компактный'), ('comfortable', 'Комфортный')], default='compact', max_length=32, verbose_name='Профиль компоновки')),
                ('theme', models.CharField(choices=[('light', 'Светлая'), ('dark', 'Тёмная'), ('system', 'Системная')], default='system', max_length=16, verbose_name='Тема')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='device_profiles', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Профиль устройства',
                'verbose_name_plural': 'Профили устройств',
                'unique_together': {('device_id', 'user')},
            },
        ),
        migrations.CreateModel(
            name='UiEvent',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('event_type', models.CharField(max_length=64, verbose_name='Тип события')),
                ('payload', models.JSONField(blank=True, null=True, verbose_name='Payload')),
                ('device_profile', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='events', to='ai.deviceprofile')),
            ],
            options={
                'verbose_name': 'UI‑событие',
                'verbose_name_plural': 'UI‑события',
            },
        ),
        migrations.CreateModel(
            name='ChatMessage',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('role', models.CharField(choices=[('user', 'User'), ('assistant', 'Assistant')], max_length=16, verbose_name='Роль')),
                ('text', models.TextField(verbose_name='Текст')),
                ('meta', models.JSONField(blank=True, null=True, verbose_name='Метаданные')),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='messages', to='ai.chatsession')),
            ],
            options={
                'verbose_name': 'Сообщение чата',
                'verbose_name_plural': 'Сообщения чата',
                'ordering': ('-created_at',),
            },
        ),
        migrations.CreateModel(
            name='ChatFeedback',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('rating', models.IntegerField(default=0, verbose_name='Оценка')),
                ('message', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='feedback', to='ai.chatmessage')),
            ],
            options={
                'verbose_name': 'Фидбек чата',
                'verbose_name_plural': 'Фидбек чата',
                'ordering': ('-created_at',),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 55
PATH: ai\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 56
PATH: ai_services\__init__.py
LANG: python
===== CONTENT START =====
"""
AI microservices for ParkShare / ParkShare RU.

Содержит отдельные FastAPI‑приложения:
- ai_pricing_service: динамическое ценообразование;
- cv_service: Computer Vision (распознавание номеров, заполненность и т.д.).
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 57
PATH: ai_services\ai_pricing_service\__init__.py
LANG: python
===== CONTENT START =====
"""
AI Pricing microservice (FastAPI) for dynamic parking spot pricing.
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 58
PATH: ai_services\ai_pricing_service\main.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from decimal import Decimal, ROUND_HALF_UP
from typing import Optional

from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI(
    title="ParkShare AI Pricing Service",
    version="0.1.0",
    description=(
        "Отдельный микросервис ParkMate AI для динамического ценообразования "
        "парковочных мест. Пока использует простые эвристики, но интерфейс "
        "готов для подключения CatBoost/Transformer‑моделей."
    ),
)


def round_price(value: float, step: float = 10.0) -> float:
    """
    Локальная реализация round_price, не зависящая от Django.
    Округляет цену к ближайшему step (по умолчанию 10 ₽).
    """
    if step <= 0:
        return float(Decimal(str(value)).quantize(Decimal("0.01")))

    v = Decimal(str(value))
    step_dec = Decimal(str(step))
    scaled = (v / step_dec).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    result = scaled * step_dec
    return float(result)


# ai_services/ai_pricing_service/main.py

class PricingRequest(BaseModel):
    base_price: float = Field(
        ...,
        gt=0,
        description="Базовая цена за час, ₽",
    )
    occupancy_7d: float = Field(
        0.0,
        ge=0.0,
        le=1.0,
        description="Загруженность места за последние 7 дней (0..1)",
    )
    stress_index: float = Field(
        0.0,
        ge=0.0,
        le=1.0,
        description="Индекс загруженности парковки (0..1)",
    )
    hour: Optional[int] = Field(
        None,
        ge=0,
        le=23,
        description="Час суток (0–23, локальное время парковки)",
    )
    dow: Optional[int] = Field(
        None,
        ge=0,
        le=6,
        description="День недели (0=понедельник, 6=воскресенье)",
    )
    use_ml: bool = Field(
        False,
        description=(
            "Флаг для использования ML‑модели (зарезервировано; "
            "пока используется только эвристика)."
        ),
    )



class PricingResponse(BaseModel):
    base_price: float
    recommended_price: float
    min_price: float
    max_price: float
    discount_percent: float
    is_discount: bool
    reason: str


@app.get("/health", tags=["health"])
def health() -> dict:
    """
    Простой healthcheck.
    """
    return {"status": "ok"}


@app.post(
    "/api/v1/pricing/recommend",
    response_model=PricingResponse,
    tags=["pricing"],
    summary="Получить рекомендованную цену за час",
)
def recommend_price(payload: PricingRequest) -> PricingResponse:
    """
    Эвристическое ценообразование на основе:
    - базовой цены;
    - загруженности места/парковки;
    - времени суток (час пик / не час пик).

    В дальнейшем сюда можно подставить CatBoost/Transformer‑модель.
    """
    base_price = payload.base_price
    occ = float(payload.occupancy_7d or 0.0)
    stress = float(payload.stress_index or 0.0)

    factor = 1.0
    reasons: list[str] = []

    # Загруженность места
    if occ > 0.8:
        factor += 0.15
        reasons.append("место часто занято (высокая загруженность за 7 дней)")
    elif occ < 0.3:
        factor -= 0.10
        reasons.append("место простаивает (низкая загруженность за 7 дней)")

    # Стресс по парковке
    if stress > 0.7:
        factor += 0.10
        reasons.append("высокий парковочный стресс по объекту")
    elif stress < 0.3:
        factor -= 0.05
        reasons.append("низкий парковочный стресс по объекту")

    # Время суток
    if payload.hour is not None:
        hour = payload.hour
        if 8 <= hour <= 11 or 17 <= hour <= 21:
            factor += 0.10
            reasons.append("час пик")
        else:
            factor -= 0.05
            reasons.append("не час пик")

    # Ограничиваем фактор
    if factor < 0.5:
        factor = 0.5
    if factor > 1.5:
        factor = 1.5

    recommended = round_price(base_price * factor, step=5.0)
    min_price = round_price(recommended * 0.9, step=5.0)
    max_price = round_price(recommended * 1.1, step=5.0)

    # Скидка относительно базовой цены
    discount_percent = 0.0
    is_discount = False
    if recommended < base_price:
        diff = (base_price - recommended) / base_price
        discount_percent = float(
            (Decimal(str(diff)) * Decimal("100")).quantize(Decimal("0.1"))
        )
        is_discount = True

    if not reasons:
        reasons.append("используется только базовая ставка")

    reason = "; ".join(reasons)

    return PricingResponse(
        base_price=base_price,
        recommended_price=recommended,
        min_price=min_price,
        max_price=max_price,
        discount_percent=discount_percent,
        is_discount=is_discount,
        reason=reason,
    )

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 59
PATH: ai_services\cv_service\__init__.py
LANG: python
===== CONTENT START =====
"""
Computer Vision microservice (FastAPI) for ParkShare:
- распознавание номеров;
- оценка заполненности парковок по кадрам камер.
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 60
PATH: ai_services\cv_service\main.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from datetime import datetime, timezone
from typing import Optional

from fastapi import FastAPI
from pydantic import BaseModel, Field, root_validator

app = FastAPI(
    title="ParkShare CV Service",
    version="0.1.0",
    description=(
        "Заглушечный CV‑сервис ParkMate AI. "
        "Интерфейс готов под интеграцию OpenCV/ONNX/WebGPU‑моделей."
    ),
)


class LicensePlateRequest(BaseModel):
    image_url: Optional[str] = Field(
        None,
        description="URL до кадра/фото с номером автомобиля (если используется серверная загрузка).",
    )
    image_base64: Optional[str] = Field(
        None,
        description="Base64‑кодированное изображение (если отправляем напрямую).",
    )
    region: str = Field("RU", description="Код региона/страны (например, RU, EU, US).")

    @root_validator
    def validate_source(cls, values):
        if not values.get("image_url") and not values.get("image_base64"):
            raise ValueError("Нужно передать либо image_url, либо image_base64.")
        return values


class LicensePlateResponse(BaseModel):
    plate: str
    normalized_plate: str
    region: str
    confidence: float


class ParkingOccupancyRequest(BaseModel):
    image_url: Optional[str] = Field(
        None,
        description="URL до кадра камеры с парковкой.",
    )
    camera_id: Optional[str] = Field(
        None,
        description="ID камеры/потока в вашем домене.",
    )
    total_slots: Optional[int] = Field(
        None,
        gt=0,
        description="Общее количество мест (если известно заранее).",
    )

    @root_validator
    def validate_source(cls, values):
        if not values.get("image_url") and not values.get("camera_id"):
            raise ValueError("Нужно указать image_url или camera_id.")
        return values


class ParkingOccupancyResponse(BaseModel):
    occupied_slots: int
    total_slots: int
    occupancy_rate: float = Field(..., ge=0.0, le=1.0)
    timestamp: datetime


@app.get("/health", tags=["health"])
def health() -> dict:
    return {"status": "ok"}


@app.post(
    "/api/v1/cv/license-plate",
    response_model=LicensePlateResponse,
    tags=["cv"],
    summary="Распознавание госномера (заглушка)",
)
def recognize_plate(payload: LicensePlateRequest) -> LicensePlateResponse:
    """
    Заглушка для распознавания госномера.
    Реальная логика должна вызывать модель (OpenCV+ONNX и т.п.).
    """
    # TODO: заменить на вызов реальной модели/сервиса
    fake_plate = "A000AA197"
    normalized = fake_plate.replace(" ", "")
    return LicensePlateResponse(
        plate=fake_plate,
        normalized_plate=normalized,
        region=payload.region,
        confidence=0.85,
    )


@app.post(
    "/api/v1/cv/parking-occupancy",
    response_model=ParkingOccupancyResponse,
    tags=["cv"],
    summary="Оценка заполненности парковки по кадру (заглушка)",
)
def parking_occupancy(payload: ParkingOccupancyRequest) -> ParkingOccupancyResponse:
    """
    Заглушка для оценки заполненности парковки:
    - если total_slots известен, считаем примерно 50% занятости;
    - если нет, предполагаем 20 мест и 40% занято.
    """
    total_slots = payload.total_slots or 20
    occupied_slots = max(1, int(total_slots * 0.4))
    occupancy_rate = occupied_slots / float(total_slots)
    return ParkingOccupancyResponse(
        occupied_slots=occupied_slots,
        total_slots=total_slots,
        occupancy_rate=round(occupancy_rate, 3),
        timestamp=datetime.now(timezone.utc),
    )

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 61
PATH: backend\__init__.py
LANG: python
===== CONTENT START =====
"""
Top-level package marker for the Django project.
Ensures the project package has a concrete module file so multiprocessing
on Windows (used by Celery's prefork pool) can resolve the project
location without raising errors when __file__ is missing.
"""

# Expose Celery app for shared imports
from backend.backend.config.celery import app as celery_app

__all__ = ("celery_app",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 62
PATH: backend\manage.py
LANG: python
===== CONTENT START =====
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""

import os
import sys
from pathlib import Path


def main() -> None:
    """
    Точка входа для manage.py.

    ВАЖНО: добавляем корень репозитория в sys.path, чтобы пакеты
    уровня `accounts`, `parking`, `payments` и т.п. корректно импортировались,
    даже если запускаем `python backend/manage.py ...`.
    """
    current_file = Path(__file__).resolve()
    backend_dir = current_file.parent           # .../parkshare_ru_part1/backend
    project_root = backend_dir.parent           # .../parkshare_ru_part1

    # Гарантируем, что корень проекта в PYTHONPATH
    project_root_str = str(project_root)
    if project_root_str not in sys.path:
        sys.path.insert(0, project_root_str)

    # Если переменная окружения не задана – по умолчанию используем dev-настройки
    # Обязательно полный путь "backend.backend.settings.*", иначе Celery/uvicorn
    # падают с ModuleNotFoundError: backend.settings
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Не удалось импортировать Django. Убедись, что виртуальное "
            "окружение активировано и зависимости установлены."
        ) from exc

    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 63
PATH: backend\backend\__init__.py
LANG: python
===== CONTENT START =====
from .config.celery import app as celery_app

__all__ = ("celery_app",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 64
PATH: backend\backend\config\__init__.py
LANG: python
===== CONTENT START =====
"""Django config package for ASGI/WSGI and Celery app exposure."""

import os

# Гарантируем, что Celery и Django получают настройки даже при запуске воркеров напрямую.
# Используем полный путь, чтобы избежать ModuleNotFoundError при вызове Celery/uvicorn.
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

from .celery import app as celery_app  # noqa: E402

__all__ = ("celery_app",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 65
PATH: backend\backend\config\asgi.py
LANG: python
===== CONTENT START =====
import os

from django.core.asgi import get_asgi_application

settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module:
    raise RuntimeError(
        "DJANGO_SETTINGS_MODULE не задан. "
        "Укажи backend.backend.settings.local (dev) или backend.backend.settings.production (prod)."
    )

application = get_asgi_application()


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 66
PATH: backend\backend\config\celery.py
LANG: python
===== CONTENT START =====
# backend/backend/config/celery.py

from __future__ import annotations

import os

from celery import Celery


# Устанавливаем DJANGO_SETTINGS_MODULE до импорта Django.
settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module or settings_module.startswith("backend.settings"):
    # Позволяет запускать Celery локально без эксплицитного экспорта переменной.
    # Путь backend.settings.* больше не существует — используем полный путь пакета.
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

# Создаём Celery-приложение, конфигурацию читаем из Django settings с префиксом CELERY_.
app = Celery("backend")
app.config_from_object("django.conf:settings", namespace="CELERY")

# Авто-обнаружение tasks.py во всех Django-приложениях.
app.autodiscover_tasks()


@app.task(bind=True)
def debug_task(self) -> None:
    print(f"Debug task: Request: {self.request!r}")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 67
PATH: backend\backend\config\urls.py
LANG: python
===== CONTENT START =====
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.contrib.staticfiles import finders
from django.http import Http404, HttpResponse
from django.urls import include, path
from django.views.decorators.cache import never_cache
from django.views.generic import TemplateView
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularRedocView,
    SpectacularSwaggerView,
)
from rest_framework import routers

from accounts import views as accounts_api
from ai import views as ai_api
from parking import views as parking_views
from payments import views as payments_api
from vehicles import views as vehicles_api

router = routers.DefaultRouter()

# Accounts / пользователи (только API)
router.register(r"accounts/users", accounts_api.UserViewSet, basename="user")

# Vehicles
router.register(r"vehicles", vehicles_api.VehicleViewSet, basename="vehicle")

# Parking
router.register(r"parking/lots", parking_views.ParkingLotViewSet, basename="parking-lot")
router.register(r"parking/spots", parking_views.ParkingSpotViewSet, basename="parking-spot")
router.register(r"parking/bookings", parking_views.BookingViewSet, basename="booking")
router.register(r"parking/waitlist", parking_views.WaitlistViewSet, basename="waitlist")
router.register(r"parking/complaints", parking_views.ComplaintViewSet, basename="complaint")
router.register(
    r"parking/favorites", parking_views.FavoriteParkingSpotViewSet, basename="favorite-spot"
)
router.register(
    r"parking/saved-places", parking_views.SavedPlaceViewSet, basename="saved-place"
)
router.register(
    r"parking/push-subscriptions",
    parking_views.PushSubscriptionViewSet,
    basename="push-subscription",
)

# Payments
router.register(r"payments", payments_api.PaymentViewSet, basename="payment")
router.register(
    r"payment-methods", payments_api.PaymentMethodViewSet, basename="payment-method"
)
router.register(
    r"payments/methods", payments_api.PaymentMethodViewSet, basename="payment-method-nested"
)


@never_cache
def service_worker(request):
    """
    Отдаём service-worker.js с корня домена, но физически он лежит в static/.
    """
    path = finders.find("service-worker.js")
    if not path:
        raise Http404("Service worker not found")
    with open(path, "rb") as f:
        content = f.read()
    return HttpResponse(content, content_type="application/javascript")


@never_cache
def manifest(request):
    """
    Отдаём manifest.webmanifest с правильным content-type.
    """
    path = finders.find("manifest.webmanifest")
    if not path:
        raise Http404("Manifest not found")
    with open(path, "rb") as f:
        content = f.read()
    return HttpResponse(content, content_type="application/manifest+json")


urlpatterns = [
    path("admin/", admin.site.urls),

    # PWA файлы
    path("service-worker.js", service_worker, name="service_worker"),
    path("manifest.webmanifest", manifest, name="manifest"),

    # Web‑страницы
    path("", parking_views.LandingPageView.as_view(), name="landing"),
    path("map/", parking_views.MapPageView.as_view(), name="map_page"),
    path("pwa-install/", parking_views.PWAInstallGuideView.as_view(), name="pwa_install"),
    path("личный-кабинет/", parking_views.UserDashboardView.as_view(), name="user_dashboard"),
    path("кабинет-владельца/", parking_views.OwnerDashboardView.as_view(), name="owner_dashboard"),
    path("offline/", TemplateView.as_view(template_name="offline.html"), name="offline"),
    path("assistant/", TemplateView.as_view(template_name="ai/concierge.html"), name="ai_chat"),
    path("ai/", TemplateView.as_view(template_name="ai/concierge.html")),

    # Auth страницы (регистрация/логин/сброс пароля)
    path("accounts/", include("accounts.urls")),

    # API (DRF router)
    path("api/", include(router.urls)),

    # JWT auth
    path(
        "api/auth/token/",
        accounts_api.TokenObtainPairView.as_view(),
        name="token_obtain_pair",
    ),
    path(
        "api/auth/token/refresh/",
        accounts_api.TokenRefreshSlidingView.as_view(),
        name="token_refresh",
    ),

    # OTP / auth
    path("api/auth/request-code/", accounts_api.AuthOTPRequestView.as_view(), name="auth_request_code"),
    path("api/auth/verify-code/", accounts_api.AuthOTPVerifyView.as_view(), name="auth_verify_code"),

    # OpenAPI / документация
    path("api/schema/", SpectacularAPIView.as_view(), name="api-schema"),
    path(
        "api/docs/",
        SpectacularSwaggerView.as_view(url_name="api-schema"),
        name="api-docs",
    ),
    path(
        "api/docs/redoc/",
        SpectacularRedocView.as_view(url_name="api-schema"),
        name="api-docs-redoc",
    ),

    # AI API (ParkMate + аналитика)
    path("api/ai/recommendations/", ai_api.RecommendationsAPIView.as_view(), name="ai_recommendations"),
    path("api/ai/stress-index/", ai_api.StressIndexAPIView.as_view(), name="ai_stress_index"),
    path("api/ai/departure-assistant/", ai_api.DepartureAssistantAPIView.as_view(), name="ai_departure_assistant"),
    path("api/ai/parkmate/config/", ai_api.ParkMateConfigAPIView.as_view(), name="parkmate_config"),
    path("api/ai/parkmate/price-forecast/", ai_api.ParkMatePriceForecastAPIView.as_view(), name="parkmate_price_forecast"),
    path("api/chat/", ai_api.ChatStreamAPIView.as_view(), name="ai_chat_stream"),
    path("api/ai/llm/health/", ai_api.LLMServiceHealthAPIView.as_view(), name="ai_llm_health"),
    path("api/parking/map/", parking_views.ParkingMapAPIView.as_view(), name="parking_map"),
    path("api/geocode/", parking_views.GeocodeAPIView.as_view(), name="geocode"),

    # Payments webhooks
    path("payments/webhook/yookassa/", payments_api.YooKassaWebhookView.as_view(), name="yookassa_webhook"),
    path("payments/webhook/stripe/", payments_api.StripeWebhookView.as_view(), name="stripe_webhook"),

    # DRF browsable API login/logout
    path("api-auth/", include("rest_framework.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 68
PATH: backend\backend\config\wsgi.py
LANG: python
===== CONTENT START =====
import os

from django.core.wsgi import get_wsgi_application

settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module:
    raise RuntimeError(
        "DJANGO_SETTINGS_MODULE не задан. "
        "Укажи backend.backend.settings.local (dev) или backend.backend.settings.production (prod)."
    )

application = get_wsgi_application()


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 69
PATH: backend\backend\settings\__init__.py
LANG: python
===== CONTENT START =====
"""
Пакет настроек Django для ParkShare.

Важно:
- Не используйте DJANGO_SETTINGS_MODULE=backend.settings.
- Всегда указывайте конкретный модуль:

    - backend.backend.settings.local      — для локальной разработки
    - backend.backend.settings.production — для продакшена

Это согласовано с проверками в backend.backend.config.wsgi / asgi / celery.
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 70
PATH: backend\backend\settings\base.py
LANG: python
===== CONTENT START =====
import os
from datetime import timedelta
from pathlib import Path
from typing import List

import environ

from .regions import REGION_PROFILES

# ---------------------------------------------------------------------------
# Пути
# ---------------------------------------------------------------------------

# BASE_DIR — корень репозитория: C:\Users\Sultan\Downloads\parkshare_ru_part1
BASE_DIR = Path(__file__).resolve().parents[3]

# Тут главная правка: больше не уходим на уровень выше
PROJECT_ROOT = BASE_DIR  # C:\Users\Sultan\Downloads\parkshare_ru_part1


# ---------------------------------------------------------------------------
# Окружение
# ---------------------------------------------------------------------------

env = environ.Env(
    DEBUG=(bool, False),
)

env_file = PROJECT_ROOT / ".env"
if env_file.exists():
    environ.Env.read_env(str(env_file))

DEBUG: bool = env.bool("DEBUG", default=False)
# ОБЯЗАТЕЛЬНО: ключ только из переменной окружения / .env
SECRET_KEY: str = env("SECRET_KEY")

ALLOWED_HOSTS: List[str] = env.list(
    "ALLOWED_HOSTS", default=["localhost", "127.0.0.1"]
)

# Маркет/регион: RU — по умолчанию, GLOBAL — международный профиль.
PLATFORM_MODE: str = env("PLATFORM_MODE", default="RU").upper()

# ---------------------------------------------------------------------------
# Региональные профили / карты
# ---------------------------------------------------------------------------

REGION_PROFILE: str = env("REGION_PROFILE", default="RU")
REGION = REGION_PROFILES.get(REGION_PROFILE, REGION_PROFILES["RU"])

# Провайдер карты можно переопределить через MAP_PROVIDER,
# иначе берём primary из профиля.
MAP_PROVIDER: str = env("MAP_PROVIDER", default=REGION["maps"]["primary"])
MAP_PROVIDER_FALLBACK: str = env(
    "MAP_PROVIDER_FALLBACK", default=REGION["maps"].get("fallback", "leaflet")
)
YANDEX_MAP_API_KEY: str = env("YANDEX_MAP_API_KEY", default="")
MAPBOX_TOKEN: str = env("MAPBOX_TOKEN", default="")

MAP_DEFAULT_CENTER = REGION["maps"].get("default_center", [55.75, 37.61])
MAP_DEFAULT_ZOOM = REGION["maps"].get("default_zoom", 11)

# ---------------------------------------------------------------------------
# Приложения
# ---------------------------------------------------------------------------

INSTALLED_APPS = [
    # Django
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # Сторонние
    "rest_framework",
    "corsheaders",
    "django_cryptography",
    "drf_spectacular",

    # Проектные
    "accounts",
    "vehicles",
    "parking",
    "payments",
    "ai",
    "core",
]

MIDDLEWARE = [
    "core.middleware.RateLimitMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "core.middleware.SecurityHeadersMiddleware",
    "django.middleware.gzip.GZipMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.backend.config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                # Глобальные настройки ParkShare: регион, карта и т.д.
                "core.context_processors.global_settings",
            ],
        },
    },
]

WSGI_APPLICATION = "backend.backend.config.wsgi.application"
ASGI_APPLICATION = "backend.backend.config.asgi.application"

# ---------------------------------------------------------------------------
# Базы данных
# ---------------------------------------------------------------------------

DATABASES = {
    "default": env.db(
        "DATABASE_URL", default=f"sqlite:///{BASE_DIR / 'db.sqlite3'}"
    )
}

# Если используем PostgreSQL — переключаемся на PostGIS
if DATABASES["default"]["ENGINE"] == "django.db.backends.postgresql":
    DATABASES["default"]["ENGINE"] = "django.contrib.gis.db.backends.postgis"

# ---------------------------------------------------------------------------
# Пользователь / аутентификация
# ---------------------------------------------------------------------------

AUTH_USER_MODEL = "accounts.User"

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        "OPTIONS": {"min_length": 8},
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# ---------------------------------------------------------------------------
# Локализация
# ---------------------------------------------------------------------------

LANGUAGE_CODE = env("LANGUAGE_CODE", default="ru-ru")
TIME_ZONE = env("TIME_ZONE", default="Europe/Moscow")
USE_I18N = True
USE_L10N = True
USE_TZ = True

# ---------------------------------------------------------------------------
# Статика / медиа
# ---------------------------------------------------------------------------

STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

# ---------------------------------------------------------------------------
# PWA
# ---------------------------------------------------------------------------

PWA_APP_NAME = "ParkShare RU"
PWA_APP_SHORT_NAME = "ParkShare"
PWA_THEME_COLOR = "#0d6efd"
PWA_BACKGROUND_COLOR = "#050816"

# ---------------------------------------------------------------------------
# DRF / OpenAPI
# ---------------------------------------------------------------------------

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework_simplejwt.authentication.JWTAuthentication",
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ],
    "DEFAULT_PAGINATION_CLASS": "core.pagination.DefaultPageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

SPECTACULAR_SETTINGS = {
    "TITLE": "ParkShare RU API",
    "DESCRIPTION": "API сервиса бронирования парковочных мест ParkShare RU.",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
}

# ---------------------------------------------------------------------------
# CORS
# ---------------------------------------------------------------------------

CORS_ALLOWED_ORIGINS = env.list("CORS_ALLOWED_ORIGINS", default=[])
CORS_ALLOWED_ORIGIN_REGEXES = env.list("CORS_ALLOWED_ORIGIN_REGEXES", default=[])
CORS_ALLOW_CREDENTIALS = True
CSRF_TRUSTED_ORIGINS = env.list("CSRF_TRUSTED_ORIGINS", default=[])

# ---------------------------------------------------------------------------
# JWT
# ---------------------------------------------------------------------------

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=15),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
    "ROTATE_REFRESH_TOKENS": True,
    "BLACKLIST_AFTER_ROTATION": True,
    "ALGORITHM": "HS256",
    "SIGNING_KEY": SECRET_KEY,
    "AUTH_HEADER_TYPES": ("Bearer",),
    "AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
    "UPDATE_LAST_LOGIN": True,
}

# ---------------------------------------------------------------------------
# Redis / Celery
# ---------------------------------------------------------------------------

REDIS_URL = env("REDIS_URL", default="redis://redis:6379/0")

CELERY_BROKER_URL = env("CELERY_BROKER_URL", default=REDIS_URL)
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND", default=REDIS_URL)
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE

CELERY_BEAT_SCHEDULE = {
    "expire_unpaid_bookings": {
        "task": "parking.tasks.expire_unpaid_bookings",
        "schedule": 60 * 10,  # каждые 10 минут
    },
    "update_ai_models": {
        "task": "ai.tasks.update_models",
        "schedule": 60 * 60,  # раз в час
    },
    "check_stale_payments": {
        "task": "payments.tasks.check_stale_payments",
        "schedule": 60 * 15,  # каждые 15 минут
    },
}

# ---------------------------------------------------------------------------
# Логи
# ---------------------------------------------------------------------------

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "[{asctime}] {levelname} {name} {message}",
            "style": "{",
        },
        "simple": {
            "format": "{levelname} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "verbose",
        },
    },
    "loggers": {
        "django": {
            "handlers": ["console"],
            "level": "INFO",
        },
        "parkshare": {
            "handlers": ["console"],
            "level": "INFO",
        },
        "ai": {
            "handlers": ["console"],
            "level": "DEBUG",
            "propagate": False,
        },
        "services": {
            "handlers": ["console"],
            "level": "DEBUG",
            "propagate": False,
        },
    },
}

# ---------------------------------------------------------------------------
# Email
# ---------------------------------------------------------------------------

EMAIL_BACKEND = env(
    "EMAIL_BACKEND",
    default="django.core.mail.backends.console.EmailBackend",
)
DEFAULT_FROM_EMAIL = env(
    "DEFAULT_FROM_EMAIL",
    default="ParkShare RU <noreply@example.com>",
)
SERVER_EMAIL = env("SERVER_EMAIL", default=DEFAULT_FROM_EMAIL)

# ---------------------------------------------------------------------------
# Безопасность (базовый уровень, детали переопределяются в production.py)
# ---------------------------------------------------------------------------

SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=False)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=False)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=False)
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = "Lax"
CSRF_COOKIE_SAMESITE = "Lax"
X_FRAME_OPTIONS = "DENY"
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")

CONTENT_SECURITY_POLICY = env(
    "CONTENT_SECURITY_POLICY",
    default=(
        "default-src 'self'; "
        "script-src 'self' 'unsafe-inline' https:; "
        "style-src 'self' 'unsafe-inline' https:; "
        "img-src 'self' data: https:; "
        "connect-src 'self' https:; "
        "font-src 'self' https: data:; "
        "frame-ancestors 'none'; "
        "form-action 'self';"
    ),
)

if DEBUG:
    X_FRAME_OPTIONS = "SAMEORIGIN"
    CONTENT_SECURITY_POLICY = (
        "default-src 'self'; "
        "script-src 'self' 'unsafe-inline' https:; "
        "style-src 'self' 'unsafe-inline' https:; "
        "img-src 'self' data: https:; "
        "connect-src 'self' https: http://localhost:3000 http://127.0.0.1:3000; "
        "font-src 'self' https: data:; "
        "frame-src 'self' http://localhost:3000 http://127.0.0.1:3000; "
        "frame-ancestors 'self'; "
        "form-action 'self';"
    )

REFERRER_POLICY = env("REFERRER_POLICY", default="strict-origin-when-cross-origin")
PERMISSIONS_POLICY = env(
    "PERMISSIONS_POLICY",
    # Разрешаем геолокацию только себе, остальное по умолчанию запрещено
    default="geolocation=(self), camera=(), microphone=(), payment=()",
)

# COOP / COEP / CORP — по умолчанию выключены, чтобы не ломать
# внешние ресурсы (карты, CDN, платёжные виджеты и т.п.).
# Если понадобится SharedArrayBuffer и строгая изоляция — включишь
# явно через .env.
CROSS_ORIGIN_OPENER_POLICY = env(
    "CROSS_ORIGIN_OPENER_POLICY", default=""
)
CROSS_ORIGIN_EMBEDDER_POLICY = env(
    "CROSS_ORIGIN_EMBEDDER_POLICY", default=""
)
CROSS_ORIGIN_RESOURCE_POLICY = env(
    "CROSS_ORIGIN_RESOURCE_POLICY", default=""
)

# ---------------------------------------------------------------------------
# Rate limiting
# ---------------------------------------------------------------------------

RATE_LIMIT_CACHE = env("RATE_LIMIT_CACHE", default="default")
RATE_LIMIT_WINDOW = env.int("RATE_LIMIT_WINDOW", default=60)
RATE_LIMIT_REQUESTS = env.int("RATE_LIMIT_REQUESTS", default=120)
RATE_LIMIT_WHITELIST = env.list(
    "RATE_LIMIT_WHITELIST", default=["127.0.0.1", "::1"]
)

# ---------------------------------------------------------------------------
# django-cryptography
# ---------------------------------------------------------------------------

DJANGO_CRYPTography_KEY = SECRET_KEY

# ---------------------------------------------------------------------------
# Бизнес-настройки
# ---------------------------------------------------------------------------

VEHICLE_PLATE_SALT = env("VEHICLE_PLATE_SALT", default="change_me_vehicle_salt")

YOOKASSA_SHOP_ID = env("YOOKASSA_SHOP_ID", default="")
YOOKASSA_SECRET_KEY = env("YOOKASSA_SECRET_KEY", default="")
YOOKASSA_RETURN_URL = env("YOOKASSA_RETURN_URL", default="")
YOOKASSA_WEBHOOK_SECRET = env("YOOKASSA_WEBHOOK_SECRET", default="")
STRIPE_SECRET_KEY = env("STRIPE_SECRET_KEY", default="")
STRIPE_WEBHOOK_SECRET = env("STRIPE_WEBHOOK_SECRET", default="")
DEFAULT_PAYMENT_PROVIDER = env(
    "PAYMENT_PROVIDER",
    default="yookassa" if PLATFORM_MODE == "RU" else "stripe",
)

SERVICE_COMMISSION_PERCENT = env.int("SERVICE_COMMISSION_PERCENT", default=10)

# ---------------------------------------------------------------------------
# Кэш по умолчанию — in-memory (в продакшене можно переключить на Redis)
# ---------------------------------------------------------------------------

CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "parkshare_cache",
    }
}

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 71
PATH: backend\backend\settings\local.py
LANG: python
===== CONTENT START =====
from .base import *  # noqa: F401,F403

# Локальная разработка

DEBUG = env.bool("DEBUG", default=True)
ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=["127.0.0.1", "localhost"])

INTERNAL_IPS = ["127.0.0.1"]

SECURE_SSL_REDIRECT = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 72
PATH: backend\backend\settings\production.py
LANG: python
===== CONTENT START =====
from django.core.exceptions import ImproperlyConfigured

from .base import *  # noqa: F401,F403

# Продакшен-настройки

DEBUG = False

ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=[])
if not ALLOWED_HOSTS:
    raise ImproperlyConfigured(
        "В продакшене ALLOWED_HOSTS не должен быть пустым. "
        "Задайте ALLOWED_HOSTS в .env"
    )

SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=True)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=True)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=True)

SECURE_HSTS_SECONDS = env.int("SECURE_HSTS_SECONDS", default=60 * 60 * 24)
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 73
PATH: backend\backend\settings\regions.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

"""
Региональные профили ParkShare.

RU — основной профиль (ParkShare RU) с Яндекс.Картами, российскими платёжками
и провайдерами аутентификации.

EU/US — заготовки для будущих рынков.
"""

REGION_PROFILES = {
    "RU": {
        "code": "RU",
        "name": "Russia",
        "maps": {
            # Важно: логические идентификаторы, а не "маркетинговые" названия
            "primary": "yandex",
            "fallback": "leaflet",
            "language": "ru_RU",
            "default_center": [55.75, 37.61],  # Москва
            "default_zoom": 11,
        },
        "payments": {
            "required": [
                "sberbank_online",
                "tinkoff",
                "yoomoney",
                "mir_pay",
                "qiwi",
            ],
        },
        "auth": [
            "gosuslugi",
            "vk_id",
            "yandex_id",
            "sber_id",
        ],
        "holidays": {
            "provider": "ru_holidays",
        },
    },
    "EU": {
        "code": "EU",
        "name": "European Union",
        "maps": {
            "primary": "leaflet",
            "fallback": "leaflet",
            "language": "en_US",
            "default_center": [52.52, 13.405],  # Берлин как условный центр
            "default_zoom": 11,
        },
        "payments": {
            "required": [
                "visa_mastercard",
            ],
        },
        "auth": ["email_password"],
        "holidays": {
            "provider": "eu_holidays",
        },
    },
    "US": {
        "code": "US",
        "name": "United States",
        "maps": {
            "primary": "leaflet",
            "fallback": "leaflet",
            "language": "en_US",
            "default_center": [40.7128, -74.0060],  # Нью-Йорк
            "default_zoom": 11,
        },
        "payments": {
            "required": [
                "visa_mastercard",
                "apple_pay",
                "google_pay",
            ],
        },
        "auth": ["email_password"],
        "holidays": {
            "provider": "us_holidays",
        },
    },
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 74
PATH: backend\rest_framework_simplejwt\__init__.py
LANG: python
===== CONTENT START =====
"""Stub for rest_framework_simplejwt to allow offline checks."""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 75
PATH: backend\rest_framework_simplejwt\authentication.py
LANG: python
===== CONTENT START =====
from rest_framework.authentication import BaseAuthentication


class JWTAuthentication(BaseAuthentication):
    def authenticate(self, request):
        return None

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 76
PATH: backend\rest_framework_simplejwt\tokens.py
LANG: python
===== CONTENT START =====
class RefreshToken:
    @classmethod
    def for_user(cls, user):
        return cls()

    def __str__(self):
        return "stub-token"

    @property
    def access_token(self):
        return "stub-access"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 77
PATH: backend\rest_framework_simplejwt\views.py
LANG: python
===== CONTENT START =====
from rest_framework.response import Response
from rest_framework.views import APIView


class TokenObtainPairView(APIView):
    def post(self, request, *args, **kwargs):
        return Response({"access": "stub", "refresh": "stub"})


class TokenRefreshView(APIView):
    def post(self, request, *args, **kwargs):
        return Response({"access": "stub"})


class TokenRefreshSlidingView(TokenRefreshView):
    pass

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 78
PATH: backend\tests\__init__.py
LANG: python
===== CONTENT START =====
# Пакет с базовыми тестами проекта ParkShare RU.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 79
PATH: backend\tests\test_auth_api.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from rest_framework.test import APIClient


class AuthApiTests(TestCase):
    def setUp(self) -> None:
        self.client = APIClient()
        self.password = "StrongPass123"

    def test_register_and_login_by_username_email_and_phone(self):
        # Регистрация
        resp = self.client.post(
            "/api/accounts/users/register/",
            {
                "username": "demo",
                "password": self.password,
                "email": "demo@example.com",
                "phone": "+7 (999) 123-45-67",
            },
            format="json",
        )
        self.assertEqual(resp.status_code, 201)
        self.client.logout()

        # Логин по логину
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "demo", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(resp.data["username"], "demo")
        self.client.logout()

        # Логин по email
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "demo@example.com", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)
        self.client.logout()

        # Логин по телефону (в любом удобном формате)
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "+7 999 123-45-67", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 80
PATH: backend\tests\test_booking_model.py
LANG: python
===== CONTENT START =====
from datetime import timedelta
from decimal import Decimal

from django.test import TestCase
from django.utils import timezone

from accounts.models import User
from parking.models import Booking, ParkingLot, ParkingSpot


class BookingModelTests(TestCase):
    def setUp(self) -> None:
        self.owner = User.objects.create_user(
            username="owner",
            password="StrongPass123",
            role=User.Role.OWNER,
        )
        self.driver = User.objects.create_user(
            username="driver",
            password="StrongPass123",
            role=User.Role.DRIVER,
        )

        self.lot = ParkingLot.objects.create(
            owner=self.owner,
            name="Test Lot",
            city="Test City",
            address="Test street, 1",
        )
        self.spot = ParkingSpot.objects.create(
            lot=self.lot,
            name="A1",
            hourly_price=Decimal("100.00"),
        )

    def test_calculate_price_hourly_with_commission(self):
        now = timezone.now()
        booking = Booking(
            user=self.driver,
            spot=self.spot,
            booking_type=Booking.BookingType.HOURLY,
            start_at=now,
            end_at=now + timedelta(hours=1, minutes=30),
            total_price=Decimal("0.00"),
            currency="RUB",
        )
        total = booking.calculate_price()
        # 2 часа * 100 ₽ + 10% комиссии = 220
        self.assertEqual(total, Decimal("220.00"))

    def test_is_spot_available(self):
        now = timezone.now()
        existing = Booking.objects.create(
            user=self.driver,
            spot=self.spot,
            booking_type=Booking.BookingType.HOURLY,
            start_at=now,
            end_at=now + timedelta(hours=2),
            status=Booking.Status.CONFIRMED,
            total_price=Decimal("200.00"),
            currency="RUB",
        )

        # Пересекающийся интервал — недоступен
        self.assertFalse(
            Booking.is_spot_available(
                self.spot,
                now + timedelta(minutes=30),
                now + timedelta(hours=3),
            )
        )

        # Непересекающийся интервал — доступен
        self.assertTrue(
            Booking.is_spot_available(
                self.spot,
                existing.end_at + timedelta(minutes=1),
                existing.end_at + timedelta(hours=1),
            )
        )

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 81
PATH: backend\tests\test_ui_theme_chat.py
LANG: python
===== CONTENT START =====
from django.contrib.auth import get_user_model
from django.test import Client, TestCase
from django.urls import reverse


class UIThemeTests(TestCase):
    def setUp(self):
        self.client = Client()

    def test_landing_has_theme_toggle(self):
        response = self.client.get(reverse("landing"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "ParkShare")
        self.assertContains(response, "data-theme-toggle")
        self.assertContains(response, "data-search-bar")
        self.assertContains(response, "data-map-panel")
        self.assertContains(response, "data-spots-list")
        self.assertContains(response, "Рекомендации")
        self.assertContains(response, 'data-nav="assistant"')
        self.assertContains(response, "data-geocode-input")

    def test_map_page_renders(self):
        response = self.client.get(reverse("map_page"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-map-panel")

    def test_assistant_page_renders(self):
        response = self.client.get(reverse("ai_chat"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-ai-chat")
        self.assertContains(response, "ps-ai-prompts")
        self.assertContains(response, "data-ai-send")

    def test_bookings_page_for_user(self):
        User = get_user_model()
        user = User.objects.create_user(username="demo", password="pass")
        self.client.login(username="demo", password="pass")
        response = self.client.get(reverse("user_dashboard"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-route=\"bookings\"")
        self.assertContains(response, "Мои бронирования")

    def test_owner_page_for_owner_role(self):
        User = get_user_model()
        owner = User.objects.create_user(username="owner", password="pass", role=User.Role.OWNER)
        self.client.login(username="owner", password="pass")
        response = self.client.get(reverse("owner_dashboard"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-route=\"parking\"")


class ChatAPITests(TestCase):
    def setUp(self):
        self.client = Client()

    def test_chat_api_requires_messages(self):
        response = self.client.post("/api/chat/", data={}, content_type="application/json")
        self.assertEqual(response.status_code, 400)

    def test_chat_api_returns_text(self):
        payload = {"messages": [{"role": "user", "content": "Привет"}]}
        response = self.client.post("/api/chat/", data=payload, content_type="application/json")
        self.assertEqual(response.status_code, 200)
        self.assertIn("text/plain", response.headers.get("Content-Type", ""))

    def test_chat_api_rejects_wrong_type(self):
        payload = {"messages": "not-a-list"}
        response = self.client.post("/api/chat/", data=payload, content_type="application/json")
        self.assertEqual(response.status_code, 400)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 82
PATH: core\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 83
PATH: core\admin.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 84
PATH: core\apps.py
LANG: python
===== CONTENT START =====
# core/apps.py

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"
    verbose_name = "Ядро ParkShare"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 85
PATH: core\context_processors.py
LANG: python
===== CONTENT START =====
# core/context_processors.py

from __future__ import annotations

from django.conf import settings


def global_settings(request):
    """
    Глобальные настройки, которые нужны во всех шаблонах:
    регион, карта, ключи и дефолтный центр.
    """
    return {
        "REGION_PROFILE": getattr(settings, "REGION_PROFILE", "RU"),
        "PLATFORM_MODE": getattr(settings, "PLATFORM_MODE", "RU"),
        "MAP_PROVIDER": getattr(settings, "MAP_PROVIDER", "yandex"),
        "MAP_PROVIDER_FALLBACK": getattr(settings, "MAP_PROVIDER_FALLBACK", "leaflet"),
        "YANDEX_MAP_API_KEY": getattr(settings, "YANDEX_MAP_API_KEY", ""),
        "MAPBOX_TOKEN": getattr(settings, "MAPBOX_TOKEN", ""),
        "MAP_DEFAULT_CENTER": getattr(
            settings,
            "MAP_DEFAULT_CENTER",
            [55.75, 37.61],
        ),
        "MAP_DEFAULT_ZOOM": getattr(settings, "MAP_DEFAULT_ZOOM", 11),
    }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 86
PATH: core\integrations.py
LANG: python
===== CONTENT START =====
"""core/integrations.py

Адаптеры для интеграций по регионам:
- карты (RU: Яндекс, GLOBAL: Mapbox/OSM);
- платежи (RU: YooKassa, GLOBAL: Stripe);
- аутентификация (RU: ЕСИА/VK/Яндекс, GLOBAL: generic OAuth2).

Цель — единая точка выбора провайдера через PLATFORM_MODE
(ENV: PLATFORM_MODE=RU|GLOBAL) без раздувания микросервисов.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

from django.conf import settings


@dataclass
class MapProviderAdapter:
    key: str
    api_key: str
    language: str
    default_center: list[float]
    default_zoom: int

    def as_frontend_payload(self) -> Dict[str, str | list[float] | int]:
        return {
            "provider": self.key,
            "language": self.language,
            "api_key": self.api_key,
            "center": self.default_center,
            "zoom": self.default_zoom,
        }


@dataclass
class PaymentGatewayAdapter:
    key: str
    webhook_url: str
    return_url: str

    def as_dict(self) -> Dict[str, str]:
        return {
            "provider": self.key,
            "webhook_url": self.webhook_url,
            "return_url": self.return_url,
        }


@dataclass
class AuthProviderAdapter:
    key: str
    client_id: str
    authorization_url: str
    scopes: list[str]

    def as_dict(self) -> Dict[str, str | list[str]]:
        return {
            "provider": self.key,
            "client_id": self.client_id,
            "authorization_url": self.authorization_url,
            "scopes": self.scopes,
        }


RU_INTEGRATIONS = {
    "maps": MapProviderAdapter(
        key=settings.MAP_PROVIDER,
        api_key=settings.YANDEX_MAP_API_KEY,
        language=settings.REGION.get("maps", {}).get("language", "ru_RU"),
        default_center=settings.MAP_DEFAULT_CENTER,
        default_zoom=settings.MAP_DEFAULT_ZOOM,
    ),
    "payments": PaymentGatewayAdapter(
        key=settings.DEFAULT_PAYMENT_PROVIDER,
        webhook_url="/payments/webhook/yookassa/",
        return_url=settings.YOOKASSA_RETURN_URL,
    ),
    "auth": [
        AuthProviderAdapter(
            key="gosuslugi",
            client_id="GOSUSLUGI_CLIENT_ID_PLACEHOLDER",
            authorization_url="https://esia.gosuslugi.ru/aas/oauth2/ac",
            scopes=["openid", "profile"],
        ),
        AuthProviderAdapter(
            key="vk_id",
            client_id="VK_CLIENT_ID_PLACEHOLDER",
            authorization_url="https://id.vk.com/authorize",
            scopes=["email"],
        ),
    ],
}

GLOBAL_INTEGRATIONS = {
    "maps": MapProviderAdapter(
        key=settings.MAP_PROVIDER if settings.PLATFORM_MODE == "GLOBAL" else "mapbox",
        api_key=settings.MAPBOX_TOKEN,
        language="en_US",
        default_center=settings.MAP_DEFAULT_CENTER,
        default_zoom=settings.MAP_DEFAULT_ZOOM,
    ),
    "payments": PaymentGatewayAdapter(
        key=settings.DEFAULT_PAYMENT_PROVIDER,
        webhook_url="/payments/webhook/stripe/",
        return_url="/payments/return/",
    ),
    "auth": [
        AuthProviderAdapter(
            key="google",
            client_id="GOOGLE_OAUTH_CLIENT_ID",
            authorization_url="https://accounts.google.com/o/oauth2/v2/auth",
            scopes=["openid", "email", "profile"],
        ),
        AuthProviderAdapter(
            key="apple",
            client_id="APPLE_CLIENT_ID",
            authorization_url="https://appleid.apple.com/auth/authorize",
            scopes=["name", "email"],
        ),
    ],
}


def get_integrations() -> dict:
    if settings.PLATFORM_MODE == "GLOBAL":
        return GLOBAL_INTEGRATIONS
    return RU_INTEGRATIONS

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 87
PATH: core\middleware.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import time
from typing import Callable

from django.conf import settings
from django.core.cache import caches
from django.http import HttpRequest, HttpResponse, JsonResponse


# core/middleware.py

from django.conf import settings


class SecurityHeadersMiddleware:
    """
    Добавляет базовые защитные заголовки.
    COOP/COEP/CORP берём из settings.* и в DEBUG по умолчанию отключаем,
    чтобы не ломать dev-фичи вроде Leaflet / внешних API.
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        # CSP
        csp = getattr(settings, "CONTENT_SECURITY_POLICY", None)
        if csp:
            response.setdefault("Content-Security-Policy", csp)

        # X-Frame-Options
        frame_option = getattr(settings, "X_FRAME_OPTIONS", "DENY")
        if frame_option:
            response.setdefault("X-Frame-Options", frame_option)

        # X-Content-Type-Options
        response.setdefault("X-Content-Type-Options", "nosniff")

        # Referrer-Policy
        referrer = getattr(settings, "REFERRER_POLICY", None)
        if referrer:
            response.setdefault("Referrer-Policy", referrer)

        # Permissions-Policy
        perm = getattr(settings, "PERMISSIONS_POLICY", None)
        if perm:
            response.setdefault("Permissions-Policy", perm)

        # --- COOP / COEP / CORP ---

        if settings.DEBUG:
            # В dev вообще не ставим их, и заодно сносим, если кто-то выше их повесил
            for header in (
                "Cross-Origin-Opener-Policy",
                "Cross-Origin-Embedder-Policy",
                "Cross-Origin-Resource-Policy",
            ):
                if header in response:
                    del response[header]
        else:
            coop = getattr(settings, "CROSS_ORIGIN_OPENER_POLICY", None)
            coep = getattr(settings, "CROSS_ORIGIN_EMBEDDER_POLICY", None)
            corp = getattr(settings, "CROSS_ORIGIN_RESOURCE_POLICY", None)

            if coop:
                response.setdefault("Cross-Origin-Opener-Policy", coop)
            if coep:
                response.setdefault("Cross-Origin-Embedder-Policy", coep)
            if corp:
                response.setdefault("Cross-Origin-Resource-Policy", corp)

        return response


class RateLimitMiddleware:
    """Простейший rate limiting на уровне приложения.

    Используем cache (Redis в продакшене) для подсчёта количества запросов
    в фиксированное окно. Если лимит превышен — отдаём 429 и заголовок
    ``Retry-After``.
    """

    def __init__(self, get_response: Callable):
        self.get_response = get_response
        self.cache = caches[getattr(settings, "RATE_LIMIT_CACHE", "default")]
        self.window = int(getattr(settings, "RATE_LIMIT_WINDOW", 60))
        self.limit = int(getattr(settings, "RATE_LIMIT_REQUESTS", 120))
        self.whitelist = set(getattr(settings, "RATE_LIMIT_WHITELIST", []))

    def __call__(self, request: HttpRequest) -> HttpResponse:
        if request.method.upper() == "OPTIONS":
            return self.get_response(request)

        client_ip = self._get_client_ip(request)
        if client_ip and client_ip not in self.whitelist:
            if self._is_rate_limited(client_ip):
                retry_after = self.window
                return JsonResponse(
                    {"detail": "Too many requests, please retry later."},
                    status=429,
                    headers={"Retry-After": str(retry_after)},
                )

        return self.get_response(request)

    def _get_client_ip(self, request: HttpRequest) -> str:
        forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        return request.META.get("REMOTE_ADDR", "")

    def _is_rate_limited(self, client_ip: str) -> bool:
        window_start = int(time.time() // self.window) * self.window
        cache_key = f"ratelimit:{client_ip}:{window_start}"

        added = self.cache.add(cache_key, 1, timeout=self.window)
        if added:
            return False

        try:
            current = self.cache.incr(cache_key)
        except Exception:
            # Fallback: если бекенд не поддерживает incr, пробуем читать/писать вручную.
            current = int(self.cache.get(cache_key) or 0) + 1
            self.cache.set(cache_key, current, timeout=self.window)

        return current > self.limit
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 88
PATH: core\models.py
LANG: python
===== CONTENT START =====
# backend/core/models.py
import uuid

from django.db import models
from django.utils.translation import gettext_lazy as _


class TimeStampedModel(models.Model):
    """
    Абстрактная модель с полями created_at/updated_at.

    Используется для единообразного аудита времени создания и обновления
    записей в базовых моделях (парковки, бронирования, платежи и т.п.).
    """

    created_at = models.DateTimeField(_("Дата создания"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Дата обновления"), auto_now=True)

    class Meta:
        abstract = True


class UUIDModel(models.Model):
    """Абстрактная модель с UUID в качестве первичного ключа."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    class Meta:
        abstract = True


class TimeStampedUUIDModel(TimeStampedModel, UUIDModel):
    """Комбо UUID + таймстемпы."""

    class Meta:
        abstract = True

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 89
PATH: core\pagination.py
LANG: python
===== CONTENT START =====
# core/pagination.py

from django.conf import settings
from rest_framework.pagination import PageNumberPagination


class DefaultPageNumberPagination(PageNumberPagination):
    """
    Базовый пагинатор для API.
    Размер страницы берётся из настроек DRF (PAGE_SIZE), с возможностью
    переопределения через query-параметр ?page_size=.
    """

    page_size = settings.REST_FRAMEWORK.get("PAGE_SIZE", 20)
    page_size_query_param = "page_size"
    max_page_size = 100

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 90
PATH: core\permissions.py
LANG: python
===== CONTENT START =====
# core/permissions.py

from typing import Any

from django.contrib.auth import get_user_model
from rest_framework.permissions import BasePermission, SAFE_METHODS

User = get_user_model()


def _is_admin(user: User) -> bool:
    """
    Утилита: определение админа по суперпользователю или роли.
    """
    if not user.is_authenticated:
        return False

    role_cls = getattr(User, "Role", None)
    admin_value = None
    if role_cls is not None:
        admin_value = getattr(role_cls, "ADMIN", None)

    if admin_value is not None:
        return bool(user.is_superuser or getattr(user, "role", "") == admin_value)

    return bool(user.is_superuser or getattr(user, "is_staff", False))


class IsAdminOrReadOnly(BasePermission):
    """
    Разрешает только администраторам изменять данные, остальным — только чтение.
    """

    def has_permission(self, request, view) -> bool:
        if request.method in SAFE_METHODS:
            return True
        user: User = request.user
        return _is_admin(user)


class IsSelfOrAdmin(BasePermission):
    """
    Доступ к объекту пользователя: либо сам пользователь, либо админ.
    """

    def has_object_permission(self, request, view, obj: Any) -> bool:
        user: User = request.user
        if not user.is_authenticated:
            return False
        if _is_admin(user):
            return True
        return getattr(obj, "pk", None) == getattr(user, "pk", None)


class IsOwnerObject(BasePermission):
    """
    Доступ к объектам, у которых есть атрибут owner: только владелец или админ.
    """

    def has_object_permission(self, request, view, obj: Any) -> bool:
        user: User = request.user
        if not user.is_authenticated:
            return False
        if _is_admin(user):
            return True
        owner = getattr(obj, "owner", None)
        return owner == user

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 91
PATH: core\utils.py
LANG: python
===== CONTENT START =====
# backend/core/utils.py

import hashlib
import math
from decimal import Decimal, ROUND_HALF_UP
from typing import Optional

from django.conf import settings


def hash_plate_digits(plate: str) -> str:
    """
    Хэширует только цифры госномера с солью (SHA‑256).
    Буквы и пробелы игнорируются.
    В БД мы сохраняем только этот хэш.
    """
    if not plate:
        return ""
    digits = "".join(ch for ch in plate if ch.isdigit())
    salted = f"{settings.VEHICLE_PLATE_SALT}:{digits}"
    return hashlib.sha256(salted.encode("utf-8")).hexdigest()


def mask_plate_for_display(plate: str) -> str:
    """
    Возвращает маску номера для отображения (если вдруг нужно выводить).
    Фактический номер мы нигде не храним, поэтому функция может применяться
    только к введённому пользователем значению до хэширования.
    """
    digits = "".join(ch for ch in plate if ch.isdigit())
    if not digits:
        return ""
    if len(digits) <= 2:
        return "*" * len(digits)
    return "*" * (len(digits) - 2) + digits[-2:]


def normalize_phone(phone: Optional[str]) -> str:
    """
    Нормализация телефона:

    - убираем все символы кроме цифр и '+';
    - для РФ приводим к формату +7XXXXXXXXXX, если возможно;
    - для остальных стран просто добавляем '+' перед цифрами.
    """
    if not phone:
        return ""
    raw = phone.strip()

    # Оставляем плюс только в начале
    plus = "+" if raw.startswith("+") else ""
    digits = "".join(ch for ch in raw if ch.isdigit())
    if not digits:
        return ""

    # РФ: 10 или 11 цифр, начинающихся с 8/7
    if len(digits) == 11 and digits.startswith("8"):
        digits = "7" + digits[1:]
    elif len(digits) == 10:
        digits = "7" + digits

    if plus or digits.startswith("7"):
        return "+" + digits
    return "+" + digits  # простой фолбэк


def haversine_distance_km(
    lat1: float, lon1: float, lat2: float, lon2: float
) -> float:
    """
    Расстояние между двумя точками на сфере Земли (км).

    Используем для поиска парковок «рядом» без обязательной привязки
    к PostGIS (работает и на SQLite).
    """
    try:
        lat1_f = float(lat1)
        lon1_f = float(lon1)
        lat2_f = float(lat2)
        lon2_f = float(lon2)
    except (TypeError, ValueError):
        return 0.0

    radius = 6371.0  # км

    d_lat = math.radians(lat2_f - lat1_f)
    d_lon = math.radians(lon2_f - lon1_f)
    r_lat1 = math.radians(lat1_f)
    r_lat2 = math.radians(lat2_f)

    a = (
        math.sin(d_lat / 2) ** 2
        + math.cos(r_lat1) * math.cos(r_lat2) * math.sin(d_lon / 2) ** 2
    )
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return radius * c


def parse_float(value: Optional[str]) -> Optional[float]:
    """
    Аккуратно парсит строку в float, возвращая None при ошибке.
    Удобно для работы с query‑параметрами API.
    """
    if value is None:
        return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def round_price(value: float | Decimal, step: float = 10.0) -> float:
    """
    Округляет цену к ближайшему шагу (step), по умолчанию — 10 ₽.

    Используется в AI-модуле ценообразования.
    """
    if step <= 0:
        return float(Decimal(str(value)).quantize(Decimal("0.01")))

    v = Decimal(str(value))
    step_dec = Decimal(str(step))
    scaled = (v / step_dec).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    result = scaled * step_dec
    return float(result)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 92
PATH: drf_spectacular\__init__.py
LANG: python
===== CONTENT START =====
"""Локальный заглушечный пакет drf_spectacular для офлайн-среды."""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 93
PATH: drf_spectacular\openapi.py
LANG: python
===== CONTENT START =====
from rest_framework.schemas.openapi import AutoSchema  # type: ignore

__all__ = ["AutoSchema"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 94
PATH: drf_spectacular\views.py
LANG: python
===== CONTENT START =====
from rest_framework.response import Response
from rest_framework.views import APIView


class SpectacularAPIView(APIView):
    def get(self, request, *args, **kwargs):
        return Response({"schema": "stub"})


class SpectacularSwaggerView(APIView):
    url_name = None

    def get(self, request, *args, **kwargs):
        return Response({"swagger": "stub"})


class SpectacularRedocView(APIView):
    url_name = None

    def get(self, request, *args, **kwargs):
        return Response({"redoc": "stub"})

__all__ = [
    "SpectacularAPIView",
    "SpectacularSwaggerView",
    "SpectacularRedocView",
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 95
PATH: frontend\next-app\.env.local
LANG: text
===== CONTENT START =====
# базовый адрес фронтенда в dev
NEXTAUTH_URL=http://localhost:3000

# любая длинная случайная строка (секрет для подписи JWT)
NEXTAUTH_SECRET=change_me_to_long_random_string

# сюда вставишь реальные значения из Google Cloud
GOOGLE_CLIENT_ID=82639895776-qrfcc2pggusro3pauh3b5q8n9j8m4vqf.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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

# ключ для OpenAI (или совместимого провайдера)
OPENAI_API_KEY=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
AI_MODEL=gpt-4o

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 96
PATH: frontend\next-app\.eslintrc.json
LANG: json
===== CONTENT START =====
{
  "extends": "next/core-web-vitals"
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 97
PATH: frontend\next-app\Dockerfile
LANG: text
===== CONTENT START =====
# Multi-stage build for the Next.js AI Concierge
FROM node:18-alpine AS deps
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm ci || npm install

FROM deps AS builder
WORKDIR /app
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
ENV NODE_ENV=production
ENV PORT=3000
WORKDIR /app
COPY --from=builder /app/package.json ./
COPY --from=builder /app/next.config.mjs ./next.config.mjs
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/tailwind.config.ts ./tailwind.config.ts
COPY --from=builder /app/postcss.config.js ./postcss.config.js
COPY --from=builder /app/tsconfig.json ./tsconfig.json

USER node
EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=5s --start-period=20s CMD wget --quiet --spider http://localhost:3000/ || exit 1
CMD ["npm", "start"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 98
PATH: frontend\next-app\jest.config.js
LANG: javascript
===== CONTENT START =====
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  dir: './'
});

const customJestConfig = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
    '^uuid$': require.resolve('uuid')
  },
  testPathIgnorePatterns: ['<rootDir>/.next/', '<rootDir>/node_modules/'],
  transformIgnorePatterns: ['node_modules/(?!(nanoid)/)']
};

module.exports = createJestConfig(customJestConfig);

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 99
PATH: frontend\next-app\jest.setup.ts
LANG: typescript
===== CONTENT START =====
import '@testing-library/jest-dom';

const { TextEncoder, TextDecoder } = require('util');
if (!global.TextEncoder) {
  global.TextEncoder = TextEncoder;
}
if (!global.TextDecoder) {
  global.TextDecoder = TextDecoder;
}

if (!global.crypto) {
  const { webcrypto } = require('crypto');
  global.crypto = webcrypto as Crypto;
}

if (!global.ReadableStream) {
  const { ReadableStream } = require('stream/web');
  global.ReadableStream = ReadableStream as typeof global.ReadableStream;
}

if (!global.fetch || !global.Response) {
  const { fetch, Headers, Request, Response } = require('undici');
  if (!global.fetch) {
    global.fetch = fetch;
  }
  if (!global.Headers) {
    global.Headers = Headers;
  }
  if (!global.Request) {
    global.Request = Request;
  }
  if (!global.Response) {
    global.Response = Response;
  }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 100
PATH: frontend\next-app\next-env.d.ts
LANG: typescript
===== CONTENT START =====
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 101
PATH: frontend\next-app\next.config.mjs
LANG: text
===== CONTENT START =====
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    serverActions: {
      bodySizeLimit: '2mb'
    }
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**'
      }
    ]
  },
  async headers() {
    const isDev = process.env.NODE_ENV !== 'production';
    const connectSrc = [
      "'self'",
      'https://www.googleapis.com',
      'https://accounts.google.com',
      'https://api.openai.com'
    ];

    const extraOrigins = [process.env.LLM_API_URL, process.env.NEXT_PUBLIC_AUTH_API_URL, process.env.NEXT_PUBLIC_AUTH_API_BASE]
      .filter(Boolean)
      .map((value) => {
        try {
          return new URL(value).origin;
        } catch (error) {
          return null;
        }
      })
      .filter(Boolean);

    connectSrc.push(...extraOrigins);

    const csp = [
      "default-src 'self'",
      // Next.js injects small inline hydration/runtime scripts; keep inline until moved to a nonce-based policy.
      "script-src 'self' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' data:",
      `connect-src ${connectSrc.join(' ')}`,
      "frame-src 'self' https://accounts.google.com",
      "worker-src 'self'",
      "manifest-src 'self'",
      "object-src 'none'",
      "base-uri 'self'",
      "frame-ancestors 'self' http://localhost:8000 http://127.0.0.1:8000",
      "form-action 'self'"
    ].join('; ');

    const securityHeaders = [
      {
        key: 'Content-Security-Policy',
        value: csp
      },
      ...(!isDev
        ? [
            {
              key: 'X-Frame-Options',
              value: 'DENY'
            }
          ]
        : []),
      {
        key: 'X-Content-Type-Options',
        value: 'nosniff'
      },
      {
        key: 'Referrer-Policy',
        value: 'strict-origin-when-cross-origin'
      },
      {
        key: 'Permissions-Policy',
        value: 'geolocation=(), microphone=(), camera=()'
      },
      {
        key: 'Strict-Transport-Security',
        value: 'max-age=63072000; includeSubDomains; preload'
      }
    ];

    return [
      {
        source: '/(.*)',
        headers: securityHeaders
      }
    ];
  }
};

export default nextConfig;

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 102
PATH: frontend\next-app\package.json
LANG: json
===== CONTENT START =====
{
  "name": "parkshare-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.19",
    "@heroicons/react": "^2.1.5",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-config-next": "^14.2.5",
    "highlight.js": "^11.9.0",
    "next": "^14.2.5",
    "postcss": "^8.4.39",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.2.1",
    "react-markdown": "^9.0.3",
    "rehype-highlight": "^5.0.2",
    "rehype-sanitize": "^6.0.0",
    "remark-gfm": "^4.0.0",
    "tailwind-merge": "^2.2.0",
    "tailwindcss": "^3.4.4",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.8",
    "@testing-library/react": "^14.2.2",
    "@testing-library/user-event": "^14.5.2",
    "@types/jest": "^29.5.12",
    "@types/node": "^20.14.10",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.5.4",
    "undici": "^6.19.8"
  }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 103
PATH: frontend\next-app\postcss.config.js
LANG: javascript
===== CONTENT START =====
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
};

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 104
PATH: frontend\next-app\tailwind.config.ts
LANG: typescript
===== CONTENT START =====
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: 'class',
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
    './lib/**/*.{js,ts,jsx,tsx}'
  ],
  theme: {
    extend: {
      colors: {
        surface: '#f5f5f5',
        'surface-dark': '#0f172a'
      }
    }
  },
  plugins: []
};

export default config;

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 105
PATH: frontend\next-app\tsconfig.json
LANG: json
===== CONTENT START =====
{
  "compilerOptions": {
    "target": "ES5",
    "lib": [
      "DOM",
      "DOM.Iterable",
      "ESNext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "types": ["jest", "node"],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.mjs",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 106
PATH: frontend\next-app\app\globals.css
LANG: css
===== CONTENT START =====
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    color-scheme: light;
    --font-sans: 'SF Pro Display', 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    --font-mono: 'SFMono-Regular', 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    --bg-surface: #f4f7fb;
    --bg-elevated: #ffffff;
    --bg-soft: #eef2f8;
    --text-primary: #0f172a;
    --text-muted: #5f6a7a;
    --accent: #3f7df4;
    --accent-strong: #335edc;
    --border-subtle: #e5e7eb;
    --radius-lg: 20px;
    --shadow-soft: 0 18px 38px rgba(15, 23, 42, 0.08);
  }

  :root.dark {
    color-scheme: dark;
    --bg-surface: #0b1220;
    --bg-elevated: #0f172a;
    --bg-soft: #0c1424;
    --text-primary: #e5e7eb;
    --text-muted: #94a3b8;
    --accent: #6ca8ff;
    --accent-strong: #8b9eff;
    --border-subtle: #1f2937;
    --radius-lg: 20px;
    --shadow-soft: 0 18px 38px rgba(0, 0, 0, 0.45);
  }

  * {
    @apply antialiased;
  }

  body {
    @apply min-h-screen text-[var(--text-primary)];
    font-family: var(--font-sans);
    background: radial-gradient(circle at 20% 20%, rgba(51, 94, 220, 0.05), transparent 28%),
      radial-gradient(circle at 80% 0%, rgba(63, 125, 244, 0.06), transparent 25%),
      linear-gradient(180deg, #f7f9fc 0%, #f1f5f9 60%, #eef2f8 100%);
    color: var(--text-primary);
  }

  .dark body {
    background: radial-gradient(circle at 20% 20%, rgba(140, 158, 255, 0.07), transparent 25%),
      radial-gradient(circle at 80% 10%, rgba(108, 168, 255, 0.08), transparent 24%),
      linear-gradient(180deg, #0c1222 0%, #0b1020 50%, #0b1324 100%);
  }

  a {
    @apply underline decoration-2 underline-offset-4 transition-colors;
    color: var(--accent-strong);
  }

  input,
  textarea {
    @apply w-full rounded-2xl border border-[var(--border-subtle)] bg-[var(--bg-elevated)] px-4 py-3 text-sm text-[var(--text-primary)] shadow-sm outline-none transition focus:-translate-y-[1px] focus:border-[var(--accent)] focus:shadow-[0_10px_30px_rgba(79,70,229,0.06)];
    font-family: var(--font-sans);
  }

  button {
    @apply rounded-2xl px-4 py-2 text-sm font-medium transition duration-200 ease-out;
  }

  h1, h2, h3, h4, h5 {
    font-family: var(--font-sans);
    @apply tracking-tight text-[var(--text-primary)];
  }

  code, pre {
    font-family: var(--font-mono);
  }

  ::selection {
    background: rgba(63, 125, 244, 0.15);
  }
  }


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 107
PATH: frontend\next-app\app\layout.tsx
LANG: tsx
===== CONTENT START =====
import './globals.css';
import type { ReactNode } from 'react';

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="ru" suppressHydrationWarning>
      <head>
        <meta name="theme-color" content="#0f172a" />
      </head>
      <body className="bg-[var(--bg-surface)] text-[var(--text-primary)]">{children}</body>
    </html>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 108
PATH: frontend\next-app\app\(site)\layout.tsx
LANG: tsx
===== CONTENT START =====
import { Providers } from '@/components/providers';
import { Header } from '@/components/header';
import { ServiceWorkerRegistrar } from '@/components/pwa/register-service-worker';
import { ChatWidget } from '@/components/widget/chat-widget';

export default function SiteLayout({ children }: { children: React.ReactNode }) {
  return (
    <Providers>
      <div className="flex min-h-screen flex-col bg-surface dark:bg-surface-dark">
        <Header />
        <main className="mx-auto flex w-full max-w-6xl flex-1 flex-col gap-4 p-4">{children}</main>
        <ServiceWorkerRegistrar />
        <ChatWidget />
      </div>
    </Providers>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 109
PATH: frontend\next-app\app\(site)\page.tsx
LANG: tsx
===== CONTENT START =====
import { ChatPanel } from '@/components/chat/chat-panel';

export default function HomePage() {
  return (
    <section className="flex flex-1 flex-col gap-6">
      <div className="overflow-hidden rounded-[28px] border border-[var(--border-subtle)]/80 bg-gradient-to-r from-white/85 via-[var(--bg-surface)] to-white/90 p-6 shadow-[0_25px_60px_rgba(15,23,42,0.08)] backdrop-blur dark:border-slate-800 dark:from-slate-950 dark:via-slate-900 dark:to-indigo-950/40">
        <div className="flex flex-col gap-3">
          <p className="text-[11px] font-semibold uppercase tracking-[0.3em] text-[var(--accent-strong)]">AI Concierge</p>
          <h1 className="text-3xl font-semibold leading-tight text-[var(--text-primary)] sm:text-4xl">Премиальный чат для парковок и гостей ParkShare</h1>
          <p className="max-w-3xl text-sm text-[var(--text-muted)] sm:text-base">
            Сфокусирован на мобильном опыте: липкое поле ввода, аккуратные карточки, мгновенные подсказки и готовность к офлайн.
            Начните новый диалог или возобновите прежний в один тап.
          </p>
          <div className="flex flex-wrap gap-2 text-[11px] font-semibold uppercase tracking-[0.15em] text-[var(--text-muted)]">
            <span className="rounded-full border border-[var(--border-subtle)]/60 bg-white px-3 py-1 shadow-sm">Локальная история</span>
            <span className="rounded-full border border-[var(--border-subtle)]/60 bg-white px-3 py-1 shadow-sm">Поддержка тем</span>
            <span className="rounded-full border border-[var(--border-subtle)]/60 bg-white px-3 py-1 shadow-sm">AI потоковые ответы</span>
          </div>
        </div>
      </div>
      <ChatPanel />
      <div id="features" className="grid grid-cols-1 gap-4 md:grid-cols-3">
        {[
          { title: 'Мульти-провайдерный AI', desc: 'LLM через OpenAI/прокси. Потоковые ответы, обработка ошибок и перегенерация.' },
          { title: 'Безопасный вход', desc: 'Телефон + OTP, почта + пароль, VK/Яндекс OAuth. История привязывается к профилю.' },
          { title: 'PWA и офлайн', desc: 'Сервис-воркер, манифест, кеш оболочки и мягкие лоадеры для мобильного опыта.' }
        ].map((feature) => (
          <div
            key={feature.title}
            className="rounded-[22px] border border-[var(--border-subtle)]/70 bg-[var(--bg-elevated)] p-4 shadow-[0_14px_40px_rgba(15,23,42,0.06)]"
          >
            <p className="text-sm font-semibold text-[var(--text-primary)]">{feature.title}</p>
            <p className="mt-1 text-sm text-[var(--text-muted)]">{feature.desc}</p>
          </div>
        ))}
      </div>
    </section>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 110
PATH: frontend\next-app\app\(site)\auth\page.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { useMemo, useState } from 'react';
import {
  ArrowRightIcon,
  EnvelopeIcon,
  LockClosedIcon,
  PhoneIcon,
  SparklesIcon,
  ShieldCheckIcon
} from '@heroicons/react/24/outline';
import { useAuth } from '@/hooks/useAuth';

export default function AuthPage() {
  const {
    user,
    isAuthenticated,
    loading: authLoading,
    loginWithEmail,
    registerWithEmail,
    requestPhoneOtp,
    verifyPhoneOtp,
    loginWithVK,
    loginWithYandex,
    logout
  } = useAuth();

  const [phone, setPhone] = useState('');
  const [otp, setOtp] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [mode, setMode] = useState<'login' | 'register'>('login');
  const [status, setStatus] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [otpRequested, setOtpRequested] = useState(false);

  const isPhoneValid = useMemo(() => phone.replace(/[^\d]/g, '').length >= 10, [phone]);

  const handleSendOtp = async () => {
    setIsSubmitting(true);
    setError(null);
    setStatus(null);
    try {
      await requestPhoneOtp(phone);
      setOtpRequested(true);
      setStatus('Код отправлен. Введите его, чтобы подтвердить вход.');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Не удалось отправить код.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleVerifyOtp = async () => {
    setIsSubmitting(true);
    setError(null);
    setStatus(null);
    try {
      await verifyPhoneOtp(phone, otp);
      setStatus('Успешно! Сессия активна и готова к работе.');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Не удалось подтвердить код.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleEmailAuth = async () => {
    setIsSubmitting(true);
    setError(null);
    setStatus(null);
    try {
      if (mode === 'login') {
        await loginWithEmail(email, password);
        setStatus('Вход выполнен. Продолжайте в чате.');
      } else {
        await registerWithEmail(email, password);
        setStatus('Аккаунт создан, вы уже вошли.');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Не удалось выполнить действие.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="mx-auto flex w-full max-w-4xl flex-col gap-6 py-6">
      <div className="flex flex-col gap-3 rounded-[28px] border border-[var(--border-subtle)]/80 bg-[var(--bg-elevated)] p-6 shadow-[0_25px_60px_rgba(15,23,42,0.08)]">
        <div className="flex items-start gap-3">
          <div className="flex h-12 w-12 items-center justify-center rounded-2xl bg-gradient-to-br from-[var(--accent)] to-[var(--accent-strong)] text-white shadow-[0_14px_38px_rgba(59,130,246,0.35)]">
            <SparklesIcon className="h-6 w-6" />
          </div>
          <div className="flex-1">
            <p className="text-[11px] font-semibold uppercase tracking-[0.3em] text-[var(--accent-strong)]">Единый вход</p>
            <h1 className="text-3xl font-semibold leading-tight text-[var(--text-primary)]">Вход в ParkShare</h1>
            <p className="mt-2 text-sm text-[var(--text-muted)]">
              Выберите способ: телефон с OTP, почта с паролем или VK/Яндекс. Одна учётка для всех сервисов ParkShare.
            </p>
            {isAuthenticated && (
              <div className="mt-3 flex items-center gap-3 rounded-2xl border border-emerald-200 bg-emerald-50 px-4 py-3 text-sm text-emerald-800 shadow-sm dark:border-emerald-800/60 dark:bg-emerald-950/40 dark:text-emerald-100">
                <ShieldCheckIcon className="h-5 w-5" />
                <div>
                  <p className="font-semibold">Вы вошли как {user?.name || user?.email || user?.phone || 'пользователь'}</p>
                  <p className="text-xs text-emerald-700/80 dark:text-emerald-100/80">Продолжайте в чате или выйдите, чтобы сменить профиль.</p>
                </div>
                <button
                  onClick={() => void logout()}
                  className="rounded-full bg-white/80 px-3 py-1 text-xs font-semibold text-emerald-700 transition hover:-translate-y-[1px] hover:shadow-sm"
                >
                  Выйти
                </button>
              </div>
            )}
          </div>
        </div>
        {status && (
          <p className="rounded-2xl border border-emerald-200 bg-emerald-50 px-4 py-3 text-sm text-emerald-700 shadow-sm dark:border-emerald-900/60 dark:bg-emerald-950/40 dark:text-emerald-100">
            {status}
          </p>
        )}
        {error && (
          <p className="rounded-2xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-700 shadow-sm dark:border-red-900/60 dark:bg-red-950/40 dark:text-red-100">
            {error}
          </p>
        )}
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="rounded-[20px] border border-[var(--border-subtle)]/70 bg-white/70 p-4 shadow-sm backdrop-blur dark:border-slate-800 dark:bg-slate-900/70">
            <div className="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)]">
              <PhoneIcon className="h-5 w-5" />
              <span>Телефон + SMS</span>
            </div>
            <p className="mt-1 text-xs text-[var(--text-muted)]">Отправим код на ваш номер. Без пароля.</p>
            <div className="mt-3 space-y-2">
              <input
                type="tel"
                inputMode="tel"
                placeholder="+7 (___) ___-__-__"
                value={phone}
                onChange={(e) => setPhone(e.target.value)}
              />
              <div className="flex gap-2">
                <button
                  className="w-full rounded-2xl bg-gradient-to-r from-[var(--accent)] to-[var(--accent-strong)] px-4 py-2 text-sm font-semibold text-white shadow-[0_14px_38px_rgba(59,130,246,0.35)] disabled:cursor-not-allowed disabled:opacity-60"
                  onClick={handleSendOtp}
                  disabled={!isPhoneValid || isSubmitting || authLoading}
                >
                  {otpRequested ? 'Отправить снова' : 'Отправить код'}
                </button>
                <button
                  className="min-w-[110px] rounded-2xl border border-[var(--border-subtle)]/70 bg-[var(--bg-elevated)] px-3 py-2 text-xs font-semibold text-[var(--text-primary)] shadow-sm disabled:opacity-50"
                  onClick={handleVerifyOtp}
                  disabled={!otp || isSubmitting || authLoading}
                >
                  Подтвердить
                </button>
              </div>
              <input
                type="text"
                inputMode="numeric"
                placeholder="Код из SMS"
                value={otp}
                onChange={(e) => setOtp(e.target.value)}
              />
            </div>
          </div>
          <div className="flex flex-col gap-3 rounded-[20px] border border-[var(--border-subtle)]/70 bg-white/70 p-4 shadow-sm backdrop-blur dark:border-slate-800 dark:bg-slate-900/70">
            <div className="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)]">
              <EnvelopeIcon className="h-5 w-5" />
              <span>Почта + пароль</span>
            </div>
            <div className="flex items-center gap-2 text-xs text-[var(--text-muted)]">
              <button
                onClick={() => setMode('login')}
                className={`rounded-full px-2 py-1 font-semibold transition ${mode === 'login' ? 'bg-[var(--bg-surface)] text-[var(--text-primary)] shadow-sm' : 'text-[var(--text-muted)]'}`}
              >
                Вход
              </button>
              <button
                onClick={() => setMode('register')}
                className={`rounded-full px-2 py-1 font-semibold transition ${mode === 'register' ? 'bg-[var(--bg-surface)] text-[var(--text-primary)] shadow-sm' : 'text-[var(--text-muted)]'}`}
              >
                Регистрация
              </button>
            </div>
            <input type="email" placeholder="you@example.com" value={email} onChange={(e) => setEmail(e.target.value)} />
            <input
              type="password"
              placeholder="••••••••"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
            <button
              className="flex items-center justify-center gap-2 rounded-2xl bg-[var(--text-primary)] px-4 py-3 text-sm font-semibold text-white shadow-[0_14px_38px_rgba(15,23,42,0.15)] transition hover:-translate-y-[1px] hover:shadow-lg disabled:opacity-50"
              onClick={handleEmailAuth}
              disabled={!email || !password || isSubmitting || authLoading}
            >
              <LockClosedIcon className="h-4 w-4" />
              {mode === 'login' ? 'Войти' : 'Создать аккаунт'}
              <ArrowRightIcon className="h-4 w-4" />
            </button>
            <p className="text-[11px] text-[var(--text-muted)]">Пароли передаются только по HTTPS. После входа используйте чат или бронирования без повторного подтверждения.</p>
          </div>
        </div>
        <div className="rounded-[20px] border border-[var(--border-subtle)]/70 bg-white/70 p-4 shadow-sm backdrop-blur dark:border-slate-800 dark:bg-slate-900/70">
          <p className="text-sm font-semibold text-[var(--text-primary)]">Соцсети</p>
          <p className="text-xs text-[var(--text-muted)]">VK и Яндекс через OAuth с редиректом назад в ParkShare.</p>
          <div className="mt-3 grid grid-cols-1 gap-2 sm:grid-cols-3">
            <button
              onClick={loginWithVK}
              className="flex items-center justify-center gap-2 rounded-2xl border border-[var(--border-subtle)]/70 bg-[var(--bg-elevated)] px-4 py-3 text-sm font-semibold text-[var(--text-primary)] shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg"
            >
              VK ID
            </button>
            <button
              onClick={loginWithYandex}
              className="flex items-center justify-center gap-2 rounded-2xl border border-[var(--border-subtle)]/70 bg-[var(--bg-elevated)] px-4 py-3 text-sm font-semibold text-[var(--text-primary)] shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg"
            >
              Яндекс ID
            </button>
            <a
              href="/api/auth/signin"
              className="flex items-center justify-center gap-2 rounded-2xl border border-[var(--border-subtle)]/70 bg-[var(--bg-elevated)] px-4 py-3 text-sm font-semibold text-[var(--text-primary)] shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg"
            >
              Google (NextAuth)
            </a>
          </div>
          <p className="mt-2 text-[11px] text-[var(--text-muted)]">
            OAuth перенаправит вас на страницу провайдера, а затем вернёт на этот домен с токеном. Настройте переменные VK_CLIENT_ID/VK_REDIRECT_URI и YANDEX_CLIENT_ID/YANDEX_REDIRECT_URI.
          </p>
        </div>
      </div>
    </div>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 111
PATH: frontend\next-app\app\api\chat\route.ts
LANG: typescript
===== CONTENT START =====
import type { NextRequest } from 'next/server';
import { streamChat, type LLMMessage } from '@/lib/llmClient';

export const runtime = 'nodejs';

export async function POST(req: NextRequest) {
  let payload: { messages?: LLMMessage[]; stream?: boolean };

  try {
    payload = await req.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON body' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const messages = payload.messages;

  if (!messages || !Array.isArray(messages) || messages.length === 0) {
    return new Response(JSON.stringify({ error: 'No messages provided' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const stream = await streamChat(messages, { stream: payload.stream !== false });

  return new Response(stream, {
    headers: { 'Content-Type': 'text/plain; charset=utf-8', 'Cache-Control': 'no-store' }
  });
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 112
PATH: frontend\next-app\app\embed\page.tsx
LANG: tsx
===== CONTENT START =====
import { CompactChatPanel } from '@/components/chat/compact-chat-panel';

export const metadata = {
  title: 'AI Concierge – Embed'
};

export default function EmbedPage() {
  return (
    <main className="min-h-screen bg-slate-950 flex items-center justify-center p-2">
      <div className="w-full max-w-md h-[80vh] rounded-3xl bg-slate-900/90 shadow-2xl border border-slate-700/80 overflow-hidden">
        <CompactChatPanel />
      </div>
    </main>
  );
}
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 113
PATH: frontend\next-app\components\header.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { ThemeToggle } from './theme-toggle';
import { Bars3Icon } from '@heroicons/react/24/outline';
import { useAuth } from '@/hooks/useAuth';

export function Header() {
  const { user, isAuthenticated, logout, loading } = useAuth();
  const userLabel = user?.name || user?.email || user?.phone || 'Гость';

  return (
    <header className="sticky top-0 z-20 border-b border-[var(--border-subtle)]/60 bg-[var(--bg-elevated)]/90 backdrop-blur-lg">
      <div className="mx-auto flex max-w-6xl items-center justify-between px-4 py-3">
        <div className="flex items-center gap-3">
          <div className="flex h-11 w-11 items-center justify-center rounded-2xl bg-gradient-to-br from-[var(--accent)] to-[var(--accent-strong)] text-white shadow-[0_10px_30px_rgba(59,130,246,0.25)]">
            <Bars3Icon className="h-6 w-6" />
          </div>
          <div className="leading-tight">
            <p className="text-lg font-semibold tracking-tight">ParkShare Concierge</p>
            <p className="text-xs text-[var(--text-muted)]">Премиальный ассистент для партнёров</p>
          </div>
        </div>
        <nav className="hidden items-center gap-4 text-sm font-medium text-[var(--text-muted)] sm:flex">
          <a className="rounded-full px-3 py-1 transition hover:text-[var(--text-primary)] hover:shadow-sm" href="/">Чат</a>
          <a className="rounded-full px-3 py-1 transition hover:text-[var(--text-primary)] hover:shadow-sm" href="/auth">Вход</a>
          <a className="rounded-full px-3 py-1 transition hover:text-[var(--text-primary)] hover:shadow-sm" href="#features">Особенности</a>
        </nav>
        <div className="flex items-center gap-3">
          <ThemeToggle />
          <div className="hidden sm:flex items-center gap-2 rounded-full border border-[var(--border-subtle)]/70 bg-[var(--bg-surface)] px-3 py-1.5 text-xs font-semibold text-[var(--text-muted)] shadow-sm">
            <span
              className={`h-2 w-2 rounded-full ${isAuthenticated ? 'bg-emerald-400' : 'bg-amber-400'}`}
              aria-hidden
            />
            <span className="text-[var(--text-primary)]">{loading ? 'Загрузка…' : userLabel}</span>
            {isAuthenticated ? (
              <button
                onClick={() => void logout()}
                className="rounded-full bg-white/70 px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] transition hover:-translate-y-[1px] hover:text-[var(--text-primary)]"
              >
                Выйти
              </button>
            ) : (
              <a
                href="/auth"
                className="rounded-full bg-white/80 px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] transition hover:-translate-y-[1px] hover:text-[var(--text-primary)]"
              >
                Войти
              </a>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 114
PATH: frontend\next-app\components\providers.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { ThemeProvider } from './theme-provider';
import { AuthProvider } from '@/context/AuthContext';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <AuthProvider>{children}</AuthProvider>
    </ThemeProvider>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 115
PATH: frontend\next-app\components\theme-provider.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { createContext, useContext, useEffect, useMemo, useState } from 'react';

type Theme = 'light' | 'dark';

interface ThemeContextValue {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light');

  useEffect(() => {
    const savedTheme = (typeof window !== 'undefined' && localStorage.getItem('theme')) as Theme | null;
    if (savedTheme === 'dark' || savedTheme === 'light') {
      setTheme(savedTheme);
      return;
    }
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    setTheme(prefersDark ? 'dark' : 'light');
  }, []);

  useEffect(() => {
    const root = document.documentElement;
    root.classList.remove(theme === 'dark' ? 'light' : 'dark');
    root.classList.add(theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  const value = useMemo(
    () => ({
      theme,
      toggleTheme: () => setTheme((prev) => (prev === 'dark' ? 'light' : 'dark'))
    }),
    [theme]
  );

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 116
PATH: frontend\next-app\components\theme-toggle.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { MoonIcon, SunIcon } from '@heroicons/react/24/solid';
import { useTheme } from './theme-provider';

export function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();

  return (
    <button
      onClick={toggleTheme}
      className="flex items-center gap-2 border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-slate-800 dark:text-slate-100 hover:bg-slate-50 dark:hover:bg-slate-700 px-3 py-2 rounded-lg"
      aria-label="Toggle theme"
      type="button"
    >
      {theme === 'dark' ? <SunIcon className="h-5 w-5" /> : <MoonIcon className="h-5 w-5" />}
      <span className="hidden sm:inline">{theme === 'dark' ? 'Light' : 'Dark'} mode</span>
    </button>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 117
PATH: frontend\next-app\components\chat\chat-panel.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import dynamic from 'next/dynamic';
import {
  PaperAirplaneIcon,
  SparklesIcon,
  ClockIcon,
  ArrowPathIcon,
  Bars3Icon,
  ClipboardIcon,
  StopCircleIcon,
  ExclamationTriangleIcon
} from '@heroicons/react/24/outline';
import { ChatMessage } from '@/lib/aiProvider';
import { Conversation, MessageWithId } from './types';
import { ConversationList } from './conversation-list';
import { SuggestedPrompts } from './suggested-prompts';
import { streamChatFromApi } from '@/lib/chatClient';
import { useAuth } from '@/hooks/useAuth';

const MarkdownMessage = dynamic(() => import('./markdown-message'), {
  ssr: false,
  loading: () => <div className="h-4 w-24 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />
});

const STORAGE_KEY_BASE = 'parkshare_conversations_v2';
const ONBOARDING_KEY = 'parkshare_onboarding_seen';
const MAX_HISTORY = 14;
const FAVORITE_PROMPTS = [
  'Сформируй чат-скрипт для диспетчера парковки с VIP-клиентами.',
  'Собери сводку по пиковым часам и дай рекомендации по динамическим тарифам.',
  'Сценарий поддержки: клиент не может найти въезд. Какие шаги предложить?',
  'Что добавить в онбординг партнёра, чтобы повысить NPS?',
  'Сделай контрольный чек-лист для запуска новой парковки на выходные.'
];

const createWelcomeMessage = (): MessageWithId => ({
  id: crypto.randomUUID(),
  role: 'assistant',
  content: 'Привет! Я ParkShare AI Concierge. Спроси про загрузку, цены, сценарии для гостей или подготовку персонала.',
  createdAt: Date.now()
});

const createConversation = (title = 'New conversation'): Conversation => ({
  id: crypto.randomUUID(),
  title,
  messages: [createWelcomeMessage()],
  updatedAt: Date.now()
});

const storageKeyForUser = (userId?: string | null) => `${STORAGE_KEY_BASE}:${userId ?? 'guest'}`;

export function ChatPanel() {
  const { user, isAuthenticated } = useAuth();
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isStreaming, setIsStreaming] = useState(false);
  const [showSidebar, setShowSidebar] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [showOnboarding, setShowOnboarding] = useState(false);
  const chatEndRef = useRef<HTMLDivElement | null>(null);
  const lastStorageKey = useRef<string | null>(null);
  const abortRef = useRef<AbortController | null>(null);

  const storageKey = useMemo(() => storageKeyForUser(user?.id), [user?.id]);

  useEffect(() => {
    if (typeof window === 'undefined' || lastStorageKey.current === storageKey) return;
    lastStorageKey.current = storageKey;
    try {
      const stored = localStorage.getItem(storageKey);
      if (stored) {
        const parsed: Conversation[] = JSON.parse(stored);
        setConversations(parsed);
        setActiveConversationId(parsed[0]?.id ?? null);
        return;
      }
    } catch (error) {
      console.warn('Failed to parse saved conversations', error);
    }
    // TODO: Mirror conversation history to a backend store for multi-device sync and tenant scoping.
    const starter = createConversation('Welcome thread');
    setConversations([starter]);
    setActiveConversationId(starter.id);
  }, [storageKey]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    localStorage.setItem(storageKey, JSON.stringify(conversations));
  }, [conversations, storageKey]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    const seen = localStorage.getItem(ONBOARDING_KEY);
    if (!seen) {
      setShowOnboarding(true);
      localStorage.setItem(ONBOARDING_KEY, 'true');
    }
  }, []);

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' });
  }, [conversations, activeConversationId]);

  const currentConversation = useMemo(
    () => conversations.find((conv) => conv.id === activeConversationId) ?? null,
    [conversations, activeConversationId]
  );

  const updateConversation = useCallback(
    (id: string, updater: (conversation: Conversation) => Conversation) => {
      setConversations((prev) => prev.map((conv) => (conv.id === id ? updater(conv) : conv)));
    },
    []
  );

  const handleCreate = useCallback(() => {
    const conversation = createConversation('New idea');
    setConversations((prev) => [conversation, ...prev]);
    setActiveConversationId(conversation.id);
  }, []);

  const handleRename = useCallback((id: string, name: string) => {
    updateConversation(id, (conv) => ({ ...conv, title: name, updatedAt: Date.now() }));
  }, [updateConversation]);

  const handleDelete = useCallback(
    (id: string) => {
      setConversations((prev) => {
        const remaining = prev.filter((conv) => conv.id !== id);
        if (id === activeConversationId) {
          setActiveConversationId(remaining[0]?.id ?? null);
        }
        return remaining;
      });
    },
    [activeConversationId]
  );

  const handleSelectConversation = useCallback((id: string) => {
    setActiveConversationId(id);
    setShowSidebar(false);
  }, []);

  const handleSend = useCallback(async () => {
    if (!currentConversation || !input.trim() || isLoading) return;

    abortRef.current?.abort();
    const controller = new AbortController();
    abortRef.current = controller;
    const userMessage: MessageWithId = {
      id: crypto.randomUUID(),
      role: 'user',
      content: input.trim(),
      createdAt: Date.now()
    };

    setInput('');
    setIsLoading(true);
    setIsStreaming(true);
    setErrorMessage(null);

    const payloadMessages: ChatMessage[] = currentConversation.messages
      .concat(userMessage)
      .slice(-MAX_HISTORY)
      .map(({ id, createdAt, ...rest }) => rest as ChatMessage);

    updateConversation(currentConversation.id, (conv) => {
      const trimmedHistory = [...conv.messages, userMessage].slice(-MAX_HISTORY);
      return { ...conv, messages: trimmedHistory, updatedAt: Date.now() };
    });

    const assistantMessage: MessageWithId = { id: crypto.randomUUID(), role: 'assistant', content: '', createdAt: Date.now() };
    updateConversation(currentConversation.id, (conv) => ({
      ...conv,
      messages: [...conv.messages, assistantMessage].slice(-MAX_HISTORY),
      updatedAt: Date.now()
    }));

    try {
      await streamChatFromApi(payloadMessages, {
        signal: controller.signal,
        onChunk: (textChunk: string) =>
          updateConversation(currentConversation.id, (conv) => ({
            ...conv,
            messages: conv.messages.map((msg) =>
              msg.id === assistantMessage.id ? { ...msg, content: msg.content + textChunk } : msg
            ),
            updatedAt: Date.now()
          }))
      });
    } catch (error) {
      console.error(error);
      setErrorMessage('We could not reach the concierge right now. Please retry or check your connection.');
      updateConversation(currentConversation.id, (conv) => ({
        ...conv,
        messages: conv.messages.map((msg) =>
          msg.id === assistantMessage.id
            ? {
                ...msg,
                content: 'Something went wrong reaching the AI. Please confirm your API key and try again.'
              }
            : msg
        ),
        updatedAt: Date.now()
      }));
    } finally {
      setIsLoading(false);
      setIsStreaming(false);
      abortRef.current = null;
    }
  }, [currentConversation, input, isLoading, updateConversation]);

  const handleKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      void handleSend();
    }
  };

  const handleAbort = useCallback(() => {
    abortRef.current?.abort();
    setIsLoading(false);
    setIsStreaming(false);
  }, []);

  const handleClear = useCallback(() => {
    if (!currentConversation) return;
    updateConversation(currentConversation.id, (conv) => ({
      ...conv,
      messages: [createWelcomeMessage()],
      updatedAt: Date.now()
    }));
    setInput('');
    setErrorMessage(null);
  }, [currentConversation, updateConversation]);

  const handleRegenerate = useCallback(
    async (assistantMessageId: string) => {
      if (!currentConversation || isLoading) return;
      const targetIndex = currentConversation.messages.findIndex((msg) => msg.id === assistantMessageId);
      if (targetIndex <= 0) return;
      const historyBefore = currentConversation.messages.slice(0, targetIndex);
      const lastUserIndex = [...historyBefore].reverse().findIndex((msg) => msg.role === 'user');
      if (lastUserIndex === -1) return;
      const userIndex = historyBefore.length - 1 - lastUserIndex;
      const historyToSend = currentConversation.messages.slice(0, userIndex + 1);

      abortRef.current?.abort();
      const controller = new AbortController();
      abortRef.current = controller;
      setIsLoading(true);
      setIsStreaming(true);
      setErrorMessage(null);

      const assistantMessage: MessageWithId = { id: crypto.randomUUID(), role: 'assistant', content: '', createdAt: Date.now() };
      updateConversation(currentConversation.id, (conv) => ({
        ...conv,
        messages: [...historyToSend, assistantMessage].slice(-MAX_HISTORY),
        updatedAt: Date.now()
      }));

      const payloadMessages: ChatMessage[] = historyToSend.map(({ id, createdAt, ...rest }) => rest as ChatMessage);

      try {
        await streamChatFromApi(payloadMessages, {
          signal: controller.signal,
          onChunk: (chunk) =>
            updateConversation(currentConversation.id, (conv) => ({
              ...conv,
              messages: conv.messages.map((msg) =>
                msg.id === assistantMessage.id ? { ...msg, content: msg.content + chunk } : msg
              ),
              updatedAt: Date.now()
            }))
        });
      } catch (error) {
        console.error(error);
        setErrorMessage('Не удалось перегенерировать ответ. Попробуйте снова.');
      } finally {
        setIsLoading(false);
        setIsStreaming(false);
        abortRef.current = null;
      }
    },
    [currentConversation, isLoading, updateConversation]
  );

  const handlePrefill = useCallback((prompt: string) => {
    setInput(prompt);
  }, []);

  const sendDisabled = isLoading || isStreaming || !input.trim();

  return (
    <div className="relative flex min-h-[70vh] flex-1 flex-col overflow-hidden rounded-[28px] border border-[var(--border-subtle)]/80 bg-gradient-to-br from-white via-[var(--bg-surface)] to-white p-4 shadow-[0_18px_42px_rgba(15,23,42,0.08)] dark:border-slate-800/80 dark:from-slate-950 dark:via-slate-900 dark:to-indigo-950/40">
      <div className="mb-4 flex flex-col gap-4 rounded-3xl border border-slate-200/60 bg-white/70 p-4 backdrop-blur dark:border-slate-800/70 dark:bg-slate-900/60">
        <div className="flex flex-wrap items-center justify-between gap-4">
          <div className="flex items-center gap-3">
            <div className="flex h-12 w-12 items-center justify-center rounded-2xl bg-gradient-to-r from-blue-500 to-indigo-500 text-white shadow-md">
              <SparklesIcon className="h-6 w-6" />
            </div>
            <div className="space-y-0.5">
              <p className="text-lg font-semibold text-slate-900 dark:text-slate-50">AI Concierge</p>
              <p className="text-sm text-slate-600 dark:text-slate-400">Потоковые ответы, готовые пресеты и офлайн-поведение.</p>
              <p className="text-xs text-slate-500 dark:text-slate-400">
                Статус: {isAuthenticated ? 'Личный профиль' : 'Гостевой режим'} • История хранится локально
              </p>
            </div>
          </div>
          <div className="flex flex-wrap items-center gap-2">
            <button
              className="flex items-center gap-2 rounded-full border border-slate-200 bg-white/60 px-3 py-2 text-xs font-medium text-slate-700 shadow-sm transition hover:border-indigo-300 hover:text-indigo-700 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200 dark:hover:border-indigo-500/60"
              onClick={handleCreate}
            >
              <ArrowPathIcon className="h-4 w-4" />
              Новый диалог
            </button>
            <button
              onClick={handleClear}
              className="flex items-center gap-2 rounded-full border border-slate-200 bg-white/60 px-3 py-2 text-xs font-medium text-slate-700 shadow-sm transition hover:border-red-200 hover:text-red-600 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200"
            >
              <StopCircleIcon className="h-4 w-4" />
              Очистить
            </button>
            <button
              className="inline-flex items-center gap-2 rounded-full border border-indigo-200/80 bg-indigo-50 px-3 py-2 text-xs font-semibold text-indigo-700 shadow-sm transition hover:-translate-y-[1px] hover:shadow-md dark:border-indigo-500/50 dark:bg-indigo-900/40 dark:text-indigo-100"
              onClick={() => setShowSidebar(true)}
            >
              <Bars3Icon className="h-4 w-4" />
              Диалоги
            </button>
          </div>
        </div>
        <div className="flex flex-wrap items-center justify-between gap-2">
          <div className="flex items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
            <ClockIcon className="h-4 w-4" />
            <span>Контекст до 14 сообщений. Профиль влияет на подсказки и историю.</span>
          </div>
          {isStreaming && (
            <div className="inline-flex items-center gap-2 rounded-full bg-indigo-50 px-3 py-1 text-[11px] font-semibold text-indigo-700 shadow-sm dark:bg-indigo-900/50 dark:text-indigo-100">
              <span className="h-2 w-2 animate-pulse rounded-full bg-indigo-500" />
              Генерируем ответ
            </div>
          )}
        </div>
        <SuggestedPrompts onSelect={handlePrefill} />
        <div className="flex flex-wrap items-center gap-2">
          {FAVORITE_PROMPTS.map((prompt) => (
            <button
              key={prompt}
              onClick={() => handlePrefill(prompt)}
              className="group rounded-full border border-slate-200/70 bg-white/70 px-3 py-2 text-xs text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-slate-300 hover:bg-white dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200"
            >
              <span className="mr-2 inline-block h-2 w-2 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 transition group-hover:scale-110" />
              {prompt}
            </button>
          ))}
        </div>
        {showOnboarding && (
          <div className="rounded-2xl border border-indigo-200 bg-indigo-50/80 px-4 py-3 text-xs text-indigo-800 shadow-sm dark:border-indigo-800/70 dark:bg-indigo-900/40 dark:text-indigo-100">
            <div className="flex items-center justify-between gap-2">
              <p>Подсказки и история сохраняются локально. Нажмите «Диалоги» для быстрого переключения веток.</p>
              <button
                onClick={() => setShowOnboarding(false)}
                className="rounded-full bg-white/70 px-3 py-1 text-[11px] font-semibold text-indigo-700 shadow-sm transition hover:-translate-y-[1px] dark:bg-indigo-800/60 dark:text-indigo-100"
              >
                Понятно
              </button>
            </div>
          </div>
        )}
        {!isAuthenticated && (
          <div className="flex items-center justify-between gap-2 rounded-2xl border border-amber-200 bg-amber-50 px-4 py-3 text-xs text-amber-800 shadow-sm dark:border-amber-800 dark:bg-amber-950/50 dark:text-amber-100">
            <p>Войдите, чтобы закрепить историю за аккаунтом и продолжать с любого устройства.</p>
            <a
              href="/auth"
              className="rounded-full bg-white/70 px-3 py-1 text-[11px] font-semibold text-amber-800 shadow-sm transition hover:-translate-y-[1px] dark:bg-amber-900 dark:text-amber-50"
            >
              Войти
            </a>
          </div>
        )}
      </div>

      <div className="grid h-full grid-cols-1 gap-4 lg:grid-cols-[320px,1fr]">
        <div className="hidden lg:block">
          <ConversationList
            conversations={conversations}
            activeId={activeConversationId}
            onSelect={handleSelectConversation}
            onCreate={handleCreate}
            onRename={handleRename}
            onDelete={handleDelete}
          />
        </div>
        <div className="flex flex-col overflow-hidden rounded-[22px] border border-[var(--border-subtle)]/80 bg-[var(--bg-elevated)] shadow-[0_16px_36px_rgba(15,23,42,0.08)] backdrop-blur dark:border-slate-800/70 dark:bg-slate-900/70">
          <div className="flex-1 space-y-4 overflow-y-auto px-4 py-6">
            {currentConversation && currentConversation.messages.length <= 1 ? (
              <div className="flex flex-col gap-3 rounded-2xl border border-dashed border-slate-200 bg-white/60 p-4 text-sm text-slate-700 shadow-sm dark:border-slate-800 dark:bg-slate-900/60 dark:text-slate-200">
                <p className="font-semibold text-slate-900 dark:text-slate-50">Начните новый диалог</p>
                <p className="text-xs text-slate-500 dark:text-slate-400">
                  Добавьте первый запрос или выберите одну из заготовок. История сохранится локально и привяжется к вашему профилю.
                </p>
                <div className="flex flex-wrap gap-2">
                  {FAVORITE_PROMPTS.slice(0, 3).map((prompt) => (
                    <button
                      key={prompt}
                      onClick={() => handlePrefill(prompt)}
                      className="rounded-full border border-slate-200/70 bg-white px-3 py-2 text-xs font-semibold text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-indigo-300 hover:text-indigo-700 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200"
                    >
                      {prompt}
                    </button>
                  ))}
                </div>
              </div>
            ) : (
              currentConversation?.messages.map((message) => (
                <MessageBubble key={message.id} message={message} isLoading={isLoading} onRegenerate={handleRegenerate} />
              ))
            )}
            <div ref={chatEndRef} />
          </div>
          <div className="sticky bottom-0 border-t border-[var(--border-subtle)]/80 bg-gradient-to-r from-white/95 via-[var(--bg-elevated)] to-white/95 p-4 backdrop-blur dark:border-slate-800 dark:from-slate-900/90 dark:via-slate-900 dark:to-slate-900/90">
            <div className="flex flex-col gap-2">
              <label htmlFor="chat-input" className="text-sm font-medium text-slate-700 dark:text-slate-200">
                Спросить ассистента
              </label>
              {!isAuthenticated && (
                <p className="text-[11px] text-amber-700 dark:text-amber-200">
                  Гостевой режим: история сохраняется только в этом браузере. Войдите, чтобы привязать её к профилю.
                </p>
              )}
              {errorMessage && (
                <div className="flex items-start justify-between gap-3 rounded-xl border border-red-200 bg-red-50 px-3 py-2 text-xs text-red-700 shadow-sm dark:border-red-900 dark:bg-red-950/40 dark:text-red-100">
                  <div className="flex items-start gap-2">
                    <ExclamationTriangleIcon className="mt-0.5 h-4 w-4" />
                    <p>{errorMessage}</p>
                  </div>
                  <button
                    onClick={() => setErrorMessage(null)}
                    className="rounded-md px-2 py-1 text-[11px] font-semibold text-red-700 transition hover:bg-red-100 dark:text-red-50 dark:hover:bg-red-900/60"
                    aria-label="Dismiss error"
                  >
                    Dismiss
                  </button>
                </div>
              )}
              <div className="flex flex-col gap-3 rounded-2xl border border-slate-200/70 bg-white/70 p-3 shadow-sm transition focus-within:border-indigo-200 focus-within:ring-1 focus-within:ring-indigo-200 dark:border-slate-800/60 dark:bg-slate-900/70 dark:focus-within:border-indigo-500/50 dark:focus-within:ring-indigo-500/50">
                <textarea
                  id="chat-input"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  onKeyDown={handleKeyDown}
                  rows={3}
                  className="flex-1 resize-none border-none bg-transparent text-sm text-slate-900 outline-none placeholder:text-slate-400 dark:text-slate-100"
                  placeholder="Как оптимизировать тарифы на выходные или при событиях?"
                />
                <div className="flex flex-wrap items-center justify-between gap-3">
                  <div className="flex flex-wrap items-center gap-3 text-xs text-slate-500 dark:text-slate-400">
                    <span>Enter — отправить • Shift+Enter — перенос строки</span>
                    {isStreaming && (
                      <button
                        onClick={handleAbort}
                        className="inline-flex items-center gap-1 rounded-full border border-slate-200 px-3 py-1 text-[11px] font-semibold text-slate-700 transition hover:-translate-y-[1px] hover:border-red-200 hover:text-red-600 dark:border-slate-700 dark:text-slate-200"
                      >
                        <StopCircleIcon className="h-3.5 w-3.5" />
                        Остановить
                      </button>
                    )}
                  </div>
                  <div className="flex items-center gap-2">
                    <button
                      onClick={handleClear}
                      className="rounded-full border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-indigo-200 dark:border-slate-700 dark:bg-slate-800 dark:text-slate-200"
                    >
                      Очистить
                    </button>
                    <button
                      onClick={() => void handleSend()}
                      disabled={sendDisabled}
                      className="inline-flex items-center gap-2 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 px-4 py-2 text-sm font-semibold text-white shadow-md transition hover:-translate-y-[1px] hover:shadow-lg disabled:cursor-not-allowed disabled:opacity-60"
                    >
                      <PaperAirplaneIcon className="h-5 w-5" />
                      Отправить
                    </button>
                  </div>
                </div>
              </div>
              {isLoading && (
                <p className="flex items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
                  <span className="h-2 w-2 animate-pulse rounded-full bg-indigo-500" /> Потоковый ответ…
                </p>
              )}
            </div>
          </div>
        </div>
      </div>

      {showSidebar && (
        <div className="fixed inset-0 z-30 flex bg-black/50 backdrop-blur-sm lg:hidden">
          <div className="m-4 flex w-full max-w-sm flex-col">
            <ConversationList
              conversations={conversations}
              activeId={activeConversationId}
              onSelect={handleSelectConversation}
              onCreate={() => {
                handleCreate();
                setShowSidebar(false);
              }}
              onRename={handleRename}
              onDelete={handleDelete}
              onClose={() => setShowSidebar(false)}
            />
            <button
              onClick={() => setShowSidebar(false)}
              className="mt-3 rounded-2xl border border-slate-200 bg-white/90 px-3 py-2 text-sm text-slate-700 shadow-sm dark:border-slate-700 dark:bg-slate-800 dark:text-slate-200"
            >
              Close
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

const MessageBubble = React.memo(function MessageBubble({
  message,
  isLoading,
  onRegenerate
}: {
  message: MessageWithId;
  isLoading: boolean;
  onRegenerate?: (id: string) => void;
}) {
  const isUser = message.role === 'user';
  const timestamp = useMemo(() => new Date(message.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }), [message.createdAt]);
  const bubbleClass = useMemo(
    () =>
      `group relative max-w-3xl rounded-2xl px-4 py-3 text-sm shadow-sm transition-all duration-200 ${
        isUser
          ? 'ml-auto bg-gradient-to-r from-indigo-500 to-blue-500 text-white'
          : 'bg-slate-100/90 text-slate-900 dark:bg-slate-800/80 dark:text-slate-50'
      }`,
    [isUser]
  );
  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(() => {
    if (!message.content) return;
    navigator.clipboard
      ?.writeText(message.content)
      .then(() => {
        setCopied(true);
        setTimeout(() => setCopied(false), 1500);
      })
      .catch(() => setCopied(false));
  }, [message.content]);

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
      <div className={bubbleClass}>
        <div className="mb-1 flex items-center gap-2 text-[11px] font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
          <span className="inline-flex items-center rounded-full bg-slate-200 px-2 py-0.5 text-[10px] font-semibold text-slate-700 dark:bg-slate-700 dark:text-slate-200">
            {isUser ? 'You' : 'AI'}
          </span>
          <span className="text-[10px] text-slate-500 dark:text-slate-400">{timestamp}</span>
        </div>
        {!isUser && message.content && (
          <div className="absolute -right-3 -top-3 flex items-center gap-1">
            <button
              onClick={handleCopy}
              className="flex items-center gap-1 rounded-full border border-[var(--border-subtle)]/70 bg-white px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] shadow-sm transition hover:-translate-y-[1px] hover:text-[var(--text-primary)] dark:bg-slate-900"
              aria-label="Copy message"
            >
              <ClipboardIcon className="h-3.5 w-3.5" />
              {copied ? 'Скопировано' : 'Копия'}
            </button>
            {onRegenerate && (
              <button
                onClick={() => onRegenerate(message.id)}
                className="flex items-center gap-1 rounded-full border border-[var(--border-subtle)]/70 bg-white px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] shadow-sm transition hover:-translate-y-[1px] hover:text-[var(--text-primary)] dark:bg-slate-900"
                aria-label="Regenerate"
              >
                <ArrowPathIcon className="h-3.5 w-3.5" />
                Повторить
              </button>
            )}
          </div>
        )}
        {isUser ? (
          <p className="whitespace-pre-line leading-relaxed">{message.content}</p>
        ) : message.content ? (
          <div className="transition-opacity duration-200">
            <MarkdownMessage content={message.content} />
          </div>
        ) : (
          <div className="flex flex-col gap-2">
            <div className="h-3 w-24 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />
            <div className="h-3 w-36 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />
            {isLoading && <div className="h-3 w-16 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />}
          </div>
        )}
      </div>
    </div>
  );
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 118
PATH: frontend\next-app\components\chat\compact-chat-panel.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { ChatPanel } from './chat-panel';

export function CompactChatPanel() {
  // На будущее сюда можно будет передать пропсы для "урезанного" вида,
  // сейчас просто используем существующую панель.
  return <ChatPanel />;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 119
PATH: frontend\next-app\components\chat\conversation-list.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { useMemo } from 'react';
import { Conversation } from './types';
import { PlusIcon, PencilSquareIcon, TrashIcon } from '@heroicons/react/24/outline';

interface ConversationListProps {
  conversations: Conversation[];
  activeId: string | null;
  onSelect: (id: string) => void;
  onCreate: () => void;
  onRename: (id: string, name: string) => void;
  onDelete: (id: string) => void;
  onClose?: () => void;
}

function formatTimestamp(timestamp: number) {
  const diff = Date.now() - timestamp;
  const minutes = Math.floor(diff / (1000 * 60));
  if (minutes < 60) return `${minutes || 1}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}

export function ConversationList({ conversations, activeId, onSelect, onCreate, onRename, onDelete, onClose }: ConversationListProps) {
  const sorted = useMemo(() => [...conversations].sort((a, b) => b.updatedAt - a.updatedAt), [conversations]);

  return (
    <aside className="flex h-full flex-col rounded-3xl border border-slate-200/80 bg-white/70 p-4 shadow-md backdrop-blur dark:border-slate-800/60 dark:bg-slate-900/70">
      <div className="mb-4 flex items-center justify-between gap-3">
        <div>
          <p className="text-sm font-semibold text-slate-800 dark:text-slate-100">Диалоги</p>
          <p className="text-xs text-slate-500 dark:text-slate-400">Возвращайтесь к предыдущим веткам</p>
        </div>
        <button
          onClick={onCreate}
          className="flex items-center gap-1 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 px-3 py-2 text-xs font-semibold text-white shadow-sm transition hover:shadow-md"
        >
          <PlusIcon className="h-4 w-4" />
          Новый
        </button>
      </div>
      <div className="flex-1 space-y-2 overflow-y-auto pr-1">
        {sorted.map((conversation) => {
          const isActive = conversation.id === activeId;
          const lastMessage = conversation.messages[conversation.messages.length - 1];
          return (
            <div
              key={conversation.id}
              className={`group relative overflow-hidden rounded-2xl border border-transparent transition hover:border-indigo-200 hover:bg-indigo-50/50 dark:hover:border-indigo-600/40 dark:hover:bg-indigo-950/30 ${
                isActive
                  ? 'border-indigo-300 bg-indigo-50 dark:border-indigo-600/60 dark:bg-indigo-900/40'
                  : 'border-slate-100 dark:border-slate-800'
              }`}
            >
              <button
                onClick={() => {
                  onSelect(conversation.id);
                  onClose?.();
                }}
                className="flex w-full flex-col gap-1 px-3 py-3 text-left"
              >
                <div className="flex items-center justify-between gap-2">
                  <p className="line-clamp-1 text-sm font-semibold text-slate-800 dark:text-slate-50">{conversation.title}</p>
                  <span className="text-[11px] text-slate-500 dark:text-slate-400">{formatTimestamp(conversation.updatedAt)}</span>
                </div>
                <p className="line-clamp-2 text-xs text-slate-500 dark:text-slate-400">
                  {lastMessage?.content || 'Ветка пустая'}
                </p>
              </button>
              <div className="absolute right-2 top-2 flex gap-1 opacity-0 transition group-hover:opacity-100">
                <button
                  aria-label="Rename conversation"
                  onClick={() => {
                    const nextName = prompt('Rename conversation', conversation.title);
                    if (nextName?.trim()) {
                      onRename(conversation.id, nextName.trim());
                    }
                  }}
                  className="rounded-full bg-white/90 p-1 text-slate-500 shadow hover:text-indigo-600 dark:bg-slate-800/80"
                >
                  <PencilSquareIcon className="h-4 w-4" />
                </button>
                <button
                  aria-label="Delete conversation"
                  onClick={() => {
                    const confirmed = confirm('Удалить этот диалог? Действие необратимо.');
                    if (confirmed) {
                      onDelete(conversation.id);
                    }
                  }}
                  className="rounded-full bg-white/90 p-1 text-slate-500 shadow hover:text-red-600 dark:bg-slate-800/80"
                >
                  <TrashIcon className="h-4 w-4" />
                </button>
              </div>
            </div>
          );
        })}
        {sorted.length === 0 && (
          <div className="rounded-2xl border border-dashed border-slate-300 bg-slate-50/70 p-4 text-center text-sm text-slate-500 dark:border-slate-700 dark:bg-slate-800/40 dark:text-slate-400">
            Пока нет диалогов.
          </div>
        )}
      </div>
    </aside>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 120
PATH: frontend\next-app\components\chat\markdown-message.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeSanitize from 'rehype-sanitize';
import rehypeHighlight from 'rehype-highlight';

interface Props {
  content: string;
}

export default function MarkdownMessage({ content }: Props) {
  return (
    <ReactMarkdown
      remarkPlugins={[remarkGfm]}
      rehypePlugins={[rehypeSanitize as any, rehypeHighlight as any]}
      className="prose prose-sm max-w-none dark:prose-invert"
    >
      {content}
    </ReactMarkdown>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 121
PATH: frontend\next-app\components\chat\suggested-prompts.tsx
LANG: tsx
===== CONTENT START =====
'use client';

interface SuggestedPromptsProps {
  onSelect: (prompt: string) => void;
}

const PROMPTS = [
  'Analyze occupancy trends for the last 7 days.',
  'Suggest dynamic pricing for weekend events.',
  'Generate a customer journey improvement plan.',
  'What KPIs should I monitor for a new garage launch?',
  'Draft a personalized outreach message for high-value partners.'
];

export function SuggestedPrompts({ onSelect }: SuggestedPromptsProps) {
  return (
    <div className="flex flex-wrap items-center gap-2">
      {PROMPTS.map((prompt) => (
        <button
          key={prompt}
          onClick={() => onSelect(prompt)}
          className="group rounded-full border border-slate-200/70 bg-white/70 px-3 py-2 text-xs text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-indigo-300 hover:bg-indigo-50 hover:text-indigo-700 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200 dark:hover:border-indigo-500/60 dark:hover:bg-indigo-900/40 dark:hover:text-indigo-100"
        >
          <span className="mr-1 inline-block h-2 w-2 rounded-full bg-gradient-to-r from-blue-500 to-indigo-500 transition group-hover:scale-110" />
          {prompt}
        </button>
      ))}
    </div>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 122
PATH: frontend\next-app\components\chat\types.ts
LANG: typescript
===== CONTENT START =====
import { ChatMessage } from '@/lib/aiProvider';

export interface MessageWithId extends ChatMessage {
  id: string;
  createdAt: number;
}

export interface Conversation {
  id: string;
  title: string;
  messages: MessageWithId[];
  updatedAt: number;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 123
PATH: frontend\next-app\components\pwa\register-service-worker.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { useEffect, useState } from 'react';

export function ServiceWorkerRegistrar() {
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (process.env.NODE_ENV !== 'production') return;
    if (!('serviceWorker' in navigator)) return;

    const register = async () => {
      try {
        await navigator.serviceWorker.register('/service-worker.js');
        console.info('Service worker registered');
      } catch (error) {
        console.error('Failed to register service worker', error);
        setError('Offline mode is temporarily unavailable. We will retry soon.');
      }
    };

    register();
  }, []);

  if (!error) return null;

  return (
    <div className="fixed bottom-4 right-4 z-30 max-w-sm rounded-xl border border-amber-200 bg-amber-50 px-4 py-3 text-sm text-amber-900 shadow-md dark:border-amber-800 dark:bg-amber-950/70 dark:text-amber-100">
      <div className="flex items-start gap-3">
        <span className="mt-0.5 inline-flex h-5 w-5 items-center justify-center rounded-full bg-amber-200 text-xs font-bold text-amber-800 dark:bg-amber-800 dark:text-amber-100">!</span>
        <div className="space-y-1">
          <p className="font-semibold">Offline caching issue</p>
          <p className="text-xs leading-relaxed">{error}</p>
        </div>
      </div>
    </div>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 124
PATH: frontend\next-app\components\widget\chat-widget.tsx
LANG: tsx
===== CONTENT START =====
'use client';
import { useState } from 'react';
import { ChatPanel } from '@/components/chat/chat-panel';
import { XMarkIcon } from '@heroicons/react/24/outline';

export function ChatWidget() {
  const [open, setOpen] = useState(false);

  return (
    <>
      {!open && (
        <button
          onClick={() => setOpen(true)}
          className="fixed bottom-6 right-6 z-50 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 px-5 py-3 text-sm font-semibold text-white shadow-xl transition hover:-translate-y-[1px] hover:shadow-2xl"
        >
          AI Assistant
        </button>
      )}

      {open && (
        <div className="fixed bottom-6 right-6 z-50 bg-white dark:bg-slate-900 rounded-2xl shadow-2xl w-[420px] max-h-[80vh] flex flex-col border border-slate-200 dark:border-slate-700">
          <div className="flex justify-between items-center p-3 border-b dark:border-slate-700">
            <h3 className="font-semibold text-slate-800 dark:text-slate-200">AI Assistant</h3>
            <button
              onClick={() => setOpen(false)}
              className="rounded-full border border-slate-200 bg-white p-1 text-slate-600 shadow-sm transition hover:-translate-y-[1px] hover:border-slate-300 dark:border-slate-700 dark:bg-slate-800 dark:text-slate-200"
              aria-label="Закрыть виджет"
            >
              <XMarkIcon className="h-4 w-4" />
            </button>
          </div>
          <div className="flex-1 overflow-y-auto">
            <ChatPanel />
          </div>
        </div>
      )}
    </>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 125
PATH: frontend\next-app\context\AuthContext.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import {
  type AuthUser,
  getCurrentUser,
  loginWithEmailPassword,
  logout as apiLogout,
  registerWithEmailPassword,
  requestOtp,
  startOAuth,
  verifyOtp
} from '@/lib/authClient';

interface AuthContextValue {
  user: AuthUser | null;
  loading: boolean;
  loginWithEmail: (email: string, password: string) => Promise<AuthUser | null>;
  registerWithEmail: (email: string, password: string, name?: string) => Promise<AuthUser | null>;
  requestPhoneOtp: (phone: string) => Promise<void>;
  verifyPhoneOtp: (phone: string, code: string) => Promise<AuthUser | null>;
  loginWithVK: () => void;
  loginWithYandex: () => void;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);
const STORAGE_KEY = 'parkshare_auth_user';

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const bootstrap = async () => {
      try {
        if (typeof window !== 'undefined') {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) {
            setUser(JSON.parse(saved));
            setLoading(false);
            return;
          }
        }
        const serverUser = await getCurrentUser();
        if (serverUser) {
          setUser(serverUser);
          if (typeof window !== 'undefined') {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(serverUser));
          }
        }
      } catch (error) {
        console.warn('Auth bootstrap failed', error);
      } finally {
        setLoading(false);
      }
    };

    void bootstrap();
  }, []);

  const persistUser = useCallback((nextUser: AuthUser | null) => {
    setUser(nextUser);
    if (typeof window !== 'undefined') {
      if (nextUser) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(nextUser));
      } else {
        localStorage.removeItem(STORAGE_KEY);
      }
    }
  }, []);

  const loginWithEmail = useCallback(async (email: string, password: string) => {
    const response = await loginWithEmailPassword(email, password);
    if (response.user) {
      persistUser(response.user);
      return response.user;
    }
    return null;
  }, [persistUser]);

  const registerWithEmail = useCallback(async (email: string, password: string, name?: string) => {
    const response = await registerWithEmailPassword(email, password, name);
    if (response.user) {
      persistUser(response.user);
      return response.user;
    }
    return null;
  }, [persistUser]);

  const requestPhoneOtp = useCallback(async (phone: string) => {
    await requestOtp(phone);
  }, []);

  const verifyPhoneOtp = useCallback(async (phone: string, code: string) => {
    const response = await verifyOtp(phone, code);
    if (response.user) {
      persistUser(response.user);
      return response.user;
    }
    return null;
  }, [persistUser]);

  const loginWithVK = useCallback(() => startOAuth('vk'), []);
  const loginWithYandex = useCallback(() => startOAuth('yandex'), []);

  const logout = useCallback(async () => {
    await apiLogout();
    persistUser(null);
  }, [persistUser]);

  const value = useMemo(
    () => ({
      user,
      loading,
      loginWithEmail,
      registerWithEmail,
      requestPhoneOtp,
      verifyPhoneOtp,
      loginWithVK,
      loginWithYandex,
      logout
    }),
    [user, loading, loginWithEmail, registerWithEmail, requestPhoneOtp, verifyPhoneOtp, loginWithVK, loginWithYandex, logout]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuthContext() {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error('useAuthContext must be used within AuthProvider');
  }
  return ctx;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 126
PATH: frontend\next-app\hooks\useAuth.ts
LANG: typescript
===== CONTENT START =====
'use client';

import { useMemo } from 'react';
import { useAuthContext } from '@/context/AuthContext';

export function useAuth() {
  const ctx = useAuthContext();

  return useMemo(
    () => ({
      ...ctx,
      isAuthenticated: Boolean(ctx.user)
    }),
    [ctx]
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 127
PATH: frontend\next-app\lib\aiProvider.ts
LANG: typescript
===== CONTENT START =====
export { streamChat as streamChatResponse } from './llmClient';
export type { LLMMessage as ChatMessage } from './llmClient';

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 128
PATH: frontend\next-app\lib\authClient.ts
LANG: typescript
===== CONTENT START =====
export type AuthUser = {
  id: string;
  email?: string;
  phone?: string;
  name?: string;
  avatarUrl?: string;
  provider?: string;
};

export type AuthResponse = {
  success: boolean;
  message?: string;
  user?: AuthUser;
  data?: unknown;
};

const API_BASE = process.env.NEXT_PUBLIC_AUTH_API_URL || process.env.NEXT_PUBLIC_AUTH_API_BASE;

async function request<T = AuthResponse>(endpoint: string, body?: Record<string, unknown>, init?: RequestInit): Promise<T> {
  if (!API_BASE) {
    // Demo-friendly fallback to avoid breaking UX when backend is not configured.
    return Promise.resolve({
      success: true,
      message: 'DEMO: Backend URL не задан, имитируем успешный ответ.',
      user: {
        id: 'demo-user',
        email: body && 'email' in body ? (body.email as string) : undefined,
        phone: body && 'phone' in body ? (body.phone as string) : undefined,
        name: 'Demo User',
        provider: 'demo'
      }
    } as T);
  }

  const response = await fetch(`${API_BASE}${endpoint}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: body ? JSON.stringify(body) : undefined,
    ...init
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(errorText || 'Auth request failed');
  }

  return response.json();
}

export async function requestOtp(phone: string) {
  if (!phone) throw new Error('Введите номер телефона');
  return request<AuthResponse>('/auth/otp/request', { phone });
}

export async function verifyOtp(phone: string, code: string) {
  if (!phone || !code) throw new Error('Введите телефон и код');
  return request<AuthResponse>('/auth/otp/verify', { phone, code });
}

export async function loginWithEmailPassword(email: string, password: string) {
  if (!email || !password) throw new Error('Нужны почта и пароль');
  return request<AuthResponse>('/auth/email/login', { email, password });
}

export async function registerWithEmailPassword(email: string, password: string, name?: string) {
  if (!email || !password) throw new Error('Укажите почту и пароль');
  return request<AuthResponse>('/auth/email/register', { email, password, name });
}

export async function logout() {
  if (!API_BASE) return { success: true, message: 'DEMO: лог-аут выполнен локально.' };
  return request<AuthResponse>('/auth/logout');
}

export async function getCurrentUser() {
  if (!API_BASE) return null;
  // Expected backend endpoint: GET /auth/me returns { success, user }
  const response = await fetch(`${API_BASE}/auth/me`, { credentials: 'include' });
  if (!response.ok) return null;
  const data = (await response.json()) as AuthResponse;
  return data.user ?? null;
}

function buildOAuthUrl(provider: 'vk' | 'yandex') {
  const redirectUriParam =
    provider === 'vk'
      ? process.env.NEXT_PUBLIC_VK_REDIRECT_URI
      : process.env.NEXT_PUBLIC_YANDEX_REDIRECT_URI;
  const clientIdParam =
    provider === 'vk' ? process.env.NEXT_PUBLIC_VK_CLIENT_ID : process.env.NEXT_PUBLIC_YANDEX_CLIENT_ID;

  if (clientIdParam && redirectUriParam) {
    const redirect = encodeURIComponent(redirectUriParam);
    return provider === 'vk'
      ? `https://id.vk.com/authorize?client_id=${clientIdParam}&redirect_uri=${redirect}&response_type=code`
      : `https://oauth.yandex.ru/authorize?response_type=code&client_id=${clientIdParam}&redirect_uri=${redirect}`;
  }

  const base = API_BASE || '';
  const returnTo = encodeURIComponent(typeof window !== 'undefined' ? window.location.href : '/');
  return `${base}/auth/oauth/${provider}?redirect_uri=${returnTo}`;
}

export function startOAuth(provider: 'vk' | 'yandex' | 'google') {
  if (provider === 'google') {
    const base = API_BASE || '';
    const redirect = encodeURIComponent(typeof window !== 'undefined' ? window.location.href : '/');
    window.location.href = `${base}/auth/oauth/google?redirect_uri=${redirect}`;
    return;
  }

  const url = buildOAuthUrl(provider);
  window.location.href = url;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 129
PATH: frontend\next-app\lib\chatClient.ts
LANG: typescript
===== CONTENT START =====
import { ChatMessage } from './aiProvider';

type StreamChatOptions = {
  fetcher?: typeof fetch;
  onChunk?: (chunk: string) => void;
  signal?: AbortSignal;
};

export async function streamChatFromApi(messages: ChatMessage[], options: StreamChatOptions = {}) {
  const fetcher = options.fetcher ?? fetch;
  const response = await fetcher('/api/chat', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ messages, stream: true }),
    signal: options.signal
  });

  if (!response.ok || !response.body) {
    const errorText = await response.text();
    throw new Error(errorText || 'Failed to reach chat API');
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    const textChunk = decoder.decode(value, { stream: true });
    options.onChunk?.(textChunk);
  }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 130
PATH: frontend\next-app\lib\llmClient.ts
LANG: typescript
===== CONTENT START =====
import type { ReadableStream } from 'stream/web';

export type LLMMessage = {
  role: 'user' | 'assistant' | 'system';
  content: string;
};

export type LLMProvider = 'openai' | 'proxy' | 'custom';

export interface LLMClientConfig {
  provider: LLMProvider;
  apiUrl: string;
  apiKey?: string;
  model?: string;
  authHeader?: string;
  authScheme?: string;
}

const encoder = new TextEncoder();

function fallbackStream(message: string) {
  return new ReadableStream<Uint8Array>({
    start(controller) {
      controller.enqueue(encoder.encode(message));
      controller.close();
    }
  });
}

function resolveConfig(): LLMClientConfig {
  return {
    provider: (process.env.LLM_PROVIDER as LLMProvider) || 'openai',
    apiUrl: process.env.LLM_API_URL || 'https://api.openai.com/v1/chat/completions',
    apiKey: process.env.LLM_API_KEY || process.env.OPENAI_API_KEY,
    model: process.env.LLM_MODEL || 'gpt-4o-mini',
    authHeader: process.env.LLM_AUTH_HEADER || 'Authorization',
    authScheme: process.env.LLM_AUTH_SCHEME || 'Bearer'
  };
}

async function createRequest(messages: LLMMessage[], stream: boolean, signal?: AbortSignal): Promise<Response> {
  const config = resolveConfig();

  if (!config.apiUrl) {
    throw new Error('LLM_API_URL is not configured');
  }

  const headers: Record<string, string> = {
    'Content-Type': 'application/json'
  };

  if (config.apiKey) {
    headers[config.authHeader || 'Authorization'] = `${config.authScheme || 'Bearer'} ${config.apiKey}`.trim();
  }

  const body = {
    model: config.model,
    messages,
    stream
  };

  return fetch(config.apiUrl, {
    method: 'POST',
    headers,
    body: JSON.stringify(body),
    signal
  });
}

export async function streamChat(messages: LLMMessage[], { signal, stream = true }: { signal?: AbortSignal; stream?: boolean } = {}) {
  if (!messages || !Array.isArray(messages) || messages.length === 0) {
    return fallbackStream('No messages provided to LLM.');
  }

  try {
    const response = await createRequest(messages, stream, signal);

    if (!response.ok || !response.body) {
      const errorText = await response.text();
      return fallbackStream(errorText || 'The LLM provider responded with an error.');
    }

    if (!stream) {
      // Non-streaming: return one chunk with the final message.
      const result = await response.json();
      const content =
        result?.choices?.[0]?.message?.content ||
        result?.message ||
        'The LLM provider did not return a message.';
      return fallbackStream(content);
    }

    const decoder = new TextDecoder();
    const reader = response.body.getReader();

    return new ReadableStream<Uint8Array>({
      async pull(controller) {
        const { done, value } = await reader.read();
        if (done) {
          controller.close();
          return;
        }

        const textChunk = decoder.decode(value, { stream: true });
        const lines = textChunk
          .split('\n')
          .map((line) => line.trim())
          .filter(Boolean);

        for (const line of lines) {
          const data = line.startsWith('data:') ? line.replace('data:', '').trim() : line;
          if (data === '[DONE]') {
            controller.close();
            return;
          }

          try {
            const payload = JSON.parse(data) as { choices?: Array<{ delta?: { content?: string } }> };
            const token = payload.choices?.[0]?.delta?.content;
            if (token) {
              controller.enqueue(encoder.encode(token));
              continue;
            }
          } catch {
            // Not JSON or not OpenAI-shaped – stream raw text.
          }

          if (data) {
            controller.enqueue(encoder.encode(data));
          }
        }
      },
      cancel() {
        reader.cancel().catch(() => undefined);
      }
    });
  } catch (error) {
    console.error('LLM streaming failed', error);
    return fallbackStream('LLM is unreachable. Check configuration or network.');
  }
}

export const isLLMConfigured = () => Boolean(process.env.LLM_API_URL || process.env.OPENAI_API_KEY || process.env.LLM_API_KEY);

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 131
PATH: frontend\next-app\public\manifest.webmanifest
LANG: text
===== CONTENT START =====
{
  "name": "ParkShare AI Concierge",
  "short_name": "PS Concierge",
  "start_url": "/",
  "display": "standalone",
  "theme_color": "#0f172a",
  "background_color": "#f4f7fb",
  "icons": [
    {
      "src": "/icons/icon-192.svg",
      "sizes": "192x192",
      "type": "image/svg+xml"
    },
    {
      "src": "/icons/icon-512.svg",
      "sizes": "512x512",
      "type": "image/svg+xml"
    }
  ]
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 132
PATH: frontend\next-app\public\offline.html
LANG: html
===== CONTENT START =====
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ParkShare AI Concierge – Offline</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        background: radial-gradient(circle at 20% 20%, #eef2ff, #f8fafc);
      }
      body {
        margin: 0;
        display: grid;
        place-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(14, 165, 233, 0.08)), #0f172a;
        color: #e2e8f0;
      }
      .card {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 24px;
        padding: 28px;
        width: min(480px, 90vw);
        box-shadow: 0 16px 48px rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(12px);
      }
      h1 {
        margin: 0 0 8px 0;
        font-size: 22px;
      }
      p {
        margin: 4px 0;
        line-height: 1.6;
        color: rgba(226, 232, 240, 0.9);
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(99, 102, 241, 0.15);
        border: 1px solid rgba(99, 102, 241, 0.4);
        color: #c7d2fe;
      }
    </style>
  </head>
  <body>
    <div class="card">
      <div class="pill">Offline mode</div>
      <h1>ParkShare AI Concierge</h1>
      <p>You're currently offline. We'll keep your latest sessions saved on this device.</p>
      <p>Reconnect to resume chatting or send queued prompts.</p>
    </div>
  </body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 133
PATH: frontend\next-app\public\service-worker.js
LANG: javascript
===== CONTENT START =====
const CACHE_NAME = 'ps-concierge-v2';
const CORE_ASSETS = ['/', '/offline.html', '/manifest.webmanifest'];

self.addEventListener('install', (event) => {
  event.waitUntil(caches.open(CACHE_NAME).then((cache) => cache.addAll(CORE_ASSETS)).then(() => self.skipWaiting()));
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((keys) =>
        Promise.all(
          keys.map((key) => {
            if (key !== CACHE_NAME) {
              return caches.delete(key);
            }
            return undefined;
          })
        )
      )
      .then(() => self.clients.claim())
  );
});

const staticAssetMatch = (url) =>
  url.pathname.startsWith('/_next/') ||
  url.pathname.startsWith('/icons/') ||
  url.pathname.endsWith('.css') ||
  url.pathname.endsWith('.js') ||
  url.pathname.endsWith('.woff2') ||
  url.pathname.endsWith('.png') ||
  url.pathname.endsWith('.svg');

const staleWhileRevalidate = async (request) => {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(request);
  try {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (error) {
    return cached || Promise.reject(error);
  }
};

self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  if (request.method !== 'GET') return;
  if (url.pathname.startsWith('/api')) return;

  if (request.mode === 'navigate') {
    event.respondWith(
      fetch(request)
        .then((response) => {
          const copy = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(request, copy));
          return response;
        })
        .catch(() => caches.match(request).then((match) => match || caches.match('/offline.html')))
    );
    return;
  }

  if (staticAssetMatch(url)) {
    event.respondWith(staleWhileRevalidate(request));
  }
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 134
PATH: frontend\next-app\__tests__\chat-client.test.ts
LANG: typescript
===== CONTENT START =====
import { streamChatFromApi } from '@/lib/chatClient';
import type { ChatMessage } from '@/lib/aiProvider';

const encoder = new TextEncoder();

function streamFromStrings(chunks: string[]) {
  return new ReadableStream<Uint8Array>({
    start(controller) {
      chunks.forEach((chunk) => controller.enqueue(encoder.encode(chunk)));
      controller.close();
    }
  });
}

describe('streamChatFromApi', () => {
  it('posts chat messages and streams tokens to callback', async () => {
    const messages: ChatMessage[] = [
      { role: 'user', content: 'Hello' },
      { role: 'assistant', content: 'Hi!' }
    ];

    const mockFetch = jest.fn().mockResolvedValue(
      new Response(streamFromStrings(['Hello', ' world']), {
        status: 200,
        headers: { 'Content-Type': 'text/plain' }
      })
    );

    const onChunk = jest.fn();

    await streamChatFromApi(messages, { fetcher: mockFetch, onChunk });

    expect(mockFetch).toHaveBeenCalledWith(
      '/api/chat',
      expect.objectContaining({
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      })
    );

    const body = mockFetch.mock.calls[0][1]?.body as string;
    expect(JSON.parse(body).messages).toEqual(messages);

    expect(onChunk).toHaveBeenCalledWith('Hello');
    expect(onChunk).toHaveBeenCalledWith(' world');
  });

  it('throws when the API response is not ok', async () => {
    const mockFetch = jest.fn().mockResolvedValue(new Response(null, { status: 500 }));

    await expect(streamChatFromApi([{ role: 'user', content: 'test' }], { fetcher: mockFetch })).rejects.toThrow(
      'Failed to reach chat API'
    );
  });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 135
PATH: frontend\next-app\__tests__\conversation-list.test.tsx
LANG: tsx
===== CONTENT START =====
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ConversationList } from '@/components/chat/conversation-list';
import type { Conversation } from '@/components/chat/types';

describe('ConversationList', () => {
  const baseConversations: Conversation[] = [
    {
      id: 'one',
      title: 'First thread',
      updatedAt: Date.now() - 1000 * 60 * 5,
      messages: [{ id: 'm1', role: 'user', content: 'Hello', createdAt: Date.now() - 1000 * 60 * 5 }]
    },
    {
      id: 'two',
      title: 'Second thread',
      updatedAt: Date.now() - 1000 * 60 * 60,
      messages: [{ id: 'm2', role: 'assistant', content: 'Hi there', createdAt: Date.now() - 1000 * 60 * 60 }]
    }
  ];

  beforeEach(() => {
    jest.spyOn(window, 'prompt').mockReturnValue('Renamed thread');
    jest.spyOn(window, 'confirm').mockReturnValue(true);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('renders conversations and handles selection, rename, and deletion', async () => {
    const onSelect = jest.fn();
    const onCreate = jest.fn();
    const onRename = jest.fn();
    const onDelete = jest.fn();

    render(
      <ConversationList
        conversations={baseConversations}
        activeId={'one'}
        onSelect={onSelect}
        onCreate={onCreate}
        onRename={onRename}
        onDelete={onDelete}
      />
    );

    expect(screen.getByText('First thread')).toBeInTheDocument();
    expect(screen.getByText('Second thread')).toBeInTheDocument();

    await userEvent.click(screen.getByText('First thread'));
    expect(onSelect).toHaveBeenCalledWith('one');

    await userEvent.click(screen.getByText('Новый'));
    expect(onCreate).toHaveBeenCalled();

    const renameButton = screen.getAllByLabelText('Rename conversation')[0];
    await userEvent.click(renameButton);
    expect(onRename).toHaveBeenCalledWith('one', 'Renamed thread');

    const deleteButton = screen.getAllByLabelText('Delete conversation')[0];
    await userEvent.click(deleteButton);
    expect(onDelete).toHaveBeenCalledWith('one');
  });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 136
PATH: frontend\parkmate\parkmate.types.ts
LANG: typescript
===== CONTENT START =====
// frontend/parkmate/parkmate.types.ts

export interface ParkMateAI {
  voiceCommands: {
    booking: string;
    navigation: string;
    payment: string;
    support: string;
  };
  computerVision: {
    licensePlateRecognition: string;
    parkingSpotDetection: string;
    damageDetection: string;
    occupancyAnalytics: string;
  };
  predictions: {
    arrivalTime: string;
    priceForecast: string;
    availability: string;
  };
}

/**
 * Базовый конфиг ParkMate, который фронтенд может запросить с бэка.
 * На следующей фазе мы добавим endpoint вроде /api/ai/parkmate/config/.
 */
export const defaultParkMateConfig: ParkMateAI = {
  voiceCommands: {
    booking: "Забронируй ближайшее свободное место на 2 часа",
    navigation: "Построй маршрут до моего места парковки",
    payment: "Оплати мою текущую парковку",
    support: "Соедини с поддержкой ParkShare",
  },
  computerVision: {
    licensePlateRecognition: "/api/ai/cv/license-plate/",
    parkingSpotDetection: "/api/ai/cv/parking-spots/",
    damageDetection: "/api/ai/cv/damage/",
    occupancyAnalytics: "/api/ai/cv/occupancy/",
  },
  predictions: {
    arrivalTime: "/api/ai/predict/arrival-time/",
    priceForecast: "/api/ai/predict/pricing/",
    availability: "/api/ai/predict/availability/",
  },
};

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 137
PATH: nginx\nginx.conf
LANG: text
===== CONTENT START =====
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml+rss;

    upstream django {
        server web:8000;
    }

    server {
        listen 80;
        server_name _;

        # Uncomment for HTTPS termination + Let's Encrypt
        # listen 443 ssl http2;
        # ssl_certificate /etc/letsencrypt/live/DOMAIN/fullchain.pem;
        # ssl_certificate_key /etc/letsencrypt/live/DOMAIN/privkey.pem;

        add_header X-Content-Type-Options "nosniff" always;
        add_header X-Frame-Options "DENY" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Permissions-Policy "geolocation=(), camera=(), microphone=(), payment=()" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; connect-src 'self' https: wss:;";

        location /static/ {
            alias /static/;
            expires 7d;
        }

        location /media/ {
            alias /media/;
            expires 1d;
        }

        location /embed {
            proxy_pass http://frontend:3000/embed;
        }

        location / {
            proxy_pass http://django;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location = /health/ {
            access_log off;
            return 200 'ok';
        }
    }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 138
PATH: parking\__init__.py
LANG: python
===== CONTENT START =====
# backend/parking/__init__.py

default_app_config = "parking.apps.ParkingConfig"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 139
PATH: parking\admin.py
LANG: python
===== CONTENT START =====
# backend/parking/admin.py

from django.contrib import admin

from .models import Booking, Complaint, ParkingLot, ParkingSpot, WaitlistEntry


@admin.register(ParkingLot)
class ParkingLotAdmin(admin.ModelAdmin):
    list_display = ("name", "city", "owner", "parking_type", "is_active", "is_approved")
    list_filter = ("city", "parking_type", "is_active", "is_approved")
    search_fields = ("name", "city", "address", "owner__username")
    autocomplete_fields = ("owner",)


@admin.register(ParkingSpot)
class ParkingSpotAdmin(admin.ModelAdmin):
    list_display = (
        "name",
        "lot",
        "vehicle_type",
        "is_covered",
        "has_ev_charging",
        "status",
        "hourly_price",
    )
    list_filter = (
        "vehicle_type",
        "is_covered",
        "has_ev_charging",
        "status",
        "lot__city",
    )
    search_fields = ("name", "lot__name", "lot__city")
    autocomplete_fields = ("lot",)


@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "spot",
        "user",
        "booking_type",
        "status",
        "start_at",
        "end_at",
        "total_price",
        "is_paid",
    )
    list_filter = ("booking_type", "status", "start_at", "spot__lot__city")
    search_fields = ("spot__name", "spot__lot__name", "user__username")
    autocomplete_fields = ("spot", "user", "vehicle")


@admin.register(WaitlistEntry)
class WaitlistEntryAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "spot", "status", "auto_book", "created_at")
    list_filter = ("status", "auto_book", "created_at")
    search_fields = ("user__username", "spot__name")
    autocomplete_fields = ("user", "spot")


@admin.register(Complaint)
class ComplaintAdmin(admin.ModelAdmin):
    list_display = ("id", "author", "category", "status", "created_at")
    list_filter = ("category", "status", "created_at")
    search_fields = ("author__username", "description")
    autocomplete_fields = ("author", "booking", "spot")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 140
PATH: parking\apps.py
LANG: python
===== CONTENT START =====
# backend/parking/apps.py

from django.apps import AppConfig


class ParkingConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "parking"
    verbose_name = "Парковки и бронирования"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 141
PATH: parking\models.py
LANG: python
===== CONTENT START =====
# backend/parking/models.py

from __future__ import annotations

from datetime import timedelta
from decimal import Decimal, ROUND_UP
from typing import Optional

from django.conf import settings
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


# PointField с fallback для SQLite: храним JSON {"lat": ..., "lng": ...}
_db_settings = getattr(settings, "DATABASES", {})
_default_db = _db_settings.get("default") or {}
_default_engine = _default_db.get("ENGINE", "")


if _default_engine.endswith("sqlite3"):
    class PointField(models.JSONField):  # type: ignore[misc]
        def __init__(self, *args, **kwargs):
            kwargs.pop("geography", None)
            super().__init__(*args, **kwargs)
else:  # PostGIS / другие GIS-бэкенды
    from django.contrib.gis.db.models import PointField  # type: ignore[assignment]


class ParkingLot(TimeStampedModel):
    """
    Объект парковки (двор, подземный паркинг, офисный паркинг и т.д.).
    """

    class ParkingType(models.TextChoices):
        YARD = "yard", "Дворовая парковка"
        UNDERGROUND = "underground", "Подземная парковка"
        MULTILEVEL = "multilevel", "Многоуровневая парковка"
        STREET = "street", "Уличная парковка"
        OFFICE = "office", "Офисная парковка"
        HOME = "home", "Домашнее место"

    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="parking_lots",
        verbose_name="Владелец",
    )
    name = models.CharField("Название", max_length=255)
    city = models.CharField("Город", max_length=100)
    address = models.CharField("Адрес", max_length=255)
    parking_type = models.CharField(
        "Тип парковки",
        max_length=32,
        choices=ParkingType.choices,
        default=ParkingType.YARD,
    )
    description = models.TextField("Описание", blank=True)

    location = PointField("Точка на карте", geography=True, null=True, blank=True)
    latitude = models.FloatField("Широта", null=True, blank=True)
    longitude = models.FloatField("Долгота", null=True, blank=True)

    is_active = models.BooleanField("Активен", default=True)
    is_approved = models.BooleanField(
        "Одобрен модерацией",
        default=False,
        help_text="Одобряется администратором перед публикацией.",
    )
    is_private = models.BooleanField(
        "Приватный",
        default=False,
        help_text="Если включено, объект виден только по прямым ссылкам/владельцу.",
    )

    stress_index = models.FloatField(
        "Индекс загруженности (0..1)",
        default=0.0,
        help_text=(
            "Средняя загруженность мест за последние 7 дней. "
            "Обновляется фоновыми задачами AI."
        ),
    )

    class Meta:
        verbose_name = "Объект парковки"
        verbose_name_plural = "Объекты парковки"
        ordering = ("name",)

    def __str__(self) -> str:
        return f"{self.name} ({self.city})"

    @property
    def owner_username(self) -> str:
        return getattr(self.owner, "username", "")

    def set_coordinates(self, lat: Optional[float], lng: Optional[float]) -> None:
        """
        Устанавливает координаты и PointField (если доступен GeoDjango).
        """
        self.latitude = lat
        self.longitude = lng
        if lat is None or lng is None:
            self.location = None
            return

        try:
            from django.contrib.gis.geos import Point  # type: ignore[import]
        except Exception:
            # SQLite/JSON fallback
            self.location = {"lat": lat, "lng": lng}
        else:
            self.location = Point(lng, lat)


class ParkingSpot(TimeStampedModel):
    """
    Конкретное парковочное место внутри ParkingLot.
    """

    class SpotStatus(models.TextChoices):
        ACTIVE = "active", "Активно"
        INACTIVE = "inactive", "Неактивно"

    class VehicleType(models.TextChoices):
        CAR = "car", "Легковой автомобиль"
        MOTO = "moto", "Мотоцикл"
        COMMERCIAL = "commercial", "Коммерческий транспорт"

    lot = models.ForeignKey(
        ParkingLot,
        on_delete=models.CASCADE,
        related_name="spots",
        verbose_name="Объект парковки",
    )
    name = models.CharField("Название/номер места", max_length=64)
    description = models.TextField("Описание", blank=True)

    vehicle_type = models.CharField(
        "Тип транспорта",
        max_length=16,
        choices=VehicleType.choices,
        default=VehicleType.CAR,
    )

    is_covered = models.BooleanField("Крытое место", default=False)
    has_ev_charging = models.BooleanField("Есть зарядка", default=False)
    is_24_7 = models.BooleanField("Круглосуточно", default=True)
    max_height_m = models.DecimalField(
        "Максимальная высота (м)",
        max_digits=4,
        decimal_places=2,
        null=True,
        blank=True,
    )

    hourly_price = models.DecimalField(
        "Цена за час, ₽", max_digits=8, decimal_places=2
    )
    nightly_price = models.DecimalField(
        "Цена за ночь, ₽", max_digits=8, decimal_places=2, null=True, blank=True
    )
    daily_price = models.DecimalField(
        "Цена за сутки, ₽", max_digits=8, decimal_places=2, null=True, blank=True
    )
    monthly_price = models.DecimalField(
        "Цена за месяц, ₽", max_digits=9, decimal_places=2, null=True, blank=True
    )

    allow_dynamic_pricing = models.BooleanField(
        "Динамическая цена (AI)",
        default=False,
        help_text="Если включено, тариф может корректироваться рекомендациями AI.",
    )

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=SpotStatus.choices,
        default=SpotStatus.ACTIVE,
    )

    occupancy_7d = models.FloatField(
        "Загруженность за 7 дней (0..1)",
        default=0.0,
        help_text=(
            "Доля времени, когда место было занято за последние 7 дней. "
            "Обновляется фоновыми задачами AI."
        ),
    )

    class Meta:
        verbose_name = "Парковочное место"
        verbose_name_plural = "Парковочные места"
        ordering = ("lot__name", "name")

    def __str__(self) -> str:
        return f"{self.lot.name} — {self.name}"

    @property
    def owner(self):
        """
        Для IsOwnerObject из core.permissions: владелец места = владелец ParkingLot.
        """
        return self.lot.owner

    @property
    def city(self) -> str:
        return self.lot.city

    @property
    def is_active(self) -> bool:
        return (
            self.status == self.SpotStatus.ACTIVE
            and self.lot.is_active
            and self.lot.is_approved
        )


class Booking(TimeStampedModel):
    """
    Бронирование парковочного места.
    """

    class BookingType(models.TextChoices):
        HOURLY = "hourly", "Почасовая"
        DAILY = "daily", "Суточная"
        NIGHT = "night", "Ночная"
        WEEKLY = "weekly", "Недельная"
        MONTHLY = "monthly", "Месячная"

    class Status(models.TextChoices):
        PENDING = "pending", "Ожидает оплаты"
        CONFIRMED = "confirmed", "Подтверждена"
        ACTIVE = "active", "Активна"
        COMPLETED = "completed", "Завершена"
        CANCELLED = "cancelled", "Отменена"
        EXPIRED = "expired", "Истекла"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="bookings",
        verbose_name="Пользователь",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.PROTECT,
        related_name="bookings",
        verbose_name="Парковочное место",
    )
    vehicle = models.ForeignKey(
        "vehicles.Vehicle",
        on_delete=models.SET_NULL,
        related_name="bookings",
        verbose_name="Транспорт",
        null=True,
        blank=True,
    )

    booking_type = models.CharField(
        "Тип бронирования",
        max_length=16,
        choices=BookingType.choices,
        default=BookingType.HOURLY,
    )

    start_at = models.DateTimeField("Начало брони")
    end_at = models.DateTimeField("Окончание брони")

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.PENDING,
    )
    total_price = models.DecimalField(
        "Итоговая стоимость, ₽", max_digits=10, decimal_places=2
    )
    currency = models.CharField("Валюта", max_length=8, default="RUB")
    is_paid = models.BooleanField("Оплачено", default=False)
    dynamic_pricing_applied = models.BooleanField(
        "Динамическое ценообразование", default=False
    )
    ai_snapshot = models.JSONField(
        "AI snapshot",
        null=True,
        blank=True,
        help_text="Данные решений AI (цены, доступность, риски)",
    )

    external_payment_id = models.CharField(
        "ID платежа провайдера",
        max_length=64,
        blank=True,
        help_text="Связка с платежом у провайдера (например, YooKassa payment_id).",
    )

    class Meta:
        verbose_name = "Бронирование"
        verbose_name_plural = "Бронирования"
        ordering = ("-start_at",)

    def __str__(self) -> str:
        return f"Бронь #{self.pk} — {self.spot} ({self.start_at} → {self.end_at})"

    @property
    def owner(self):
        """
        Для удобства — владелец места, по которому идёт бронь.
        """
        return self.spot.lot.owner

    @staticmethod
    def is_spot_available(
        spot: ParkingSpot,
        start_at,
        end_at,
        exclude_booking_id: Optional[int] = None,
    ) -> bool:
        """
        Проверка пересечения интервалов с существующими бронями.
        """
        qs = Booking.objects.filter(spot=spot).exclude(
            status__in=[Booking.Status.CANCELLED, Booking.Status.EXPIRED]
        )
        if exclude_booking_id:
            qs = qs.exclude(id=exclude_booking_id)
        # Пересечение интервалов: (start1 < end2) и (end1 > start2)
        overlap = qs.filter(start_at__lt=end_at, end_at__gt=start_at).exists()
        return not overlap

    def calculate_price(self) -> Decimal:
        """
        Простая модель расчёта цены на основе тарифов ParkingSpot и типа брони.
        """

        if not self.spot:
            return Decimal("0.00")

        delta = self.end_at - self.start_at
        total_hours = Decimal(delta.total_seconds()) / Decimal(3600)
        total_days = Decimal(delta.total_seconds()) / Decimal(86400)

        base_price = Decimal("0.00")

        if self.booking_type == self.BookingType.HOURLY:
            hourly = self.spot.hourly_price
            units = max(
                Decimal("1"),
                total_hours.to_integral_value(rounding=ROUND_UP),
            )
            base_price = hourly * units
        elif self.booking_type == self.BookingType.DAILY:
            daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
            units = max(
                Decimal("1"),
                total_days.to_integral_value(rounding=ROUND_UP),
            )
            base_price = daily * units
        elif self.booking_type == self.BookingType.NIGHT:
            nightly = self.spot.nightly_price or (
                self.spot.hourly_price * Decimal("10")
            )
            base_price = nightly
        elif self.booking_type == self.BookingType.WEEKLY:
            daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
            units = max(
                Decimal("1"),
                (total_days / Decimal("7")).to_integral_value(rounding=ROUND_UP),
            )
            base_price = daily * Decimal("7") * units
        elif self.booking_type == self.BookingType.MONTHLY:
            monthly = self.spot.monthly_price or (
                (self.spot.daily_price or self.spot.hourly_price * Decimal("24"))
                * Decimal("30")
            )
            units = max(
                Decimal("1"),
                (total_days / Decimal("30")).to_integral_value(rounding=ROUND_UP),
            )
            base_price = monthly * units
        else:
            base_price = self.spot.hourly_price * max(
                Decimal("1"),
                total_hours.to_integral_value(rounding=ROUND_UP),
            )

        base_price = base_price.quantize(Decimal("0.01"))

        commission_percent = getattr(settings, "SERVICE_COMMISSION_PERCENT", 0)
        commission = (
            base_price * Decimal(commission_percent) / Decimal("100")
        ).quantize(Decimal("0.01"))
        total = (base_price + commission).quantize(Decimal("0.01"))
        self.total_price = total
        return total

    def mark_paid(self, payment_id: str | None = None) -> None:
        """
        Отметить бронь как оплаченную (вызывается из модуля payments по webhook).
        """
        self.is_paid = True
        self.status = self.Status.CONFIRMED
        if payment_id:
            self.external_payment_id = payment_id
        self.save(update_fields=["is_paid", "status", "external_payment_id"])

    @property
    def has_started(self) -> bool:
        return self.start_at <= timezone.now()

    @property
    def has_ended(self) -> bool:
        return self.end_at <= timezone.now()

    @property
    def duration(self) -> timedelta:
        return self.end_at - self.start_at


class WaitlistEntry(TimeStampedModel):
    """
    Запись в листе ожидания для занятого места.
    """

    class Status(models.TextChoices):
        WAITING = "waiting", "Ожидает"
        NOTIFIED = "notified", "Уведомлён"
        BOOKED = "booked", "Авто‑бронирование создано"
        CANCELLED = "cancelled", "Отменено"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="waitlist_entries",
        verbose_name="Пользователь",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.CASCADE,
        related_name="waitlist_entries",
        verbose_name="Парковочное место",
    )
    desired_start = models.DateTimeField("Желаемое начало")
    desired_end = models.DateTimeField("Желаемое окончание")
    auto_book = models.BooleanField(
        "Авто‑бронирование",
        default=False,
        help_text="Если включено, при освобождении места будет создана бронь автоматически.",
    )
    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.WAITING,
    )

    class Meta:
        verbose_name = "Запись в листе ожидания"
        verbose_name_plural = "Лист ожидания"
        ordering = ("-created_at",)
        unique_together = ("user", "spot", "desired_start", "desired_end")

    def __str__(self) -> str:
        return f"Waitlist #{self.pk} — {self.user} → {self.spot}"


class Complaint(TimeStampedModel):
    """
    Жалоба по бронированию/месту:
    - чужая машина;
    - пользователь не приехал;
    - частые отмены и т.п.
    """

    class Category(models.TextChoices):
        FOREIGN_CAR = "foreign_car", "Чужая машина на месте"
        NO_SHOW = "no_show", "Пользователь не приехал"
        NO_FREE_SPOT = "no_free_spot", "Не нашёл свободного места"
        OTHER = "other", "Другое"

    class Status(models.TextChoices):
        NEW = "new", "Новая"
        IN_PROGRESS = "in_progress", "В работе"
        RESOLVED = "resolved", "Решена"
        REJECTED = "rejected", "Отклонена"

    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="complaints",
        verbose_name="Автор",
    )
    booking = models.ForeignKey(
        Booking,
        on_delete=models.SET_NULL,
        related_name="complaints",
        null=True,
        blank=True,
        verbose_name="Бронирование",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.SET_NULL,
        related_name="complaints",
        null=True,
        blank=True,
        verbose_name="Парковочное место",
    )

    category = models.CharField(
        "Категория",
        max_length=32,
        choices=Category.choices,
        default=Category.OTHER,
    )
    description = models.TextField("Описание", blank=True)

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.NEW,
    )

    class Meta:
        verbose_name = "Жалоба"
        verbose_name_plural = "Жалобы"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Жалоба #{self.pk} ({self.get_category_display()})"


class FavoriteParkingSpot(TimeStampedModel):
    """Избранные парковочные места пользователя."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="favorite_spots",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.CASCADE,
        related_name="favorites",
    )
    note = models.CharField("Заметка", max_length=120, blank=True)

    class Meta:
        verbose_name = "Избранное место"
        verbose_name_plural = "Избранные места"
        ordering = ("-created_at",)
        unique_together = ("user", "spot")

    def __str__(self) -> str:
        return f"{self.user} → {self.spot}"


class SavedPlace(TimeStampedModel):
    """Сохранённые точки (дом/офис) для быстрого поиска."""

    class PlaceType(models.TextChoices):
        HOME = "home", "Дом"
        WORK = "work", "Офис"
        CUSTOM = "custom", "Другое"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="saved_places",
    )
    title = models.CharField("Название", max_length=64)
    place_type = models.CharField(
        "Тип точки",
        max_length=16,
        choices=PlaceType.choices,
        default=PlaceType.CUSTOM,
    )
    latitude = models.FloatField("Широта")
    longitude = models.FloatField("Долгота")

    class Meta:
        verbose_name = "Сохранённая точка"
        verbose_name_plural = "Сохранённые точки"
        ordering = ("title",)
        unique_together = ("user", "title")

    def __str__(self) -> str:
        return f"{self.title} ({self.user})"


class PushSubscription(TimeStampedModel):
    """Хранение WebPush‑подписок для уведомлений."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="push_subscriptions",
        null=True,
        blank=True,
    )
    endpoint = models.URLField(unique=True)
    p256dh = models.CharField(max_length=255)
    auth = models.CharField(max_length=255)
    platform = models.CharField(max_length=64, blank=True)
    user_agent = models.CharField(max_length=255, blank=True)

    class Meta:
        verbose_name = "Push-подписка"
        verbose_name_plural = "Push-подписки"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"{self.user or 'guest'} {self.endpoint[:32]}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 142
PATH: parking\push.py
LANG: python
===== CONTENT START =====
"""Lightweight push notification service wrapper.

The module intentionally avoids binding to a specific provider. It validates
payloads and envelopes and provides a single entry point that backend code can
call without caring about transport details.
"""
from __future__ import annotations

import json
import logging
import os
from typing import Iterable, Optional

from parking.models import PushSubscription

logger = logging.getLogger(__name__)


class PushTransportError(Exception):
    """Raised when the configured push transport fails."""


def _vapid_keys() -> tuple[Optional[str], Optional[str]]:
    return os.getenv("PUSH_VAPID_PUBLIC_KEY"), os.getenv("PUSH_VAPID_PRIVATE_KEY")


def send_parking_notification(user, payload: dict, subscriptions: Optional[Iterable[PushSubscription]] = None) -> int:
    """Send a WebPush notification to the provided subscriptions.

    The function is transport-agnostic; actual integration with a provider
    (VAPID/FCM/etc.) should be added where marked. Returns number of successfully
    queued notifications.
    """

    public_key, private_key = _vapid_keys()
    if not public_key or not private_key:
        logger.info("Push skipped: VAPID keys are not configured")
        return 0

    subs = list(subscriptions or [])
    if not subs and user:
        subs = list(PushSubscription.objects.filter(user=user))
    if not subs:
        return 0

    # Normalize payload to expected shape consumed by service worker
    normalized = {
        "title": payload.get("title") or "ParkShare",
        "body": payload.get("body") or "Новые события по бронированиям",
        "data": payload.get("data") or {},
        "actions": payload.get("actions") or [],
    }

    delivered = 0
    for sub in subs:
        try:
            # TODO: plug in concrete push provider here (pywebpush/FCM/etc.)
            logger.debug("Would send push to %s", sub.endpoint)
            _ = json.dumps(normalized, ensure_ascii=False)  # payload validation
            delivered += 1
        except Exception as exc:  # pragma: no cover - integration placeholder
            logger.warning("Push delivery failed, dropping subscription %s: %s", sub.id, exc)
            sub.delete()
    return delivered

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 143
PATH: parking\serializers.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from django.utils import timezone
from rest_framework import serializers

from core.utils import haversine_distance_km
from ai.orchestrator import apply_ai_pricing
from .models import (
    Booking,
    Complaint,
    FavoriteParkingSpot,
    ParkingLot,
    ParkingSpot,
    PushSubscription,
    SavedPlace,
    WaitlistEntry,
)


class ParkingLotSerializer(serializers.ModelSerializer):
    owner = serializers.ReadOnlyField(source="owner.username")
    spots_count = serializers.SerializerMethodField()

    class Meta:
        model = ParkingLot
        fields = (
            "id",
            "name",
            "city",
            "address",
            "parking_type",
            "description",
            "latitude",
            "longitude",
            "is_active",
            "is_approved",
            "is_private",
            "owner",
            "spots_count",
        )
        read_only_fields = ("id", "is_approved", "owner", "spots_count")

    def get_spots_count(self, obj: ParkingLot) -> int:
        return obj.spots.filter(status=ParkingSpot.SpotStatus.ACTIVE).count()

    def create(self, validated_data):
        """
        При создании парковки автоматически подставляем owner из request
        и синхронизируем PointField / lat / lng, если координаты заданы.
        """
        request = self.context.get("request")
        owner = getattr(request, "user", None)
        if owner is not None and owner.is_authenticated:
            validated_data["owner"] = owner
        lot = super().create(validated_data)

        if lot.latitude is not None and lot.longitude is not None:
            lot.set_coordinates(lot.latitude, lot.longitude)
            lot.save(update_fields=["latitude", "longitude", "location"])
        return lot

    def update(self, instance: ParkingLot, validated_data):
        lat = validated_data.get("latitude", instance.latitude)
        lng = validated_data.get("longitude", instance.longitude)
        instance = super().update(instance, validated_data)
        instance.set_coordinates(lat, lng)
        instance.save(update_fields=["latitude", "longitude", "location"])
        return instance


class ParkingSpotSerializer(serializers.ModelSerializer):
    """
    Серилизатор спота для публичного API.

    Дополнительные read-only поля:
    - lot_name, city — для удобного отображения;
    - lot_latitude, lot_longitude, lot_address — чтобы рисовать маркеры на карте;
    - distance_km — расстояние от точки запроса (lat/lng) до лота.
    """

    lot_name = serializers.ReadOnlyField(source="lot.name")
    city = serializers.ReadOnlyField(source="lot.city")
    lot_latitude = serializers.ReadOnlyField(source="lot.latitude")
    lot_longitude = serializers.ReadOnlyField(source="lot.longitude")
    lot_address = serializers.ReadOnlyField(source="lot.address")
    distance_km = serializers.SerializerMethodField()

    class Meta:
        model = ParkingSpot
        fields = (
            "id",
            "lot",
            "lot_name",
            "city",
            "lot_latitude",
            "lot_longitude",
            "lot_address",
            "name",
            "description",
            "vehicle_type",
            "is_covered",
            "has_ev_charging",
            "is_24_7",
            "max_height_m",
            "hourly_price",
            "nightly_price",
            "daily_price",
            "monthly_price",
            "allow_dynamic_pricing",
            "status",
            "distance_km",
        )
        read_only_fields = (
            "id",
            "lot_name",
            "city",
            "lot_latitude",
            "lot_longitude",
            "lot_address",
            "distance_km",
        )

    def get_distance_km(self, obj: ParkingSpot):
        """
        Если атрибут distance_km уже повешен во viewset — используем его.
        Иначе считаем по lat/lng из query-параметров (если они заданы).
        """
        distance = getattr(obj, "distance_km", None)
        if distance is not None:
            return round(float(distance), 2)

        request = self.context.get("request")
        if not request:
            return None
        lat_param = request.query_params.get("lat")
        lng_param = request.query_params.get("lng")
        if not lat_param or not lng_param:
            return None
        if obj.lot.latitude is None or obj.lot.longitude is None:
            return None

        try:
            lat = float(lat_param)
            lng = float(lng_param)
        except (TypeError, ValueError):
            return None

        return round(
            haversine_distance_km(lat, lng, obj.lot.latitude, obj.lot.longitude), 2
        )


class BookingSerializer(serializers.ModelSerializer):
    user = serializers.ReadOnlyField(source="user.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")
    lot_name = serializers.ReadOnlyField(source="spot.lot.name")

    class Meta:
        model = Booking
        fields = (
            "id",
            "user",
            "spot",
            "spot_name",
            "lot_name",
            "vehicle",
            "booking_type",
            "start_at",
            "end_at",
            "status",
            "total_price",
            "currency",
            "is_paid",
            "created_at",
            "updated_at",
            "external_payment_id",
        )
        read_only_fields = (
            "id",
            "user",
            "status",
            "total_price",
            "currency",
            "is_paid",
            "created_at",
            "updated_at",
            "external_payment_id",
            "spot_name",
            "lot_name",
        )

    def validate(self, attrs):
        """
        Базовая валидация бронирования:
        - start < end
        - не в прошлом
        - место активно
        - нет пересечения с другими бронями.
        """
        request = self.context["request"]
        spot: ParkingSpot = attrs.get("spot", getattr(self.instance, "spot", None))
        start_at = attrs.get("start_at", getattr(self.instance, "start_at", None))
        end_at = attrs.get("end_at", getattr(self.instance, "end_at", None))
        booking_type = attrs.get(
            "booking_type",
            getattr(self.instance, "booking_type", Booking.BookingType.HOURLY),
        )

        if not spot or not start_at or not end_at:
            raise serializers.ValidationError(
                "Необходимо указать место и интервал бронирования."
            )

        if start_at >= end_at:
            raise serializers.ValidationError(
                "Дата начала должна быть меньше даты окончания."
            )

        if start_at < timezone.now():
            raise serializers.ValidationError(
                "Нельзя создавать бронирование в прошлом."
            )

        if not spot.is_active:
            raise serializers.ValidationError(
                "Выбранное место сейчас недоступно для бронирования."
            )

        exclude_id = self.instance.id if self.instance else None
        if not Booking.is_spot_available(
            spot, start_at, end_at, exclude_booking_id=exclude_id
        ):
            raise serializers.ValidationError(
                "На выбранный период это место уже забронировано."
            )

        attrs["spot"] = spot
        attrs["start_at"] = start_at
        attrs["end_at"] = end_at
        attrs["booking_type"] = booking_type
        return attrs

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        booking = Booking(
            user=user,
            **validated_data,
        )
        booking.total_price = booking.calculate_price()
        booking.currency = "RUB"
        booking.status = Booking.Status.PENDING
        apply_ai_pricing(booking)
        booking.save()
        return booking

    def update(self, instance, validated_data):
        for field in ("spot", "start_at", "end_at", "booking_type", "vehicle"):
            if field in validated_data:
                setattr(instance, field, validated_data[field])

        # Для простоты разрешаем редактировать только PENDING‑брони.
        if instance.status != Booking.Status.PENDING:
            raise serializers.ValidationError(
                "Можно редактировать только бронирования в статусе 'Ожидает оплаты'."
            )

        instance.total_price = instance.calculate_price()
        apply_ai_pricing(instance)
        instance.save()
        return instance


class WaitlistEntrySerializer(serializers.ModelSerializer):
    user = serializers.ReadOnlyField(source="user.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")

    class Meta:
        model = WaitlistEntry
        fields = (
            "id",
            "user",
            "spot",
            "spot_name",
            "desired_start",
            "desired_end",
            "auto_book",
            "status",
            "created_at",
            "updated_at",
        )
        read_only_fields = (
            "id",
            "user",
            "spot_name",
            "status",
            "created_at",
            "updated_at",
        )

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        entry = WaitlistEntry.objects.create(user=user, **validated_data)
        return entry


class ComplaintSerializer(serializers.ModelSerializer):
    author = serializers.ReadOnlyField(source="author.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")
    booking_id = serializers.ReadOnlyField(source="booking.id")

    class Meta:
        model = Complaint
        fields = (
            "id",
            "author",
            "booking",
            "booking_id",
            "spot",
            "spot_name",
            "category",
            "description",
            "status",
            "created_at",
            "updated_at",
        )
        read_only_fields = (
            "id",
            "author",
            "status",
            "created_at",
            "updated_at",
            "spot_name",
            "booking_id",
        )

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        complaint = Complaint.objects.create(author=user, **validated_data)
        return complaint


class FavoriteParkingSpotSerializer(serializers.ModelSerializer):
    spot_name = serializers.ReadOnlyField(source="spot.name")
    lot_name = serializers.ReadOnlyField(source="spot.lot.name")
    city = serializers.ReadOnlyField(source="spot.lot.city")

    class Meta:
        model = FavoriteParkingSpot
        fields = (
            "id",
            "spot",
            "spot_name",
            "lot_name",
            "city",
            "note",
            "created_at",
        )
        read_only_fields = ("id", "spot_name", "lot_name", "city", "created_at")

    def create(self, validated_data):
        request = self.context.get("request")
        if request and request.user.is_authenticated:
            validated_data["user"] = request.user
        return super().create(validated_data)


class SavedPlaceSerializer(serializers.ModelSerializer):
    class Meta:
        model = SavedPlace
        fields = (
            "id",
            "title",
            "place_type",
            "latitude",
            "longitude",
            "created_at",
        )
        read_only_fields = ("id", "created_at")

    def create(self, validated_data):
        request = self.context.get("request")
        if request and request.user.is_authenticated:
            validated_data["user"] = request.user
        return super().create(validated_data)


class PushSubscriptionSerializer(serializers.ModelSerializer):
    class Meta:
        model = PushSubscription
        fields = (
            "id",
            "endpoint",
            "p256dh",
            "auth",
            "platform",
            "user_agent",
            "created_at",
        )
        read_only_fields = ("id", "created_at")

    def create(self, validated_data):
        request = self.context.get("request")
        if request:
            validated_data.setdefault("user_agent", request.META.get("HTTP_USER_AGENT", ""))
            if request.user.is_authenticated:
                validated_data.setdefault("user", request.user)
        return super().create(validated_data)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 144
PATH: parking\tasks.py
LANG: python
===== CONTENT START =====
# backend/parking/tasks.py

from __future__ import annotations

from datetime import timedelta

from celery import shared_task
from django.utils import timezone

from .models import Booking


@shared_task
def expire_unpaid_bookings() -> str:
    """
    Фоновая задача: помечает как EXPIRED неоплаченные бронирования,
    у которых время начала уже давно прошло.

    Подключена в CELERY_BEAT_SCHEDULE как parking.tasks.expire_unpaid_bookings.
    """

    now = timezone.now()
    grace = timedelta(minutes=15)  # "льготный" период
    qs = Booking.objects.filter(
        status=Booking.Status.PENDING,
        is_paid=False,
        start_at__lt=now - grace,
    )
    count = qs.count()
    for booking in qs:
        booking.status = Booking.Status.EXPIRED
        booking.save(update_fields=["status"])
    return f"Expired {count} unpaid bookings"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 145
PATH: parking\urls.py
LANG: python
===== CONTENT START =====
# backend/parking/urls.py

from django.urls import path

app_name = "parking"

urlpatterns: list = [
    # На данный момент все HTML‑страницы подключаются напрямую из config.urls.
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 146
PATH: parking\views.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from typing import Any, Iterable, List

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.cache import cache
from django.db.models import Q
import math
import requests
from django.shortcuts import redirect
from django.urls import reverse
from django.views.generic import TemplateView
from rest_framework import permissions, status, viewsets
from rest_framework.response import Response

from core.permissions import IsAdminOrReadOnly
from core.utils import haversine_distance_km, parse_float
from vehicles.models import Vehicle

from .models import (
    Booking,
    Complaint,
    FavoriteParkingSpot,
    ParkingLot,
    ParkingSpot,
    PushSubscription,
    SavedPlace,
    WaitlistEntry,
)
from .serializers import (
    BookingSerializer,
    ComplaintSerializer,
    FavoriteParkingSpotSerializer,
    ParkingLotSerializer,
    ParkingSpotSerializer,
    PushSubscriptionSerializer,
    SavedPlaceSerializer,
    WaitlistEntrySerializer,
)


# =======================
#   DRF ViewSets (API)
# =======================


class ParkingLotViewSet(viewsets.ModelViewSet):
    """
    CRUD по объектам парковки.

    - GET /api/parking/lots/ — список (фильтрация по городу/типу)
    - POST /api/parking/lots/ — создать (только владельцы/админы)
    """

    serializer_class = ParkingLotSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        qs = ParkingLot.objects.select_related("owner")
        user = self.request.user
        if not user.is_authenticated or (
            not user.is_staff and not getattr(user, "is_owner", False)
        ):
            qs = qs.filter(is_active=True, is_approved=True)

        city = self.request.query_params.get("city")
        if city:
            qs = qs.filter(city__iexact=city)

        parking_type = self.request.query_params.get("parking_type")
        if parking_type:
            qs = qs.filter(parking_type=parking_type)

        return qs

    def perform_create(self, serializer):
        user = self.request.user
        if not user.is_authenticated or not getattr(user, "is_owner", False):
            raise permissions.PermissionDenied(
                "Создавать объекты парковки могут только пользователи с ролью 'owner' или администраторы."
            )
        serializer.save(owner=user)


class ParkingSpotViewSet(viewsets.ModelViewSet):
    """
    CRUD по парковочным местам.

    - GET /api/parking/spots/?lat=.&lng=.&radius_km=2 — места рядом
    - Фильтры: ?city=, ?vehicle_type=, ?max_price=, ?has_ev=1, ?covered=1, ?is_24_7=1
    """

    serializer_class = ParkingSpotSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        qs = ParkingSpot.objects.select_related("lot", "lot__owner").all()
        user = self.request.user

        if self.request.method in ("GET", "HEAD", "OPTIONS"):
            qs = qs.filter(
                status=ParkingSpot.SpotStatus.ACTIVE,
                lot__is_active=True,
                lot__is_approved=True,
            )
        else:
            # Управлять местами может только владелец/админ
            if not user.is_authenticated or (
                not getattr(user, "is_owner", False) and not user.is_superuser
            ):
                return ParkingSpot.objects.none()
            qs = qs.filter(lot__owner=user)

        # Фильтрация
        params = self.request.query_params
        city = params.get("city")
        if city:
            qs = qs.filter(lot__city__iexact=city)

        vehicle_type = params.get("vehicle_type")
        if vehicle_type:
            qs = qs.filter(vehicle_type=vehicle_type)

        max_price = parse_float(params.get("max_price"))
        if max_price is not None:
            qs = qs.filter(hourly_price__lte=max_price)

        has_ev = params.get("has_ev")
        if has_ev == "1":
            qs = qs.filter(has_ev_charging=True)

        covered = params.get("covered")
        if covered == "1":
            qs = qs.filter(is_covered=True)

        is_24_7 = params.get("is_24_7")
        if is_24_7 == "1":
            qs = qs.filter(is_24_7=True)

        return qs

    def list(self, request, *args, **kwargs):
        """
        Список мест c опциональной фильтрацией по радиусу от точки (lat/lng).
        """
        queryset = self.filter_queryset(self.get_queryset())

        try:
            page_size = int(request.query_params.get("page_size") or 50)
        except (TypeError, ValueError):
            page_size = 50
        page_size = min(max(page_size, 1), 100)
        if hasattr(self, "paginator"):
            self.paginator.page_size = page_size

        lat = parse_float(request.query_params.get("lat"))
        lng = parse_float(request.query_params.get("lng"))
        radius_km = parse_float(request.query_params.get("radius_km")) or 5
        radius_km = min(radius_km, 25)

        if lat is not None and lng is not None and radius_km is not None:
            lat_delta = radius_km / 111  # приблизительно ~111 км на градус
            lng_delta = radius_km / max(1, 111 * math.cos(math.radians(lat)))
            queryset = queryset.filter(
                lot__latitude__gte=lat - lat_delta,
                lot__latitude__lte=lat + lat_delta,
                lot__longitude__gte=lng - lng_delta,
                lot__longitude__lte=lng + lng_delta,
            )
            # Python‑фильтрация по расстоянию (работает и без PostGIS)
            filtered: List[ParkingSpot] = []
            for spot in queryset:
                lot = spot.lot
                if lot.latitude is None or lot.longitude is None:
                    continue
                distance = haversine_distance_km(
                    lat, lng, lot.latitude, lot.longitude
                )
                if distance <= radius_km:
                    spot.distance_km = distance  # для сериализатора
                    filtered.append(spot)
            queryset = filtered

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            response = self.get_paginated_response(serializer.data)
            self._maybe_cache_response(request, response.data)
            return response

        serializer = self.get_serializer(queryset, many=True)
        data = serializer.data
        self._maybe_cache_response(request, data)
        return Response(data)

    def _maybe_cache_response(self, request, data):
        user = request.user
        if user.is_authenticated:
            return
        lat = parse_float(request.query_params.get("lat"))
        lng = parse_float(request.query_params.get("lng"))
        if lat is None or lng is None:
            return
        cache_key = "spots:{lat:.4f}:{lng:.4f}:{radius}:{page}:{size}".format(
            lat=lat,
            lng=lng,
            radius=request.query_params.get("radius_km") or "default",
            page=request.query_params.get("page") or "1",
            size=request.query_params.get("page_size") or "",
        )
        cache.set(cache_key, data, 60)


class BookingViewSet(viewsets.ModelViewSet):
    """
    Бронирования.

    - Пользователь видит свои бронирования.
    - Владелец видит свои бронирования и брони по своим местам.
    """

    serializer_class = BookingSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Booking.objects.select_related(
            "spot", "spot__lot", "user", "vehicle"
        ).all()
        if not user.is_authenticated:
            return Booking.objects.none()

        if user.is_superuser:
            return qs

        if getattr(user, "is_owner", False):
            return qs.filter(Q(user=user) | Q(spot__lot__owner=user))
        return qs.filter(user=user)

    def perform_create(self, serializer):
        booking = serializer.save()
        return booking

    def destroy(self, request, *args, **kwargs):
        """
        Отмена бронирования: помечаем как CANCELLED, если оно ещё не началось.
        """
        instance: Booking = self.get_object()
        if instance.has_started:
            return Response(
                {"detail": "Нельзя отменить уже начавшееся бронирование."},
                status=status.HTTP_400_BAD_REQUEST,
            )
        instance.status = Booking.Status.CANCELLED
        instance.save(update_fields=["status"])
        return Response(status=status.HTTP_204_NO_CONTENT)


class WaitlistViewSet(viewsets.ModelViewSet):
    """
    Лист ожидания. Пользователь управляет только своими записями.
    Админ может видеть всё.
    """

    serializer_class = WaitlistEntrySerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = WaitlistEntry.objects.select_related("spot", "spot__lot", "user")
        if user.is_superuser:
            return qs
        return qs.filter(user=user)


class ComplaintViewSet(viewsets.ModelViewSet):
    """
    Жалобы. Создатель видит свои, админ — все.
    """

    serializer_class = ComplaintSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Complaint.objects.select_related("author", "spot", "booking")
        if user.is_superuser:
            return qs
        return qs.filter(author=user)

    def perform_create(self, serializer):
        serializer.save(author=self.request.user)


class FavoriteParkingSpotViewSet(viewsets.ModelViewSet):
    """API избранных парковочных мест."""

    serializer_class = FavoriteParkingSpotSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = FavoriteParkingSpot.objects.select_related("spot", "spot__lot")
        if user.is_superuser:
            return qs
        return qs.filter(user=user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class SavedPlaceViewSet(viewsets.ModelViewSet):
    """Сохранённые точки (дом/офис)."""

    serializer_class = SavedPlaceSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = SavedPlace.objects.all()
        if user.is_superuser:
            return qs
        return qs.filter(user=user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class PushSubscriptionViewSet(viewsets.ModelViewSet):
    """Регистрация WebPush подписок."""

    serializer_class = PushSubscriptionSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return PushSubscription.objects.none()
        return PushSubscription.objects.filter(user=user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user if self.request.user.is_authenticated else None)


# =======================
#   HTML-вьюхи
# =======================


class LandingPageView(TemplateView):
    """
    Лендинг с картой и списком парковок/мест.
    Поддерживает фильтры:
    - city
    - lat, lng, radius_km (поиск по радиусу)
    """

    template_name = "parking/landing.html"

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        city = (self.request.GET.get("city") or "").strip()
        ctx["lots"] = []  # данные отдаём через API, чтобы не дублировать шаблонную логику
        ctx["spots"] = []
        ctx["has_query"] = bool(city)
        ctx["spots_total"] = ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        ).count()
        return ctx


class MapPageView(LandingPageView):
    """Полноэкранная карта с теми же данными, что и лендинг."""

    template_name = "parking/map_fullscreen.html"


class PWAInstallGuideView(TemplateView):
    """Простая страница с инструкциями по установке PWA."""

    template_name = "parking/pwa_install.html"


class UserDashboardView(LoginRequiredMixin, TemplateView):
    """
    Личный кабинет водителя: его машины и бронирования.
    """

    template_name = "parking/user_dashboard.html"

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        user = self.request.user
        vehicles = Vehicle.objects.filter(owner=user).order_by("-created_at")
        bookings = (
            Booking.objects.filter(user=user)
            .select_related("spot", "spot__lot")
            .order_by("-start_at")
        )
        ctx["vehicles"] = vehicles
        ctx["bookings"] = bookings
        return ctx


class OwnerDashboardView(LoginRequiredMixin, TemplateView):
    """
    Кабинет владельца: его паркинги, места и бронирования по ним.
    """

    template_name = "parking/owner_dashboard.html"

    def dispatch(self, request, *args, **kwargs):
        user = request.user
        if not (getattr(user, "is_owner", False) or user.is_superuser):
            # Если не владелец — отправляем в обычный кабинет
            return redirect("user_dashboard")
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        user = self.request.user
        lots = (
            ParkingLot.objects.filter(owner=user)
            .prefetch_related("spots")
            .order_by("city", "name")
        )
        spots = (
            ParkingSpot.objects.filter(lot__owner=user)
            .select_related("lot")
            .order_by("lot__city", "lot__name", "name")
        )
        bookings = (
            Booking.objects.filter(spot__lot__owner=user)
            .select_related("spot", "spot__lot", "user")
            .order_by("-start_at")
        )
        ctx["lots"] = lots
        ctx["spots"] = spots
        ctx["bookings"] = bookings
        return ctx

# parking/views.py (добавить после существующих APIView/ ViewSet)

from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from ai.orchestrator import AvailabilityDecision
from .models import ParkingSpot


class ParkingMapAPIView(APIView):
    """
    Лёгкий эндпоинт для карты:
    - фильтры по цене/фичам;
    - возвращает GeoJSON‑подобную структуру (features).
    """

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        params = request.query_params
        only_free = params.get("only_free") == "true"
        has_ev = params.get("ev") == "true"
        covered = params.get("covered") == "true"
        is_24_7 = params.get("is_24_7") == "true"
        ai_only = params.get("ai_recommended") == "true"

        try:
            min_price = float(params.get("min_price") or 0)
        except ValueError:
            min_price = 0.0
        try:
            max_price = float(params.get("max_price") or 0)
        except ValueError:
            max_price = 0.0

        qs = ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        ).select_related("lot")

        if has_ev:
            qs = qs.filter(has_ev_charging=True)
        if covered:
            qs = qs.filter(is_covered=True)
        if is_24_7:
            qs = qs.filter(is_24_7=True)
        if min_price:
            qs = qs.filter(hourly_price__gte=min_price)
        if max_price:
            qs = qs.filter(hourly_price__lte=max_price)
        if ai_only:
            qs = qs.filter(allow_dynamic_pricing=True)

        features = []
        for spot in qs[:500]:  # safety limit
            lat = getattr(spot.lot, "latitude", None)
            lng = getattr(spot.lot, "longitude", None)
            if lat is None or lng is None:
                continue

            availability_score = 1.0 - float(spot.occupancy_7d or 0.0)
            is_free_like = availability_score > 0.3

            if only_free and not is_free_like:
                continue

            features.append(
                {
                    "id": str(spot.id),
                    "type": "Feature",
                    "geometry": {
                        "type": "Point",
                        "coordinates": [lng, lat],
                    },
                    "properties": {
                        "spot_id": str(spot.id),
                        "lot_id": str(spot.lot_id),
                        "lot_name": spot.lot.name,
                        "city": spot.lot.city,
                        "address": spot.lot.address,
                        "name": spot.name,
                        "vehicle_type": spot.vehicle_type,
                        "has_ev_charging": spot.has_ev_charging,
                        "is_covered": spot.is_covered,
                        "is_24_7": spot.is_24_7,
                        "hourly_price": float(spot.hourly_price),
                        "allow_dynamic_pricing": spot.allow_dynamic_pricing,
                        "occupancy_7d": float(spot.occupancy_7d or 0.0),
                        "stress_index": float(spot.lot.stress_index or 0.0),
                    },
                }
            )

        return Response(
            {
                "type": "FeatureCollection",
                "features": features,
            }
        )


class GeocodeAPIView(APIView):
    """Простой прокси к Nominatim с кешированием."""

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        query = (request.query_params.get("q") or "").strip()
        if not query:
            return Response({"detail": "q is required"}, status=status.HTTP_400_BAD_REQUEST)

        cache_key = f"geocode:{query}"
        cached = cache.get(cache_key)
        if cached:
            return Response(cached)

        url = "https://nominatim.openstreetmap.org/search"
        resp = requests.get(
            url,
            params={"q": query, "format": "json", "limit": 5, "addressdetails": 1},
            headers={"User-Agent": "ParkShare-RU/1.0"},
            timeout=10,
        )
        resp.raise_for_status()
        data = resp.json()
        results = [
            {
                "title": item.get("display_name"),
                "lat": float(item.get("lat")),
                "lng": float(item.get("lon")),
            }
            for item in data
        ]
        payload = {"results": results}
        cache.set(cache_key, payload, 60 * 10)
        return Response(payload)


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 147
PATH: parking\management\commands\seed_demo_parking.py
LANG: python
===== CONTENT START =====
# parking/management/commands/seed_demo_parking.py

from __future__ import annotations

from decimal import Decimal

from django.contrib.auth import get_user_model
from django.core.management.base import BaseCommand
from django.db import transaction

from parking.models import ParkingLot, ParkingSpot


class Command(BaseCommand):
    help = "Создаёт демо-объект парковки и несколько мест для локальной разработки."

    def handle(self, *args, **options):
        User = get_user_model()

        # ---------- 1. Владелец парковки ----------
        role_cls = getattr(User, "Role", None)
        owner_role_value = getattr(role_cls, "OWNER", None) if role_cls else None

        owner_defaults = {
            "email": "demo-owner@example.com",
            "is_active": True,
        }
        if owner_role_value is not None:
            owner_defaults["role"] = owner_role_value

        owner, created_owner = User.objects.get_or_create(
            username="demo_owner",
            defaults=owner_defaults,
        )

        if created_owner:
            owner.set_password("demo_owner")
            owner.save(update_fields=["password"])
            self.stdout.write(
                self.style.SUCCESS(
                    "Создан пользователь-владелец demo_owner / пароль: demo_owner"
                )
            )
        else:
            self.stdout.write(
                self.style.SUCCESS(f"Найден владелец demo_owner (id={owner.pk})")
            )

        # ---------- 2. Объект парковки ----------
        with transaction.atomic():
            lot, created_lot = ParkingLot.objects.get_or_create(
                name="Демо-парковка ParkShare",
                city="Москва",
                address="ул. Примерная, д. 1",
                defaults={
                    "owner": owner,
                    "parking_type": "yard",  # см. choices в миграции
                    "latitude": 55.751244,
                    "longitude": 37.618423,
                    "is_active": True,
                    "is_approved": True,
                    "is_private": False,
                },
            )

            if not created_lot:
                # На всякий случай привязываем к нашему демо-владельцу
                if lot.owner_id != owner.id:
                    lot.owner = owner
                    lot.save(update_fields=["owner"])
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Используем существующую парковку (id={lot.pk})"
                    )
                )
            else:
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Создана демо-парковка (id={lot.pk}) в Москве"
                    )
                )

            # ---------- 3. Парковочные места ----------
            spots_spec = [
                {
                    "name": "Место 1 — EV 24/7",
                    "description": "Рядом с въездом, есть зарядка для EV.",
                    "is_covered": False,
                    "has_ev_charging": True,
                    "is_24_7": True,
                    "hourly_price": Decimal("120.00"),
                    "allow_dynamic_pricing": True,
                    "occupancy_7d": 0.65,
                },
                {
                    "name": "Место 2 — крытое",
                    "description": "Крытое место на -1 этаже.",
                    "is_covered": True,
                    "has_ev_charging": False,
                    "is_24_7": True,
                    "hourly_price": Decimal("90.00"),
                    "allow_dynamic_pricing": False,
                    "occupancy_7d": 0.40,
                },
                {
                    "name": "Место 3 — бюджетное",
                    "description": "Самое дешёвое, но чуть дальше от выезда.",
                    "is_covered": False,
                    "has_ev_charging": False,
                    "is_24_7": True,
                    "hourly_price": Decimal("70.00"),
                    "allow_dynamic_pricing": True,
                    "occupancy_7d": 0.80,
                },
                {
                    "name": "Место 4 — премиум",
                    "description": "Широкое место, удобно для кроссоверов.",
                    "is_covered": True,
                    "has_ev_charging": True,
                    "is_24_7": True,
                    "hourly_price": Decimal("150.00"),
                    "allow_dynamic_pricing": True,
                    "occupancy_7d": 0.55,
                },
            ]

            created_count = 0
            for spec in spots_spec:
                spot, created_spot = ParkingSpot.objects.get_or_create(
                    lot=lot,
                    name=spec["name"],
                    defaults=spec,
                )
                if created_spot:
                    created_count += 1

            total_spots = ParkingSpot.objects.filter(lot=lot).count()
            self.stdout.write(
                self.style.SUCCESS(
                    f"Готово: мест в демо-парковке сейчас {total_spots} "
                    f"(создано за этот запуск {created_count})."
                )
            )

        self.stdout.write(self.style.SUCCESS("seed_demo_parking: демо-данные готовы."))

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 148
PATH: parking\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
import parking.models
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('vehicles', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Booking',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('booking_type', models.CharField(choices=[('hourly', 'Почасовая'), ('daily', 'Суточная'), ('night', 'Ночная'), ('weekly', 'Недельная'), ('monthly', 'Месячная')], default='hourly', max_length=16, verbose_name='Тип бронирования')),
                ('start_at', models.DateTimeField(verbose_name='Начало брони')),
                ('end_at', models.DateTimeField(verbose_name='Окончание брони')),
                ('status', models.CharField(choices=[('pending', 'Ожидает оплаты'), ('confirmed', 'Подтверждена'), ('active', 'Активна'), ('completed', 'Завершена'), ('cancelled', 'Отменена'), ('expired', 'Истекла')], default='pending', max_length=16, verbose_name='Статус')),
                ('total_price', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Итоговая стоимость, ₽')),
                ('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
                ('is_paid', models.BooleanField(default=False, verbose_name='Оплачено')),
                ('external_payment_id', models.CharField(blank=True, help_text='Связка с платежом у провайдера (например, YooKassa payment_id).', max_length=64, verbose_name='ID платежа провайдера')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
                ('vehicle', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='bookings', to='vehicles.vehicle', verbose_name='Транспорт')),
            ],
            options={
                'verbose_name': 'Бронирование',
                'verbose_name_plural': 'Бронирования',
                'ordering': ('-start_at',),
            },
        ),
        migrations.CreateModel(
            name='ParkingLot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=255, verbose_name='Название')),
                ('city', models.CharField(max_length=100, verbose_name='Город')),
                ('address', models.CharField(max_length=255, verbose_name='Адрес')),
                ('parking_type', models.CharField(choices=[('yard', 'Дворовая парковка'), ('underground', 'Подземная парковка'), ('multilevel', 'Многоуровневая парковка'), ('street', 'Уличная парковка'), ('office', 'Офисная парковка'), ('home', 'Домашнее место')], default='yard', max_length=32, verbose_name='Тип парковки')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('location', parking.models.PointField(blank=True, null=True, verbose_name='Точка на карте')),
                ('latitude', models.FloatField(blank=True, null=True, verbose_name='Широта')),
                ('longitude', models.FloatField(blank=True, null=True, verbose_name='Долгота')),
                ('is_active', models.BooleanField(default=True, verbose_name='Активен')),
                ('is_approved', models.BooleanField(default=False, help_text='Одобряется администратором перед публикацией.', verbose_name='Одобрен модерацией')),
                ('is_private', models.BooleanField(default=False, help_text='Если включено, объект виден только по прямым ссылкам/владельцу.', verbose_name='Приватный')),
                ('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='parking_lots', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
            ],
            options={
                'verbose_name': 'Объект парковки',
                'verbose_name_plural': 'Объекты парковки',
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='ParkingSpot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=64, verbose_name='Название/номер места')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
                ('is_covered', models.BooleanField(default=False, verbose_name='Крытое место')),
                ('has_ev_charging', models.BooleanField(default=False, verbose_name='Есть зарядка')),
                ('is_24_7', models.BooleanField(default=True, verbose_name='Круглосуточно')),
                ('max_height_m', models.DecimalField(blank=True, decimal_places=2, max_digits=4, null=True, verbose_name='Максимальная высота (м)')),
                ('hourly_price', models.DecimalField(decimal_places=2, max_digits=8, verbose_name='Цена за час, ₽')),
                ('nightly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за ночь, ₽')),
                ('daily_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за сутки, ₽')),
                ('monthly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=9, null=True, verbose_name='Цена за месяц, ₽')),
                ('allow_dynamic_pricing', models.BooleanField(default=False, help_text='Если включено, тариф может корректироваться рекомендациями AI.', verbose_name='Динамическая цена (AI)')),
                ('status', models.CharField(choices=[('active', 'Активно'), ('inactive', 'Неактивно')], default='active', max_length=16, verbose_name='Статус')),
                ('lot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='spots', to='parking.parkinglot', verbose_name='Объект парковки')),
            ],
            options={
                'verbose_name': 'Парковочное место',
                'verbose_name_plural': 'Парковочные места',
                'ordering': ('lot__name', 'name'),
            },
        ),
        migrations.CreateModel(
            name='Complaint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('category', models.CharField(choices=[('foreign_car', 'Чужая машина на месте'), ('no_show', 'Пользователь не приехал'), ('no_free_spot', 'Не нашёл свободного места'), ('other', 'Другое')], default='other', max_length=32, verbose_name='Категория')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('status', models.CharField(choices=[('new', 'Новая'), ('in_progress', 'В работе'), ('resolved', 'Решена'), ('rejected', 'Отклонена')], default='new', max_length=16, verbose_name='Статус')),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='complaints', to=settings.AUTH_USER_MODEL, verbose_name='Автор')),
                ('booking', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.booking', verbose_name='Бронирование')),
                ('spot', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.parkingspot', verbose_name='Парковочное место')),
            ],
            options={
                'verbose_name': 'Жалоба',
                'verbose_name_plural': 'Жалобы',
                'ordering': ('-created_at',),
            },
        ),
        migrations.AddField(
            model_name='booking',
            name='spot',
            field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='bookings', to='parking.parkingspot', verbose_name='Парковочное место'),
        ),
        migrations.CreateModel(
            name='WaitlistEntry',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('desired_start', models.DateTimeField(verbose_name='Желаемое начало')),
                ('desired_end', models.DateTimeField(verbose_name='Желаемое окончание')),
                ('auto_book', models.BooleanField(default=False, help_text='Если включено, при освобождении места будет создана бронь автоматически.', verbose_name='Авто‑бронирование')),
                ('status', models.CharField(choices=[('waiting', 'Ожидает'), ('notified', 'Уведомлён'), ('booked', 'Авто‑бронирование создано'), ('cancelled', 'Отменено')], default='waiting', max_length=16, verbose_name='Статус')),
                ('spot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to='parking.parkingspot', verbose_name='Парковочное место')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
            ],
            options={
                'verbose_name': 'Запись в листе ожидания',
                'verbose_name_plural': 'Лист ожидания',
                'ordering': ('-created_at',),
                'unique_together': {('user', 'spot', 'desired_start', 'desired_end')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 149
PATH: parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-22 11:21

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('parking', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='parkinglot',
            name='stress_index',
            field=models.FloatField(default=0.0, help_text='Средняя загруженность мест за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Индекс загруженности (0..1)'),
        ),
        migrations.AddField(
            model_name='parkingspot',
            name='occupancy_7d',
            field=models.FloatField(default=0.0, help_text='Доля времени, когда место было занято за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Загруженность за 7 дней (0..1)'),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 150
PATH: parking\migrations\0003_booking_ai_fields.py
LANG: python
===== CONTENT START =====
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("parking", "0002_parkinglot_stress_index_parkingspot_occupancy_7d"),
    ]

    operations = [
        migrations.AddField(
            model_name="booking",
            name="ai_snapshot",
            field=models.JSONField(blank=True, help_text="Данные решений AI (цены, доступность, риски)", null=True, verbose_name="AI snapshot"),
        ),
        migrations.AddField(
            model_name="booking",
            name="dynamic_pricing_applied",
            field=models.BooleanField(default=False, verbose_name="Динамическое ценообразование"),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 151
PATH: parking\migrations\0004_favoriteparkingspot_savedplace.py
LANG: python
===== CONTENT START =====
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ('parking', '0003_booking_ai_fields'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='FavoriteParkingSpot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('note', models.CharField(blank=True, max_length=120, verbose_name='Заметка')),
                ('spot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='favorites', to='parking.parkingspot')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='favorite_spots', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Избранное место',
                'verbose_name_plural': 'Избранные места',
                'ordering': ('-created_at',),
                'unique_together': {('user', 'spot')},
            },
        ),
        migrations.CreateModel(
            name='SavedPlace',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('title', models.CharField(max_length=64, verbose_name='Название')),
                ('place_type', models.CharField(choices=[('home', 'Дом'), ('work', 'Офис'), ('custom', 'Другое')], default='custom', max_length=16, verbose_name='Тип точки')),
                ('latitude', models.FloatField(verbose_name='Широта')),
                ('longitude', models.FloatField(verbose_name='Долгота')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='saved_places', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Сохранённая точка',
                'verbose_name_plural': 'Сохранённые точки',
                'ordering': ('title',),
                'unique_together': {('user', 'title')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 152
PATH: parking\migrations\0005_pushsubscription.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-12-06 10:47

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("parking", "0004_favoriteparkingspot_savedplace"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="PushSubscription",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "created_at",
                    models.DateTimeField(
                        auto_now_add=True, verbose_name="Дата создания"
                    ),
                ),
                (
                    "updated_at",
                    models.DateTimeField(auto_now=True, verbose_name="Дата обновления"),
                ),
                ("endpoint", models.URLField(unique=True)),
                ("p256dh", models.CharField(max_length=255)),
                ("auth", models.CharField(max_length=255)),
                ("platform", models.CharField(blank=True, max_length=64)),
                ("user_agent", models.CharField(blank=True, max_length=255)),
                (
                    "user",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="push_subscriptions",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
            options={
                "verbose_name": "Push-подписка",
                "verbose_name_plural": "Push-подписки",
                "ordering": ("-created_at",),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 153
PATH: parking\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 154
PATH: parking\tests\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 155
PATH: parking\tests\test_pwa_endpoints.py
LANG: python
===== CONTENT START =====
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

import django
from django.conf import settings
from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient


class PushSubscriptionAPITest(TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        django.setup()
        settings.ALLOWED_HOSTS.append("testserver")

    def setUp(self):
        self.client = APIClient()

    def test_requires_payload(self):
        url = reverse('push-subscription-list')
        resp = self.client.post(url, {}, format='json')
        self.assertEqual(resp.status_code, 403)

    def test_authenticated_create(self):
        User = get_user_model()
        user = User.objects.create_user(username='pwa-user', password='pw')
        self.client.force_authenticate(user)
        url = reverse('push-subscription-list')
        payload = {
            'endpoint': 'https://example.com/sub',
            'p256dh': 'key',
            'auth': 'auth',
        }
        resp = self.client.post(url, payload, format='json')
        self.assertEqual(resp.status_code, 201)
        self.assertEqual(resp.data['endpoint'], payload['endpoint'])

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 156
PATH: payments\__init__.py
LANG: python
===== CONTENT START =====
default_app_config = "payments.apps.PaymentsConfig"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 157
PATH: payments\admin.py
LANG: python
===== CONTENT START =====
from django.contrib import admin

from .models import Payment


@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "booking",
        "payer",
        "provider",
        "provider_payment_id",
        "amount",
        "currency",
        "status",
        "success",
        "failure",
        "created_at",
    )
    list_filter = (
        "provider",
        "status",
        "success",
        "failure",
        "created_at",
    )
    search_fields = ("provider_payment_id", "booking__id", "payer__username")
    autocomplete_fields = ("booking", "payer")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 158
PATH: payments\apps.py
LANG: python
===== CONTENT START =====
from django.apps import AppConfig


class PaymentsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "payments"
    verbose_name = "Платежи"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 159
PATH: payments\models.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from decimal import Decimal
from typing import Any, Optional

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


class Payment(TimeStampedModel):
    """
    Платёж за бронирование через внешнего провайдера (по умолчанию — YooKassa).

    Для простоты в текущей реализации у каждой брони может быть не более
    одного связанного платежа (OneToOne), который используется повторно
    при повторных попытках оплаты, пока не станет успешным или не будет
    отменён/завершён с ошибкой.
    """

    class Provider(models.TextChoices):
        YOOKASSA = "yookassa", "YooKassa"
        STRIPE = "stripe", "Stripe"

    class Status(models.TextChoices):
        CREATED = "created", _("Создан")
        PENDING = "pending", _("Ожидает оплаты")
        SUCCEEDED = "succeeded", _("Успешен")
        CANCELLED = "cancelled", _("Отменён")
        FAILED = "failed", _("Ошибка")

    booking = models.OneToOneField(
        "parking.Booking",
        on_delete=models.CASCADE,
        related_name="payment",
        verbose_name=_("Бронь"),
    )
    payer = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="payments",
        verbose_name=_("Плательщик"),
    )

    provider = models.CharField(
        _("Провайдер"),
        max_length=32,
        choices=Provider.choices,
        default=Provider.YOOKASSA,
    )
    provider_payment_id = models.CharField(
        _("ID платежа у провайдера"),
        max_length=128,
        blank=True,
        db_index=True,
    )

    amount = models.DecimalField(
        _("Сумма"),
        max_digits=10,
        decimal_places=2,
    )
    currency = models.CharField(
        _("Валюта"),
        max_length=8,
        default="RUB",
    )

    status = models.CharField(
        _("Статус"),
        max_length=16,
        choices=Status.choices,
        default=Status.CREATED,
        db_index=True,
    )
    success = models.BooleanField(_("Успешен"), default=False)
    failure = models.BooleanField(_("Ошибка"), default=False)

    raw_response = models.JSONField(
        _("Ответ провайдера"),
        null=True,
        blank=True,
        help_text=_("Сырые данные, вернувшиеся при создании платежа."),
    )
    raw_webhook = models.JSONField(
        _("Последний webhook"),
        null=True,
        blank=True,
        help_text=_("Последнее уведомление провайдера по этому платежу."),
    )

    class Meta:
        verbose_name = _("Платёж")
        verbose_name_plural = _("Платежи")
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Payment #{self.pk} for booking #{self.booking_id}"

    @property
    def is_active(self) -> bool:
        """
        "Активный" платёж — тот, который ещё может сменить состояние на успешное.
        """
        return self.status in {self.Status.CREATED, self.Status.PENDING}

    def _update_status(
        self,
        status: str,
        success: bool,
        failure: bool,
        webhook_data: Optional[dict[str, Any]] = None,
    ) -> None:
        self.status = status
        self.success = success
        self.failure = failure
        if webhook_data is not None:
            self.raw_webhook = webhook_data
        self.save(
            update_fields=[
                "status",
                "success",
                "failure",
                "raw_webhook",
                "updated_at",
            ]
        )

    def mark_succeeded(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как успешный и вызывает booking.mark_paid(...).

        Вызывается из обработчика вебхуков YooKassa после подтверждения
        успешного платежа.
        """
        self._update_status(
            status=self.Status.SUCCEEDED,
            success=True,
            failure=False,
            webhook_data=webhook_data,
        )

        # Обновляем связанную бронь.
        booking = self.booking
        if booking:
            booking.mark_paid(payment_id=self.provider_payment_id or "")

    def mark_failed(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как неуспешный (ошибка).
        """
        self._update_status(
            status=self.Status.FAILED,
            success=False,
            failure=True,
            webhook_data=webhook_data,
        )

    def mark_cancelled(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как отменённый пользователем или провайдером.
        """
        self._update_status(
            status=self.Status.CANCELLED,
            success=False,
            failure=True,
            webhook_data=webhook_data,
        )


class PaymentMethod(TimeStampedModel):
    """
    Привязанный способ оплаты (карта/кошелёк), без хранения PAN.

    Данные карты хранятся в токенизированном виде у провайдера эквайринга,
    здесь остаётся только маска и метаданные для UI. Настоящий токен
    хранится в encrypted поле token_masked, чтобы можно было инициировать
    повторные списания в будущем.
    """

    class Brand(models.TextChoices):
        VISA = "visa", "VISA"
        MASTERCARD = "mc", "Mastercard"
        MIR = "mir", "Мир"
        UNIONPAY = "up", "UnionPay"
        OTHER = "other", "Другая"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="payment_methods",
        verbose_name=_("Пользователь"),
    )
    label = models.CharField(
        _("Название"),
        max_length=64,
        blank=True,
        help_text=_("Например: 'Личная', 'Для работы', 'Юрлицо'."),
    )
    brand = models.CharField(
        _("Бренд"),
        max_length=16,
        choices=Brand.choices,
        default=Brand.OTHER,
    )
    last4 = models.CharField(_("Последние 4 цифры"), max_length=4)
    exp_month = models.PositiveSmallIntegerField(_("Месяц окончания"))
    exp_year = models.PositiveSmallIntegerField(_("Год окончания"))
    is_default = models.BooleanField(_("По умолчанию"), default=False)
    token_masked = models.CharField(
        _("Токен/маска"),
        max_length=255,
        help_text=_("Служебный идентификатор платёжного провайдера."),
    )

    class Meta:
        verbose_name = _("Способ оплаты")
        verbose_name_plural = _("Способы оплаты")
        ordering = ("-is_default", "-created_at")
        unique_together = ("user", "token_masked")

    def __str__(self) -> str:
        return f"{self.get_brand_display()} ****{self.last4}"

    def save(self, *args, **kwargs):
        if self.is_default:
            PaymentMethod.objects.filter(user=self.user, is_default=True).exclude(
                pk=self.pk
            ).update(is_default=False)
        return super().save(*args, **kwargs)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 160
PATH: payments\providers.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import uuid
from decimal import Decimal
from typing import Any, Tuple

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

try:
    # Официальный синхронный SDK YooKassa
    from yookassa import Configuration, Payment as YooPayment  # type: ignore[import]
except ImportError:  # pragma: no cover - мягкий фолбэк
    Configuration = None
    YooPayment = None


class YooKassaError(Exception):
    """Базовая ошибка при работе с YooKassa."""


def _configure_yookassa() -> None:
    """
    Настраивает SDK YooKassa из Django settings.

    Требуются:
    - YOOKASSA_SHOP_ID
    - YOOKASSA_SECRET_KEY
    """
    if Configuration is None or YooPayment is None:
        raise ImproperlyConfigured(
            "Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
        )

    shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
    secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
    if not shop_id or not secret_key:
        raise ImproperlyConfigured(
            "Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
        )

    Configuration.account_id = shop_id
    Configuration.secret_key = secret_key


def create_yookassa_payment(booking) -> Tuple[str, str, dict[str, Any]]:
    """
    Создаёт платёж в YooKassa для указанной брони.

    Возвращает:
        (payment_url, provider_payment_id, raw_response_dict)

    Все сетевые вызовы инкапсулированы здесь.
    """
    _configure_yookassa()

    from parking.models import Booking  # локальный импорт, чтобы избежать циклов

    if not isinstance(booking, Booking):
        raise YooKassaError("create_yookassa_payment ожидает экземпляр Booking.")

    amount = booking.total_price
    if not isinstance(amount, Decimal):
        amount = Decimal(str(amount))

    amount_str = str(amount.quantize(Decimal("0.01")))
    currency = booking.currency or "RUB"
    return_url = getattr(settings, "YOOKASSA_RETURN_URL", "")

    description = f"Оплата брони #{booking.id} — {booking.spot}"

    payload: dict[str, Any] = {
        "amount": {
            "value": amount_str,
            "currency": currency,
        },
        "confirmation": {
            "type": "redirect",
            "return_url": return_url,
        },
        "capture": True,
        "description": description,
        "metadata": {
            "booking_id": str(booking.id),
            "user_id": str(booking.user_id),
        },
    }

    try:
        payment = YooPayment.create(payload, uuid.uuid4())
    except Exception as exc:  # noqa: BLE001
        raise YooKassaError(str(exc)) from exc

    confirmation = getattr(payment, "confirmation", None)
    payment_url = getattr(confirmation, "confirmation_url", None) if confirmation else None
    provider_payment_id = getattr(payment, "id", None)

    if not payment_url or not provider_payment_id:
        raise YooKassaError(
            "Некорректный ответ от YooKassa: не получены id или URL оплаты."
        )

    raw_response = {
        "id": provider_payment_id,
        "status": getattr(payment, "status", None),
    }

    return payment_url, provider_payment_id, raw_response

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 161
PATH: payments\serializers.py
LANG: python
===== CONTENT START =====
# payments/serializers.py

from __future__ import annotations

from typing import Any, Dict

from django.conf import settings
from django.urls import reverse
from rest_framework import serializers

from parking.models import Booking
from .models import Payment, PaymentMethod
from .providers import get_payment_provider


class PaymentSerializer(serializers.ModelSerializer):
    """
    Создание платежа для бронирования.

    Поток:
      - клиент вызывает POST /api/payments/ с booking_id;
      - сериализатор поднимает Booking, вызывает AI-ценообразование (если нужно – уже
        сделано при создании брони), берёт итоговую сумму;
      - выбирает провайдера по REGION/PLATFORM (YooKassa для RU, Stripe для GLOBAL);
      - создаёт payment в БД и у провайдера;
      - возвращает клиенту payment_url, по которому можно уйти на оплату.

    Важно: бизнес-логика расчёта цены (включая AI) находится в booking/ai,
    здесь только оркестрация и адаптеры к платёжным провайдерам.
    """

    booking_id = serializers.UUIDField(write_only=True)
    payment_url = serializers.SerializerMethodField(read_only=True)

    class Meta:
        model = Payment
        fields = (
            "id",
            "booking_id",
            "amount",
            "currency",
            "status",
            "provider",
            "provider_payment_id",
            "created_at",
            "updated_at",
            "payment_url",
        )
        read_only_fields = (
            "id",
            "amount",
            "currency",
            "status",
            "provider",
            "provider_payment_id",
            "created_at",
            "updated_at",
            "payment_url",
        )

    def validate_booking_id(self, value):
        try:
            booking = Booking.objects.select_related("spot", "spot__lot").get(pk=value)
        except Booking.DoesNotExist:
            raise serializers.ValidationError("Бронирование не найдено.")
        if booking.status not in (
            Booking.Status.PENDING,
            Booking.Status.CONFIRMED,
        ):
            raise serializers.ValidationError(
                "Платёж можно создать только для ожидающего/подтверждённого бронирования."
            )
        return value

    def _get_booking(self, booking_id) -> Booking:
        return Booking.objects.select_related("spot", "spot__lot").get(pk=booking_id)

    def create(self, validated_data: Dict[str, Any]) -> Payment:
        request = self.context.get("request")
        booking_id = validated_data["booking_id"]
        booking = self._get_booking(booking_id)

        # Сумма для оплаты – итоговая цена брони (уже с AI-ценообразованием, если применено)
        amount = booking.total_price
        currency = getattr(settings, "DEFAULT_CURRENCY", "RUB")

        # Выбор провайдера:
        #   - для RU профиль по умолчанию будет YooKassa (см. .env/.env.prod);
        #   - для GLOBAL можно выставить stripe в PAYMENT_PROVIDER/DEFAULT_PAYMENT_PROVIDER.
        provider = get_payment_provider()

        payment = Payment.objects.create(
            booking=booking,
            amount=amount,
            currency=currency,
            provider=provider.code,
            status=Payment.Status.CREATED,
        )

        # URL возврата пользователя после оплаты
        if request is not None:
            return_url = request.build_absolute_uri(
                reverse("payments:return")  # см. urls в payments/views
            )
            webhook_url = request.build_absolute_uri(
                reverse("payments:webhook", kwargs={"provider": provider.code})
            )
        else:
            # fallback для внутренних вызовов/тестов
            return_url = getattr(settings, "YOOKASSA_RETURN_URL", "/")
            webhook_url = ""

        # Вызов провайдера (адаптер)
        provider_response = provider.create_payment(
            payment=payment,
            return_url=return_url,
            webhook_url=webhook_url,
        )

        # Ожидаем, что адаптер вернёт структуру с provider_payment_id и
        # опциональным полем payment_url/confirmation_url.
        payment.provider_payment_id = provider_response.get("id") or provider_response.get(
            "provider_payment_id", ""
        )
        payment.raw_response = provider_response
        payment.save(update_fields=["provider_payment_id", "raw_response"])

        return payment

    def get_payment_url(self, obj: Payment) -> str | None:
        """
        Вытаскиваем URL для редиректа пользователя из raw_response.
        Для YooKassa это обычно confirmation.redirect_url,
        для Stripe – session.url и т.п.
        """
        data = obj.raw_response or {}
        # Общий подход: пытаемся найти наиболее очевидные поля
        return (
            data.get("payment_url")
            or data.get("confirmation_url")
            or (data.get("confirmation") or {}).get("confirmation_url")
            or (data.get("session") or {}).get("url")
        )


class PaymentMethodSerializer(serializers.ModelSerializer):
    """Сериализатор для сохранённых карт/кошельков."""

    mask = serializers.SerializerMethodField(read_only=True)

    class Meta:
        model = PaymentMethod
        fields = (
            "id",
            "label",
            "brand",
            "last4",
            "exp_month",
            "exp_year",
            "is_default",
            "token_masked",
            "mask",
            "created_at",
        )
        read_only_fields = ("id", "mask", "created_at")

    def get_mask(self, obj: PaymentMethod) -> str:
        return f"**** **** **** {obj.last4}"

    def create(self, validated_data):
        request = self.context.get("request")
        if request and request.user.is_authenticated:
            validated_data["user"] = request.user
        return super().create(validated_data)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 162
PATH: payments\tasks.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from celery import shared_task

from .models import Payment


@shared_task
def check_stale_payments() -> str:
    """
    Заготовка фоновой задачи для проверки "зависших" платежей.

    В будущей версии здесь можно реализовать:
    - поиск платежей в статусе PENDING слишком долго;
    - запрос их фактического состояния у YooKassa;
    - перевод в FAILED/CANCELLED при необходимости.
    """
    pending_count = Payment.objects.filter(status=Payment.Status.PENDING).count()
    return f"Pending payments count: {pending_count}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 163
PATH: payments\views.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from django.conf import settings
from rest_framework import mixins, permissions, status, viewsets
from rest_framework.response import Response
from rest_framework.views import APIView

from .models import Payment, PaymentMethod
from .serializers import PaymentMethodSerializer, PaymentSerializer
from .providers.registry import get_payment_provider


class PaymentViewSet(
    mixins.CreateModelMixin,
    mixins.ListModelMixin,
    mixins.RetrieveModelMixin,
    viewsets.GenericViewSet,
):
    """
    API платежей:

    - GET  /api/payments/       — список платежей текущего пользователя;
    - POST /api/payments/       — начать оплату для брони;
    - GET  /api/payments/{id}/  — детали платежа.

    Только владелец платежа видит свои платежи; админ — все.
    """

    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Payment.objects.select_related(
            "booking",
            "booking__spot",
            "booking__spot__lot",
            "payer",
        )
        if not user.is_authenticated:
            return Payment.objects.none()
        if user.is_superuser:
            return qs
        return qs.filter(payer=user)

    def perform_create(self, serializer: PaymentSerializer) -> None:
        serializer.save()


class PaymentMethodViewSet(
    mixins.CreateModelMixin,
    mixins.ListModelMixin,
    mixins.UpdateModelMixin,
    mixins.DestroyModelMixin,
    viewsets.GenericViewSet,
):
    """
    Мини-API для управления сохранёнными картами в ЛК.

    POST /api/payment-methods/ — добавить карту (пока без реального токенизации);
    GET  /api/payment-methods/ — список карт пользователя;
    DELETE /api/payment-methods/{id}/ — удалить карту.
    """

    serializer_class = PaymentMethodSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return PaymentMethod.objects.none()
        if user.is_superuser:
            return PaymentMethod.objects.select_related("user").order_by("-is_default", "-created_at")
        return PaymentMethod.objects.filter(user=user).order_by("-is_default", "-created_at")

    def perform_create(self, serializer: PaymentMethodSerializer) -> None:
        serializer.save(user=self.request.user)

    def perform_update(self, serializer: PaymentMethodSerializer) -> None:
        serializer.save(user=self.request.user)


class YooKassaWebhookView(APIView):
    """
    Обработчик webhook‑уведомлений YooKassa.

    URL: /payments/webhook/yookassa/  (см. backend.config.urls)

    Ожидается JSON вида:

    {
        "event": "payment.succeeded",
        "object": {
            "id": "...",
            "status": "succeeded",
            ...
        }
    }

    Подпись/секрет проверяется по заголовку X-Yookassa-Signature
    (или X-Yookassa-Webhook-Secret), который совпадает с
    settings.YOOKASSA_WEBHOOK_SECRET. Если секрет не задан, проверка
    подписи пропускается.
    """

    authentication_classes: list = []
    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        secret_expected = getattr(settings, "YOOKASSA_WEBHOOK_SECRET", "")
        if secret_expected:
            signature = (
                request.headers.get("X-Yookassa-Signature")
                or request.headers.get("X-Yookassa-Webhook-Secret")
            )
            if not signature or signature != secret_expected:
                return Response(
                    {"detail": "Invalid webhook signature"},
                    status=status.HTTP_403_FORBIDDEN,
                )

        data = request.data or {}
        event = data.get("event")
        obj = data.get("object") or {}
        provider_payment_id = obj.get("id")

        if not provider_payment_id:
            return Response(
                {"detail": "Missing payment id"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            payment = Payment.objects.select_related("booking").get(
                provider_payment_id=provider_payment_id
            )
        except Payment.DoesNotExist:
            return Response(
                {"detail": "Payment not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        status_from_provider = obj.get("status")
        payment.raw_webhook = data

        if status_from_provider == "succeeded" or event == "payment.succeeded":
            payment.mark_succeeded(webhook_data=data)
        elif status_from_provider in ("canceled", "cancelled") or event == "payment.canceled":
            payment.mark_cancelled(webhook_data=data)
        else:
            # Любые промежуточные статусы считаем ожидающими
            payment.status = Payment.Status.PENDING
            payment.success = False
            payment.failure = False
            payment.save(
                update_fields=["status", "success", "failure", "raw_webhook", "updated_at"]
            )

        return Response({"detail": "ok"}, status=status.HTTP_200_OK)


class StripeWebhookView(APIView):
    """Простой webhook Stripe (stub)."""

    authentication_classes: list = []
    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        provider = get_payment_provider("stripe")
        payment = provider.handle_webhook(request)
        if not payment:
            return Response({"detail": "Payment not found"}, status=status.HTTP_404_NOT_FOUND)
        return Response({"detail": "ok"}, status=status.HTTP_200_OK)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 164
PATH: payments\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('parking', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('provider', models.CharField(choices=[('yookassa', 'YooKassa')], default='yookassa', max_length=32, verbose_name='Провайдер')),
                ('provider_payment_id', models.CharField(blank=True, db_index=True, max_length=128, verbose_name='ID платежа у провайдера')),
                ('amount', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Сумма')),
                ('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
                ('status', models.CharField(choices=[('created', 'Создан'), ('pending', 'Ожидает оплаты'), ('succeeded', 'Успешен'), ('cancelled', 'Отменён'), ('failed', 'Ошибка')], db_index=True, default='created', max_length=16, verbose_name='Статус')),
                ('success', models.BooleanField(default=False, verbose_name='Успешен')),
                ('failure', models.BooleanField(default=False, verbose_name='Ошибка')),
                ('raw_response', models.JSONField(blank=True, help_text='Сырые данные, вернувшиеся при создании платежа.', null=True, verbose_name='Ответ провайдера')),
                ('raw_webhook', models.JSONField(blank=True, help_text='Последнее уведомление провайдера по этому платежу.', null=True, verbose_name='Последний webhook')),
                ('booking', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='payment', to='parking.booking', verbose_name='Бронь')),
                ('payer', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payments', to=settings.AUTH_USER_MODEL, verbose_name='Плательщик')),
            ],
            options={
                'verbose_name': 'Платёж',
                'verbose_name_plural': 'Платежи',
                'ordering': ('-created_at',),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 165
PATH: payments\migrations\0002_alter_payment_provider.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-23 12:00

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('payments', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='payment',
            name='provider',
            field=models.CharField(choices=[('yookassa', 'YooKassa'), ('stripe', 'Stripe')], default='yookassa', max_length=32, verbose_name='Провайдер'),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 166
PATH: payments\migrations\0003_paymentmethod.py
LANG: python
===== CONTENT START =====
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ('payments', '0002_alter_payment_provider'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='PaymentMethod',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('label', models.CharField(blank=True, help_text="Например: 'Личная', 'Для работы', 'Юрлицо'.", max_length=64, verbose_name='Название')),
                ('brand', models.CharField(choices=[('visa', 'VISA'), ('mc', 'Mastercard'), ('mir', 'Мир'), ('up', 'UnionPay'), ('other', 'Другая')], default='other', max_length=16, verbose_name='Бренд')),
                ('last4', models.CharField(max_length=4, verbose_name='Последние 4 цифры')),
                ('exp_month', models.PositiveSmallIntegerField(verbose_name='Месяц окончания')),
                ('exp_year', models.PositiveSmallIntegerField(verbose_name='Год окончания')),
                ('is_default', models.BooleanField(default=False, verbose_name='По умолчанию')),
                ('token_masked', models.CharField(help_text='Служебный идентификатор платёжного провайдера.', max_length=255, verbose_name='Токен/маска')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payment_methods', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
            ],
            options={
                'verbose_name': 'Способ оплаты',
                'verbose_name_plural': 'Способы оплаты',
                'ordering': ('-is_default', '-created_at'),
                'unique_together': {('user', 'token_masked')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 167
PATH: payments\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 168
PATH: payments\providers\__init__.py
LANG: python
===== CONTENT START =====
# payments/providers/__init__.py

from __future__ import annotations

from typing import Dict, Type

from django.conf import settings

from .base import BasePaymentProvider
from .yookassa import YooKassaProvider
from .stripe import StripeProvider


# Реестр провайдеров по коду
_PROVIDER_REGISTRY: Dict[str, Type[BasePaymentProvider]] = {
    "yookassa": YooKassaProvider,
    "yoomoney": YooKassaProvider,  # на будущее – алиас
    "stripe": StripeProvider,
    # сюда же можно добавить Sber, Tinkoff, Mir Pay, QIWI и т.д.
}


def get_payment_provider(name: str | None = None) -> BasePaymentProvider:
    """
    Возвращает инстанс провайдера платежей по имени.

    name:
      - None     -> берём DEFAULT_PAYMENT_PROVIDER / PAYMENT_PROVIDER из настроек
      - "yookassa", "stripe" и т.п.

    Для RU-профиля по умолчанию используется YooKassa, для GLOBAL – Stripe,
    но это задаётся в .env / настройках.
    """
    # Совместимость с разными именами переменных
    configured = getattr(settings, "DEFAULT_PAYMENT_PROVIDER", None) or getattr(
        settings, "PAYMENT_PROVIDER", "yookassa"
    )

    provider_name = (name or configured or "yookassa").lower()
    provider_cls = _PROVIDER_REGISTRY.get(provider_name)

    if provider_cls is None:
        raise ValueError(
            f"Unknown payment provider '{provider_name}'. "
            f"Доступные: {', '.join(sorted(_PROVIDER_REGISTRY.keys()))}"
        )

    return provider_cls()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 169
PATH: payments\providers\base.py
LANG: python
===== CONTENT START =====
# payments/providers/base.py

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Any, Dict, Optional

from ..models import Payment  # относительный импорт, чтобы избежать циклов


class BasePaymentProvider(ABC):
    """
    Базовый интерфейс платёжного провайдера.

    Этот класс — единая точка расширения для YooKassa, Stripe, Сбера и т.д.
    """

    @abstractmethod
    def create_payment(
        self,
        payment: Payment,
        return_url: str,
        webhook_url: str,
    ) -> Dict[str, Any]:
        """
        Создать платёж у провайдера и вернуть его данные (включая URL для подтверждения/оплаты).
        Должен вернуть словарь с полями вроде:
            {
                "payment_url": "...",
                "provider_payment_id": "...",
                ...
            }
        """
        raise NotImplementedError

    @abstractmethod
    def handle_webhook(self, request) -> Optional[Payment]:
        """
        Обработать webhook от провайдера и обновить Payment/Booking.

        Должен:
        - найти Payment по данным из webhook;
        - обновить статус/флаги;
        - вернуть обновлённый Payment (или None, если не найден/игнорируем).
        """
        raise NotImplementedError

    @abstractmethod
    def refund(self, payment: Payment, amount: Optional[float] = None) -> None:
        """
        Инициировать возврат по платежу (полный или частичный).
        """
        raise NotImplementedError


# ---------------------------------------------------------
# Обратная совместимость:
# старый код может импортировать PaymentProvider или BasePaymentProvider.
# ---------------------------------------------------------
PaymentProvider = BasePaymentProvider

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 170
PATH: payments\providers\registry.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from typing import Dict, Type

from django.core.exceptions import ImproperlyConfigured

from .base import PaymentProvider
from .stripe import StripeProvider
from .yookassa import YooKassaProvider

REGISTRY: Dict[str, Type[PaymentProvider]] = {
    "yookassa": YooKassaProvider,
    "stripe": StripeProvider,
}


def get_payment_provider(provider_key: str) -> PaymentProvider:
    provider_cls = REGISTRY.get(provider_key)
    if not provider_cls:
        raise ImproperlyConfigured(f"Unknown payment provider: {provider_key}")
    return provider_cls()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 171
PATH: payments\providers\stripe.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import uuid
from typing import Any, Dict, Optional

from django.conf import settings

from .base import PaymentProvider


class StripeProvider(PaymentProvider):
    key = "stripe"

    def create_payment(
        self, payment, return_url: str, webhook_url: str
    ) -> Dict[str, Any]:
        """Stub: эмуляция Stripe Checkout Session.

        В бою надо подключить stripe SDK и создать Checkout Session с
        success/cancel URL. Здесь формируется предсказуемая ссылка.
        """

        session_id = str(uuid.uuid4())
        confirmation_url = f"https://checkout.stripe.com/pay/{session_id}"
        return {
            "payment_url": confirmation_url,
            "provider_payment_id": session_id,
            "raw": {
                "mode": "payment",
                "return_url": return_url,
                "webhook": webhook_url,
            },
        }

    def handle_webhook(self, request) -> Optional["Payment"]:
        from payments.models import Payment

        payload = request.data or {}
        event_type = payload.get("type")
        data_object = payload.get("data", {}).get("object", {})
        provider_payment_id = data_object.get("id")
        if not provider_payment_id:
            return None

        try:
            payment = Payment.objects.select_related("booking").get(
                provider_payment_id=provider_payment_id
            )
        except Payment.DoesNotExist:
            return None

        if event_type == "checkout.session.completed":
            payment.mark_succeeded(webhook_data=payload)
        elif event_type == "payment_intent.payment_failed":
            payment.mark_failed(webhook_data=payload)
        return payment

    def refund(self, payment, amount: Optional[float] = None) -> None:
        # Заглушка — Stripe refund через SDK
        return None

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 172
PATH: payments\providers\yookassa.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from __future__ import annotations

import uuid
from decimal import Decimal
from typing import Any, Dict, Optional

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from .base import PaymentProvider

try:  # pragma: no cover - soft dependency
    from yookassa import Configuration, Payment as YooPayment  # type: ignore[import]
except ImportError:  # pragma: no cover - fallback
    Configuration = None
    YooPayment = None


class YooKassaError(Exception):
    """Базовая ошибка при работе с YooKassa."""


class YooKassaProvider(PaymentProvider):
    key = "yookassa"

    def _configure(self) -> None:
        if Configuration is None or YooPayment is None:
            raise ImproperlyConfigured(
                "Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
            )

        shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
        secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
        if not shop_id or not secret_key:
            raise ImproperlyConfigured(
                "Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
            )

        Configuration.account_id = shop_id
        Configuration.secret_key = secret_key

    def create_payment(
        self, payment, return_url: str, webhook_url: str
    ) -> Dict[str, Any]:
        self._configure()
        from parking.models import Booking  # локальный импорт

        booking: Booking = payment.booking
        amount = booking.total_price
        if not isinstance(amount, Decimal):
            amount = Decimal(str(amount))

        amount_str = str(amount.quantize(Decimal("0.01")))
        currency = booking.currency or "RUB"
        description = f"Оплата брони #{booking.id} — {booking.spot}"

        payload: dict[str, Any] = {
            "amount": {
                "value": amount_str,
                "currency": currency,
            },
            "confirmation": {
                "type": "redirect",
                "return_url": return_url,
            },
            "capture": True,
            "description": description,
            "metadata": {
                "booking_id": str(booking.id),
                "user_id": str(booking.user_id),
                "webhook": webhook_url,
            },
        }

        try:
            provider_payment = YooPayment.create(payload, uuid.uuid4())
        except Exception as exc:  # noqa: BLE001
            raise YooKassaError(str(exc)) from exc

        confirmation = getattr(provider_payment, "confirmation", None)
        payment_url = (
            getattr(confirmation, "confirmation_url", None) if confirmation else None
        )
        provider_payment_id = getattr(provider_payment, "id", None)

        if not payment_url or not provider_payment_id:
            raise YooKassaError(
                "Некорректный ответ от YooKassa: не получены id или URL оплаты."
            )

        raw_response = {
            "id": provider_payment_id,
            "status": getattr(provider_payment, "status", None),
        }

        return {
            "payment_url": payment_url,
            "provider_payment_id": provider_payment_id,
            "raw": raw_response,
        }

    def handle_webhook(self, request) -> Optional[Payment]:
        from payments.models import Payment

        data = request.data or {}
        event = data.get("event")
        obj = data.get("object") or {}
        provider_payment_id = obj.get("id")

        if not provider_payment_id:
            return None

        try:
            payment = Payment.objects.select_related("booking").get(
                provider_payment_id=provider_payment_id
            )
        except Payment.DoesNotExist:
            return None

        status_from_provider = obj.get("status")
        payment.raw_webhook = data

        if status_from_provider == "succeeded" or event == "payment.succeeded":
            payment.mark_succeeded(webhook_data=data)
        elif status_from_provider in ("canceled", "cancelled") or event == "payment.canceled":
            payment.mark_cancelled(webhook_data=data)
        else:
            payment.status = Payment.Status.PENDING
            payment.success = False
            payment.failure = False
            payment.save(
                update_fields=["status", "success", "failure", "raw_webhook", "updated_at"]
            )

        return payment

    def refund(self, payment, amount: Optional[float] = None) -> None:
        # Неполная реализация для MVP
        raise NotImplementedError("YooKassa refunds are not implemented in this stub.")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 173
PATH: regions\global.yml
LANG: yaml
===== CONTENT START =====
# Базовый глобальный профиль ParkShare (по умолчанию для не-RU регионов)

id: "global"
name: "ParkShare Global"

locale:
  default_language: "en"
  supported_languages:
    - "en"
    - "ru"

currency:
  default: "EUR"

maps:
  default_provider: "openstreetmap"
  fallback_provider: "none"

payments:
  gateways:
    - "stripe"
    - "paypal"

auth:
  providers:
    - "email-password"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 174
PATH: regions\ru.yml
LANG: yaml
===== CONTENT START =====
id: "ru"
name: "ParkShare RU"

locale:
  default_language: "ru"
  supported_languages:
    - "ru"
    - "en"

картография:
  основной_провайдер: "Яндекс.Карты API"
  резервный: "2GIS API"

платежные_системы:
  обязательные:
    - "Сбербанк Онлайн"
    - "Тинькофф"
    - "ЮMoney"
    - "Мир Pay"
    - "QIWI"

аутентификация:
  - "Госуслуги (ЕСИА)"
  - "ВК ID"
  - "Яндекс ID"
  - "Сбер ID"
  - "Email/Телефон (native)"

pricing:
  currency: "RUB"
  tax_included: true

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 175
PATH: services\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 176
PATH: services\llm.py
LANG: python
===== CONTENT START =====
# services/llm.py
"""Async client helpers for communicating with the LLM microservice."""
from __future__ import annotations

import logging
import os
from typing import Any, Dict, Iterable, List

import httpx

logger = logging.getLogger(__name__)

DEFAULT_TIMEOUT = 8.0
CONNECT_TIMEOUT = 3.0

# По умолчанию ожидаем локальный сервис на 8002 (см. docker-compose).
# 1) внутри docker-сети: llm_service:8002
# 2) с хоста: localhost:8002
DEFAULT_LLM_URLS: List[str] = [
    "http://llm_service:8002",
    "http://localhost:8002",
]

LEGACY_ENDPOINTS: List[str] = [
    "/parse",
    "/api/v1/llm/parse-search-query",
]

DEFAULT_RETRIES = 2


class LLMClientError(Exception):
    """Raised when the LLM service cannot process the request."""


def _candidate_endpoints() -> Iterable[str]:
    """Return candidate base URLs to try for the LLM service.

    Priority: explicit env var, then defaults (llm_service, localhost).
    """
    env_url = os.getenv("LLM_SERVICE_URL")
    if env_url:
        yield env_url.rstrip("/")

    for url in DEFAULT_LLM_URLS:
        if not env_url or url.rstrip("/") != env_url.rstrip("/"):
            yield url.rstrip("/")


async def parse_search_query(query: str) -> Dict[str, Any]:
    """Parse a user parking search query via the LLM microservice.

    Args:
        query: Raw text query from the user.

    Returns:
        Structured dict with parking search attributes.

    Raises:
        LLMClientError: If the request fails or returns non-200 status.
        ValueError: If query is empty.
    """
    if not query or not query.strip():
        raise ValueError("query must be non-empty")

    retries = int(os.getenv("LLM_CLIENT_RETRIES", DEFAULT_RETRIES))
    timeout_value = float(os.getenv("LLM_CLIENT_TIMEOUT", DEFAULT_TIMEOUT))
    timeout = httpx.Timeout(timeout_value, connect=CONNECT_TIMEOUT)

    last_error: Exception | None = None

    for base_url in _candidate_endpoints():
        for path in LEGACY_ENDPOINTS:
            endpoint = f"{base_url}{path}"
            logger.info(
                "Calling LLM service",
                extra={
                    "endpoint": endpoint,
                    "timeout": timeout_value,
                    "retries": retries,
                    "query_preview": query[:120],
                },
            )
            try:
                async with httpx.AsyncClient(timeout=timeout) as client:
                    for attempt in range(1, retries + 1):
                        try:
                            logger.debug(
                                "LLM HTTP request",
                                extra={
                                    "endpoint": endpoint,
                                    "attempt": attempt,
                                    "timeout": timeout_value,
                                },
                            )
                            response = await client.post(endpoint, json={"query": query})
                            response.raise_for_status()
                            data = response.json()
                            logger.debug(
                                "LLM service response",
                                extra={
                                    "endpoint": endpoint,
                                    "attempt": attempt,
                                    "response": data,
                                },
                            )
                            return data
                        except httpx.TimeoutException as exc:
                            logger.warning(
                                "LLM request timeout",
                                extra={"endpoint": endpoint, "attempt": attempt},
                            )
                            last_error = exc
                        except httpx.HTTPStatusError as exc:
                            logger.warning(
                                "LLM service returned HTTP error",
                                extra={
                                    "status": exc.response.status_code,
                                    "endpoint": endpoint,
                                    "attempt": attempt,
                                    "body": exc.response.text[:500],
                                },
                            )
                            last_error = exc
                            break
                        except httpx.RequestError as exc:
                            logger.warning(
                                "LLM request error",
                                extra={"endpoint": endpoint, "attempt": attempt},
                                exc_info=exc,
                            )
                            last_error = exc
                        except ValueError as exc:
                            logger.warning(
                                "LLM service returned invalid JSON",
                                extra={"endpoint": endpoint, "attempt": attempt},
                                exc_info=exc,
                            )
                            last_error = exc
                            break
            except Exception as exc:
                last_error = exc
                logger.exception(
                    "Unexpected LLM client error", extra={"endpoint": endpoint}
                )

    if last_error:
        raise LLMClientError(f"LLM service unreachable: {last_error}") from last_error

    raise LLMClientError("LLM service unreachable: no endpoints configured")


async def check_llm_health() -> Dict[str, Any]:
    """Check health endpoints of the LLM service for diagnostics."""
    timeout_value = float(os.getenv("LLM_CLIENT_TIMEOUT", DEFAULT_TIMEOUT))
    timeout = httpx.Timeout(timeout_value, connect=CONNECT_TIMEOUT)

    results: Dict[str, Any] = {"endpoints": []}

    for base_url in _candidate_endpoints():
        for path in ["/health", "/healthz"]:
            health_url = f"{base_url}{path}"
            try:
                async with httpx.AsyncClient(timeout=timeout) as client:
                    resp = await client.get(health_url)
                results["endpoints"].append(
                    {
                        "url": health_url,
                        "status": resp.status_code,
                        "body": resp.json()
                        if resp.headers.get("content-type", "").startswith(
                            "application/json"
                        )
                        else resp.text,
                    }
                )
                if resp.status_code == 200:
                    results["ok"] = True
                    results["active_url"] = health_url
                    return results
            except Exception as exc:
                logger.warning(
                    "LLM health check failed", extra={"url": health_url}, exc_info=exc
                )
                results["endpoints"].append({"url": health_url, "error": str(exc)})

    results["ok"] = False
    return results

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 177
PATH: services\llm_service\Dockerfile
LANG: text
===== CONTENT START =====
FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Устанавливаем зависимости для FastAPI и LLM-клиента
RUN pip install --no-cache-dir fastapi uvicorn[standard] httpx pydantic

COPY services/llm_service /app

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8002"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 178
PATH: services\llm_service\main.py
LANG: python
===== CONTENT START =====
"""Modern FastAPI-based LLM gateway for ParkShare.

Highlights
- OpenAI-compatible /v1/chat/completions endpoint with fallbacks (OpenAI/Anthropic/Groq/local via LiteLLM).
- In-memory caching and rate limiting to reduce latency and protect upstream APIs.
- Health probes and lightweight parking-aware helper endpoint for UI chat integrations.
- Context memory per conversation with TTL to keep replies coherent.
"""
from __future__ import annotations

import asyncio
import hashlib
import json
import logging
import time
import uuid
from functools import lru_cache
from collections import deque
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

from fastapi import Depends, FastAPI, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, ValidationError, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

try:  # lightweight optional cache backend
    from cachetools import TTLCache
except Exception:  # pragma: no cover - fallback when dependency is absent
    TTLCache = None  # type: ignore

try:  # optional Redis cache
    from redis import asyncio as aioredis
except Exception:  # pragma: no cover - optional dependency already in requirements
    aioredis = None  # type: ignore

try:
    from aiolimiter import AsyncLimiter
except Exception:  # pragma: no cover
    AsyncLimiter = None  # type: ignore

try:
    import litellm
except Exception as exc:  # pragma: no cover
    raise RuntimeError(
        "LiteLLM must be installed (requirements.txt) to start the LLM service"
    ) from exc

logger = logging.getLogger("parkshare.llm_service")
logging.basicConfig(level=logging.INFO)


class Settings(BaseSettings):
    """Service configuration loaded from environment/.env."""

    # Networking
    host: str = "0.0.0.0"
    port: int = 8002
    cors_allow_origins: list[str] = []

    # Provider configuration
    openai_api_key: str = ""
    openai_base_url: str = "https://api.openai.com/v1"
    anthropic_api_key: str = ""
    groq_api_key: str = ""
    default_model: str = "gpt-4o-mini"
    fallback_models: list[str] = ["gpt-4o-mini"]

    # Service features
    cache_enabled: bool = True
    cache_url: str | None = None
    cache_ttl_seconds: int = 30
    cache_size: int = 128
    max_history_messages: int = 16
    history_ttl_seconds: int = 3600
    requests_per_minute: int = 60
    rate_limit: str | None = None
    request_timeout: float = 20.0

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        env_prefix="LLM_",
        case_sensitive=False,
        extra="ignore",
    )

    @field_validator("fallback_models", mode="before")
    @classmethod
    def _parse_fallbacks(cls, value):
        """Позволяет передавать список в виде JSON или через запятую."""

        if value is None:
            return []
        if isinstance(value, list):
            return value
        if isinstance(value, str):
            text = value.strip()
            # Попробуем JSON
            try:
                parsed = json.loads(text)
                if isinstance(parsed, list):
                    return parsed
            except Exception:
                pass
            return [item.strip() for item in text.split(",") if item.strip()]
        return [str(value)]

    @field_validator("requests_per_minute", mode="before")
    @classmethod
    def _parse_rate_limit(cls, value, info):
        rate_limit_value = info.data.get("rate_limit")
        if rate_limit_value and isinstance(rate_limit_value, str) and "/" in rate_limit_value:
            try:
                count, window = rate_limit_value.split("/", 1)
                if window.lower() in {"m", "min", "minute", "hour"}:
                    divisor = 60 if window.lower().startswith("m") else 1
                    return int(int(count) / divisor)
            except Exception:
                pass
        return value


class ChatMessage(BaseModel):
    role: str = Field(..., description="system|user|assistant")
    content: str


class ChatCompletionRequest(BaseModel):
    model: Optional[str] = None
    messages: List[ChatMessage]
    temperature: float | None = 0.3
    max_tokens: Optional[int] = None
    user: Optional[str] = None
    conversation_id: Optional[str] = Field(
        default=None,
        description="Conversation key to keep lightweight context in memory",
    )


class CompletionChoice(BaseModel):
    index: int
    message: ChatMessage
    finish_reason: str | None = None


class CompletionUsage(BaseModel):
    prompt_tokens: int | None = None
    completion_tokens: int | None = None
    total_tokens: int | None = None


class ChatCompletionResponse(BaseModel):
    id: str
    object: str = "chat.completion"
    created: int
    model: str
    choices: List[CompletionChoice]
    usage: CompletionUsage | None = None


class ParkingChatRequest(BaseModel):
    query: str
    conversation_id: Optional[str] = None


class ParkingChatResponse(BaseModel):
    reply: str
    conversation_id: str
    provider: str


class RateLimiter:
    """Simple in-memory sliding window limiter."""

    def __init__(self, max_per_minute: int) -> None:
        self.max_per_minute = max_per_minute
        self.events: deque[float] = deque()
        self._lock = asyncio.Lock()

    async def acquire(self) -> None:
        async with self._lock:
            now = time.time()
            window_start = now - 60
            while self.events and self.events[0] < window_start:
                self.events.popleft()
            if len(self.events) >= self.max_per_minute:
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail="LLM rate limit exceeded",
                )
            self.events.append(now)


class BaseCache:
    async def get(self, key: str) -> Any:  # pragma: no cover - interface
        raise NotImplementedError

    async def set(self, key: str, value: Any) -> None:  # pragma: no cover - interface
        raise NotImplementedError


class MemoryCache(BaseCache):
    """TTL cache wrapper with graceful fallback."""

    def __init__(self, size: int, ttl: int) -> None:
        if TTLCache:
            self._cache = TTLCache(maxsize=size, ttl=ttl)
        else:  # pragma: no cover - simplified fallback
            self._cache: Dict[str, tuple[float, Any]] = {}
            self.ttl = ttl

    async def get(self, key: str) -> Any:
        if TTLCache:
            return self._cache.get(key)
        value = self._cache.get(key)
        if not value:
            return None
        expire_at, payload = value
        if expire_at < time.time():
            self._cache.pop(key, None)
            return None
        return payload

    async def set(self, key: str, value: Any) -> None:
        if TTLCache:
            self._cache[key] = value
        else:
            self._cache[key] = (time.time() + self.ttl, value)


class RedisCache(BaseCache):
    """Redis-based cache for shared workers."""

    def __init__(self, url: str, ttl: int) -> None:
        if not aioredis:
            raise RuntimeError("redis asyncio client is required for Redis cache")
        self.client = aioredis.from_url(url)
        self.ttl = ttl

    async def get(self, key: str) -> Any:
        raw = await self.client.get(key)
        if not raw:
            return None
        try:
            return json.loads(raw)
        except Exception:
            return None

    async def set(self, key: str, value: Any) -> None:
        payload = json.dumps(value, default=str)
        await self.client.set(key, payload, ex=self.ttl)


class ConversationMemory:
    """Keeps short-lived message history to provide context continuity."""

    def __init__(self, limit: int, ttl: int) -> None:
        self.limit = limit
        self.ttl = ttl
        self.storage: Dict[str, tuple[float, List[ChatMessage]]] = {}

    def get_history(self, conv_id: str) -> List[ChatMessage]:
        payload = self.storage.get(conv_id)
        if not payload:
            return []
        expires_at, messages = payload
        if expires_at < time.time():
            self.storage.pop(conv_id, None)
            return []
        return messages

    def append(self, conv_id: str, messages: List[ChatMessage]) -> None:
        history = self.get_history(conv_id)
        combined = (history + messages)[-self.limit :]
        self.storage[conv_id] = (time.time() + self.ttl, combined)


@lru_cache(maxsize=1)
def get_settings() -> Settings:
    return Settings()


@lru_cache(maxsize=1)
def get_rate_limiter(settings: Settings = Depends(get_settings)) -> RateLimiter:
    return RateLimiter(settings.requests_per_minute)


@lru_cache(maxsize=1)
def get_cache(settings: Settings = Depends(get_settings)) -> BaseCache:
    if settings.cache_enabled and settings.cache_url and aioredis:
        try:
            return RedisCache(settings.cache_url, settings.cache_ttl_seconds)
        except Exception:
            logger.warning("Redis cache недоступен, переключаемся на память")
    return MemoryCache(settings.cache_size, settings.cache_ttl_seconds)


@lru_cache(maxsize=1)
def get_history(settings: Settings = Depends(get_settings)) -> ConversationMemory:
    return ConversationMemory(settings.max_history_messages, settings.history_ttl_seconds)


app = FastAPI(title="ParkShare LLM Gateway", version="1.0.0")
_settings = Settings()
app.add_middleware(
    CORSMiddleware,
    allow_origins=_settings.cors_allow_origins or ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

if AsyncLimiter:
    limiter = AsyncLimiter(_settings.requests_per_minute, time_period=60)
else:
    limiter = None


async def _call_litellm(model: str, request: ChatCompletionRequest, settings: Settings) -> Dict[str, Any]:
    """Invoke LiteLLM with provider-specific credentials."""

    common_kwargs: Dict[str, Any] = {
        "model": model,
        "messages": [m.model_dump() for m in request.messages],
        "timeout": settings.request_timeout,
    }
    if request.temperature is not None:
        common_kwargs["temperature"] = request.temperature
    if request.max_tokens:
        common_kwargs["max_tokens"] = request.max_tokens
    if request.user:
        common_kwargs["user"] = request.user

    if model.startswith("claude") and settings.anthropic_api_key:
        common_kwargs["api_key"] = settings.anthropic_api_key
        common_kwargs["base_url"] = "https://api.anthropic.com"
    elif model.startswith("gpt") and settings.openai_api_key:
        common_kwargs["api_key"] = settings.openai_api_key
        common_kwargs["base_url"] = settings.openai_base_url.rstrip("/")
    elif settings.groq_api_key and model.startswith("groq"):
        common_kwargs["api_key"] = settings.groq_api_key
        common_kwargs["base_url"] = "https://api.groq.com/openai/v1"

    try:
        response = await litellm.acompletion(**common_kwargs)
    except litellm.RateLimitError as exc:  # pragma: no cover - network-specific
        raise HTTPException(status_code=429, detail=str(exc)) from exc
    except litellm.BadRequestError as exc:  # pragma: no cover
        raise HTTPException(status_code=400, detail=str(exc)) from exc
    except Exception as exc:  # pragma: no cover
        logger.exception("LLM provider error")
        raise HTTPException(status_code=502, detail="LLM upstream error") from exc

    return response  # type: ignore[no-any-return]


async def _make_response(
    provider_payload: Dict[str, Any],
    model: str,
    conversation_id: Optional[str],
    history: ConversationMemory,
) -> ChatCompletionResponse:
    first_choice = provider_payload["choices"][0]
    message_payload = first_choice["message"]
    message = ChatMessage(role=message_payload.get("role", "assistant"), content=message_payload.get("content", ""))

    if conversation_id:
        history.append(conversation_id, [message])

    usage = provider_payload.get("usage") or {}
    return ChatCompletionResponse(
        id=provider_payload.get("id") or f"chatcmpl-{uuid.uuid4().hex}",
        created=int(provider_payload.get("created") or time.time()),
        model=model,
        choices=[
            CompletionChoice(index=0, message=message, finish_reason=first_choice.get("finish_reason")),
        ],
        usage=CompletionUsage(
            prompt_tokens=usage.get("prompt_tokens"),
            completion_tokens=usage.get("completion_tokens"),
            total_tokens=usage.get("total_tokens"),
        ),
    )


def _cache_key(request: ChatCompletionRequest) -> str:
    payload = json.dumps(request.model_dump(), sort_keys=True, ensure_ascii=False)
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()


async def _with_history(request: ChatCompletionRequest, history: ConversationMemory) -> ChatCompletionRequest:
    if not request.conversation_id:
        return request
    previous = history.get_history(request.conversation_id)
    if not previous:
        return request
    merged = previous + request.messages
    return ChatCompletionRequest(**{**request.model_dump(), "messages": merged})


@app.middleware("http")
async def guard_rate_limit(request: Request, call_next):
    if limiter:
        async with limiter:
            return await call_next(request)
    return await call_next(request)


@app.get("/health", tags=["health"])
async def health() -> dict[str, Any]:
    return {
        "status": "ok",
        "provider": "litellm",
        "default_model": _settings.default_model,
        "fallbacks": _settings.fallback_models,
    }


@app.get("/healthz", tags=["health"])
async def healthz() -> dict[str, Any]:
    return await health()


@app.get("/v1/models")
async def list_models(settings: Settings = Depends(get_settings)) -> dict[str, Any]:
    models = list({settings.default_model, *settings.fallback_models})
    return {"data": [{"id": m, "object": "model"} for m in models], "object": "list"}


@app.post("/v1/chat/completions", response_model=ChatCompletionResponse)
async def chat_completions(
    payload: ChatCompletionRequest,
    settings: Settings = Depends(get_settings),
    cache: BaseCache = Depends(get_cache),
    history: ConversationMemory = Depends(get_history),
    limiter_dep: RateLimiter = Depends(get_rate_limiter),
) -> ChatCompletionResponse:
    await limiter_dep.acquire()
    payload = await _with_history(payload, history)
    cache_key = _cache_key(payload)
    cached = await cache.get(cache_key)
    if cached:
        try:
            return ChatCompletionResponse.model_validate(cached)
        except Exception:
            pass

    models_chain = [payload.model or settings.default_model, *settings.fallback_models]
    last_error: Optional[Exception] = None
    for model in models_chain:
        try:
            provider_payload = await _call_litellm(model, payload, settings)
            response = await _make_response(provider_payload, model, payload.conversation_id, history)
            await cache.set(cache_key, response.model_dump())
            return response
        except HTTPException as exc:
            last_error = exc
            if exc.status_code < 500:
                break
            continue
        except Exception as exc:  # pragma: no cover - unexpected fallback
            last_error = exc
            logger.exception("Unexpected LLM error for model %s", model)
            continue

    if last_error:
        raise last_error  # type: ignore[misc]
    raise HTTPException(status_code=502, detail="LLM provider unavailable")


@app.post("/v1/parkshare/chat", response_model=ParkingChatResponse)
async def parking_chat(
    payload: ParkingChatRequest,
    settings: Settings = Depends(get_settings),
    history: ConversationMemory = Depends(get_history),
) -> ParkingChatResponse:
    """Parking-aware helper endpoint to drive the web chat UI."""

    system_prompt = (
        "You are ParkShare's multilingual assistant. "
        "You help users book and discover parking spots with contextual hints from their history. "
        "Answer succinctly in the language of the user."
    )
    conversation_id = payload.conversation_id or uuid.uuid4().hex
    messages: List[ChatMessage] = [ChatMessage(role="system", content=system_prompt)]
    history_messages = history.get_history(conversation_id)
    messages.extend(history_messages[-6:])
    messages.append(ChatMessage(role="user", content=payload.query))

    request_payload = ChatCompletionRequest(
        model=settings.default_model,
        messages=messages,
        conversation_id=conversation_id,
        temperature=0.4,
    )
    response = await chat_completions(request_payload, settings, get_cache(settings), history, get_rate_limiter(settings))
    reply = response.choices[0].message.content
    return ParkingChatResponse(reply=reply, conversation_id=conversation_id, provider=response.model)


@app.exception_handler(ValidationError)
async def validation_exception_handler(_: Request, exc: ValidationError):  # pragma: no cover - FastAPI hook
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()},
    )


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host=_settings.host, port=_settings.port)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 179
PATH: services\llm_service\requirements.txt
LANG: text
===== CONTENT START =====
fastapi==0.115.0
uvicorn[standard]==0.32.1
httpx==0.27.2
pydantic==2.12.4
pydantic-settings==2.8.0
python-dotenv==1.2.1

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 180
PATH: static\manifest.webmanifest
LANG: text
===== CONTENT START =====
{
  "name": "ParkShare — умная парковка",
  "short_name": "ParkShare",
  "description": "Поиск, бронирование и оплата парковок рядом с вами. Работает как приложение, даже офлайн.",
  "start_url": "/?pwa=true",
  "scope": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "background_color": "#020617",
  "theme_color": "#0f172a",
  "icons": [
    {
      "src": "/static/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/static/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/static/icons/icon-maskable-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/static/icons/icon-maskable-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "shortcuts": [
    {
      "name": "Найти парковку рядом",
      "short_name": "Найти рядом",
      "url": "/#search",
      "icons": [
        {
          "src": "/static/icons/shortcut-search.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Мои бронирования",
      "short_name": "Брони",
      "url": "/dashboard/#bookings"
    }
  ],
  "categories": ["navigation", "productivity", "travel"],
  "lang": "ru-RU"
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 181
PATH: static\service-worker.js
LANG: javascript
===== CONTENT START =====
// static/service-worker.js — production-grade PWA cache with app versioning
const APP_VERSION = '2024.09.1';
const CACHE_PREFIX = 'parkshare-';
const PUBLIC_STATIC_CACHE = `${CACHE_PREFIX}static-${APP_VERSION}`;
const PUBLIC_PAGE_CACHE = `${CACHE_PREFIX}pages-${APP_VERSION}`;
const PUBLIC_API_CACHE = `${CACHE_PREFIX}api-${APP_VERSION}`;
const PRIVATE_API_CACHE = `${CACHE_PREFIX}api-private-${APP_VERSION}`;
const MAP_CACHE = `${CACHE_PREFIX}map-${APP_VERSION}`;
const RUNTIME_CACHE = `${CACHE_PREFIX}runtime-${APP_VERSION}`;
const OFFLINE_URL = '/offline/';

const PRIVATE_TTL_MS = 5 * 60 * 1000;
const PRIVATE_MAX_ENTRIES = 30;
const SHELL_ROUTES = ['/map/', '/app/', '/личный-кабинет/', '/кабинет-владельца/'];
const APP_SHELL = [...SHELL_ROUTES, OFFLINE_URL, '/manifest.webmanifest'];

const STATIC_ASSETS = [
  '/static/css/app.css',
  '/static/js/app.js',
  '/static/js/map.js',
  '/static/js/quantum-theme-manager.js',
  '/static/icons/icon-192.png',
  '/static/icons/icon-512.png',
  '/static/icons/icon-72.png',
  '/static/pwa/app.js',
  '/static/pwa/api-client.js',
  '/static/pwa/state-store.js',
  '/static/pwa/router.js',
  '/static/pwa/spots-view.js',
  '/static/pwa/ui-kit.js',
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    Promise.all([
      caches.open(PUBLIC_PAGE_CACHE).then((cache) => cache.addAll(APP_SHELL)),
      caches.open(PUBLIC_STATIC_CACHE).then((cache) => cache.addAll(STATIC_ASSETS)),
    ]).catch((err) => {
      console.warn('[SW] install cache error', err);
    })
  );
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(
        keys
          .filter(
            (key) =>
              key.startsWith(CACHE_PREFIX) &&
              ![
                RUNTIME_CACHE,
                PUBLIC_STATIC_CACHE,
                PUBLIC_PAGE_CACHE,
                PUBLIC_API_CACHE,
                PRIVATE_API_CACHE,
                MAP_CACHE,
              ].includes(key)
          )
          .map((key) => caches.delete(key))
      )
    )
  );
  self.clients.claim();
});

self.addEventListener('message', (event) => {
  if (event.data === 'SW_APPLY_UPDATE') {
    self.skipWaiting();
    return;
  }
  if (event.data && event.data.type === 'PRIME_SHELL') {
    precacheShell();
  }
});

self.addEventListener('fetch', (event) => {
  const { request } = event;
  if (request.method !== 'GET') return;

  const url = new URL(request.url);
  const isSameOrigin = url.origin === self.location.origin;

  if (request.headers.get('accept')?.includes('text/html')) {
    if (isSameOrigin) {
      const targetCache = isPwaShell(url) ? PUBLIC_PAGE_CACHE : null;
      event.respondWith(handleHtmlRequest(request, targetCache));
      return;
    }
  }

  if (isApiRequest(url)) {
    if (isPrivateApi(url)) {
      event.respondWith(networkFirstPrivate(request, PRIVATE_API_CACHE));
      return;
    }
    event.respondWith(staleWhileRevalidate(request, PUBLIC_API_CACHE));
    return;
  }

  if (isMapTile(url)) {
    event.respondWith(limitCacheSize(cacheFirst(request, MAP_CACHE), 150));
    return;
  }

  if (isAsset(url)) {
    event.respondWith(cacheFirst(request, PUBLIC_STATIC_CACHE));
    return;
  }

  event.respondWith(staleWhileRevalidate(request, RUNTIME_CACHE));
});

self.addEventListener('sync', (event) => {
  if (event.tag === 'ps-sync-queue') {
    event.waitUntil(flushOfflineQueue());
  }
});

self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'ParkShare';
  const body = data.body || 'Новые события по вашим бронированиям';
  const url = data.data?.url || data.url || '/map/';
  const actions = data.actions || [];
  event.waitUntil(
    self.registration.showNotification(title, {
      body,
      data: { url, ...data.data },
      icon: '/static/icons/icon-192.png',
      badge: '/static/icons/icon-72.png',
      actions,
    })
  );
});

self.addEventListener('notificationclick', (event) => {
  const targetUrl = event.notification?.data?.url || '/map/';
  event.notification.close();
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      for (const client of clientList) {
        if ('focus' in client) {
          client.navigate(targetUrl);
          return client.focus();
        }
      }
      return clients.openWindow(targetUrl);
    })
  );
});

async function precacheShell() {
  const cache = await caches.open(PUBLIC_PAGE_CACHE);
  await cache.addAll(APP_SHELL);
}

function isApiRequest(url) {
  return url.pathname.startsWith('/api/');
}

function isPrivateApi(url) {
  if (!isApiRequest(url)) return false;
  return (
    url.pathname.includes('/favorites/') ||
    url.pathname.includes('/saved-places/') ||
    url.pathname.includes('/push-subscriptions/') ||
    url.pathname.includes('/accounts/profile') ||
    url.pathname.includes('/ai/parkmate/config')
  );
}

function isPwaShell(url) {
  return SHELL_ROUTES.some((route) => url.pathname.startsWith(route));
}

function isMapTile(url) {
  return url.hostname.includes('tile') || url.pathname.includes('/tiles/') || url.pathname.match(/\/(\d+)\/(\d+)\/(\d+)\.png/);
}

function isAsset(url) {
  return (
    url.pathname.startsWith('/static/') ||
    url.pathname.match(/\.(?:js|css|png|svg|webp|jpg|jpeg|woff2?)$/)
  );
}

async function cacheFirst(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  if (cached) return cached;
  const response = await fetch(request);
  if (response && response.ok) {
    cache.put(request, response.clone());
  }
  return response;
}

async function networkFirstPrivate(request, cacheName) {
  const cache = await caches.open(cacheName);
  try {
    const response = await fetch(request);
    if (response && response.ok) {
      const stamped = stampResponse(response);
      await cache.put(request, stamped.clone());
      await trimCache(cacheName, PRIVATE_MAX_ENTRIES);
    }
    return response;
  } catch (err) {
    const cached = await cache.match(request);
    if (cached && !isExpired(cached, PRIVATE_TTL_MS)) return cached;
    throw err;
  }
}

async function staleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  const network = fetch(request)
    .then((response) => {
      if (response && response.ok) {
        cache.put(request, response.clone());
      }
      return response;
    })
    .catch(() => cached);
  return cached || network;
}

async function handleHtmlRequest(request, cacheName) {
  if (!cacheName) {
    return fetch(request).catch(async () => (await caches.match(OFFLINE_URL)) || Response.error());
  }
  const cache = await caches.open(cacheName);
  try {
    const response = await fetch(request);
    if (response && response.ok) {
      await cache.put(request, response.clone());
    }
    return response;
  } catch (_) {
    const cached = await cache.match(request);
    if (cached) return cached;
    const fallback = await caches.match(OFFLINE_URL);
    if (fallback) return fallback;
    return Response.error();
  }
}

async function limitCacheSize(responsePromise, maxEntries = 150) {
  const response = await responsePromise;
  const cache = await caches.open(MAP_CACHE);
  const keys = await cache.keys();
  if (keys.length > maxEntries) {
    await cache.delete(keys[0]);
  }
  return response;
}

async function flushOfflineQueue() {
  const queue = await loadQueue();
  const stillPending = [];
  for (const item of queue) {
    try {
      await fetch(item.url, item.options);
    } catch (err) {
      if ((item.attempts || 0) < 3) {
        stillPending.push({ ...item, attempts: (item.attempts || 0) + 1 });
      }
    }
  }
  await saveQueue(stillPending);
}

async function loadQueue() {
  try {
    const cache = await caches.open(RUNTIME_CACHE);
    const stored = await cache.match('ps-offline-queue');
    if (!stored) return [];
    const payload = await stored.json();
    const cutoff = Date.now() - 24 * 60 * 60 * 1000;
    return (payload || []).filter((item) => (item.created_at || 0) > cutoff).slice(-50);
  } catch (_) {
    return [];
  }
}

async function saveQueue(payload) {
  const cache = await caches.open(RUNTIME_CACHE);
  const limited = (payload || []).slice(-50);
  await cache.put('ps-offline-queue', new Response(JSON.stringify(limited)));
}

function stampResponse(response) {
  const headers = new Headers(response.headers);
  headers.set('X-SW-Timestamp', Date.now().toString());
  return new Response(response.clone().body, {
    status: response.status,
    statusText: response.statusText,
    headers,
  });
}

function isExpired(response, ttlMs) {
  const ts = Number(response.headers.get('X-SW-Timestamp') || 0);
  if (!ts) return true;
  return Date.now() - ts > ttlMs;
}

async function trimCache(cacheName, maxEntries) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  if (keys.length > maxEntries) {
    await cache.delete(keys[0]);
  }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 182
PATH: static\css\app.css
LANG: css
===== CONTENT START =====
/* ---------- Tokens ---------- */

:root {
    color-scheme: light;

    --ps-bg: #f4f6fb;
    --ps-bg-elevated: #ffffff;
    --ps-bg-card: #ffffff;
    --ps-bg-nav: rgba(246, 248, 252, 0.92);

    --ps-text-primary: #0b1628;
    --ps-text-secondary: #1f2b3c;
    --ps-text-muted: #6b7280;

    --ps-border-subtle: rgba(12, 18, 32, 0.08);
    --ps-border-strong: rgba(12, 18, 32, 0.14);

    --ps-accent: #4fc3ff;
    --ps-accent-soft: rgba(79, 195, 255, 0.16);
    --ps-accent-on-dark: #9fe2ff;

    --ps-success: #22c55e;
    --ps-warning: #f5a524;
    --ps-danger: #ef4444;

    --ps-radius-card: 24px;
    --ps-radius-soft: 16px;
    --ps-radius-pill: 999px;

    --ps-shadow-card: 0 14px 38px rgba(15, 23, 42, 0.12);
    --ps-shadow-nav: 0 10px 28px rgba(15, 23, 42, 0.12);

    --ps-font-family: "SF Pro Display", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;

    --ps-topbar-height: 68px;
    --ps-bottom-bar-height: 72px;
}

[data-theme="dark"] {
    color-scheme: dark;

    --ps-bg: #050910;
    --ps-bg-elevated: #0a0f19;
    --ps-bg-card: #0f1624;
    --ps-bg-nav: rgba(6, 10, 18, 0.92);

    --ps-text-primary: #e9edf5;
    --ps-text-secondary: #cfd6e7;
    --ps-text-muted: #9aa3b8;

    --ps-border-subtle: rgba(255, 255, 255, 0.08);
    --ps-border-strong: rgba(255, 255, 255, 0.16);

    --ps-accent: #5dd6ff;
    --ps-accent-soft: rgba(93, 214, 255, 0.18);
    --ps-accent-on-dark: #b6e6ff;

    --ps-shadow-card: 0 18px 46px rgba(0, 0, 0, 0.5);
    --ps-shadow-nav: 0 12px 38px rgba(0, 0, 0, 0.45);
}

@media (min-width: 768px) {
    :root {
        --ps-topbar-height: 72px;
    }
}

/* ---------- Base ---------- */

*,
*::before,
*::after {
    box-sizing: border-box;
}

body.ps-body {
    margin: 0;
    min-height: 100vh;
    font-family: var(--ps-font-family);
    font-size: 15px;
    line-height: 1.6;
    color: var(--ps-text-primary);
    background: var(--ps-bg);
    -webkit-font-smoothing: antialiased;
    padding-bottom: calc(var(--ps-bottom-bar-height) + env(safe-area-inset-bottom));
}

.ps-app {
    min-height: 100vh;
    background: var(--ps-bg);
}

a {
    color: inherit;
    text-decoration: none;
}

.ps-icon {
    width: 20px;
    height: 20px;
    display: inline-block;
}

/* ---------- Top bar ---------- */

.ps-topbar {
    position: sticky;
    top: 0;
    z-index: 40;
    background: var(--ps-bg-nav);
    backdrop-filter: blur(16px);
    border-bottom: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-nav);
}

.ps-topbar__safe {
    padding-top: env(safe-area-inset-top);
}

.ps-topbar__row {
    height: var(--ps-topbar-height);
    padding: 0 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
}

.ps-brand {
    display: flex;
    flex-direction: column;
    gap: 2px;
    color: var(--ps-text-primary);
}

.ps-brand__title {
    font-weight: 800;
    font-size: 1.5rem;
    letter-spacing: -0.02em;
}

.ps-brand__region {
    display: inline-flex;
    align-items: center;
    width: fit-content;
    padding: 2px 10px;
    border-radius: var(--ps-radius-pill);
    background: var(--ps-accent-soft);
    color: var(--ps-text-secondary);
    border: 1px solid var(--ps-border-subtle);
    font-size: 0.78rem;
}

.ps-topbar__actions {
    display: inline-flex;
    align-items: center;
    gap: 10px;
}

.ps-icon-btn {
    width: 42px;
    height: 42px;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.08);
}

.ps-icon-btn:hover {
    transform: translateY(-1px);
    border-color: var(--ps-border-strong);
}

[data-theme="dark"] .ps-icon-btn {
    background: var(--ps-bg-elevated);
    box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
}

.ps-icon-btn--ghost {
    background: transparent;
    border-color: var(--ps-border-subtle);
    box-shadow: none;
    color: var(--ps-text-secondary);
}

.ps-icon-moon {
    display: none;
}

[data-theme="dark"] .ps-icon-sun {
    display: none;
}

[data-theme="dark"] .ps-icon-moon {
    display: inline-block;
}

/* ---------- Layout ---------- */

.ps-main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem 1rem 2rem;
}

@media (min-width: 960px) {
    .ps-main {
        padding: 1.25rem 1.5rem 2.5rem;
    }
}

.ps-section {
    margin-bottom: 1.8rem;
}

.ps-section--flush-top {
    margin-top: 0.4rem;
}

.ps-section--narrow {
    max-width: 680px;
    margin: 0 auto 1.8rem;
}

.ps-section-header {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    align-items: flex-start;
    margin-bottom: 0.9rem;
}

.ps-section-header--stack {
    flex-direction: column;
    align-items: flex-start;
}

.ps-section-title {
    margin: 0 0 0.2rem;
    font-size: 1.2rem;
    font-weight: 700;
    letter-spacing: -0.01em;
}

.ps-section-subtitle {
    margin: 0;
    color: var(--ps-text-muted);
    font-size: 0.92rem;
    line-height: 1.4;
}

.ps-section-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.ps-section-actions--link {
    margin-bottom: 0.6rem;
}

.ps-section-subheader {
    margin: 0.6rem 0 0.4rem;
}

.ps-section-title-sm {
    margin: 0;
    font-size: 1rem;
    font-weight: 700;
}

.ps-stack {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.ps-grid {
    display: grid;
    gap: 1rem;
}

.ps-grid--2col {
    grid-template-columns: repeat(2, minmax(0, 1fr));
}

.ps-grid--gap-lg {
    gap: 1.25rem;
}

@media (max-width: 768px) {
    .ps-section-header {
        flex-direction: column;
    }
    .ps-grid--2col {
        grid-template-columns: 1fr;
    }
}

.ps-landing {
    display: grid;
    gap: 1.1rem;
}

.ps-landing__head {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 0.85rem;
}

.ps-landing__title {
    margin: 0;
    font-size: 1.55rem;
    font-weight: 800;
    letter-spacing: -0.02em;
}

.ps-landing__subtitle {
    margin: 0.2rem 0 0;
    color: var(--ps-text-muted);
    font-size: 0.95rem;
}

@media (max-width: 768px) {
    .ps-landing__head {
        flex-direction: column;
        align-items: flex-start;
    }
    .ps-landing__title {
        font-size: 1.4rem;
    }
}

/* ---------- Typography helpers ---------- */

.ps-kicker {
    text-transform: uppercase;
    letter-spacing: 0.18em;
    font-size: 0.72rem;
    color: var(--ps-text-muted);
    margin: 0 0 0.3rem;
    font-weight: 700;
}

.ps-text-muted {
    color: var(--ps-text-muted);
}

.ps-label {
    color: var(--ps-text-muted);
    font-size: 0.86rem;
}

/* ---------- Buttons ---------- */

.ps-btn {
    border: 1px solid transparent;
    border-radius: var(--ps-radius-pill);
    padding: 0.58rem 1.25rem;
    font-weight: 600;
    font-size: 0.96rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.45rem;
    background: var(--ps-accent);
    color: #04121f;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12);
    transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease, filter 0.2s ease;
}

.ps-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 16px 36px rgba(0, 0, 0, 0.16);
}

.ps-btn:active {
    transform: translateY(0);
}

.ps-btn-primary {
    background: var(--ps-accent);
    color: #04121f;
}

.ps-btn-secondary {
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: none;
}

.ps-btn-ghost {
    background: transparent;
    color: var(--ps-text-secondary);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: none;
}

.ps-btn-sm {
    padding: 0.38rem 0.85rem;
    font-size: 0.85rem;
}

.ps-btn-xs {
    padding: 0.25rem 0.7rem;
    font-size: 0.78rem;
}

.ps-btn-lg {
    padding: 0.65rem 1.3rem;
    font-size: 1rem;
}

.ps-btn-full,
.ps-btn-block {
    width: 100%;
}

.ps-btn[disabled],
.ps-btn[aria-disabled="true"] {
    opacity: 0.6;
    cursor: not-allowed;
    box-shadow: none;
}

/* ---------- Inputs & forms ---------- */

.ps-form {
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
}

.ps-form-row {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.ps-form-label {
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

.ps-input {
    width: 100%;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    padding: 0.55rem 0.75rem;
    font-size: 0.95rem;
    transition: border-color 0.15s ease, box-shadow 0.2s ease, background-color 0.15s ease;
}

.ps-input:focus {
    outline: none;
    border-color: var(--ps-accent);
    box-shadow: 0 0 0 3px var(--ps-accent-soft);
}

.ps-input--pill {
    border-radius: var(--ps-radius-pill);
}

[data-theme="dark"] .ps-input {
    background: var(--ps-bg-elevated);
}

.ps-field-help {
    font-size: 0.8rem;
    color: var(--ps-text-muted);
}

.ps-field-error {
    font-size: 0.8rem;
    color: var(--ps-danger);
}

.ps-form-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.ps-checkbox {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    color: var(--ps-text-secondary);
    font-size: 0.9rem;
}

.ps-checkbox input {
    width: 18px;
    height: 18px;
}

.ps-checkbox--inline {
    justify-content: flex-end;
}

.ps-form-row--inline {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 0.5rem;
}

.ps-form-compact .ps-form-row {
    gap: 0.2rem;
}

@media (max-width: 640px) {
    .ps-form-row--inline {
        grid-template-columns: 1fr;
    }
}

/* ---------- Cards & badges ---------- */

.ps-card {
    background: var(--ps-bg-card);
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    padding: 1rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-card--elevated {
    box-shadow: 0 22px 48px rgba(0, 0, 0, 0.12);
}

.ps-card-header {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    align-items: center;
    margin-bottom: 0.6rem;
}

.ps-card-title {
    margin: 0;
    font-size: 1.05rem;
    font-weight: 700;
}

.ps-card-body {
    display: grid;
    gap: 0.35rem;
    font-size: 0.95rem;
}

.ps-card-body--spacing-lg {
    gap: 0.75rem;
}

.ps-card-line {
    margin: 0;
}

.ps-card-line--muted {
    color: var(--ps-text-muted);
}

.ps-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 0.15rem 0.55rem;
    border-radius: var(--ps-radius-pill);
    font-size: 0.78rem;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-secondary);
}

.ps-badge--success {
    background: rgba(34, 197, 94, 0.15);
    border-color: rgba(34, 197, 94, 0.35);
    color: var(--ps-text-primary);
}

.ps-badge--neutral {
    background: rgba(148, 163, 184, 0.16);
    border-color: rgba(148, 163, 184, 0.26);
}

.ps-badge--status-confirmed,
.ps-badge--status-active {
    background: rgba(34, 197, 94, 0.16);
    border-color: rgba(34, 197, 94, 0.4);
}

.ps-badge--status-cancelled {
    background: rgba(239, 68, 68, 0.14);
    border-color: rgba(239, 68, 68, 0.35);
}

/* ---------- Lists & table ---------- */

.ps-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.ps-list-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    padding: 0.65rem 0;
    border-bottom: 1px solid var(--ps-border-subtle);
}

.ps-list-title {
    font-weight: 600;
    font-size: 0.95rem;
}

.ps-list-subtitle {
    font-size: 0.85rem;
    color: var(--ps-text-muted);
}

.ps-list-empty {
    padding: 0.6rem 0;
    color: var(--ps-text-muted);
}

.ps-list-ordered {
    padding-left: 1.1rem;
    color: var(--ps-text-primary);
}

.ps-list-ordered li {
    margin-bottom: 0.35rem;
}

.ps-list--compact .ps-list-item {
    padding-block: 0.45rem;
}

.ps-payment-list {
    display: grid;
    gap: 0.6rem;
}

.ps-payment-card {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.6rem;
    padding: 0.65rem 0.75rem;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
}

.ps-payment-brand {
    font-weight: 700;
}

.ps-payment-meta {
    color: var(--ps-text-muted);
    font-size: 0.86rem;
}

.ps-payment-actions {
    display: flex;
    gap: 6px;
}

.ps-table-wrapper {
    overflow: auto;
}

.ps-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.94rem;
}

.ps-table th,
.ps-table td {
    padding: 0.65rem 0.5rem;
    text-align: left;
    border-bottom: 1px solid var(--ps-border-subtle);
}

.ps-table th {
    font-weight: 600;
    color: var(--ps-text-muted);
}

/* ---------- Progress ---------- */

.ps-progress {
    width: 100%;
    height: 8px;
    background: var(--ps-border-subtle);
    border-radius: 999px;
    overflow: hidden;
}

.ps-progress-bar {
    height: 100%;
    border-radius: inherit;
    background: linear-gradient(90deg, var(--ps-accent), #1c64f2);
    width: 40%;
}

.ps-progress-block {
    display: grid;
    gap: 0.4rem;
}

.ps-progress-header {
    display: flex;
    justify-content: space-between;
    color: var(--ps-text-muted);
    font-size: 0.86rem;
}

/* ---------- Search ---------- */

.ps-search-bar {
    display: flex;
    align-items: center;
    gap: 0.55rem;
    padding: 0.75rem 0.9rem;
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-pill);
    box-shadow: var(--ps-shadow-card);
}

.ps-search-bar--pill {
    border-radius: var(--ps-radius-pill);
}

.ps-search-icon {
    width: 42px;
    height: 42px;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--ps-text-muted);
    cursor: pointer;
}

.ps-search-actions .ps-icon-btn {
    width: 42px;
    height: 42px;
}

.ps-search-input {
    border: none;
    background: transparent;
    font-size: 1rem;
    color: var(--ps-text-primary);
    width: 100%;
    outline: none;
}

.ps-search-actions {
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.ps-search-hint {
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

/* ---------- Map shell ---------- */

.ps-map-card {
    padding: 0.75rem 0.75rem 0.6rem;
    border-radius: var(--ps-radius-card);
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
    display: grid;
    gap: 0.6rem;
}

.ps-map-grid {
    display: grid;
    grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
    gap: 1rem;
}

.ps-map-hero {
    margin-top: 0.5rem;
}

@media (max-width: 960px) {
    .ps-map-grid {
        grid-template-columns: 1fr;
    }
}

.ps-map-panel {
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-card);
    padding: 0.5rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-map-card.ps-map-panel {
    padding: 0.75rem 0.75rem 0.6rem;
}

.ps-spots-panel {
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-card);
    padding: 0.9rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-spots-list {
    display: grid;
    gap: 0.75rem;
}

.ps-card--spot {
    padding: 0.9rem 1rem;
    position: relative;
}

.ps-card--spot::after {
    content: "›";
    position: absolute;
    right: 0.9rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--ps-text-muted);
    font-weight: 700;
}

.ps-map-wrapper {
    position: relative;
    overflow: hidden;
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
}

.ps-map {
    width: 100%;
    height: clamp(280px, 48vh, 420px);
    border-radius: inherit;
}

.ps-map-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: linear-gradient(180deg, rgba(0, 0, 0, 0.05), transparent 32%, transparent 72%, rgba(0, 0, 0, 0.05));
}

.ps-map-floating-actions {
    position: absolute;
    top: 12px;
    right: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 6px;
    border-radius: var(--ps-radius-soft);
    backdrop-filter: blur(12px);
    background: var(--ps-bg-nav);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
}

.ps-map-floating-actions.is-dimmed {
    opacity: 0.6;
}

.ps-map-action {
    width: 44px;
    height: 44px;
    border-radius: 14px;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    box-shadow: 0 10px 24px rgba(0, 0, 0, 0.08);
}

.ps-map-action:hover {
    transform: translateY(-1px);
    border-color: var(--ps-border-strong);
}

[data-theme="dark"] .ps-map-action {
    background: var(--ps-bg-card);
    box-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
}

.ps-map-action--spinning {
    animation: ps-spin 0.6s linear;
}

.ps-map-action--pulse {
    animation: ps-pulse 1.3s ease-out infinite;
}

.ps-map-loading {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.3);
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    letter-spacing: 0.02em;
}

.ps-map-topbar {
    position: absolute;
    top: 12px;
    left: 12px;
    right: 96px;
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 6px;
    border-radius: var(--ps-radius-soft);
    backdrop-filter: blur(12px);
    background: var(--ps-bg-nav);
    border: 1px solid var(--ps-border-subtle);
}

.ps-map-controls {
    display: grid;
    gap: 0.45rem;
}

.ps-map-chips {
    display: flex;
    gap: 8px;
    padding: 8px;
    overflow-x: auto;
    border-radius: var(--ps-radius-soft);
    background: var(--ps-bg-elevated);
    border: 1px solid var(--ps-border-subtle);
}

.ps-chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 0.35rem 0.75rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-secondary);
    cursor: pointer;
    font-size: 0.88rem;
    transition: border-color 0.15s ease, background-color 0.15s ease;
}

.ps-chip.is-active {
    background: var(--ps-accent-soft);
    border-color: var(--ps-accent);
}

.ps-chip--soft {
    background: var(--ps-accent-soft);
    border-color: transparent;
    color: var(--ps-text-secondary);
}

.ps-chip--ghost {
    background: transparent;
    border-style: dashed;
}

.ps-map-filters {
    margin-top: 0.6rem;
}

.ps-map-filters-card {
    padding: 0.85rem;
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    display: grid;
    gap: 0.65rem;
}

.ps-map-filters-row {
    display: grid;
    gap: 0.5rem;
}

.ps-map-cta {
    margin-top: 0.75rem;
    display: flex;
    justify-content: flex-start;
}

.ps-filter-slider {
    height: 6px;
    background: var(--ps-border-subtle);
    border-radius: 999px;
}

.ps-filter-price {
    font-size: 0.88rem;
    color: var(--ps-text-muted);
}

.ps-geocode-suggestions {
    margin-top: 0.4rem;
    display: grid;
    gap: 6px;
}

.ps-geocode-suggestions button {
    padding: 0.55rem 0.75rem;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    cursor: pointer;
    text-align: left;
}

.ps-route-hint {
    margin-top: 0.35rem;
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

.ps-map-popup {
    min-width: 240px;
    border-radius: 16px;
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
    padding: 0.75rem;
}

.ps-map-popup-title {
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 4px;
}

.ps-map-popup-meta {
    font-size: 0.82rem;
    color: var(--ps-text-muted);
}

.ps-map-popup-price {
    font-size: 0.95rem;
    margin: 8px 0;
    color: var(--ps-text-secondary);
}

.ps-map-popup-badges {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}

.ps-map-popup-meter {
    margin-top: 8px;
    background: var(--ps-border-subtle);
    height: 6px;
    border-radius: 999px;
    position: relative;
}

.ps-map-popup-meter span {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    border-radius: inherit;
    background: var(--ps-accent);
}

.ps-map-popup-actions {
    display: flex;
    gap: 6px;
    margin-top: 10px;
}

.ps-map-popup-meter-label {
    font-size: 0.8rem;
    color: var(--ps-text-muted);
    margin-top: 4px;
}

.ps-map-popup--list .ps-map-popup {
    margin-bottom: 8px;
}

.ps-map-marker {
    position: relative;
    width: 44px;
    height: 44px;
    display: grid;
    place-items: center;
}

.ps-map-marker__body {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    color: #0b1220;
    display: grid;
    place-items: center;
    font-weight: 800;
    font-size: 0.9rem;
    background: var(--ps-accent);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
}

.ps-map-marker__value {
    line-height: 1;
}

.ps-map-marker__halo {
    position: absolute;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: var(--ps-accent-soft);
    filter: blur(0.5px);
    z-index: -1;
}

.ps-map-marker--hot .ps-map-marker__body {
    background: var(--ps-success);
}

.ps-map-marker--active .ps-map-marker__body {
    transform: scale(1.05);
}

.ps-map-cluster {
    width: 48px;
    height: 48px;
    border-radius: 16px;
    display: grid;
    place-items: center;
    background: var(--ps-accent);
    color: #0b1220;
    font-weight: 700;
    box-shadow: 0 16px 36px rgba(0, 0, 0, 0.25);
}

.ps-map-cluster--warn {
    background: var(--ps-warning);
}

.ps-map-cluster--danger {
    background: var(--ps-danger);
    color: #fff;
}

.ps-map-card .ps-map {
    border: none;
}

.ps-bottom-sheet {
    position: relative;
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-card);
    box-shadow: var(--ps-shadow-card);
    display: grid;
    grid-template-rows: auto 1fr;
    min-height: 260px;
}

.ps-bottom-sheet__handle {
    width: 52px;
    height: 5px;
    border-radius: 999px;
    background: var(--ps-border-subtle);
    margin: 8px auto;
}

.ps-bottom-sheet__header {
    display: flex;
    justify-content: space-between;
    padding: 0 1rem 0.5rem;
    align-items: center;
}

.ps-bottom-sheet__body {
    padding: 0 1rem 1rem;
    overflow: auto;
}

.ps-bottom-sheet__footer {
    padding: 0.75rem 0;
}

/* ---------- Recommendations & cards ---------- */

.ps-reco-list {
    display: grid;
    gap: 0.85rem;
}

.ps-reco-card {
    padding: 0.9rem 1rem;
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
}

.ps-reco-meta {
    color: var(--ps-text-muted);
    font-size: 0.9rem;
}

.ps-reco-title {
    font-size: 1rem;
    font-weight: 700;
    margin-bottom: 4px;
}

.ps-reco-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 0.35rem;
}

/* ---------- AI assistant ---------- */

.ps-ai-shell {
    background: linear-gradient(135deg, rgba(79, 139, 255, 0.08), rgba(10, 14, 24, 0.02));
    border-radius: var(--ps-radius-card);
    padding: 1.2rem;
    border: 1px solid var(--ps-border-subtle);
}

.ps-assistant-card {
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
}

.ps-ai-grid {
    display: grid;
    gap: 1rem;
    grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
}

@media (max-width: 960px) {
    .ps-ai-grid {
        grid-template-columns: 1fr;
    }
}

.ps-ai-chat {
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    display: grid;
    grid-template-rows: auto 1fr auto;
    min-height: 420px;
    box-shadow: var(--ps-shadow-card);
}

.ps-ai-chat__header {
    padding: 0.9rem 1rem;
    border-bottom: 1px solid var(--ps-border-subtle);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
}

.ps-ai-actions {
    display: flex;
    gap: 0.4rem;
    align-items: center;
}

.ps-ai-prompts {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.ps-ai-prompts--inline {
    margin-top: 0;
    margin-bottom: 0.35rem;
}

.ps-ai-summary .ps-card {
    height: 100%;
}

.ps-ai-title {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 700;
}

.ps-ai-subtitle {
    margin: 0.15rem 0 0;
    color: var(--ps-text-muted);
}

.ps-ai-chat__body {
    padding: 0.9rem 1rem;
    overflow: auto;
    display: grid;
    gap: 0.65rem;
    background: linear-gradient(180deg, var(--ps-bg-card) 0%, var(--ps-bg-elevated) 100%);
}

.ps-ai-status {
    font-size: 0.85rem;
    color: var(--ps-text-muted);
}

.ps-ai-status.is-error {
    color: var(--ps-danger);
}

.ps-ai-messages {
    display: grid;
    gap: 0.65rem;
}

.ps-ai-bubble {
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    padding: 0.85rem;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.07);
}

.ps-ai-bubble--user {
    background: linear-gradient(135deg, var(--ps-accent-soft), var(--ps-bg-card));
    border-color: var(--ps-accent);
}

.ps-ai-meta {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    margin-bottom: 0.35rem;
    color: var(--ps-text-muted);
    font-size: 0.8rem;
}

.ps-ai-text {
    white-space: pre-wrap;
    line-height: 1.5;
    color: var(--ps-text-primary);
}

.ps-ai-actions-row {
    display: flex;
    gap: 0.4rem;
    margin-top: 0.4rem;
}

.ps-ai-input {
    padding: 0.9rem 1rem 1rem;
    border-top: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    display: grid;
    gap: 0.45rem;
}

.ps-ai-input__actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
}

.ps-ai-buttons {
    display: flex;
    gap: 0.4rem;
    align-items: center;
}

.ps-ai-hint {
    font-size: 0.82rem;
    color: var(--ps-text-muted);
}

/* ---------- Auth ---------- */

.ps-auth {
    min-height: calc(100vh - var(--ps-topbar-height) - 120px);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1.4rem;
}

.ps-auth-card {
    width: min(460px, 100%);
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-card);
    padding: 1.25rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-auth-title {
    margin: 0 0 0.35rem;
    font-size: 1.35rem;
}

.ps-auth-subtitle {
    margin: 0 0 1rem;
    color: var(--ps-text-muted);
}

.ps-auth-tabs {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    margin-bottom: 12px;
}

.ps-auth-tabs button {
    padding: 0.45rem 0.35rem;
    border-radius: 12px;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    cursor: pointer;
    font-weight: 600;
}

.ps-auth-tabs button.is-active {
    border-color: var(--ps-accent);
    background: var(--ps-accent-soft);
    box-shadow: 0 8px 18px rgba(79, 139, 255, 0.15);
}

.ps-auth-panel {
    display: none;
}

.ps-auth-panel.is-active {
    display: block;
}

.ps-auth-placeholder {
    padding: 1rem;
    border: 1px dashed var(--ps-border-subtle);
    border-radius: var(--ps-radius-soft);
    color: var(--ps-text-muted);
    display: grid;
    gap: 0.5rem;
    text-align: center;
}

.ps-auth-footer {
    margin-top: 0.75rem;
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

/* ---------- Toast & banners ---------- */

.ps-update-banner {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: var(--ps-bg-card);
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    margin-bottom: 1rem;
}

.ps-update-banner__text {
    font-weight: 600;
}

.ps-toast-container {
    position: fixed;
    inset-inline: 0;
    bottom: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
    padding: 0 0.75rem;
    z-index: 120;
}

.ps-toast {
    width: min(380px, 100%);
    align-self: center;
    padding: 0.65rem 0.8rem;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    box-shadow: var(--ps-shadow-card);
}

.ps-toast--success {
    border-color: rgba(34, 197, 94, 0.45);
}

.ps-toast--error {
    border-color: rgba(239, 68, 68, 0.5);
}

.ps-toast-message {
    flex: 1;
}

.ps-toast-close {
    background: transparent;
    border: none;
    color: var(--ps-text-muted);
    cursor: pointer;
}

.ps-install-banner {
    position: fixed;
    inset-inline: 0.75rem;
    bottom: calc(var(--ps-bottom-bar-height) + 12px);
    z-index: 110;
    display: flex;
    justify-content: center;
    opacity: 0;
    transform: translateY(12px);
    transition: opacity 0.2s ease, transform 0.2s ease;
}

.ps-install-banner.is-visible {
    opacity: 1;
    transform: translateY(0);
}

.ps-install-banner__inner {
    max-width: 440px;
    width: 100%;
    padding: 0.85rem 1rem;
    border-radius: var(--ps-radius-card);
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
    display: grid;
    gap: 0.5rem;
}

.ps-install-banner__actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

/* ---------- Footer ---------- */

.ps-footer {
    padding: 1rem;
    border-top: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
}

.ps-footer__inner {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    color: var(--ps-text-muted);
    font-size: 0.88rem;
}

.ps-footer__meta {
    color: var(--ps-text-muted);
}

/* ---------- Back to top ---------- */

.ps-back-to-top {
    position: fixed;
    right: 1rem;
    bottom: 1.1rem;
    width: 40px;
    height: 40px;
    border-radius: 12px;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: var(--ps-shadow-card);
    z-index: 115;
}

.ps-back-to-top.is-visible {
    display: flex;
}

/* ---------- Bottom tab bar ---------- */

.ps-tabbar {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    height: var(--ps-bottom-bar-height);
    background: var(--ps-bg-nav);
    border-top: 1px solid var(--ps-border-subtle);
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    box-shadow: 0 -12px 32px rgba(0, 0, 0, 0.08);
    z-index: 130;
    padding-bottom: env(safe-area-inset-bottom);
    padding-inline: max(0.5rem, env(safe-area-inset-left));
    backdrop-filter: blur(14px);
}

[data-theme="dark"] .ps-tabbar {
    background: rgba(8, 12, 22, 0.95);
    border-top-color: var(--ps-border-subtle);
    box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.5);
}

.ps-tabbar__item {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    color: var(--ps-text-muted);
    font-size: 0.86rem;
    position: relative;
    font-weight: 600;
}

.ps-tabbar__item::before {
    content: "";
    position: absolute;
    top: 0;
    left: 22%;
    right: 22%;
    height: 3px;
    border-radius: 999px;
    background: transparent;
    transition: background 0.15s ease;
}

.ps-tabbar__item.is-active {
    color: var(--ps-text-primary);
    font-weight: 700;
}

.ps-tabbar__item.is-active::before {
    background: linear-gradient(90deg, var(--ps-accent), #3a7bff);
}

.ps-tabbar__icon .ps-icon {
    width: 24px;
    height: 24px;
}

@media (min-width: 1025px) {
    .ps-tabbar {
        display: none;
    }
    body.ps-body {
        padding-bottom: 0;
    }
}

/* ---------- Skeleton ---------- */

.ps-card--skeleton {
    position: relative;
    overflow: hidden;
}

.ps-card--skeleton::after {
    display: none;
}

.ps-skeleton-line {
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, rgba(0, 0, 0, 0.04), rgba(0, 0, 0, 0.08), rgba(0, 0, 0, 0.04));
    background-size: 200% 100%;
    animation: ps-shimmer 1.2s linear infinite;
    margin-bottom: 0.4rem;
}

.ps-skeleton-line--lg {
    width: 70%;
}

.ps-skeleton-line--short {
    width: 40%;
}

@keyframes ps-shimmer {
    0% {
        background-position: 200% 0;
    }
    100% {
        background-position: -200% 0;
    }
}

/* ---------- Chips & pill helpers ---------- */

.ps-chip-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

/* ---------- Utility ---------- */

.ps-empty {
    color: var(--ps-text-muted);
    font-size: 0.9rem;
}

.ps-link {
    color: var(--ps-text-secondary);
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    text-decoration: none;
}

.ps-link:hover {
    color: var(--ps-text-primary);
}

.ps-link-arrow::after {
    content: "›";
    font-size: 1rem;
    color: inherit;
}

.ps-hint {
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

.ps-animate-fade-up {
    animation: ps-fade-up 0.35s ease-out both;
}

@keyframes ps-fade-up {
    from {
        opacity: 0;
        transform: translateY(6px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.ps-connection {
    display: inline-flex;
    align-items: center;
    padding: 0.35rem 0.6rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-muted);
    font-size: 0.85rem;
}

@keyframes ps-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

@keyframes ps-pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.06); }
    100% { transform: scale(1); }
}

/* ---------- Responsive tweaks ---------- */

@media (max-width: 640px) {
    .ps-main {
        padding-inline: 0.85rem;
    }
    .ps-map-topbar {
        position: static;
        flex-direction: column;
        width: 100%;
    }
    .ps-map {
        height: clamp(240px, 46vh, 340px);
    }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 183
PATH: static\css\cinematic-ui.css
LANG: css
===== CONTENT START =====
:root {
  --cinematic-glow: radial-gradient(circle at center,
      rgba(100, 200, 255, 0.4) 0%,
      transparent 70%);
  --hologram-effect: linear-gradient(45deg,
      transparent 30%,
      rgba(255, 255, 255, 0.1) 50%,
      transparent 70%);
  --quantum-shadow: 0 0 40px rgba(100, 200, 255, 0.3),
      0 0 80px rgba(100, 200, 255, 0.2),
      0 0 120px rgba(100, 200, 255, 0.1);
  --hologram-glow: rgba(0, 255, 255, 0.8);
}

@property --hologram-glow {
  syntax: '<color>';
  inherits: false;
  initial-value: rgba(0, 255, 255, 0.8);
}

.cinematic-surface {
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, rgba(12, 19, 39, 0.9), rgba(6, 11, 25, 0.9));
  border: 1px solid rgba(255, 255, 255, 0.04);
  box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55), var(--quantum-shadow);
}

.cinematic-surface::before {
  content: "";
  position: absolute;
  inset: -1px;
  background: var(--cinematic-glow);
  filter: blur(38px);
  opacity: 0.55;
  pointer-events: none;
}

.cinematic-surface::after {
  content: "";
  position: absolute;
  inset: 0;
  background: var(--hologram-effect);
  opacity: 0.35;
  mix-blend-mode: screen;
  pointer-events: none;
}

.cinematic-button,
.quantum-toggle {
  background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.35), rgba(14, 165, 233, 0.12));
  box-shadow: 0 10px 30px rgba(14, 165, 233, 0.35), 0 20px 60px rgba(6, 182, 212, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.08);
  color: #e0f2fe;
  padding: 0.5rem 0.9rem;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.cinematic-button::after,
.quantum-toggle::after {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(120deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0));
  opacity: 0;
  transition: opacity 0.35s ease;
}

.cinematic-button:hover::after,
.quantum-toggle:hover::after {
  opacity: 1;
}

.cinematic-marker {
  animation: hologram-float 3s ease-in-out infinite;
  filter: drop-shadow(0 0 20px var(--hologram-glow));
}

.quantum-pulse {
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: inherit;
  background: radial-gradient(circle at 50% 45%, rgba(56, 189, 248, 0.15), transparent 60%);
  animation: quantum-breathe 6s ease-in-out infinite;
}

.ai-forecast {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 0.5rem;
  margin-top: 0.35rem;
}

.ai-forecast-metric {
  padding: 0.55rem 0.65rem;
  border-radius: 0.75rem;
  border: 1px solid rgba(59, 130, 246, 0.2);
  background: rgba(15, 23, 42, 0.8);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.ai-forecast-label {
  font-size: 0.7rem;
  color: #cbd5e1;
  display: block;
  margin-bottom: 0.15rem;
}

.ai-forecast-value {
  font-weight: 700;
  font-size: 0.95rem;
  letter-spacing: 0.01em;
}

.ai-reasoning {
  margin-top: 0.5rem;
  padding: 0.55rem 0.6rem;
  border-radius: 0.75rem;
  border: 1px dashed rgba(255, 255, 255, 0.16);
  color: #e2e8f0;
  background: rgba(79, 70, 229, 0.08);
}

@keyframes hologram-float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
  100% { transform: translateY(0); }
}

@keyframes quantum-breathe {
  0% { opacity: 0.2; }
  50% { opacity: 0.55; }
  100% { opacity: 0.2; }
}

[data-quantum-theme="dark"] body,
body[data-quantum-theme="dark"] {
  background: radial-gradient(circle at top left, #0b1224 0%, #030712 45%, #01030a 100%);
}

[data-quantum-theme="light"] body,
body[data-quantum-theme="light"] {
  background: radial-gradient(circle at top left, #f8fafc 0%, #e2e8f0 40%, #cbd5e1 100%);
  color: #0f172a;
}

.ai-crest {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  padding: 0.35rem 0.8rem;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.14);
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.18), rgba(16, 185, 129, 0.16));
  box-shadow: 0 18px 45px rgba(15, 23, 42, 0.5);
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 184
PATH: static\js\app.js
LANG: javascript
===== CONTENT START =====
(function () {
    "use strict";

    window.ParkShare = window.ParkShare || {};

    // ---------- Helpers ----------

    function qs(selector, scope) {
        return (scope || document).querySelector(selector);
    }

    function qsa(selector, scope) {
        return Array.prototype.slice.call((scope || document).querySelectorAll(selector));
    }

    function isMobileWidth() {
        return window.matchMedia("(max-width: 767px)").matches;
    }

    // ---------- Service worker (registration is idempotent, PWA layer can override) ----------

    if ("serviceWorker" in navigator && !window.__PS_PWA_REGISTERED__) {
        window.__PS_PWA_REGISTERED__ = true;
        window.addEventListener("load", function () {
            navigator.serviceWorker
                .register("/service-worker.js", {updateViaCache: "none"})
                .then(function (reg) {
                    console.log("[SW] registered (legacy entry)", reg.scope);
                })
                .catch(function (err) {
                    console.warn("[SW] registration failed", err);
                });
        });
    }

    // ---------- Mobile menu ----------

    function initMenu() {
        const toggle = qs("[data-menu-toggle]");
        const menu = qs("[data-menu]");

        if (!toggle || !menu) return;

        function syncAria(isOpen) {
            toggle.setAttribute("aria-expanded", String(isOpen));
            toggle.setAttribute("aria-label", isOpen ? "Закрыть меню" : "Открыть меню");
        }

        toggle.addEventListener("click", function () {
            const isOpen = toggle.classList.toggle("is-open");
            menu.classList.toggle("is-open", isOpen);
            document.body.classList.toggle("ps-menu-open", isOpen);
            syncAria(isOpen);
        });

        syncAria(toggle.classList.contains("is-open"));

        // закрывать по клику на ссылку (на мобиле)
        qsa(".ps-nav-link", menu).forEach(function (link) {
            link.addEventListener("click", function () {
                toggle.classList.remove("is-open");
                menu.classList.remove("is-open");
                document.body.classList.remove("ps-menu-open");
                syncAria(false);
            });
        });
    }

    // ---------- Smooth scroll ----------

    function initSmoothScroll() {
        qsa("[data-scroll-to]").forEach(function (el) {
            el.addEventListener("click", function (e) {
                const href = el.getAttribute("href");
                if (!href || !href.startsWith("#")) return;
                const target = qs(href);
                if (!target) return;
                e.preventDefault();
                window.scrollTo({
                    top: target.getBoundingClientRect().top + window.scrollY - 72,
                    behavior: "smooth"
                });
            });
        });
    }

    // ---------- Back to top ----------

    function initBackToTop() {
        const btn = qs("[data-back-to-top]");
        if (!btn) return;

        function onScroll() {
            if (window.scrollY > 300) {
                btn.classList.add("is-visible");
            } else {
                btn.classList.remove("is-visible");
            }
        }

        window.addEventListener("scroll", onScroll, {passive: true});
        onScroll();

        btn.addEventListener("click", function () {
            window.scrollTo({top: 0, behavior: "smooth"});
        });
    }

    // ---------- Toasts ----------

    function showToast(message, type) {
        type = type || "info";
        const container = qs(".ps-toast-container");
        if (!container) return;

        const toast = document.createElement("div");
        toast.className = "ps-toast ps-toast--" + type;

        const msg = document.createElement("div");
        msg.className = "ps-toast-message";
        msg.textContent = message;

        const close = document.createElement("button");
        close.className = "ps-toast-close";
        close.type = "button";
        close.innerHTML = "×";

        close.addEventListener("click", function () {
            toast.remove();
        });

        toast.appendChild(msg);
        toast.appendChild(close);
        container.appendChild(toast);

        setTimeout(function () {
            toast.remove();
        }, 4000);
    }

    // ---------- PWA install banner ----------

    let deferredPrompt = null;
    const INSTALL_DISMISS_KEY = "pwaPromptDismissedUntil";
    const INSTALL_DISMISS_DAYS = 30;

    function isStandalone() {
        return window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
    }

    function isMobileDevice() {
        const ua = navigator.userAgent || "";
        const isIOS = /iPhone|iPad|iPod/i.test(ua);
        const isAndroid = /Android/i.test(ua);
        const isCoarse = window.matchMedia && window.matchMedia("(pointer:coarse)").matches;
        return isIOS || isAndroid || isCoarse;
    }

    function dismissedUntil() {
        try {
            const value = localStorage.getItem(INSTALL_DISMISS_KEY);
            return value ? parseInt(value, 10) : 0;
        } catch (_) {
            return 0;
        }
    }

    function markDismiss(days) {
        try {
            const until = Date.now() + days * 24 * 60 * 60 * 1000;
            localStorage.setItem(INSTALL_DISMISS_KEY, String(until));
        } catch (_) {}
    }

    function canShowBanner() {
        if (!isMobileDevice() || isStandalone()) return false;
        const until = dismissedUntil();
        if (until && until > Date.now()) return false;
        return true;
    }

    function initInstallBanner() {
        const banner = qs("[data-install-banner]");
        const btnAccept = qs("[data-install-accept]", banner);
        const btnDismiss = qs("[data-install-dismiss]", banner);
        const menuButton = qs("[data-nav-install-app]");
        const fallbackUrl = (menuButton && menuButton.getAttribute("data-install-href")) || "/pwa-install/";

        if (!banner || !btnAccept || !btnDismiss) return;

        function hideBanner() {
            banner.classList.remove("is-visible");
            setTimeout(function () { banner.hidden = true; }, 200);
        }

        function showBanner() {
            if (!canShowBanner()) return;
            banner.hidden = false;
            requestAnimationFrame(function () { banner.classList.add("is-visible"); });
        }

        function triggerInstall(source) {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice
                    .then(function (choiceResult) {
                        if (choiceResult.outcome === "accepted") {
                            showToast("Установка ParkShare RU запущена", "success");
                            markDismiss(365);
                        }
                    })
                    .finally(function () {
                        deferredPrompt = null;
                        hideBanner();
                    });
            } else {
                if (fallbackUrl) {
                    window.location.href = fallbackUrl;
                } else {
                    showToast("Откройте меню браузера и выберите «Добавить на экран»", "info");
                }
                hideBanner();
            }
        }

        if (menuButton) {
            if (!isMobileDevice() || isStandalone()) {
                menuButton.style.display = "none";
            }
            menuButton.addEventListener("click", function () { triggerInstall("menu"); });
        }

        window.addEventListener("beforeinstallprompt", function (e) {
            e.preventDefault();
            deferredPrompt = e;
            if (canShowBanner()) {
                showBanner();
            }
        });

        btnDismiss.addEventListener("click", function () {
            markDismiss(INSTALL_DISMISS_DAYS);
            hideBanner();
            deferredPrompt = null;
        });

        btnAccept.addEventListener("click", function () { triggerInstall("banner"); });

        window.addEventListener("appinstalled", function () {
            markDismiss(365);
            hideBanner();
        });

        if (canShowBanner()) {
            showBanner();
        }
    }

    // ---------- Skeleton removal ----------

    function initSkeletons() {
        const cards = qsa(".ps-card--skeleton");
        if (!cards.length) return;

        // Имитация загрузки данных — через небольшой таймаут
        window.setTimeout(function () {
            cards.forEach(function (card) {
                card.parentNode && card.parentNode.removeChild(card);
            });
        }, 350);
    }

    // ---------- Spots bottom sheet (mobile) ----------

    function initSpotsSheet() {
        const panel = qs("[data-spots-panel]");
        if (!panel) return;
        const triggers = qsa("[data-open-spots]");

        function setState(open) {
            panel.classList.toggle("is-sheet-open", open);
            if (open) {
                panel.scrollIntoView({ behavior: "smooth" });
            }
        }

        triggers.forEach(function (btn) {
            btn.addEventListener("click", function () {
                const next = !panel.classList.contains("is-sheet-open");
                setState(next);
            });
        });

        window.addEventListener("resize", function () {
            if (!isMobileWidth()) {
                panel.classList.remove("is-sheet-open");
            }
        });
    }

// ---------- Adaptive AI probe ----------
function initAdaptiveProbe() {
    const payload = {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio || 1,
        platform: document.documentElement.getAttribute("data-platform") || "RU",
    };

    fetch("/api/ai/parkmate/config/", {
        method: "POST",
        credentials: "include",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            client: payload,
            action: "adaptive-profile",
        }),
        keepalive: true, // чтобы не блокировать навигацию, аналогично sendBeacon
    }).catch(function () {
        // молча игнорируем
    });
}





    // ---------- Geolocation helper ----------

    function initGeolocation() {
        const buttons = qsa("[data-fill-location]");
        if (!buttons.length) return;

        function fill(lat, lng) {
            const latInput = qs("#lat");
            const lngInput = qs("#lng");
            if (!latInput || !lngInput) return;
            latInput.value = lat.toFixed(5);
            lngInput.value = lng.toFixed(5);
            showToast("Координаты определены, нажмите «Найти места»", "success");
        }

        buttons.forEach(function (btn) {
            btn.addEventListener("click", function () {
                if (!("geolocation" in navigator)) {
                    showToast("Геолокация недоступна в этом браузере", "error");
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    function (pos) {
                        fill(pos.coords.latitude, pos.coords.longitude);
                    },
                    function () {
                        showToast("Не удалось получить местоположение", "error");
                    },
                    {
                        enableHighAccuracy: false,
                        timeout: 8000,
                        maximumAge: 60000
                    }
                );
            });
        });
    }

    // ---------- Payment methods (ЛК) ----------

    const PAYMENT_METHODS_ENDPOINT = "/api/payments/methods/";

    function getCSRFToken() {
        const match = document.cookie.match(/csrftoken=([^;]+)/);
        return match ? match[1] : "";
    }

    function detectBrand(num) {
        if (!num) return "other";
        if (/^4/.test(num)) return "visa";
        if (/^5[1-5]/.test(num)) return "mc";
        if (/^220[0-4]/.test(num)) return "mir";
        if (/^62/.test(num)) return "up";
        return "other";
    }

    function renderPaymentMethods(methods, container) {
        if (!container) return;
        if (!methods || !methods.length) {
            container.innerHTML = "<div class='ps-empty'>Карты пока не добавлены.</div>";
            return;
        }
        container.innerHTML = methods
            .map(function (method) {
                const brand = method.brand ? method.brand.toUpperCase() : "CARD";
                const defaultBadge = method.is_default ? "<span class='ps-badge ps-badge--success'>По умолчанию</span>" : "";
                return (
                    "<div class='ps-payment-card'>" +
                    "<div>" +
                    "<div class='ps-payment-brand'>" + brand + " · " + (method.mask || ("**** " + method.last4)) + " " + defaultBadge + "</div>" +
                    "<div class='ps-payment-meta'>Срок: " + method.exp_month + "/" + method.exp_year + (method.label ? " · " + method.label : "") + "</div>" +
                    "</div>" +
                    "<div class='ps-payment-actions'>" +
                    "<button class='ps-btn ps-btn-ghost ps-btn-sm' data-payment-default='" + method.id + "'>Сделать осн.</button>" +
                    "<button class='ps-btn ps-btn-ghost ps-btn-sm' data-payment-delete='" + method.id + "'>Удалить</button>" +
                    "</div>" +
                    "</div>"
                );
            })
            .join("");
    }

    function initPaymentMethods() {
        const container = qs("[data-payment-methods]");
        const form = qs("[data-payment-method-form]");
        if (!container && !form) return;

        function loadMethods() {
            fetch(PAYMENT_METHODS_ENDPOINT, { credentials: "include" })
                .then(function (resp) { return resp.json(); })
                .then(function (data) { renderPaymentMethods(data.results || data, container); })
                .catch(function () { showToast("Не удалось загрузить способы оплаты", "error"); });
        }

        if (form) {
            form.addEventListener("submit", function (evt) {
                evt.preventDefault();
                const fd = new FormData(form);
                const cardNumber = (fd.get("card_number") || "").replace(/\D/g, "");
                const exp = (fd.get("exp") || "").split("/");
                const expMonth = parseInt(exp[0], 10) || 1;
                const expYear = parseInt((exp[1] || "").replace(/[^0-9]/g, ""), 10) || 30;
                const payload = {
                    label: fd.get("label") || fd.get("provider") || "Моя карта",
                    brand: detectBrand(cardNumber),
                    last4: cardNumber.slice(-4) || "0000",
                    exp_month: expMonth,
                    exp_year: expYear,
                    is_default: fd.get("is_default") === "on",
                    token_masked: "tok_" + (cardNumber.slice(-6) || "card") + Date.now(),
                };

                fetch(PAYMENT_METHODS_ENDPOINT, {
                    method: "POST",
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCSRFToken(),
                    },
                    body: JSON.stringify(payload),
                })
                    .then(function (resp) { return resp.json(); })
                    .then(function () {
                        showToast("Карта сохранена", "success");
                        form.reset();
                        loadMethods();
                    })
                    .catch(function () { showToast("Не удалось сохранить карту", "error"); });
            });
        }

        if (container) {
            container.addEventListener("click", function (evt) {
                const defBtn = evt.target.closest("[data-payment-default]");
                const delBtn = evt.target.closest("[data-payment-delete]");
                if (defBtn) {
                    const id = defBtn.getAttribute("data-payment-default");
                    fetch(PAYMENT_METHODS_ENDPOINT + id + "/", {
                        method: "PATCH",
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRFToken": getCSRFToken(),
                        },
                        body: JSON.stringify({ is_default: true }),
                    })
                        .then(function (resp) { return resp.json(); })
                        .then(function () { showToast("Карта выбрана по умолчанию", "success"); loadMethods(); })
                        .catch(function () { showToast("Не удалось обновить карту", "error"); });
                }
                if (delBtn) {
                    const id = delBtn.getAttribute("data-payment-delete");
                    fetch(PAYMENT_METHODS_ENDPOINT + id + "/", {
                        method: "DELETE",
                        credentials: "include",
                        headers: { "X-CSRFToken": getCSRFToken() },
                    })
                        .then(function (resp) { if (!resp.ok) throw new Error(); })
                        .then(function () { showToast("Карта удалена", "info"); loadMethods(); })
                        .catch(function () { showToast("Не удалось удалить карту", "error"); });
                }
            });
        }

        loadMethods();
    }

    // ---------- Bottom navigation ----------



    function initBottomNav() {
        const nav = qs("[data-bottom-nav]");
        if (!nav) return;
        const items = qsa("[data-nav]", nav);

        const defaultKey = (function () {
            const path = window.location.pathname;
            if (window.location.hash === "#assistant") return "assistant";
            if (path.indexOf("/assistant") === 0 || path.indexOf("/ai") === 0) return "assistant";
            if (path.indexOf("/личный-кабинет") === 0) return "bookings";
            if (path.indexOf("/кабинет-владельца") === 0) return "parking";
            if (path.indexOf("/map") === 0) return "map";
            return "map";
        })();

        function setActive(key) {
            const target = key || defaultKey;
            items.forEach(function (item) {
                const current = item.getAttribute("data-nav");
                item.classList.toggle("is-active", current === target);
            });
        }

        items.forEach(function (item) {
            item.addEventListener("click", function () {
                const key = item.getAttribute("data-nav");
                if (key) setActive(key);
            });
        });

        setActive(defaultKey);
    }

    // ---------- Init ----------

    document.addEventListener("DOMContentLoaded", function () {
        initMenu();
        initSmoothScroll();
        initBackToTop();
        initInstallBanner();
        initSkeletons();
        initSpotsSheet();
        initAdaptiveProbe();
        initGeolocation();
        initPaymentMethods();
        initBottomNav();

        const aiLauncher = document.querySelector(".ai-assistant-launcher");
        const aiPanel = document.querySelector(".ai-assistant-panel");
        const aiClose = document.querySelector(".ai-assistant-panel__close");

        if (aiLauncher && aiPanel) {
            aiLauncher.addEventListener("click", function () {
                aiPanel.classList.toggle("is-open");
            });
        }

        if (aiClose && aiPanel) {
            aiClose.addEventListener("click", function () {
                aiPanel.classList.remove("is-open");
            });
        }
    });

    // Экспортируем showToast в глобальную область на всякий
    window.ParkShare = window.ParkShare || {};
    window.ParkShare.showToast = showToast;
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 185
PATH: static\js\chat.js
LANG: javascript
===== CONTENT START =====
(function () {
  'use strict';

  function qs(selector, scope) {
    return (scope || document).querySelector(selector);
  }
  function qsa(selector, scope) {
    return Array.prototype.slice.call((scope || document).querySelectorAll(selector));
  }

  const encoder = new TextEncoder();
  const STORAGE_PREFIX = 'ps_ai_chat_v2:';

  function storageKey(userId, fallbackKey) {
    return STORAGE_PREFIX + (userId || 'guest') + ':' + (fallbackKey || 'default');
  }

  function loadState(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (_) {
      return null;
    }
  }

  function saveState(key, state) {
    try {
      localStorage.setItem(key, JSON.stringify(state));
    } catch (_) {
      // ignore quota errors
    }
  }

  function now() {
    return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function createWelcomeMessage() {
    return {
      id: crypto.randomUUID(),
      role: 'assistant',
      content: 'Привет! Я ParkShare AI Concierge. Спроси про загрузку, цены, сценарии для гостей или подготовку персонала.',
      createdAt: Date.now()
    };
  }

  function renderMessage(message) {
    const bubble = document.createElement('div');
    bubble.className = 'ps-ai-bubble ' + (message.role === 'user' ? 'ps-ai-bubble--user' : 'ps-ai-bubble--assistant');
    bubble.dataset.messageId = message.id;

    const meta = document.createElement('div');
    meta.className = 'ps-ai-meta';
    meta.innerHTML = `<span class="ps-chip ${message.role === 'user' ? 'ps-chip--primary' : 'ps-chip--ghost'}">${message.role === 'user' ? 'Вы' : 'AI'}</span><span>${new Date(message.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>`;
    bubble.appendChild(meta);

    const text = document.createElement('div');
    text.className = 'ps-ai-text';
    text.textContent = message.content || '...';
    bubble.appendChild(text);

    if (message.role === 'assistant') {
      const actions = document.createElement('div');
      actions.className = 'ps-ai-actions-row';
      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'ps-btn ps-btn-ghost ps-btn-xs';
      copyBtn.textContent = 'Копировать';
      copyBtn.dataset.aiCopy = 'true';
      actions.appendChild(copyBtn);

      const regenBtn = document.createElement('button');
      regenBtn.type = 'button';
      regenBtn.className = 'ps-btn ps-btn-ghost ps-btn-xs';
      regenBtn.textContent = 'Перегенерировать';
      regenBtn.dataset.aiRegenerate = 'true';
      actions.appendChild(regenBtn);

      actions.hidden = !message.content;
      bubble.appendChild(actions);
    }

    return bubble;
  }

  function setupChat() {
    const chatRoot = qs('[data-ai-chat]');
    if (!chatRoot) return;

    const messagesEl = qs('[data-ai-messages]', chatRoot);
    const textarea = qs('#ai-input', chatRoot);
    const sendBtn = qs('[data-ai-send]', chatRoot);
    const clearBtn = qs('[data-ai-clear]', chatRoot);
    const stopBtn = qs('[data-ai-stop]', chatRoot);
    const statusEl = qs('[data-ai-status]', chatRoot);
    const regenerateBtn = qs('[data-ai-regenerate]', chatRoot);
    const promptButtons = qsa('[data-ai-prompt]');
    const userId = document.body.getAttribute('data-user-id') || 'guest';
    const historyKey = chatRoot.getAttribute('data-ai-history-key') || 'default';
    const storage = storageKey(userId, historyKey);

    let state = loadState(storage) || { messages: [createWelcomeMessage()] };
    let isStreaming = false;
    let abortController = null;

    function persist() {
      saveState(storage, state);
    }

  function render() {
    messagesEl.innerHTML = '';
    state.messages.forEach(function (msg) {
      messagesEl.appendChild(renderMessage(msg));
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
    if (regenerateBtn) {
      const hasUserMessages = state.messages.some(function (m) { return m.role === 'user'; });
      regenerateBtn.hidden = !hasUserMessages || isStreaming;
    }
    persist();
  }

    function setStatus(text, tone) {
      if (!statusEl) return;
      statusEl.textContent = text;
      statusEl.classList.toggle('is-error', tone === 'error');
    }

  function lastUserMessage() {
      for (let i = state.messages.length - 1; i >= 0; i--) {
        if (state.messages[i].role === 'user') return state.messages[i];
      }
      return null;
  }

    function addMessage(role, content) {
      const msg = { id: crypto.randomUUID(), role, content, createdAt: Date.now() };
      state.messages.push(msg);
      return msg;
    }

    function updateMessage(id, updater) {
      state.messages = state.messages.map(function (msg) {
        return msg.id === id ? updater(msg) : msg;
      });
    }

  function handleSend() {
      if (!textarea || !textarea.value.trim() || isStreaming) return;
      const text = textarea.value.trim();
      textarea.value = '';
      const userMsg = addMessage('user', text);
      const assistant = addMessage('assistant', '');
      render();
      const history = state.messages.filter(function (msg) { return msg.id !== assistant.id; });
      streamToApi(userMsg, assistant, history);
    }

    function handleRegenerate() {
      if (isStreaming) return;
      let lastUserIndex = -1;
      for (let i = state.messages.length - 1; i >= 0; i--) {
        if (state.messages[i].role === 'user') {
          lastUserIndex = i;
          break;
        }
      }
      if (lastUserIndex === -1) return;
      // Оставляем историю до последнего пользовательского сообщения
      state.messages = state.messages.slice(0, lastUserIndex + 1);
      const userMsg = state.messages[lastUserIndex];
      const assistant = addMessage('assistant', '');
      const history = state.messages.filter(function (msg) { return msg.id !== assistant.id; });
      setStatus('Генерируем новый ответ…', 'info');
      render();
      streamToApi(userMsg, assistant, history);
    }

    function handleCopy(targetId) {
      const msg = state.messages.find(function (m) { return m.id === targetId; });
      if (!msg || !msg.content || !navigator.clipboard) return;
      navigator.clipboard.writeText(msg.content).catch(function () {});
    }

  async function streamToApi(userMsg, assistantMsg, historyOverride) {
      const baseHistory = (historyOverride && historyOverride.length ? historyOverride : state.messages).filter(function (msg) {
        return !(assistantMsg && msg.id === assistantMsg.id);
      });
      const payload = baseHistory.map(function (m) {
        return { role: m.role, content: m.content };
      });
      abortController = new AbortController();
      isStreaming = true;
      stopBtn && (stopBtn.hidden = false);
      setStatus('Генерируем ответ…', 'info');

      try {
        const resp = await fetch('/api/chat/', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ messages: payload }),
          signal: abortController.signal
        });

        if (!resp.ok || !resp.body) {
          let detail = '';
          try {
            const errJson = await resp.json();
            detail = errJson.detail || '';
          } catch (_) {
            try { detail = await resp.text(); } catch (__) { /* ignore */ }
          }
          throw new Error(detail || 'LLM недоступен. Настройте /api/chat/');
        }

        const reader = resp.body.getReader();
        const decoder = new TextDecoder();

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          const chunk = decoder.decode(value, { stream: true });
          updateMessage(assistantMsg.id, function (msg) {
            return { ...msg, content: (msg.content || '') + chunk };
          });
          render();
        }
        setStatus('Готово. Можно задавать следующий вопрос.', 'info');
      } catch (error) {
        if (error.name === 'AbortError') {
          setStatus('Остановлено пользователем.', 'info');
        } else {
          console.warn('Chat error', error);
          updateMessage(assistantMsg.id, function (msg) {
            return { ...msg, content: 'Сервис временно недоступен. Проверьте /api/chat/ или ключи LLM.' };
          });
          setStatus('Ошибка сети или LLM. Попробуйте ещё раз.', 'error');
        }
      } finally {
        isStreaming = false;
        stopBtn && (stopBtn.hidden = true);
        abortController = null;
        render();
      }
    }

    function handleStop() {
      if (abortController) {
        abortController.abort();
        abortController = null;
      }
      isStreaming = false;
      stopBtn && (stopBtn.hidden = true);
      setStatus('Остановлено пользователем.', 'info');
    }

    function handleClear() {
      state = { messages: [createWelcomeMessage()] };
      setStatus('История очищена. Новый диалог.', 'info');
      render();
    }

    chatRoot.addEventListener('click', function (e) {
      const bubble = e.target.closest('[data-message-id]');
      if (!bubble) return;
      const id = bubble.getAttribute('data-message-id');
      if (e.target.matches('[data-ai-copy]')) {
        handleCopy(id);
      }
      if (e.target.matches('[data-ai-regenerate]')) {
        handleRegenerate();
      }
    });

    sendBtn && sendBtn.addEventListener('click', handleSend);
    clearBtn && clearBtn.addEventListener('click', handleClear);
    stopBtn && stopBtn.addEventListener('click', handleStop);
    regenerateBtn && regenerateBtn.addEventListener('click', handleRegenerate);

    promptButtons.forEach(function (btn) {
      btn.addEventListener('click', function () {
        const prompt = btn.textContent || '';
        if (!textarea) return;
        textarea.value = prompt;
        textarea.focus();
      });
    });

    if (textarea) {
      textarea.addEventListener('keydown', function (evt) {
        if (evt.key === 'Enter' && !evt.shiftKey) {
          evt.preventDefault();
          handleSend();
        }
      });
    }

    render();
  }

  document.addEventListener('DOMContentLoaded', setupChat);
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 186
PATH: static\js\map.js
LANG: javascript
===== CONTENT START =====
// static/js/map.js
// Обновлённый модуль карты ParkShare: кастомные тёмные слои Яндекс.Карт,
// анимированные контролы, адаптивные балуны и мобильные шторки.

(function () {
    "use strict";

    function qs(sel, ctx) { return (ctx || document).querySelector(sel); }
    function qsa(sel, ctx) { return Array.prototype.slice.call((ctx || document).querySelectorAll(sel)); }

    var MAP_CONFIG = window.PARKSHARE_MAP_PROVIDER || {};
    var priceRange = [0, 1500];
    var prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    var dataTheme = document.documentElement.getAttribute("data-theme");
    var storedTheme = null;
    try { storedTheme = localStorage.getItem("ps-theme"); } catch (_) {}
    var isNight = (dataTheme || storedTheme || (prefersDark ? "dark" : "light")) === "dark";
    var lastFeatures = [];
    var userLocation = null;

    function distanceKm(a, b) {
        if (!a || !b) return 0;
        var rad = Math.PI / 180;
        var lat1 = a[0] * rad, lat2 = b[0] * rad, lon1 = a[1] * rad, lon2 = b[1] * rad;
        var dlat = lat2 - lat1, dlon = lon2 - lon1;
        var h = Math.sin(dlat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) ** 2;
        return 6371 * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
    }

    function applyMapTheme(theme, provider, container, silent) {
        var mode = theme === "dark" ? "dark" : "light";
        var mapEl = container || qs("#map");
        if (mapEl) {
            mapEl.classList.toggle("ps-map--dark", mode === "dark");
            mapEl.classList.toggle("ps-map--light", mode === "light");
        }

        if (!silent) {
            if (window.ThemeController && typeof window.ThemeController.setTheme === "function") {
                window.ThemeController.setTheme(mode);
            } else {
                document.documentElement.setAttribute("data-theme", mode);
                try { localStorage.setItem("ps-theme", mode); } catch (_) {}
            }
        }

        var btn = qs("[data-map-theme]");
        if (btn) {
            var isDark = mode === "dark";
            btn.setAttribute("aria-pressed", String(isDark));
            btn.classList.toggle("is-active", isDark);
        }

        isNight = mode === "dark";
        if (provider && provider.toggleTheme) provider.toggleTheme(isNight ? "night" : "day");
    }

    // ---------- Базовый интерфейс ----------
    function BaseMapProvider(options) { this.options = options || {}; }
    BaseMapProvider.prototype.init = function () {};
    BaseMapProvider.prototype.setFeatures = function () {};
    BaseMapProvider.prototype.setLoading = function () {};
    BaseMapProvider.prototype.drawRouteTo = function () {};
    BaseMapProvider.prototype.focusOn = function () {};
    BaseMapProvider.prototype.onInteraction = function () {};
    BaseMapProvider.prototype.toggleTheme = function () {};
    BaseMapProvider.prototype.showUserLocation = function () {};
    BaseMapProvider.prototype.setView = function () {};

    // ---------- Leaflet fallback ----------
    function LeafletMapProvider(options) {
        BaseMapProvider.call(this, options);
        this._map = null;
        this._markersLayer = null;
        this._tileLayers = {};
        this._currentTile = "day";
        this._activeRoute = null;
        this._highlight = null;
    }
    LeafletMapProvider.prototype = Object.create(BaseMapProvider.prototype);

    LeafletMapProvider.prototype.init = function (container, center, zoom) {
        if (typeof L === "undefined") return;
        this._map = L.map(container, { center: center, zoom: zoom, scrollWheelZoom: false });
        this._tileLayers.day = this._createBaseLayer("light");
        this._tileLayers.night = this._createBaseLayer("dark");
        this._tileLayers.day.addTo(this._map);
        this._markersLayer = L.markerClusterGroup({ chunkedLoading: true, spiderfyOnMaxZoom: true }).addTo(this._map);
    };

    LeafletMapProvider.prototype._createBaseLayer = function (mode) {
        var url = mode === "dark"
            ? "https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png"
            : "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png";
        return L.tileLayer(url, { maxZoom: 20 });
    };

    LeafletMapProvider.prototype.setFeatures = function (fc) {
        if (!this._map || !this._markersLayer) return;
        var layer = this._markersLayer;
        layer.clearLayers();
        var bounds = [];
        (fc.features || []).forEach(function (feature) {
            var coords = feature.geometry && feature.geometry.coordinates;
            if (!coords) return;
            var lng = coords[0], lat = coords[1];
            var p = feature.properties || {};
            var stress = p.stress_index || 0;
            var color = stress >= 0.8 ? "#ef4444" : stress >= 0.6 ? "#f59e0b" : "#0ea5e9";
            var isHot = p.hourly_price && stress < 0.6;
            var freeLabel = (p.free_places === 0 || p.free_places) ? p.free_places : null;
            var label = freeLabel != null ? String(freeLabel) : "P";
            var textColor = (color === "#ef4444" || color === "#f59e0b") ? "#ffffff" : "#04121f";
            var markerHtml = [
                "<div class='ps-map-marker" + (isHot ? " ps-map-marker--hot" : "") + "'>",
                "  <div class='ps-map-marker__halo'></div>",
                "  <div class='ps-map-marker__body' style='background:" + color + "; color:" + textColor + "'>",
                "    <span class='ps-map-marker__value'>" + label + "</span>",
                "  </div>",
                "</div>"
            ].join("");
            var marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: "ps-map-marker-wrap",
                    html: markerHtml,
                    iconSize: [46, 46],
                    iconAnchor: [23, 23],
                })
            });
            marker.bindPopup(buildPopupHtml(p, color), { className: "ps-map-popup-card" });
            marker.addTo(layer);
            bounds.push([lat, lng]);
        });
        lastFeatures = fc.features || [];
        if (bounds.length) this._map.fitBounds(bounds, { padding: [72, 72] });
    };

    LeafletMapProvider.prototype.toggleTheme = function (mode) {
        if (!this._map) return;
        var next = mode === "night" ? "night" : mode === "day" ? "day" : (this._currentTile === "day" ? "night" : "day");
        this._map.removeLayer(this._tileLayers[this._currentTile]);
        this._tileLayers[next].addTo(this._map);
        this._currentTile = next;
    };

    LeafletMapProvider.prototype.setLoading = function (isLoading) {
        var el = qs("[data-map-loading]");
        if (el) el.style.display = isLoading ? "flex" : "none";
    };

    LeafletMapProvider.prototype.drawRouteTo = function (target, fromCoords, onHint) {
        if (!this._map || !target) return;
        if (this._activeRoute) this._activeRoute.remove();
        var origin = fromCoords ? L.latLng(fromCoords.lat, fromCoords.lng) : this._map.getCenter();
        var dest = target.lat != null ? L.latLng(target.lat, target.lng) : L.latLng(target[0], target[1]);
        this._activeRoute = L.polyline([origin, dest], { color: "#22c55e", weight: 4, opacity: 0.85 }).addTo(this._map);
        var km = distanceKm([origin.lat, origin.lng], [dest.lat, dest.lng]);
        if (onHint) onHint(km);
        this._map.fitBounds(this._activeRoute.getBounds(), { padding: [56, 56] });
    };

    LeafletMapProvider.prototype.focusOn = function (lat, lng) {
        if (!this._map) return;
        if (this._highlight) this._highlight.remove();
        this._highlight = L.circleMarker([lat, lng], { color: "#fbbf24", radius: 14, weight: 3 }).addTo(this._map);
        this._map.setView([lat, lng], 15);
    };

    LeafletMapProvider.prototype.onInteraction = function (start, end) {
        if (!this._map) return;
        if (start) this._map.on("movestart zoomstart dragstart", start);
        if (end) this._map.on("moveend zoomend dragend", end);
    };

    LeafletMapProvider.prototype.showUserLocation = function (lat, lng) {
        if (!this._map) return;
        var radius = L.circle([lat, lng], { radius: 450, color: "#22c55e", weight: 2, fillOpacity: 0.12 }).addTo(this._map);
        radius.bringToBack();
    };

    LeafletMapProvider.prototype.setView = function (lat, lng, zoom) {
        if (!this._map) return;
        this._map.setView([lat, lng], zoom || this._map.getZoom());
    };

    // ---------- Yandex Maps ----------
    function YandexMapProvider(options) {
        BaseMapProvider.call(this, options);
        this._map = null;
        this._clusterer = null;
        this._activeRoute = null;
        this._highlight = null;
        this._ready = false;
        this._theme = options.theme || "day";
        this._mapTypesReady = false;
        this._heatLayer = null;
    }
    YandexMapProvider.prototype = Object.create(BaseMapProvider.prototype);

    YandexMapProvider.prototype._ensureMapTypes = function () {
        if (this._mapTypesReady || typeof ymaps === "undefined") return;
        var lightLayer = function () {
            return new ymaps.Layer("https://core-renderer-tiles.maps.yandex.net/tiles?l=map&theme=light&x=%x&y=%y&z=%z&scale=1&lang=ru_RU", { projection: ymaps.projection.sphericalMercator });
        };
        var darkLayer = function () {
            return new ymaps.Layer("https://core-renderer-tiles.maps.yandex.net/tiles?l=map&theme=dark&x=%x&y=%y&z=%z&scale=1&lang=ru_RU", { projection: ymaps.projection.sphericalMercator });
        };
        ymaps.mapType.storage.add("ps#light", new ymaps.MapType("ps#light", [lightLayer]));
        ymaps.mapType.storage.add("ps#dark", new ymaps.MapType("ps#dark", [darkLayer]));
        this._mapTypesReady = true;
    };

    YandexMapProvider.prototype._ensureLayouts = function () {
        if (this._markerLayout && this._clusterIconLayout && this._clusterBalloonLayout) return;

        var markerTpl = [
            "<div class='ps-map-marker {{properties.markerActive}} {{properties.markerHot ? \"ps-map-marker--hot\" : ''}}'>",
            "  <div class='ps-map-marker__halo'></div>",
            "  <div class='ps-map-marker__body' style='background: {{properties.markerColor}}; color: {{properties.markerTextColor}}'>",
            "    <span class='ps-map-marker__value'>{{properties.markerLabel}}</span>",
            "  </div>",
            "</div>"
        ].join("");
        this._markerLayout = ymaps.templateLayoutFactory.createClass(markerTpl, {
            getShape: function () { return new ymaps.shape.Circle(new ymaps.geometry.pixel.Point([28, 28]), 26); },
        });

        var clusterTpl = "<div class='ps-map-cluster'><div class='ps-map-cluster__count'>{{properties.geoObjects.length}}</div></div>";
        this._clusterIconLayout = ymaps.templateLayoutFactory.createClass(clusterTpl, {
            build: function () {
                this.constructor.superclass.build.call(this);
                var node = this.getParentElement() && this.getParentElement().firstChild;
                if (!node) return;
                var geoObjects = (this.getData().properties.get("geoObjects") || []).map(function (g) { return g.properties.getAll(); });
                var avg = geoObjects.reduce(function (acc, p) { return acc + (p.stress_index || 0); }, 0) / (geoObjects.length || 1);
                node.classList.add(avg >= 0.75 ? "ps-map-cluster--danger" : avg >= 0.45 ? "ps-map-cluster--warn" : "ps-map-cluster--ok");
            }
        });

        this._clusterBalloonLayout = ymaps.templateLayoutFactory.createClass("<div class='ps-map-popup ps-map-popup--list'></div>", {
            build: function () {
                this.constructor.superclass.build.call(this);
                var container = this.getParentElement() && this.getParentElement().querySelector(".ps-map-popup--list");
                if (!container) return;
                var items = this.getData().properties.get("geoObjects") || [];
                container.innerHTML = items.map(function (g) { return g.properties.get("balloonContent") || ""; }).join("");
            }
        });
    };

    YandexMapProvider.prototype.init = function (container, center, zoom) {
        var self = this;
        if (typeof ymaps === "undefined") return;
        this._container = container;
        ymaps.ready(function () {
            self._ensureMapTypes();
            self._map = new ymaps.Map(container, { center: center, zoom: zoom, type: isNight ? "ps#dark" : "ps#light", controls: ["zoomControl"] });
            self._map.behaviors.disable("scrollZoom");
            self._ensureLayouts();
            self._clusterer = new ymaps.Clusterer({
                clusterIconLayout: self._clusterIconLayout,
                clusterIconOffset: [-28, -28],
                clusterIconShape: { type: "Circle", coordinates: [28, 28], radius: 28 },
                clusterNumbers: [50],
                groupByCoordinates: false,
                clusterDisableClickZoom: true,
                clusterBalloonContentLayout: self._clusterBalloonLayout,
                clusterBalloonPanelMaxMapArea: 0,
            });
            self._map.geoObjects.add(self._clusterer);
            self._ready = true;
            if (self._pending) { self.setFeatures(self._pending); self._pending = null; }
        });
    };

    YandexMapProvider.prototype._renderHeat = function (features) {
        if (!this._map) return;
        if (this._heatLayer) { this._map.geoObjects.remove(this._heatLayer); }
        var collection = new ymaps.GeoObjectCollection({}, { opacity: 0.35, fillOpacity: 0.18, strokeWidth: 0 });
        features.slice(0, 40).forEach(function (f) {
            var coords = f.geometry && f.geometry.coordinates; if (!coords) return;
            var stress = f.properties && (f.properties.stress_index || 0);
            if (!stress) return;
            var radius = 250 + stress * 1200;
            var color = stress > 0.75 ? "rgba(239,68,68,0.4)" : stress > 0.5 ? "rgba(245,158,11,0.4)" : "rgba(14,165,233,0.35)";
            collection.add(new ymaps.Circle([[coords[1], coords[0]], radius], {}, { fillColor: color }));
        });
        this._heatLayer = collection;
        this._map.geoObjects.add(collection);
    };

    YandexMapProvider.prototype.setFeatures = function (fc) {
        if (typeof ymaps === "undefined") return;
        if (!this._map || !this._ready) { this._pending = fc; return; }
        this._ensureLayouts();
        this._clusterer.removeAll();
        var bounds = [];
        var features = fc.features || [];
        var prices = features.map(function (f) { return f.properties && f.properties.hourly_price; }).filter(function (v) { return typeof v === "number"; });
        var avgPrice = prices.length ? prices.reduce(function (a, b) { return a + b; }, 0) / prices.length : null;
        var self = this;

        features.forEach(function (feature) {
            var coords = feature.geometry && feature.geometry.coordinates; if (!coords) return;
            var lng = coords[0], lat = coords[1];
            var p = feature.properties || {};
            var stress = p.stress_index || 0;
            var allowAi = !!p.allow_dynamic_pricing;
            var color = allowAi ? "#22c55e" : "#0ea5e9";
            if (stress > 0.7) color = "#ef4444"; else if (stress > 0.45) color = "#f59e0b";
            var isHot = avgPrice && p.hourly_price && p.hourly_price < avgPrice * 0.75;
            var freeLabel = (p.free_places === 0 || p.free_places) ? p.free_places : null;
            var label = freeLabel != null ? String(freeLabel) : "P";
            var textColor = (color === "#ef4444" || color === "#f59e0b") ? "#ffffff" : "#04121f";
            var popupHtml = buildPopupHtml(p, color);
            var placemark = new ymaps.Placemark([lat, lng], {
                hintContent: (p.lot_name || "") + (p.name ? " — " + p.name : ""),
                balloonContent: popupHtml,
                markerColor: color,
                markerLabel: label,
                markerHot: isHot,
                markerTextColor: textColor,
                stress_index: stress,
            }, {
                iconLayout: self._markerLayout,
                iconOffset: [-26, -26],
                hideIconOnBalloonOpen: false,
                balloonPanelMaxMapArea: 0,
            });
            placemark.events.add("balloonopen", function () { self._setActive(placemark); self._map.panTo([lat, lng], { flying: true, duration: 400 }); });
            placemark.events.add("balloonclose", function () { self._setActive(null); });
            self._clusterer.add(placemark);
            bounds.push([lat, lng]);
        });

        if (bounds.length) this._map.setBounds(bounds, { checkZoomRange: true, zoomMargin: 48 });
        this._renderHeat(features);
    };

    YandexMapProvider.prototype._setActive = function (placemark) {
        if (this._activePlacemark && this._activePlacemark !== placemark) {
            this._activePlacemark.properties.set("markerActive", "");
            this._activePlacemark.options.unset("zIndex");
        }
        this._activePlacemark = placemark;
        if (placemark) { placemark.properties.set("markerActive", "ps-map-marker--active"); placemark.options.set("zIndex", 2200); }
    };

    YandexMapProvider.prototype.toggleTheme = function (mode) {
        this._theme = mode || this._theme;
        if (!this._map || !this._ready) return;
        this._ensureMapTypes();
        this._map.setType(this._theme === "night" ? "ps#dark" : "ps#light");
    };

    YandexMapProvider.prototype.setLoading = LeafletMapProvider.prototype.setLoading;

    YandexMapProvider.prototype.drawRouteTo = function (target, fromCoords, onHint) {
        if (!this._map || !target) return;
        if (this._activeRoute) this._map.geoObjects.remove(this._activeRoute);
        var origin = fromCoords ? [fromCoords.lat, fromCoords.lng] : this._map.getCenter();
        var dest = target.lat != null ? [target.lat, target.lng] : target;
        this._activeRoute = new ymaps.Polyline([origin, dest], {}, { strokeColor: "#22c55e", strokeWidth: 4, opacity: 0.82 });
        this._map.geoObjects.add(this._activeRoute);
        var km = distanceKm(origin, dest);
        if (onHint) onHint(km);
        this._map.setBounds(this._activeRoute.geometry.getBounds(), { checkZoomRange: true, zoomMargin: 48 });
    };

    YandexMapProvider.prototype.focusOn = function (lat, lng) {
        if (!this._map || !this._ready) return;
        if (this._highlight) this._map.geoObjects.remove(this._highlight);
        this._highlight = new ymaps.Circle([[lat, lng], 120], {}, { strokeColor: "#fbbf24", strokeOpacity: 0.9, strokeWidth: 3, fillColor: "rgba(251,191,36,0.18)" });
        this._map.geoObjects.add(this._highlight);
        this._map.setCenter([lat, lng], 15, { duration: 300 });
    };

    YandexMapProvider.prototype.onInteraction = function (start, end) {
        var self = this;
        if (!this._map || !this._ready) {
            if (typeof ymaps !== "undefined") ymaps.ready(function () { self.onInteraction(start, end); });
            return;
        }
        ["actionbegin", "wheel", "mousedown", "touchstart"].forEach(function (ev) { if (start) self._map.events.add(ev, start); });
        if (end) self._map.events.add("actionend", end);
    };

    YandexMapProvider.prototype.showUserLocation = function (lat, lng) {
        if (!this._map || !this._ready) return;
        if (this._userMarker) this._map.geoObjects.remove(this._userMarker);
        if (this._userRadius) this._map.geoObjects.remove(this._userRadius);
        this._userRadius = new ymaps.Circle([[lat, lng], 500], {}, { fillColor: "rgba(34,197,94,0.15)", strokeColor: "#22c55e", strokeOpacity: 0.65, strokeWidth: 2, zIndex: 1500 });
        this._userMarker = new ymaps.Placemark([lat, lng], {}, { preset: "islands#circleDotIcon", iconColor: "#16a34a", zIndex: 2000 });
        this._map.geoObjects.add(this._userRadius); this._map.geoObjects.add(this._userMarker);
    };

    YandexMapProvider.prototype.setView = function (lat, lng, zoom) {
        if (!this._map || !this._ready) return;
        this._map.setCenter([lat, lng], zoom || this._map.getZoom(), { duration: 300 });
    };

    // ---------- Helpers ----------
    function buildPopupHtml(props, color) {
        var badges = [];
        if (props.allow_dynamic_pricing) badges.push("<span class='ps-badge ps-badge--success'>AI‑тариф</span>");
        if (props.has_ev_charging) badges.push("<span class='ps-badge'>EV</span>");
        if (props.is_covered) badges.push("<span class='ps-badge'>Крытая</span>");
        if (props.is_24_7) badges.push("<span class='ps-badge'>24/7</span>");
        var occupancy = Math.min(100, Math.round((props.occupancy_7d || 0) * 100));
        var stressTone = occupancy > 80 ? "danger" : occupancy > 60 ? "warn" : "ok";
        return [
            "<div class='ps-map-popup ps-map-popup--" + stressTone + "'>",
            "  <header class='ps-map-popup-head'>",
            "    <div class='ps-map-popup-title'>" + (props.city || "") + (props.lot_name ? ", " + props.lot_name : "") + (props.name ? " — " + props.name : "") + "</div>",
            "    <div class='ps-map-popup-meta'>" + (props.address || "Адрес уточняется") + "</div>",
            "  </header>",
            "  <div class='ps-map-popup-price'>от <strong>" + (props.hourly_price || "?") + " ₽/час</strong></div>",
            "  <div class='ps-map-popup-badges'>" + badges.join(" ") + "</div>",
            "  <div class='ps-map-popup-meter'><span style='width:" + occupancy + "%; background:" + color + "'></span><div class='ps-map-popup-meter-label'>загруженность " + occupancy + "%</div></div>",
            "  <div class='ps-map-popup-actions'>",
            "    <button class='ps-btn ps-btn-primary ps-btn-sm' data-spot-id='" + (props.spot_id || props.id || "") + "'>Забронировать</button>",
            "    <button class='ps-btn ps-btn-ghost ps-btn-sm' data-focus-spot='" + (props.spot_id || props.id || "") + "'>Маршрут</button>",
            "  </div>",
            "</div>"
        ].join("");
    }

    function createProvider() {
        var id = (MAP_CONFIG.key || MAP_CONFIG.id || "yandex").toLowerCase();
        var fallback = (MAP_CONFIG.fallback || "leaflet").toLowerCase();
        var center = MAP_CONFIG.default_center || [55.75, 37.61];
        var zoom = MAP_CONFIG.default_zoom || 12;
        var container = qs("#map");
        if (!container) return { provider: null, center: center, zoom: zoom };
        var hasYandex = typeof ymaps !== "undefined";
        var hasLeaflet = typeof L !== "undefined";
        var provider = null;
        var opts = Object.assign({}, MAP_CONFIG, { theme: isNight ? "night" : "day" });
        if (id === "yandex" && hasYandex) provider = new YandexMapProvider(opts);
        else if (id === "leaflet" && hasLeaflet) provider = new LeafletMapProvider(opts);
        else if (fallback === "yandex" && hasYandex) provider = new YandexMapProvider(opts);
        else if (hasLeaflet) provider = new LeafletMapProvider(opts);
        if (!provider) return { provider: null, center: center, zoom: zoom };
        provider.init(container, center, zoom);
        return { provider: provider, center: center, zoom: zoom };
    }

    function readFilters() {
        var form = qs("[data-map-filters]");
        if (!form) return {};
        var fd = new FormData(form);
        return {
            only_free: fd.get("only_free") === "on",
            ev: fd.get("ev") === "on",
            covered: fd.get("covered") === "on",
            is_24_7: fd.get("is_24_7") === "on",
            ai_recommended: fd.get("ai_recommended") === "on",
            min_price: priceRange[0],
            max_price: priceRange[1]
        };
    }

    function buildQuery(params) {
        var q = [];
        Object.keys(params).forEach(function (k) {
            var v = params[k];
            if (v === "" || v === null || typeof v === "undefined") return;
            if (typeof v === "boolean") v = v ? "true" : "false";
            q.push(encodeURIComponent(k) + "=" + encodeURIComponent(v));
        });
        return q.length ? "?" + q.join("&") : "";
    }

    function fetchFeatures(provider) {
        if (!provider) return;
        provider.setLoading(true);
        var url = "/api/parking/map/" + buildQuery(readFilters());
        return fetch(url, { headers: { "Accept": "application/json" } })
            .then(function (resp) { if (!resp.ok) throw new Error("Map API error"); return resp.json(); })
            .then(function (data) {
                provider.setFeatures(data);
                lastFeatures = data.features || [];
                updateSpotsList(data); updateStats(data);
            })
            .catch(function () {})
            .finally(function () { provider.setLoading(false); });
    }

    function updateStats(fc) {
        var features = fc.features || [];
        var prices = features.map(function (f) { return f.properties && f.properties.hourly_price; }).filter(function (p) { return typeof p === "number"; });
        var avgEl = qs("[data-avg-price]"); var countEl = qs("[data-spots-count]");
        if (countEl) countEl.textContent = String(features.length);
        if (!avgEl) return; if (!prices.length) { avgEl.textContent = "—"; return; }
        var sum = prices.reduce(function (acc, p) { return acc + p; }, 0);
        avgEl.textContent = (Math.round((sum / prices.length) / 10) * 10) + " ₽/час";
    }

    function updateSpotsList(fc) {
        var container = qs("[data-spots-list]"); if (!container) return;
        var features = fc.features || [];
        if (!features.length) { container.innerHTML = "<div class='ps-empty'><p>Подходящих мест пока нет. Попробуйте изменить фильтры.</p></div>"; return; }
        container.innerHTML = features.map(function (f) {
            var p = f.properties || {}, tags = [];
            if (p.has_ev_charging) tags.push("EV");
            if (p.is_covered) tags.push("Крытая");
            if (p.is_24_7) tags.push("24/7");
            var badge = p.allow_dynamic_pricing ? "<span class='ps-badge ps-badge--success'>AI‑тариф</span>" : "";
            var tagLine = tags.length ? "<div class='ps-card-line ps-card-line--muted'>" + tags.join(" • ") + "</div>" : "";
            return [
                "<article class='ps-card ps-card--spot ps-animate-fade-up ps-animate-stagger' data-spot-card='" + (p.spot_id || f.id || "") + "'>",
                "  <div class='ps-card-header'><div class='ps-card-title'>" + (p.city || "") + (p.lot_name ? ", " + p.lot_name : "") + (p.name ? " — " + p.name : "") + "</div>" + badge + "</div>",
                "  <div class='ps-card-body'>",
                "    <div class='ps-card-line'>от " + (p.hourly_price || "?") + " ₽/час</div>",
                tagLine,
                "    <div class='ps-card-line ps-card-line--muted'>" + (p.address || "Адрес будет уточнён") + "</div>",
                "  </div>",
                "</article>"
            ].join("");
        }).join("");
    }

    function initPriceSlider(onChange) {
        var slider = qs("[data-price-slider]"); var priceLabel = qs("[data-price-display]");
        if (!slider || typeof noUiSlider === "undefined") return;
        function render(values) { if (priceLabel) priceLabel.textContent = "Цена: от " + values[0] + " ₽ до " + values[1] + " ₽"; }
        noUiSlider.create(slider, { start: priceRange, connect: true, step: 50, range: { min: 0, max: 2000 } });
        slider.noUiSlider.on("update", function (values) { priceRange = values.map(function (v) { return Math.round(parseFloat(v)); }); render(priceRange); if (onChange) onChange(); });
        render(priceRange);
    }

    function updateRouteHint(km) {
        var hint = qs("[data-route-hint]"); if (!hint) return;
        if (!km) { hint.textContent = "Постройте мини-маршрут до выбранной точки."; return; }
        var timeMin = Math.max(2, Math.round(km / 0.4));
        hint.textContent = "~" + km.toFixed(1) + " км, " + timeMin + " мин пешком/авто.";
    }

    function drawRoute(provider, targetLatLng) {
        if (!provider || !targetLatLng || !provider.drawRouteTo) return;
        var from = userLocation ? { lat: userLocation.lat, lng: userLocation.lng } : null;
        provider.drawRouteTo({ lat: targetLatLng.lat || targetLatLng[0], lng: targetLatLng.lng || targetLatLng[1] }, from, function (km) { updateRouteHint(km); });
    }

    function initFloatingActions(provider) {
        var actions = qs(".ps-map-floating-actions"); if (!actions) return;
        var timer = null;
        function dim() { actions.classList.add("is-dimmed"); }
        function undim() { actions.classList.remove("is-dimmed"); startTimer(); }
        function startTimer() { clearTimeout(timer); timer = setTimeout(dim, 3000); }
        startTimer();
        qsa(".ps-map-action", actions).forEach(function (btn) {
            ["mouseenter", "touchstart", "click"].forEach(function (evt) { btn.addEventListener(evt, undim, { passive: true }); });
        });
        if (provider && provider.onInteraction) provider.onInteraction(undim, startTimer);
    }

    function initGeocode(provider) {
        var inputs = qsa("[data-geocode-input]");
        var primary = inputs.length ? inputs[0] : null;
        var submit = qs("[data-geocode-submit]"); var suggestions = qs("[data-geocode-suggestions]"); var timer = null;

        function syncInputs(value) {
            inputs.forEach(function (el) { el.value = value; });
        }

        function search(query) {
            if (!query) return;
            fetch("/api/geocode/?q=" + encodeURIComponent(query))
                .then(function (resp) { return resp.json(); })
                .then(function (data) {
                    var list = data.results || [];
                    if (suggestions) suggestions.innerHTML = list.map(function (item) { return "<button type='button' data-geocode-choice data-lat='" + item.lat + "' data-lng='" + item.lng + "'>" + item.title + "</button>"; }).join("");
                })
                .catch(function () {});
        }

        inputs.forEach(function (input) {
            input.addEventListener("input", function () {
                clearTimeout(timer);
                var value = input.value.trim();
                timer = setTimeout(function () { search(value); }, 350);
            });
            input.addEventListener("keydown", function (evt) {
                if (evt.key === "Enter") { evt.preventDefault(); search(input.value.trim()); }
            });
        });

        if (submit) submit.addEventListener("click", function () { var value = primary ? primary.value : ""; search(value); });
        if (suggestions) {
            suggestions.addEventListener("click", function (e) {
                var btn = e.target.closest("[data-geocode-choice]"); if (!btn) return;
                var lat = parseFloat(btn.getAttribute("data-lat")); var lng = parseFloat(btn.getAttribute("data-lng"));
                suggestions.innerHTML = "";
                syncInputs(btn.textContent || "");
                if (provider && provider.setView) { provider.setView(lat, lng, 15); drawRoute(provider, { lat: lat, lng: lng }); }
            });
        }
    }

    document.addEventListener("DOMContentLoaded", function () {
        var mapContainer = qs("#map"); if (!mapContainer) return;
        var result = createProvider(); var provider = result.provider; if (!provider) return;
        initPriceSlider(function () { fetchFeatures(provider); });
        initGeocode(provider);
        fetchFeatures(provider);
        initFloatingActions(provider);
        applyMapTheme(isNight ? "dark" : "light", provider, mapContainer, true);

        var themeBtn = qs("[data-map-theme]");
        if (themeBtn) themeBtn.addEventListener("click", function () { var next = isNight ? "light" : "dark"; applyMapTheme(next, provider, mapContainer, false); });
        document.addEventListener("ps-theme-changed", function (e) {
            var next = e.detail && e.detail.theme;
            if (next) applyMapTheme(next, provider, mapContainer, true);
        });

        var filtersForm = qs("[data-map-filters]");
        if (filtersForm) filtersForm.addEventListener("change", function () { fetchFeatures(provider); });

        qsa("[data-chip-toggle]").forEach(function (chip) {
            var input = qs("input", chip); if (!input) return; chip.classList.toggle("is-active", input.checked);
            chip.addEventListener("click", function (e) { if (e.target.tagName === "INPUT") return; input.checked = !input.checked; chip.classList.toggle("is-active", input.checked); input.dispatchEvent(new Event("change", { bubbles: true })); fetchFeatures(provider); });
        });

        var resetBtn = qs("[data-reset-filters]");
        if (resetBtn) {
            resetBtn.addEventListener("click", function () {
                resetBtn.classList.remove("ps-map-action--spinning");
                void resetBtn.offsetWidth;
                resetBtn.classList.add("ps-map-action--spinning");
                if (filtersForm) filtersForm.reset();
                priceRange = [0, 1500];
                var slider = qs("[data-price-slider]");
                if (slider && slider.noUiSlider) slider.noUiSlider.set(priceRange);
                qsa("[data-chip-toggle]").forEach(function (chip) { chip.classList.remove("is-active"); });
                fetchFeatures(provider);
            });
        }

function getCSRFToken() {
    var match = document.cookie.match(/csrftoken=([^;]+)/);
    return match ? match[1] : "";
}

function showToast(message, type) {
    var container = document.querySelector(".ps-toast-container");
    if (!container) return alert(message);
    var toast = document.createElement("div");
    toast.className = "ps-toast ps-toast--" + (type || "info");
    toast.textContent = message;
    container.appendChild(toast);
    setTimeout(function () { toast.remove(); }, 4200);
}

function createBooking(spotId) {
    var now = new Date();
    var end = new Date(now.getTime() + 60 * 60 * 1000);
    return fetch("/api/parking/bookings/", {
        method: "POST",
        credentials: "include",
        headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": getCSRFToken(),
        },
        body: JSON.stringify({
            spot: spotId,
            start_at: now.toISOString(),
            end_at: end.toISOString(),
            booking_type: "hourly",
        }),
    }).then(function (resp) {
        if (resp.status === 401 || resp.status === 403) {
            showToast("Войдите, чтобы бронировать места", "error");
            throw new Error("auth_required");
        }
        if (!resp.ok) {
            return resp.json().then(function (data) {
                var detail = typeof data === "object" ? JSON.stringify(data) : data;
                throw new Error(detail || "Ошибка бронирования");
            }).catch(function (err) { throw err; });
        }
        return resp.json();
    });
}

        qsa("[data-fill-location]").forEach(function (btn) {
            btn.addEventListener("click", function () {
                if (!navigator.geolocation) return; btn.classList.add("ps-map-action--pulse");
                navigator.geolocation.getCurrentPosition(function (pos) {
                    userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                    if (provider.showUserLocation) provider.showUserLocation(userLocation.lat, userLocation.lng);
                    if (provider.setView) provider.setView(userLocation.lat, userLocation.lng, 14);
                    btn.classList.remove("ps-map-action--pulse");
                }, function () { btn.classList.remove("ps-map-action--pulse"); }, { timeout: 8000 });
            });
        });

        var mapPanel = qs("[data-map-panel]");
        if (mapPanel) {
            mapPanel.addEventListener("click", function (e) {
                var focusBtn = e.target.closest("[data-focus-spot]");
                var bookBtn = e.target.closest("[data-spot-id]");
                if (focusBtn) {
                    var id = focusBtn.getAttribute("data-focus-spot");
                    var match = (lastFeatures || []).find(function (f) { var fid = String(f.id); var pid = f.properties && f.properties.spot_id ? String(f.properties.spot_id) : null; return id && (fid === id || pid === id); });
                    if (match && match.geometry) { var coords = match.geometry.coordinates; var latlng = { lat: coords[1], lng: coords[0] }; if (provider.focusOn) provider.focusOn(latlng.lat, latlng.lng); drawRoute(provider, latlng); }
                }
                if (bookBtn) {
                    var targetId = bookBtn.getAttribute("data-spot-id");
                    var card = qs("[data-spot-card='" + targetId + "']");
                    if (card) card.scrollIntoView({ behavior: "smooth", block: "start" });
                    bookBtn.setAttribute("aria-busy", "true");
                    createBooking(targetId)
                        .then(function (data) {
                            var price = data.total_price || "~";
                            showToast("Бронь создана в демо-режиме. Оплата не списывается (≈ " + price + " ₽)", "success");
                        })
                        .catch(function (err) {
                            if (err.message !== "auth_required") {
                                showToast("Не удалось создать бронь: " + err.message, "error");
                            }
                        })
                        .finally(function () { bookBtn.removeAttribute("aria-busy"); });
                }
            });
        }

        qsa("[data-spots-list]").forEach(function (list) {
            list.addEventListener("click", function (e) {
                var card = e.target.closest("[data-spot-card]"); if (!card) return;
                var id = card.getAttribute("data-spot-card");
                var match = (lastFeatures || []).find(function (f) { var fid = String(f.id); var pid = f.properties && f.properties.spot_id ? String(f.properties.spot_id) : null; return id && (fid === id || pid === id); });
                if (match && match.geometry) { var coords = match.geometry.coordinates; var latlng = { lat: coords[1], lng: coords[0] }; if (provider.focusOn) provider.focusOn(latlng.lat, latlng.lng); drawRoute(provider, latlng); }
            });
        });
    });
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 187
PATH: static\js\parkmate-ai.ts
LANG: typescript
===== CONTENT START =====
/**
 * ParkMate AI — фронтовый контракт мультимодального ассистента ParkShare.
 * Файл можно использовать как исходник для будущего SPA/PWA на TypeScript.
 *
 * Соответствует backend‑эндпоинтам:
 *  - GET  /api/ai/parkmate/config/
 *  - POST /api/ai/parkmate/price-forecast/
 *  - POST /api/ai/parkmate/availability/
 *  - POST /api/ai/departure-assistant/
 *  - POST /api/ai/cv/license-plate/        (через cv_service)
 *  - POST /api/ai/cv/parking-occupancy/    (через cv_service)
 */

export interface ParkMateVoiceCommands {
  booking: string;
  navigation: string;
  payment: string;
  support: string;
}

export interface ParkMateComputerVision {
  licensePlateRecognition: string;
  parkingSpotDetection: string;
  damageDetection: string;
  occupancyAnalytics: string;
}

export interface ParkMatePredictions {
  arrivalTime: string;
  priceForecast: string;
  availability: string;
}

export interface ParkMateAI {
  voiceCommands: ParkMateVoiceCommands;
  computerVision: ParkMateComputerVision;
  predictions: ParkMatePredictions;
}

/**
 * Базовый конфиг под RU‑профиль (ParkShare RU).
 * Значения URL должны совпадать с Django‑эндпоинтами.
 */
export const parkMateConfig: ParkMateAI = {
  voiceCommands: {
    booking: "Забронировать парковку рядом",
    navigation: "Построить маршрут до парковки",
    payment: "Оплатить текущую парковку",
    support: "Связаться с поддержкой ParkShare",
  },
  computerVision: {
    licensePlateRecognition: "/api/ai/cv/license-plate/",
    parkingSpotDetection: "/api/ai/cv/parking-occupancy/",
    damageDetection: "/api/ai/cv/vehicle-damage/", // зарезервировано на будущее
    occupancyAnalytics: "/api/ai/stress-index/",
  },
  predictions: {
    arrivalTime: "/api/ai/departure-assistant/",
    priceForecast: "/api/ai/parkmate/price-forecast/",
    availability: "/api/ai/parkmate/availability/",
  },
};

// --------- Типы для REST‑ответов ParkMate ---------

export interface PriceForecastRequestPayload {
  spotId: string;
}

export interface PriceForecastResponse {
  spot_id: string;
  lot_id: string;
  currency: string;
  base_price: number;
  recommended_price: number;
  min_price: number;
  max_price: number;
  discount_percent: number;
  is_discount: boolean;
  reason: string;
}

export interface AvailabilityForecastRequestPayload {
  spotId?: string;
  occupancy_7d?: number;
  stress_index?: number;
}

export interface AvailabilityForecastResponse {
  spot_id: string | null;
  occupancy_7d: number;
  stress_index: number;
  as_of: string;
  availability: {
    next_1h: number;
    next_3h: number;
    next_24h: number;
  };
}

// --------- Helper‑функции для фронта ---------

async function jsonFetch<T>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  const resp = await fetch(url, {
    credentials: "include",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...(options.headers || {}),
    },
  });

  if (!resp.ok) {
    const text = await resp.text();
    throw new Error(`Request failed ${resp.status}: ${text}`);
  }

  return (await resp.json()) as T;
}

export async function getPriceForecast(
  payload: PriceForecastRequestPayload
): Promise<PriceForecastResponse> {
  return jsonFetch<PriceForecastResponse>(
    parkMateConfig.predictions.priceForecast,
    {
      method: "POST",
      body: JSON.stringify({ spot_id: payload.spotId }),
    }
  );
}

export async function getAvailabilityForecast(
  payload: AvailabilityForecastRequestPayload
): Promise<AvailabilityForecastResponse> {
  return jsonFetch<AvailabilityForecastResponse>(
    parkMateConfig.predictions.availability,
    {
      method: "POST",
      body: JSON.stringify({
        spot_id: payload.spotId,
        occupancy_7d: payload.occupancy_7d,
        stress_index: payload.stress_index,
      }),
    }
  );
}
export async function fetchPriceForecast(
  payload: PriceForecastRequestPayload
): Promise<PriceForecastResponse> {
  return jsonFetch<PriceForecastResponse>(
    parkMateConfig.predictions.priceForecast,
    {
      method: "POST",
      body: JSON.stringify({ spot_id: payload.spotId }),
    }
  );
}

export async function fetchAvailabilityForecast(
  payload: AvailabilityForecastRequestPayload
): Promise<AvailabilityForecastResponse> {
  return jsonFetch<AvailabilityForecastResponse>(
    parkMateConfig.predictions.availability,
    {
      method: "POST",
      body: JSON.stringify({
        spot_id: payload.spotId,
        occupancy_7d: payload.occupancy_7d,
        stress_index: payload.stress_index,
      }),
    }
  );
}


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 188
PATH: static\js\quantum-theme-manager.js
LANG: javascript
===== CONTENT START =====
class QuantumThemeManager {
  constructor(options = {}) {
    this.themes = options.themes || {
      dark: {
        map: "dark",
        css: "dark",
        effects: "hologram-dark",
        emotion: "calm",
      },
      light: {
        map: "standard",
        css: "light",
        effects: "hologram-light",
        emotion: "energetic",
      },
    };
    this.currentTheme = "dark";
    this.root = options.root || document.documentElement;
  }

  async switchTheme(theme) {
    const config = this.themes[theme];
    if (!config) return;

    this.currentTheme = theme;
    const tasks = [
      this.switchCSSTheme(config.css),
      this.switchEmotionalMode(config.emotion),
      this.switchCinematicEffects(config.effects),
    ];

    await Promise.all(tasks);
    this.triggerThemeTransitionAnimation();
  }

  switchCSSTheme(css) {
    this.root.dataset.quantumTheme = css;
    document.body.dataset.quantumTheme = css;
    return Promise.resolve();
  }

  switchEmotionalMode(emotion) {
    document.body.dataset.emotion = emotion;
    return Promise.resolve();
  }

  switchCinematicEffects(effects) {
    document.body.dataset.cinematic = effects;
    return Promise.resolve();
  }

  triggerThemeTransitionAnimation() {
    const flash = document.createElement("div");
    flash.className = "quantum-pulse";
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 800);
  }

  bindToggle(buttonId) {
    const btn = document.getElementById(buttonId);
    if (!btn) return;

    btn.addEventListener("click", () => {
      const next = this.currentTheme === "dark" ? "light" : "dark";
      btn.dataset.theme = next;
      const label = btn.querySelector(".quantum-toggle__label");
      if (label) {
        label.textContent = next === "dark" ? "Dark Matter" : "Photon";
      }
      this.switchTheme(next);
    });
  }
}

window.initQuantumThemeManager = function initQuantumThemeManager() {
  const manager = new QuantumThemeManager();
  manager.bindToggle("themeToggle");
  manager.switchTheme("dark");
  return manager;
};

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 189
PATH: static\js\theme.js
LANG: javascript
===== CONTENT START =====
(function () {
  "use strict";

  var STORAGE_KEY = "ps-theme";

  function readInitialTheme() {
    var preset = document.documentElement.getAttribute("data-theme");
    if (preset === "dark" || preset === "light") return preset;
    try {
      var stored = localStorage.getItem(STORAGE_KEY);
      if (stored === "dark" || stored === "light") return stored;
    } catch (_) {
      /* ignore storage errors */
    }
    var prefersDark =
      window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    return prefersDark ? "dark" : "light";
  }

  function setMetaTheme(theme) {
    var meta = document.querySelector('meta[name="theme-color"]');
    if (meta) {
      meta.setAttribute("content", theme === "dark" ? "#050910" : "#f4f6fb");
    }
    try {
      document.documentElement.style.colorScheme = theme;
    } catch (_) {
      /* ignore */
    }
  }

  function updateToggle(theme) {
    var toggles = document.querySelectorAll("[data-theme-toggle]");
    toggles.forEach(function (btn) {
      btn.setAttribute("data-theme", theme);
      btn.setAttribute("aria-pressed", theme === "dark");
    });
  }

  function setTheme(theme) {
    var next = theme === "dark" ? "dark" : "light";
    if (document.documentElement.dataset.theme !== next) {
      document.documentElement.dataset.theme = next;
    }
    try {
      localStorage.setItem(STORAGE_KEY, next);
    } catch (_) {
      /* ignore */
    }
    updateToggle(next);
    setMetaTheme(next);
    document.dispatchEvent(new CustomEvent("ps-theme-changed", { detail: { theme: next } }));
    return next;
  }

  function toggleTheme() {
    var current = document.documentElement.getAttribute("data-theme") === "dark" ? "dark" : "light";
    return setTheme(current === "dark" ? "light" : "dark");
  }

  function initToggle() {
    var toggles = document.querySelectorAll("[data-theme-toggle]");
    var initial = setTheme(readInitialTheme());
    if (!toggles.length) return;
    toggles.forEach(function (btn) {
      btn.addEventListener("click", toggleTheme);
    });
  }

  window.ThemeController = {
    setTheme: setTheme,
    toggle: toggleTheme,
    current: function () {
      return document.documentElement.getAttribute("data-theme") || readInitialTheme();
    },
  };

  document.addEventListener("DOMContentLoaded", initToggle);
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 190
PATH: static\pwa\api-client.js
LANG: javascript
===== CONTENT START =====
import {
  appendSpots,
  flushQueue,
  getState,
  queueAction,
  setConnectionStatus,
  setMapFeatures,
  setSavedPlaces,
  setFavorites,
  setSpots,
  setThemeConfig,
  updatePagination,
  markQueueItem,
} from './state-store.js';

const API_ROOT = '/api/parking';
const AI_ROOT = '/api/ai';
const datasetCache = new Map();
const aiCache = new Map();

async function apiFetch(path, { method = 'GET', body, params } = {}) {
  const url = new URL(path, window.location.origin);
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (value === undefined || value === null || value === '') return;
      url.searchParams.set(key, value);
    });
  }
  const headers = { 'Content-Type': 'application/json' };
  const options = { method, headers, credentials: 'include' };
  if (body) options.body = JSON.stringify(body);

  try {
    const response = await fetch(url.toString(), options);
    setConnectionStatus(true);
    if (!response.ok) throw new Error(`API ${response.status}`);
    return await response.json();
  } catch (err) {
    setConnectionStatus(false);
    throw err;
  }
}

export async function loadSpots({ append = false, filters = {}, page = 1, pageSize = 50 }) {
  const params = {
    page,
    page_size: Math.min(pageSize || 50, 100),
    ...filters,
  };
  const cacheKey = `spots:${JSON.stringify(params)}`;
  try {
    const payload = await cachedApiFetch(`${API_ROOT}/spots/`, { params }, cacheKey, 300000);
    const { results, next, previous, count } = payload;
    if (append) {
      appendSpots(results);
    } else {
      setSpots(results);
    }
    updatePagination({ next, previous, count, page_size: params.page_size });
    cacheDataset('spots', payload);
  } catch (err) {
    const cached = readDataset('spots') || datasetCache.get(cacheKey);
    if (cached) {
      const { results, next, previous, count } = cached;
      if (append) {
        appendSpots(results);
      } else {
        setSpots(results);
      }
      updatePagination({ next, previous, count, page_size: params.page_size });
    } else {
      console.warn('[PWA] failed to load spots and no cache', err);
    }
  }
}

export async function loadFavorites() {
  try {
    const payload = await apiFetch(`${API_ROOT}/favorites/`);
    setFavorites(payload.results ? payload.results.map((item) => item.spot) : payload.map((i) => i.spot));
    cacheDataset('favorites', payload);
  } catch (err) {
    const cached = readDataset('favorites');
    if (cached) {
      setFavorites(cached.results ? cached.results.map((i) => i.spot) : cached.map((i) => i.spot));
    }
  }
}

export async function saveFavorite(spotId) {
  if (!navigator.onLine) {
    queueAction({ type: 'favorite:toggle', payload: { spotId } });
    return toggleLocalFavorite(spotId);
  }
  await apiFetch(`${API_ROOT}/favorites/`, {
    method: 'POST',
    body: { spot: spotId },
  });
  toggleLocalFavorite(spotId);
}

function toggleLocalFavorite(spotId) {
  const current = getState().favorites || [];
  if (current.includes(spotId)) {
    setFavorites(current.filter((id) => id !== spotId));
  } else {
    setFavorites([...current, spotId]);
  }
}

export async function loadSavedPlaces() {
  try {
    const payload = await apiFetch(`${API_ROOT}/saved-places/`);
    const items = payload.results || payload;
    setSavedPlaces(items);
    cacheDataset('saved_places', payload);
  } catch (err) {
    const cached = readDataset('saved_places');
    if (cached) {
      setSavedPlaces(cached.results || cached);
    }
  }
}

export async function syncOfflineQueue() {
  const { offlineQueue } = getState();
  if (!offlineQueue.length || !navigator.onLine) return;
  for (const item of offlineQueue) {
    try {
      if (item.type === 'favorite:toggle') {
        await saveFavorite(item.payload.spotId);
        markQueueItem(item.id, { status: 'synced' });
      }
      if (item.type === 'saved_place:create') {
        await createSavedPlace(item.payload.place, { skipQueue: true });
        markQueueItem(item.id, { status: 'synced' });
      }
    } catch (err) {
      const attempts = (item.attempts || 0) + 1;
      if (attempts >= 3) {
        markQueueItem(item.id, { status: 'failed', attempts });
      } else {
        markQueueItem(item.id, { attempts });
      }
    }
  }
  flushQueue((item) => item.status === 'synced' || item.status === 'failed');
}

export async function loadProfile() {
  try {
    const payload = await apiFetch('/api/ai/parkmate/config/');
    setThemeConfig(payload);
  } catch (_) {
    /* ignore */
  }
}

export async function loadMapFeatures(filters = {}) {
  const params = { ...filters };
  const cacheKey = `map:${JSON.stringify(params)}`;
  try {
    const payload = await cachedApiFetch('/api/parking/map/', { params }, cacheKey, 300000);
    setMapFeatures(payload.features || []);
  } catch (err) {
    const cached = datasetCache.get(cacheKey) || readDataset('map_features');
    if (cached?.features) {
      setMapFeatures(cached.features);
    }
  }
}

export async function registerPushSubscription(subscription) {
  await apiFetch('/api/parking/push-subscriptions/', { method: 'POST', body: subscription });
}

export async function loadAiRecommendations(filters = {}) {
  const params = {
    city: filters.city,
    limit: Math.min(filters.limit || 20, 50),
  };
  const cacheKey = `ai:rec:${JSON.stringify(params)}`;
  try {
    const payload = await cachedAiFetch(`${AI_ROOT}/recommendations/`, { params }, cacheKey, 300000);
    return payload?.results || [];
  } catch (err) {
    const cached = readDataset(cacheKey) || aiCache.get(cacheKey)?.payload;
    if (cached) return cached.results || cached;
    throw err;
  }
}

export async function loadAiStressIndex(filters = {}) {
  const params = { city: filters.city };
  const cacheKey = `ai:stress:${JSON.stringify(params)}`;
  try {
    return await cachedAiFetch(`${AI_ROOT}/stress-index/`, { params }, cacheKey, 180000);
  } catch (err) {
    const cached = readDataset(cacheKey) || aiCache.get(cacheKey)?.payload;
    if (cached) return cached;
    throw err;
  }
}

export async function createSavedPlace(place, { skipQueue = false } = {}) {
  const body = {
    title: place.title,
    place_type: place.place_type || 'custom',
    latitude: place.latitude,
    longitude: place.longitude,
  };
  if (!navigator.onLine && !skipQueue) {
    queueAction({ type: 'saved_place:create', payload: { place: body } });
    setSavedPlaces([...(getState().savedPlaces || []), { ...body, id: `local-${Date.now()}` }]);
    return;
  }
  await apiFetch(`${API_ROOT}/saved-places/`, { method: 'POST', body });
  await loadSavedPlaces();
}

async function cachedApiFetch(path, opts, cacheKey, ttlMs = 120000) {
  if (datasetCache.has(cacheKey)) {
    const cached = datasetCache.get(cacheKey);
    if (cached.expires > Date.now()) {
      return cached.payload;
    }
  }
  const payload = await apiFetch(path, opts);
  datasetCache.set(cacheKey, { payload, expires: Date.now() + ttlMs });
  cacheDataset(cacheKey, payload);
  return payload;
}

function cacheDataset(name, payload) {
  try {
    localStorage.setItem(`ps.pwa.cache.${name}`, JSON.stringify(payload));
  } catch (_) {}
}

function readDataset(name) {
  try {
    const raw = localStorage.getItem(`ps.pwa.cache.${name}`);
    return raw ? JSON.parse(raw) : null;
  } catch (_) {
    return null;
  }
}

async function cachedAiFetch(path, opts, cacheKey, ttlMs = 180000) {
  if (aiCache.has(cacheKey)) {
    const cached = aiCache.get(cacheKey);
    if (cached.expires > Date.now()) {
      return cached.payload;
    }
  }
  const payload = await apiFetch(path, opts);
  aiCache.set(cacheKey, { payload, expires: Date.now() + ttlMs });
  cacheDataset(cacheKey, payload);
  return payload;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 191
PATH: static\pwa\app.js
LANG: javascript
===== CONTENT START =====
import { getState, setConnectionStatus, setMapView, subscribe } from './state-store.js';
import { loadFavorites, loadMapFeatures, loadProfile, loadSavedPlaces, syncOfflineQueue } from './api-client.js';
import { initPushUI, initLazyMedia } from './ui-kit.js';

const APP_VERSION = '2024.09.0';

function registerServiceWorker() {
  if (!('serviceWorker' in navigator)) return;
  navigator.serviceWorker
    .register('/service-worker.js', { updateViaCache: 'none' })
    .then((reg) => {
      console.log('[SW] registered', reg.scope);
      if (reg.waiting) {
        notifyUpdate(reg.waiting);
      }
      reg.addEventListener('updatefound', () => {
        const newWorker = reg.installing;
        if (!newWorker) return;
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            notifyUpdate(newWorker);
          }
        });
      });
    })
    .catch((err) => console.warn('[SW] registration failed', err));
}

function notifyUpdate(worker) {
  const banner = document.querySelector('[data-sw-update]');
  if (!banner) {
    worker.postMessage('SW_APPLY_UPDATE');
    return;
  }
  banner.hidden = false;
  const btn = banner.querySelector('button');
  btn?.addEventListener('click', () => {
    worker.postMessage('SW_APPLY_UPDATE');
    worker.addEventListener('statechange', () => {
      if (worker.state === 'activated') {
        window.location.reload();
      }
    });
  });
}

async function hydrateUI() {
  initLazyMedia();
  loadFavorites();
  loadSavedPlaces();
  loadProfile();
  initPushUI();

  const needsMap = document.querySelector('[data-spots-list]') || document.querySelector('[data-route="map"]');
  if (needsMap) {
    const [{ initRouter, bindConnectionBanner }, { initSpotsView }] = await Promise.all([
      import('./router.js'),
      import('./spots-view.js'),
    ]);
    bindConnectionBanner();
    initRouter();
    initSpotsView();
    loadMapFeatures();
  }
}

function wireConnectivity() {
  window.addEventListener('online', () => {
    setConnectionStatus(true);
    syncOfflineQueue();
  });
  window.addEventListener('offline', () => setConnectionStatus(false));
}

function hydrateMeta() {
  const counter = document.querySelector('[data-spots-count]');
  subscribe((state) => {
    if (counter) counter.textContent = state.spots.length || state.pagination.count || 0;
  });
}

function init() {
  console.log('[PWA] booting', APP_VERSION);
  registerServiceWorker();
  hydrateUI();
  wireConnectivity();
  hydrateMeta();

  const map = getState().mapView;
  if (map?.center) {
    setMapView(map);
  }
}

document.addEventListener('DOMContentLoaded', init);

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 192
PATH: static\pwa\router.js
LANG: javascript
===== CONTENT START =====
import { subscribe } from './state-store.js';

const routes = {
  map: '[data-route="map"]',
  list: '[data-route="list"]',
  dashboard: '[data-route="dashboard"]',
};

export function initRouter() {
  document.addEventListener('click', (event) => {
    const link = event.target.closest('[data-route-link]');
    if (!link) return;
    const target = link.getAttribute('data-route-link');
    if (!target || !routes[target]) return;
    event.preventDefault();
    showRoute(target);
    history.pushState({ route: target }, '', `#${target}`);
  });

  window.addEventListener('popstate', (event) => {
    const route = event.state?.route || window.location.hash.replace('#', '') || 'map';
    showRoute(route);
  });

  const initial = window.location.hash.replace('#', '') || 'map';
  showRoute(initial);
}

function showRoute(name) {
  Object.entries(routes).forEach(([key, selector]) => {
    document.querySelectorAll(selector).forEach((node) => {
      node.hidden = key !== name;
      node.classList.toggle('is-active', key === name);
    });
  });
}

export function bindConnectionBanner() {
  const badge = document.querySelector('[data-connection-badge]');
  if (!badge) return;
  subscribe((state) => {
    badge.textContent = state.isOnline ? 'Онлайн' : 'Оффлайн режим';
    badge.classList.toggle('is-offline', !state.isOnline);
    badge.hidden = false;
  });
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 193
PATH: static\pwa\spots-view.js
LANG: javascript
===== CONTENT START =====
import { subscribe, toggleFavorite, setMapView } from './state-store.js';
import { loadSpots, saveFavorite, loadAiRecommendations } from './api-client.js';
import { renderSkeletonCards, renderSpotCard } from './ui-kit.js';

let loading = false;
let aiCacheKey = null;
let aiHints = new Map();

export function initSpotsView() {
  const list = document.querySelector('[data-spots-list]');
  if (!list) return;

  subscribe((state) => {
    renderSpots(list, state.spots, state.favorites);
  });

  const loadMoreBtn = document.querySelector('[data-spots-load-more]');
  if (loadMoreBtn) {
    loadMoreBtn.addEventListener('click', () => fetchMore());
  }

  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition((pos) => {
      const center = { lat: pos.coords.latitude, lng: pos.coords.longitude };
      setMapView({ center });
      fetchInitial({ lat: center.lat, lng: center.lng });
    }, () => fetchInitial({}));
  } else {
    fetchInitial({});
  }
}

async function fetchInitial(filters) {
  if (loading) return;
  loading = true;
  renderSkeletonCards(document.querySelector('[data-spots-list]'));
  await Promise.all([loadSpots({ filters, page: 1 }), primeAiHints(filters)]);
  loading = false;
}

async function fetchMore() {
  if (loading) return;
  loading = true;
  const next = document.querySelector('[data-spots-load-more]');
  const page = next?.dataset.page ? Number(next.dataset.page) : 1;
  await loadSpots({ append: true, page: page + 1 });
  if (next) next.dataset.page = page + 1;
  loading = false;
}

function renderSpots(container, spots, favorites) {
  if (!spots || !spots.length) {
    container.innerHTML = '<div class="ps-empty">Нет парковок поблизости или вы офлайн. Проверьте соединение или выберите другой район.</div>';
    return;
  }
  container.innerHTML = '';
  const scoredSpots = [...spots].sort((a, b) => getAiScore(b.id) - getAiScore(a.id));
  scoredSpots.forEach((spot) => {
    const aiHint = aiHints.get(spot.id);
    const card = renderSpotCard(spot, {
      favorite: favorites?.includes(spot.id),
      aiHint,
      onFavorite: () => handleFavorite(spot.id),
    });
    container.appendChild(card);
  });
}

async function handleFavorite(spotId) {
  toggleFavorite(spotId);
  try {
    await saveFavorite(spotId);
  } catch (err) {
    console.warn('[PWA] favorite queued', err);
  }
}

async function primeAiHints(filters) {
  const key = JSON.stringify(filters || {});
  if (aiCacheKey === key && aiHints.size) return;
  aiCacheKey = key;
  try {
    const recommendations = await loadAiRecommendations({ city: filters?.city, limit: 40 });
    aiHints = new Map();
    recommendations.forEach((rec, index) => {
      const spotId = Number(rec.spot_id || rec.spotId);
      if (!spotId) return;
      aiHints.set(spotId, {
        label: index < 3 ? 'Рекомендуем' : 'AI',
        score: 100 - index * 2 + (rec.ai_discount_percent || 0),
        reason: rec.ai_reason || rec.address || '',
      });
    });
  } catch (err) {
    aiHints = new Map();
    console.warn('[PWA] AI hints unavailable', err);
  }
}

function getAiScore(spotId) {
  const hint = aiHints.get(spotId);
  return hint ? hint.score || 0 : 0;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 194
PATH: static\pwa\state-store.js
LANG: javascript
===== CONTENT START =====
const STORAGE_KEY = 'ps.pwa.state.v2';
const OFFLINE_QUEUE_LIMIT = 50;
const OFFLINE_QUEUE_TTL = 24 * 60 * 60 * 1000;

const initialState = {
  appVersion: '2024.09.0',
  isOnline: navigator.onLine,
  lastKnownPosition: null,
  mapView: { center: null, zoom: 11, features: [] },
  filters: {
    priceMax: null,
    onlyFree: false,
    ev: false,
    covered: false,
    is_24_7: false,
    ai_recommended: false,
    distance_km: 5,
  },
  pagination: {
    next: null,
    previous: null,
    count: 0,
    page_size: 20,
  },
  spots: [],
  favorites: [],
  savedPlaces: [],
  offlineQueue: [],
  profile: { id: null, role: 'guest', layout_profile: 'comfortable', theme: 'light', platform: 'web' },
  pushOptIn: false,
};

let state = loadState();
const subscribers = new Set();

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return { ...initialState };
    const parsed = JSON.parse(raw);
    const now = Date.now();
    const hydratedQueue = (parsed.offlineQueue || []).filter((item) =>
      item && item.created_at && now - item.created_at < OFFLINE_QUEUE_TTL
    );
    return {
      ...initialState,
      ...parsed,
      filters: { ...initialState.filters, ...(parsed.filters || {}) },
      mapView: { ...initialState.mapView, ...(parsed.mapView || {}) },
      profile: { ...initialState.profile, ...(parsed.profile || {}) },
      offlineQueue: hydratedQueue.slice(-OFFLINE_QUEUE_LIMIT),
    };
  } catch (err) {
    console.warn('[PWA] failed to load state', err);
    return { ...initialState };
  }
}

function persist() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (err) {
    console.warn('[PWA] failed to persist state', err);
  }
}

function setState(patch) {
  state = { ...state, ...patch };
  persist();
  subscribers.forEach((cb) => cb(state));
}

export function subscribe(callback) {
  subscribers.add(callback);
  callback(state);
  return () => subscribers.delete(callback);
}

export function getState() {
  return state;
}

export function updateFilters(patch) {
  setState({ filters: { ...state.filters, ...patch } });
}

export function updatePagination(meta) {
  setState({ pagination: { ...state.pagination, ...meta } });
}

export function setSpots(spots) {
  setState({ spots });
}

export function appendSpots(spots) {
  setState({ spots: [...state.spots, ...spots] });
}

export function setConnectionStatus(isOnline) {
  setState({ isOnline });
}

export function setMapView(patch) {
  setState({ mapView: { ...state.mapView, ...patch } });
}

export function setFavorites(favorites) {
  setState({ favorites });
}

export function toggleFavorite(id) {
  const exists = state.favorites.includes(id);
  const updated = exists ? state.favorites.filter((item) => item !== id) : [...state.favorites, id];
  setState({ favorites: updated });
}

export function setSavedPlaces(items) {
  setState({ savedPlaces: items });
}

export function queueAction(action) {
  const now = Date.now();
  const entry = {
    id: action.id || `${now}-${Math.random().toString(16).slice(2, 8)}`,
    type: action.type,
    payload: action.payload || {},
    status: 'pending',
    attempts: action.attempts || 0,
    created_at: action.created_at || now,
  };
  const freshQueue = state.offlineQueue.filter((item) => now - item.created_at < OFFLINE_QUEUE_TTL);
  const offlineQueue = [...freshQueue.slice(-(OFFLINE_QUEUE_LIMIT - 1)), entry];
  setState({ offlineQueue });
  return entry.id;
}

export function flushQueue(predicate) {
  const now = Date.now();
  const kept = state.offlineQueue
    .filter((item) => now - item.created_at < OFFLINE_QUEUE_TTL)
    .filter((item) => !(predicate ? predicate(item) : false));
  setState({ offlineQueue: kept });
}

export function markQueueItem(id, patch) {
  const queue = state.offlineQueue.map((item) => (item.id === id ? { ...item, ...patch } : item));
  setState({ offlineQueue: queue });
}

export function setProfile(profile) {
  setState({ profile: { ...state.profile, ...profile } });
}

export function setThemeConfig(config) {
  const profile = {
    ...state.profile,
    layout_profile: config.layout_profile || state.profile.layout_profile,
    theme: config.theme || state.profile.theme,
    platform: config.platform || state.profile.platform,
  };
  setState({ profile });
}

export function setMapFeatures(features) {
  setState({ mapView: { ...state.mapView, features } });
}

export function setPushOptIn(optIn) {
  setState({ pushOptIn: optIn });
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 195
PATH: static\pwa\ui-kit.js
LANG: javascript
===== CONTENT START =====
import { registerPushSubscription } from './api-client.js';
import { setConnectionStatus, subscribe } from './state-store.js';

export function createBadge(text, tone = 'info') {
  const span = document.createElement('span');
  span.className = `ps-badge ps-badge-${tone}`;
  span.textContent = text;
  return span;
}

export function renderSkeletonCards(container, count = 3) {
  if (!container) return;
  container.innerHTML = '';
  for (let i = 0; i < count; i += 1) {
    const card = document.createElement('article');
    card.className = 'ps-card ps-card--spot ps-card--skeleton';
    card.innerHTML = `
      <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
      <div class="ps-skeleton-line"></div>
      <div class="ps-skeleton-line ps-skeleton-line--short"></div>
    `;
    container.appendChild(card);
  }
}

export function renderSpotCard(spot, { favorite, onFavorite, aiHint } = {}) {
  const card = document.createElement('article');
  card.className = 'ps-card ps-card--spot';
  card.dataset.spotId = spot.id;
  const badge = aiHint
    ? `<span class="ps-badge ps-badge-success">${aiHint.label || 'AI'}</span>`
    : '';
  const priceHint = aiHint?.reason ? `<div class="ps-card-line ps-card-line--muted">${aiHint.reason}</div>` : '';
  card.innerHTML = `
    <div class="ps-card-header">
      <div class="ps-card-title">${spot.lot?.city || ''} ${spot.lot?.name || ''} — ${spot.name}</div>
      <button class="ps-icon-btn" type="button" aria-label="В избранное" data-fav-toggle>
        ${favorite ? '★' : '☆'}
      </button>
    </div>
    <div class="ps-card-body">
      <div class="ps-card-line">от ${spot.hourly_price} ₽/час ${badge}</div>
      <div class="ps-card-line ps-card-line--muted">${spot.lot?.address || 'Адрес уточняется'}</div>
      ${priceHint}
    </div>
  `;
  if (onFavorite) {
    card.querySelector('[data-fav-toggle]')?.addEventListener('click', onFavorite);
  }
  return card;
}

export function initLazyMedia() {
  document.querySelectorAll('img[loading="lazy"], source[loading="lazy"]').forEach((node) => {
    node.decoding = 'async';
  });
  const lazyNodes = document.querySelectorAll('[data-lazy-src]');
  if (!lazyNodes.length) return;
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const el = entry.target;
        el.src = el.dataset.lazySrc;
        observer.unobserve(el);
      }
    });
  });
  lazyNodes.forEach((node) => observer.observe(node));
}

export function initPushUI() {
  const toggle = document.querySelector('[data-push-optin]');
  if (!toggle || !('serviceWorker' in navigator) || !('PushManager' in window)) return;
  toggle.addEventListener('click', async () => {
    try {
      const permission = await Notification.requestPermission();
      if (permission !== 'granted') return;
      const reg = await navigator.serviceWorker.ready;
      const subscription = await reg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: window.PARKSHARE_VAPID_KEY || undefined,
      });
      await registerPushSubscription(subscription.toJSON());
      toggle.setAttribute('disabled', 'disabled');
      toggle.textContent = 'Уведомления включены';
    } catch (err) {
      console.warn('[PWA] push subscribe failed', err);
    }
  });
}

export function initConnectionBadge() {
  const badge = document.querySelector('[data-connection-indicator]');
  if (!badge) return;
  subscribe((state) => {
    if (state.isOnline) {
      badge.textContent = 'Онлайн';
      badge.classList.remove('ps-badge-offline');
    } else {
      badge.textContent = 'Оффлайн';
      badge.classList.add('ps-badge-offline');
    }
  });
  window.addEventListener('online', () => setConnectionStatus(true));
  window.addEventListener('offline', () => setConnectionStatus(false));
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 196
PATH: templates\base.html
LANG: html
===== CONTENT START =====
{% load static %}
<!doctype html>
<html lang="ru" data-platform="{{ PLATFORM_MODE|default:'RU' }}">
<head>
    <meta charset="utf-8">
    <title>{% block title %}ParkShare — smart parking{% endblock %}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

    <!-- PWA -->
    <meta name="theme-color" content="#050910">
    <link rel="manifest" href="{% url 'manifest' %}">
    <link rel="apple-touch-icon" sizes="192x192" href="{% static 'icons/icon-192.png' %}">
    <link rel="apple-touch-icon" sizes="512x512" href="{% static 'icons/icon-512.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'icons/icon-72.png' %}">

    <script>
        (function() {
            var storageKey = "ps-theme";
            var theme = "dark";
            try {
                var stored = localStorage.getItem(storageKey);
                var prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
                if (stored === "dark" || stored === "light") {
                    theme = stored;
                } else {
                    theme = prefersDark ? "dark" : "light";
                }
            } catch (_) {
                theme = "dark";
            }
            document.documentElement.dataset.theme = theme;
            try { document.documentElement.style.colorScheme = theme; } catch (_) {}
            var meta = document.querySelector('meta[name="theme-color"]');
            if (meta) {
                meta.setAttribute("content", theme === "dark" ? "#050910" : "#f4f6fb");
            }
        })();
    </script>

    <link rel="stylesheet" href="{% static 'css/app.css' %}">

    {% block extra_head %}{% endblock %}
</head>
<body class="ps-body" data-user-id="{% if user.is_authenticated %}{{ user.id }}{% endif %}">
<div class="ps-app">
    <header class="ps-topbar">
        <div class="ps-topbar__safe">
            <div class="ps-topbar__row">
                <a href="{% url 'landing' %}" class="ps-brand">
                    <span class="ps-brand__title">ParkShare</span>
                    <span class="ps-brand__region">{{ REGION_PROFILE }}</span>
                </a>
                <div class="ps-topbar__actions">
                    {% if user.is_authenticated %}
                        <a href="{% url 'accounts:profile' %}" class="ps-icon-btn" aria-label="Профиль" title="{{ user.username }}">
                            <svg class="ps-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Zm0 11c-3.3 0-6 1.7-6 3.8V20h12v-1.7c0-2.1-2.7-3.8-6-3.8Z" fill="currentColor"/></svg>
                        </a>
                    {% else %}
                        <a href="{% url 'accounts:login' %}" class="ps-icon-btn" aria-label="Войти">
                            <svg class="ps-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3a7 7 0 0 0-7 7v3.5A4.5 4.5 0 0 0 9.5 18h.8l1.7 2.6c.4.6 1.3.6 1.7 0L15.5 18h.8A4.5 4.5 0 0 0 19 13.5V10a7 7 0 0 0-7-7Zm0 2a5 5 0 0 1 5 5v3.5a2.5 2.5 0 0 1-2.5 2.5h-1.4l-1.1 1.8-1.1-1.8H9.5A2.5 2.5 0 0 1 7 13.5V10a5 5 0 0 1 5-5Z" fill="currentColor"/></svg>
                        </a>
                    {% endif %}
                    <button type="button" class="ps-icon-btn" data-theme-toggle aria-label="Переключить тему">
                        <svg class="ps-icon ps-icon-sun" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM12 2v2m0 16v2m10-10h-2M4 12H2m16.95 6.95-1.41-1.41M6.46 7.46 5.05 6.05m13.9 0-1.41 1.41M6.46 16.54l-1.41 1.41" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round"/></svg>
                        <svg class="ps-icon ps-icon-moon" viewBox="0 0 24 24" aria-hidden="true"><path d="M20 13.5A8.5 8.5 0 0 1 10.5 4 7 7 0 1 0 20 13.5Z" fill="currentColor"/></svg>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="ps-main">
        <div class="ps-update-banner" data-sw-update hidden>
            <div class="ps-update-banner__text">Доступно обновление PWA.</div>
            <button type="button" class="ps-btn ps-btn-primary ps-btn-sm">Обновить</button>
        </div>
        {% block content %}{% endblock %}
    </main>

    <footer class="ps-footer">
        <div class="ps-footer__inner">
            <span>© {% now "Y" %} ParkShare RU</span>
            <span class="ps-footer__meta">PWA · Offline-first · AI pricing</span>
        </div>
    </footer>

    <button class="ps-back-to-top" type="button" data-back-to-top aria-label="Наверх">↑</button>

    <div class="ps-toast-container" aria-live="polite" aria-atomic="true"></div>

    <nav class="ps-tabbar" data-bottom-nav>
        <a href="{% url 'landing' %}" class="ps-tabbar__item" data-nav="map">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M9.5 4.2 4 6.3v13l5.5-2.1 5 2.1 5.5-2.1v-13l-5.5 2.1-5-2.1Zm0 2.3 5 2.1v9l-5-2.1v-9Zm-1 9.2-3.5 1.3v-9l3.5-1.3v9Zm11-7.7v9l-3.5 1.3v-9l3.5-1.3Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Карта</span>
        </a>
        <a href="{% url 'user_dashboard' %}" class="ps-tabbar__item" data-nav="bookings">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M7 4.5h10c.8 0 1.5.7 1.5 1.5v12a1.5 1.5 0 0 1-1.5 1.5H7A1.5 1.5 0 0 1 5.5 18V6c0-.8.7-1.5 1.5-1.5Zm0 1.5V9h10V6H7Zm0 4v6h10v-6H7Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Брони</span>
        </a>
        <a href="{% url 'owner_dashboard' %}" class="ps-tabbar__item" data-nav="parking">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M7.5 4h7A3.5 3.5 0 0 1 18 7.5c0 1.9-1.6 3.5-3.5 3.5H9v6H7.5V4Zm7 6A2.5 2.5 0 0 0 17 7.5 2.5 2.5 0 0 0 14.5 5H9v5h5.5Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Моя парковка</span>
        </a>
        <a href="{% url 'ai_chat' %}" class="ps-tabbar__item" data-nav="assistant">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a7 7 0 0 0-7 7v3.5A4.5 4.5 0 0 0 9.5 18h.8l1.7 2.6c.4.6 1.3.6 1.7 0L15.5 18h.8A4.5 4.5 0 0 0 19 13.5V10a7 7 0 0 0-7-7Zm0 2a5 5 0 0 1 5 5v3.5a2.5 2.5 0 0 1-2.5 2.5h-1.4l-1.1 1.8-1.1-1.8H9.5A2.5 2.5 0 0 1 7 13.5V10a5 5 0 0 1 5-5Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Ассистент</span>
        </a>
    </nav>

    <div class="ps-install-banner" data-install-banner hidden>
        <div class="ps-install-banner__inner">
            <div class="ps-install-banner__text">
                Установите <strong>ParkShare RU</strong> как приложение
            </div>
            <div class="ps-install-banner__actions">
                <button type="button" class="ps-btn ps-btn-secondary" data-install-dismiss>Позже</button>
                <button type="button" class="ps-btn" data-install-accept>Установить</button>
            </div>
        </div>
    </div>
</div>

<script src="{% static 'js/app.js' %}"></script>
<script src="{% static 'js/theme.js' %}"></script>
{% block extra_scripts %}{% endblock %}
</body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 197
PATH: templates\offline.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Оффлайн — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center">
    <div class="ps-offline-icon">☁️</div>
    <h1 class="ps-section-title">Нет подключения к сети</h1>
    <p class="ps-section-subtitle">
        Вы оффлайн. Некоторые данные могут быть устаревшими или недоступными,
        но базовые страницы и ранее открытые ресурсы всё ещё работают.
    </p>
    <div class="ps-offline-actions">
        <button type="button" class="ps-btn" onclick="location.reload()">
            Повторить попытку
        </button>
        <a href="{% url 'landing' %}" class="ps-btn ps-btn-secondary">
            На главную
        </a>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 198
PATH: templates\accounts\login.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Вход — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Вход</h1>
        <p class="ps-auth-subtitle">
            Войдите, чтобы управлять своими бронированиями и машинами.
        </p>

        <div class="ps-auth-tabs" data-auth-switcher>
            <button type="button" class="is-active" data-auth-target="password">Email/Пароль</button>
            <button type="button" data-auth-target="google" aria-disabled="true" title="Google появится позже">Google</button>
            <button type="button" data-auth-target="sms">SMS</button>
            <button type="button" data-auth-target="esia">Госуслуги</button>
        </div>

        <div class="ps-auth-panels">
            <div class="ps-auth-panel is-active" data-auth-panel="password">
                <form method="post" class="ps-form">
                    {% csrf_token %}
                    {% if form.non_field_errors %}
                        <div class="ps-alert ps-alert--danger">
                            {{ form.non_field_errors }}
                        </div>
                    {% endif %}

                    {% for field in form.visible_fields %}
                        <div class="ps-form-row">
                            <label class="ps-form-label" for="{{ field.id_for_label }}">
                                {{ field.label }}
                            </label>

                            {{ field }}

                            {% if field.help_text %}
                                <div class="ps-field-help">{{ field.help_text }}</div>
                            {% endif %}
                            {% for error in field.errors %}
                                <div class="ps-field-error">{{ error }}</div>
                            {% endfor %}
                        </div>
                    {% endfor %}

                    <div class="ps-form-actions">
                        <button type="submit" class="ps-btn ps-btn-full">
                            Войти
                        </button>
                    </div>
                </form>
            </div>

            <div class="ps-auth-panel" data-auth-panel="google">
                <div class="ps-auth-placeholder">
                    <p>Вход через Google скоро появится. В дев-режиме используйте email/пароль.</p>
                    <button type="button" class="ps-btn ps-btn-secondary" disabled aria-disabled="true">Google</button>
                </div>
            </div>

            <div class="ps-auth-panel" data-auth-panel="sms">
                <div class="ps-auth-placeholder">
                    <p>Вход по SMS-коду в разработке.</p>
                    <button type="button" class="ps-btn ps-btn-secondary" disabled>Получить код</button>
                </div>
            </div>

            <div class="ps-auth-panel" data-auth-panel="esia">
                <div class="ps-auth-placeholder">
                    <p>Поддержка Госуслуг скоро будет доступна.</p>
                    <button type="button" class="ps-btn ps-btn-secondary" disabled>Перейти в Госуслуги</button>
                </div>
            </div>
        </div>

        <div class="ps-auth-footer">
            Нет аккаунта?
            <a href="{% url 'accounts:register' %}">Зарегистрироваться</a>
            <br>
            <a href="{% url 'accounts:password_reset' %}">Забыли пароль?</a>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
<script>
    (function () {
        const root = document.querySelector('[data-auth-switcher]');
        if (!root) return;
        const buttons = Array.from(root.querySelectorAll('[data-auth-target]'));
        const panels = Array.from(document.querySelectorAll('[data-auth-panel]'));
        buttons.forEach(function (btn) {
            btn.addEventListener('click', function () {
                const target = btn.getAttribute('data-auth-target');
                buttons.forEach(function (b) { b.classList.toggle('is-active', b === btn); });
                panels.forEach(function (panel) {
                    panel.classList.toggle('is-active', panel.getAttribute('data-auth-panel') === target);
                });
            });
        });
    })();
</script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 199
PATH: templates\accounts\password_change.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Смена пароля — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Смена пароля</h1>
        <p class="ps-auth-subtitle">
            Укажите текущий пароль и новый — мы проверим его надёжность.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Обновить пароль
                </button>
            </div>
        </form>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 200
PATH: templates\accounts\password_change_done.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Пароль обновлён — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Пароль успешно обновлён</h1>
    <p class="ps-section-subtitle">
        Ваш новый пароль сохранён. Используйте его для следующего входа.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'user_dashboard' %}" class="ps-btn">
            В личный кабинет
        </a>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 201
PATH: templates\accounts\password_reset.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Сброс пароля — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Сброс пароля</h1>
        <p class="ps-auth-subtitle">
            Укажите email, на который зарегистрирован аккаунт. Мы отправим ссылку
            для задания нового пароля.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Отправить ссылку
                </button>
            </div>
        </form>

        <div class="ps-auth-footer">
            Вспомнили пароль?
            <a href="{% url 'accounts:login' %}">Вернуться ко входу</a>
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 202
PATH: templates\accounts\password_reset_complete.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Пароль изменён — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Пароль успешно изменён</h1>
    <p class="ps-section-subtitle">
        Теперь вы можете войти в свой аккаунт, используя новый пароль.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'accounts:login' %}" class="ps-btn">
            Перейти ко входу
        </a>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 203
PATH: templates\accounts\password_reset_confirm.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Новый пароль — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        {% if validlink %}
            <h1 class="ps-auth-title">Задайте новый пароль</h1>
            <p class="ps-auth-subtitle">
                Введите новый пароль дважды, чтобы исключить опечатки.
            </p>

            <form method="post" class="ps-form">
                {% csrf_token %}
                {% if form.non_field_errors %}
                    <div class="ps-alert ps-alert--danger">
                        {{ form.non_field_errors }}
                    </div>
                {% endif %}

                {% for field in form.visible_fields %}
                    <div class="ps-form-row">
                        <label class="ps-form-label" for="{{ field.id_for_label }}">
                            {{ field.label }}
                        </label>
                        {{ field }}
                        {% if field.help_text %}
                            <div class="ps-field-help">{{ field.help_text }}</div>
                        {% endif %}
                        {% for error in field.errors %}
                            <div class="ps-field-error">{{ error }}</div>
                        {% endfor %}
                    </div>
                {% endfor %}

                <div class="ps-form-actions">
                    <button type="submit" class="ps-btn ps-btn-full">
                        Сохранить новый пароль
                    </button>
                </div>
            </form>
        {% else %}
            <h1 class="ps-auth-title">Ссылка недействительна</h1>
            <p class="ps-auth-subtitle">
                Ссылка для сброса пароля устарела или уже была использована.
                Попробуйте запросить сброс ещё раз.
            </p>
            <div class="ps-offline-actions">
                <a href="{% url 'accounts:password_reset' %}" class="ps-btn">
                    Запросить новую ссылку
                </a>
            </div>
        {% endif %}
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 204
PATH: templates\accounts\password_reset_done.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Письмо отправлено — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Проверьте почту</h1>
    <p class="ps-section-subtitle">
        Если аккаунт с таким email существует, мы отправили на него письмо
        с дальнейшими инструкциями.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'accounts:login' %}" class="ps-btn ps-btn-secondary">
            Вернуться ко входу
        </a>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 205
PATH: templates\accounts\password_reset_email.txt
LANG: text
===== CONTENT START =====
Вы получили это письмо, потому что на сайте {{ site_name }} был запрошен сброс пароля
для пользователя, использующего этот email.

Чтобы задать новый пароль, перейдите по ссылке:

{{ protocol }}://{{ domain }}{% url 'accounts:password_reset_confirm' uidb64=uid token=token %}

Если вы не запрашивали сброс пароля, просто проигнорируйте это письмо.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 206
PATH: templates\accounts\password_reset_subject.txt
LANG: text
===== CONTENT START =====
Сброс пароля на ParkShare RU

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 207
PATH: templates\accounts\profile.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Профиль — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--narrow">
    <div class="ps-section-header">
        <h1 class="ps-section-title">Профиль</h1>
        <p class="ps-section-subtitle">
            Обновите контактные данные, чтобы получать уведомления по бронированиям.
        </p>
    </div>

    <div class="ps-card ps-card--elevated ps-animate-fade-up">
        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Сохранить изменения
                </button>
                <a href="{% url 'user_dashboard' %}" class="ps-btn ps-btn-secondary ps-btn-full">
                    Вернуться в кабинет
                </a>
            </div>
        </form>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 208
PATH: templates\accounts\register.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Регистрация — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Регистрация</h1>
        <p class="ps-auth-subtitle">
            Создайте аккаунт, чтобы бронировать парковки и управлять местами.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Зарегистрироваться
                </button>
            </div>

            <div class="ps-auth-alt">
                <button type="button" class="ps-btn ps-btn-ghost" title="Скоро">Регистрация по коду</button>
                <button type="button" class="ps-btn ps-btn-ghost" title="Скоро">Госуслуги</button>
                <button type="button" class="ps-btn ps-btn-ghost" title="Скоро">Google</button>
                <!-- TODO: подключить быструю регистрацию через code/ESIA/OAuth -->
            </div>
        </form>

        <div class="ps-auth-footer">
            Уже есть аккаунт?
            <a href="{% url 'accounts:login' %}">Войти</a>
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 209
PATH: templates\ai\concierge.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Ассистент — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="assistant">
    <div class="ps-landing__head">
        <div>
            <h1 class="ps-landing__title">Ассистент</h1>
            <p class="ps-landing__subtitle">Потоковый AI-консьерж для поиска парковки и скриптов поддержки.</p>
        </div>
        <div class="ps-chip-row">
            <span class="ps-chip ps-chip--soft">{% if user.is_authenticated %}{{ user.username }}{% else %}Гостевой режим{% endif %}</span>
            <span class="ps-chip ps-chip--soft">Реальный чат</span>
        </div>
    </div>

    <div class="ps-section-actions ps-section-actions--link">
        <a href="{% url 'landing' %}" class="ps-link ps-link-arrow">К карте</a>
    </div>

    <div class="ps-ai-grid">
        <div class="ps-ai-summary">
            <div class="ps-card ps-card--elevated">
                <h3 class="ps-card-title">Предустановленные подсказки</h3>
                <p class="ps-card-line ps-card-line--muted">Выберите и отправьте в один тап.</p>
                <div class="ps-ai-prompts" data-ai-prompts>
                    <button type="button" class="ps-chip" data-ai-prompt>Сформируй чат-скрипт для диспетчера парковки с VIP-клиентами.</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Собери сводку по пиковым часам и дай рекомендации по динамическим тарифам.</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Сценарий поддержки: клиент не может найти въезд. Какие шаги предложить?</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Что добавить в онбординг партнёра, чтобы повысить NPS?</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Сделай контрольный чек-лист для запуска новой парковки на выходные.</button>
                </div>
                <div class="ps-hint">История сохраняется в браузере. Авторизация привяжет её к аккаунту.</div>
            </div>
        </div>

        <div class="ps-ai-chat" data-ai-chat data-ai-history-key="ps_ai_chat_v2">
            <div class="ps-ai-chat__header">
                <div>
                    <p class="ps-kicker">Concierge</p>
                    <p class="ps-ai-title">AI-чат ParkShare</p>
                    <p class="ps-ai-subtitle">Спроси про цены, маршруты и сценарии для гостей.</p>
                </div>
                <div class="ps-ai-actions">
                    <button type="button" class="ps-btn ps-btn-ghost ps-btn-sm" data-ai-clear>Очистить</button>
                    <button type="button" class="ps-btn ps-btn-secondary ps-btn-sm" data-ai-stop hidden>Остановить</button>
                </div>
            </div>

            <div class="ps-ai-chat__body">
                <div class="ps-ai-prompts ps-ai-prompts--inline" data-ai-prompts>
                    <button type="button" class="ps-chip ps-chip--ghost" data-ai-prompt>Где припарковаться рядом?</button>
                    <button type="button" class="ps-chip ps-chip--ghost" data-ai-prompt>Построй маршрут до центра</button>
                </div>
                <div class="ps-ai-status" data-ai-status>История сохраняется локально. Готов к диалогу.</div>
                <div class="ps-ai-messages" data-ai-messages></div>
            </div>

            <div class="ps-ai-input">
                <textarea id="ai-input" class="ps-input" rows="3" placeholder="Опиши задачу или попроси маршрут…"></textarea>
                <div class="ps-ai-input__actions">
                    <div class="ps-ai-hint">Enter — отправить, Shift+Enter — перенос строки</div>
                    <div class="ps-ai-buttons">
                        <button type="button" class="ps-btn ps-btn-secondary ps-btn-sm" data-ai-regenerate hidden>Перегенерировать</button>
                        <button type="button" class="ps-btn ps-btn-sm" data-ai-send>Отправить</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
    {% load static %}
    {% static 'js/chat.js' as chat_static %}
    <script src="{{ chat_static }}?v=2"></script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 210
PATH: templates\parking\landing.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}ParkShare RU — карта парковок{% endblock %}

{% block extra_head %}
    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
    <link rel="stylesheet" href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css">
    <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU{% if YANDEX_MAP_API_KEY %}&apikey={{ YANDEX_MAP_API_KEY }}{% endif %}"
            defer></script>
{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top ps-landing" data-route="map">
    <div class="ps-landing__head">
        <div>
            <h1 class="ps-landing__title">ParkShare</h1>
            <p class="ps-landing__subtitle">Умная парковка рядом с вами</p>
        </div>
        <div class="ps-chip-row">
            <span class="ps-chip ps-chip--soft">Свободно: <strong data-spots-count>{{ spots_total|default:0 }}</strong></span>
            <span class="ps-chip ps-chip--soft">Средняя цена: <strong data-avg-price>—</strong></span>
        </div>
    </div>

    <div class="ps-search-bar ps-search-bar--pill" data-search-bar>
        <div class="ps-search-icon" aria-hidden="true">
            <svg class="ps-icon" viewBox="0 0 24 24"><path d="M15.5 14h-.8l-.3-.3a6 6 0 1 0-.7.7l.3.3v.8l4.5 4.5 1.5-1.5-4.5-4.5Zm-5.5 0a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9Z" fill="currentColor"/></svg>
        </div>
        <input type="search" class="ps-search-input" placeholder="Искать парковку" data-geocode-input>
        <div class="ps-search-actions">
            <button type="button" class="ps-icon-btn ps-icon-btn--ghost" data-geocode-submit aria-label="Найти">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="m5 12.5 13.5-5.4a.5.5 0 0 1 .7.46L18 19.1a.5.5 0 0 1-.76.35l-4.34-3.07a1 1 0 0 0-1.16 0L7.4 18.9A.5.5 0 0 1 6.64 18L5 13.03a.5.5 0 0 1 0-.53Z" fill="currentColor"/></svg>
            </button>
            <button type="button" class="ps-icon-btn ps-icon-btn--ghost" title="Голосовой ввод">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a3 3 0 0 0-3 3v5a3 3 0 0 0 6 0V6a3 3 0 0 0-3-3Zm-1 15.9V21h2v-2.1a6.5 6.5 0 0 0 5-6.3h-2a4.5 4.5 0 1 1-9 0H5a6.5 6.5 0 0 0 5 6.3Z" fill="currentColor"/></svg>
            </button>
        </div>
    </div>

    <div class="ps-map-card ps-map-panel" data-map-panel>
        <div class="ps-map-wrapper">
            <div id="map" class="ps-map"></div>
            <div class="ps-map-overlay"></div>
            <div class="ps-map-loading" data-map-loading>Обновляем карту…</div>
            <div class="ps-map-floating-actions" aria-label="Действия карты">
                <button class="ps-map-action" type="button" data-fill-location title="Моё местоположение" aria-label="Моё местоположение">
                    <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3.5 9.6 10H4l5 4-2 6.5L12 16l5 4.5-2-6.5 5-4h-5.6L12 3.5Z" fill="currentColor"/></svg>
                </button>
                <button class="ps-map-action" type="button" data-reset-filters title="Сбросить фильтры" aria-label="Сбросить фильтры">
                    <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 5a7 7 0 0 1 6.9 6H21l-2.7 3-2.7-3H17A5 5 0 1 0 7 12H5.5A6.5 6.5 0 0 1 12 5Zm6 4h-1.5a4.5 4.5 0 0 0-9 0H6a6 6 0 0 1 12 0Zm-6 10a7 7 0 0 1-6.9-6H3l2.7-3 2.7 3H7a5 5 0 0 0 10 0h1.5A6.5 6.5 0 0 1 12 19Z" fill="currentColor"/></svg>
                </button>
                <button class="ps-map-action" type="button" data-map-theme title="Светлая / тёмная карта" aria-pressed="false">
                    <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a9 9 0 0 0 0 18c2.9 0 5.5-1.4 7.1-3.5A7 7 0 0 1 12 4.9V3Zm0 2.9A7 7 0 0 1 17.8 17 7 7 0 1 1 12 5.9Z" fill="currentColor"/></svg>
                </button>
            </div>
        </div>
        <div class="ps-map-controls">
            <div class="ps-map-chips" data-filter-chips>
                <label class="ps-chip" data-chip-toggle>
                    <input type="checkbox" name="only_free" hidden>
                    <span>Только свободные</span>
                </label>
                <label class="ps-chip" data-chip-toggle>
                    <input type="checkbox" name="ai_recommended" hidden>
                    <span>AI-рекомендации</span>
                </label>
                <label class="ps-chip" data-chip-toggle>
                    <input type="checkbox" name="ev" hidden>
                    <span>EV-зарядка</span>
                </label>
                <label class="ps-chip" data-chip-toggle>
                    <input type="checkbox" name="covered" hidden>
                    <span>Крытая</span>
                </label>
                <label class="ps-chip" data-chip-toggle>
                    <input type="checkbox" name="is_24_7" hidden>
                    <span>24/7</span>
                </label>
            </div>
            <div class="ps-map-filters" data-map-filters-container>
                <form class="ps-map-filters-card" data-map-filters>
                    <div class="ps-map-filters-row ps-map-filters-row--slider">
                        <div class="ps-filter-slider" data-price-slider></div>
                        <div class="ps-filter-price" data-price-display>Цена: от 0 ₽ до 1500 ₽</div>
                    </div>
                </form>
            </div>
            <div class="ps-geocode-suggestions" data-geocode-suggestions></div>
            <div class="ps-route-hint" data-route-hint>Постройте мини-маршрут до выбранной точки.</div>
            <div class="ps-map-cta">
                <a class="ps-link ps-link-arrow" href="{% url 'map_page' %}">Открыть карту полностью</a>
            </div>
        </div>
    </div>

    <div class="ps-section ps-reco-section">
        <div class="ps-section-header ps-section-header--stack">
            <div>
                <p class="ps-kicker">Рекомендации</p>
                <h2 class="ps-section-title">Рядом с вами</h2>
                <p class="ps-section-subtitle">Динамические цены, фильтры и быстрые действия.</p>
            </div>
        </div>
        <div class="ps-spots-panel" data-spots-panel>
            <div class="ps-spots-list" data-spots-list>
                <div class="ps-card ps-card--spot ps-card--skeleton">
                    <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
                    <div class="ps-skeleton-line"></div>
                    <div class="ps-skeleton-line ps-skeleton-line--short"></div>
                </div>
                <div class="ps-card ps-card--spot ps-card--skeleton">
                    <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
                    <div class="ps-skeleton-line"></div>
                    <div class="ps-skeleton-line ps-skeleton-line--short"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="ps-section">
        <div class="ps-card ps-card--elevated ps-assistant-card">
            <div class="ps-card-header">
                <div>
                    <p class="ps-kicker">AI Concierge</p>
                    <div class="ps-card-title">AI-консьерж по парковке</div>
                    <p class="ps-card-line ps-card-line--muted">Персональные подсказки, маршруты и сценарии поддержки в реальном времени.</p>
                </div>
                <span class="ps-badge ps-badge--neutral">Потоковый чат</span>
            </div>
            <div class="ps-card-body">
                <a class="ps-btn ps-btn-full" href="{% url 'ai_chat' %}">Открыть ассистента</a>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script>
        window.PARKSHARE_MAP_PROVIDER = {
            id: "{{ MAP_PROVIDER|default:'yandex' }}",
            fallback: "{{ MAP_PROVIDER_FALLBACK|default:'leaflet' }}",
            default_center: {{ MAP_DEFAULT_CENTER|safe }},
            default_zoom: {{ MAP_DEFAULT_ZOOM|default:11 }},
        };
    </script>
    {% load static %}
    {% static 'js/map.js' as map_static %}
    <script src="{{ map_static }}?v=44"></script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 211
PATH: templates\parking\map_fullscreen.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Полная карта — ParkShare{% endblock %}

{% block extra_head %}
    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
    <link rel="stylesheet" href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css">
    <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU{% if YANDEX_MAP_API_KEY %}&apikey={{ YANDEX_MAP_API_KEY }}{% endif %}"
            defer></script>
{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top ps-map-hero" data-route="map">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Карта</p>
            <h1 class="ps-section-title">Полноэкранный режим</h1>
            <p class="ps-section-subtitle">Поиск, фильтры, маршруты и live-темы.</p>
            <div class="ps-connection" data-connection-badge hidden>Проверяем сеть…</div>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'landing' %}" class="ps-btn ps-btn-ghost ps-btn-sm">На главную</a>
            <button type="button" class="ps-btn ps-btn-primary ps-btn-sm" data-fill-location>Рядом со мной</button>
        </div>
    </div>

    <div class="ps-map-grid">
        <div class="ps-map-panel" data-map-panel>
            <div class="ps-map-wrapper">
                <div id="map" class="ps-map"></div>
                <div class="ps-map-loading" data-map-loading>Обновляем карту…</div>
                <div class="ps-map-floating-actions" aria-label="Действия карты">
                    <button class="ps-map-action" type="button" data-fill-location title="Моё местоположение" aria-label="Моё местоположение">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3.5 9.6 10H4l5 4-2 6.5L12 16l5 4.5-2-6.5 5-4h-5.6L12 3.5Z" fill="currentColor"/></svg>
                    </button>
                    <button class="ps-map-action" type="button" data-reset-filters title="Сбросить фильтры" aria-label="Сбросить фильтры">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 5a7 7 0 0 1 6.9 6H21l-2.7 3-2.7-3H17A5 5 0 1 0 7 12H5.5A6.5 6.5 0 0 1 12 5Zm6 4h-1.5a4.5 4.5 0 0 0-9 0H6a6 6 0 0 1 12 0Zm-6 10a7 7 0 0 1-6.9-6H3l2.7-3 2.7 3H7a5 5 0 0 0 10 0h1.5A6.5 6.5 0 0 1 12 19Z" fill="currentColor"/></svg>
                    </button>
                    <button class="ps-map-action" type="button" data-map-theme title="Светлая / тёмная карта" aria-pressed="false">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a9 9 0 0 0 0 18c2.9 0 5.5-1.4 7.1-3.5A7 7 0 0 1 12 4.9V3Zm0 2.9A7 7 0 0 1 17.8 17 7 7 0 1 1 12 5.9Z" fill="currentColor"/></svg>
                    </button>
                </div>
                <div class="ps-map-topbar">
                    <input type="text" class="ps-input ps-input--pill" placeholder="Адрес, метро или место" data-geocode-input>
                    <button class="ps-btn ps-btn-primary ps-btn-sm" type="button" data-geocode-submit>Найти</button>
                </div>
                <div class="ps-map-chips" data-filter-chips>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="only_free" hidden>
                        <span>Только свободные</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="ai_recommended" hidden>
                        <span>AI-рекомендации</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="ev" hidden>
                        <span>EV-зарядка</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="covered" hidden>
                        <span>Крытая</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="is_24_7" hidden>
                        <span>24/7</span>
                    </label>
                </div>
                <div class="ps-geocode-suggestions" data-geocode-suggestions></div>
            </div>
            <div class="ps-map-filters" data-map-filters-container>
                <form class="ps-map-filters-card" data-map-filters>
                    <div class="ps-map-filters-row ps-map-filters-row--slider">
                        <div class="ps-filter-slider" data-price-slider></div>
                        <div class="ps-filter-price" data-price-display>Цена: от 0 ₽ до 1500 ₽</div>
                    </div>
                </form>
            </div>
            <div class="ps-route-hint" data-route-hint>Постройте мини-маршрут до выбранной точки.</div>
        </div>

        <div class="ps-bottom-sheet" data-spots-panel data-route="list">
            <div class="ps-bottom-sheet__handle"></div>
            <div class="ps-bottom-sheet__header">
                <div>
                    <div class="ps-section-title-sm">Доступные места</div>
                    <div class="ps-text-muted">Свободных: <span data-spots-count>{{ spots_total|default:0 }}</span>, ср. цена <span data-avg-price>—</span></div>
                </div>
                <div class="ps-bottom-sheet__actions">
                    <button type="button" class="ps-btn ps-btn-ghost ps-btn-sm" data-reset-filters>Сбросить</button>
                </div>
            </div>
            <div class="ps-bottom-sheet__body">
                <div class="ps-spots-list" data-spots-list>
                    <div class="ps-card ps-card--spot ps-card--skeleton">
                        <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
                        <div class="ps-skeleton-line"></div>
                        <div class="ps-skeleton-line ps-skeleton-line--short"></div>
                    </div>
                </div>
                <div class="ps-bottom-sheet__footer">
                    <button class="ps-btn ps-btn-secondary ps-btn-block" type="button" data-spots-load-more data-route-link="list">Показать ещё</button>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script type="module" src="{% static 'pwa/app.js' %}?v=2024.09"></script>
    <script>
        window.PARKSHARE_MAP_PROVIDER = {
            id: "{{ MAP_PROVIDER|default:'yandex' }}",
            fallback: "{{ MAP_PROVIDER_FALLBACK|default:'leaflet' }}",
            default_center: {{ MAP_DEFAULT_CENTER|safe }},
            default_zoom: {{ MAP_DEFAULT_ZOOM|default:11 }},
        };
    </script>
    {% static 'js/map.js' as map_static %}
    <script src="{{ map_static }}?v=50"></script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 212
PATH: templates\parking\owner_dashboard.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Владелец — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="parking">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Моя парковка</p>
            <h1 class="ps-section-title">Кабинет владельца</h1>
            <p class="ps-section-subtitle">
                Управляйте объектами, местами и бронированиями в одном мобильном интерфейсе.
            </p>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'map_page' %}" class="ps-btn ps-btn-secondary ps-btn-sm">К карте</a>
        </div>
    </div>
    <div class="ps-chip-row">
        <span class="ps-chip ps-chip--soft">Объектов: {{ lots|length }}</span>
        <span class="ps-chip ps-chip--soft">Мест: {{ spots|length }}</span>
        <span class="ps-chip ps-chip--soft">Брони: {{ bookings|length }}</span>
    </div>

    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Мои объекты</h2>
            </div>
            <ul class="ps-list">
                {% for lot in lots %}
                    <li class="ps-list-item">
                        <div class="ps-list-main">
                            <div class="ps-list-title">
                                {{ lot.city }}, {{ lot.name }}
                            </div>
                            <div class="ps-list-subtitle">
                                {{ lot.get_parking_type_display }} · мест: {{ lot.spots.count }}
                            </div>
                        </div>
                        <span class="ps-badge ps-badge--neutral">
                            {{ lot.created_at|date:"d.m.Y" }}
                        </span>
                    </li>
                {% empty %}
                    <li class="ps-list-empty">
                        Пока нет ни одного объекта. Добавьте парковку через web-интерфейс владельца.
                    </li>
                {% endfor %}
            </ul>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Места</h2>
            </div>
            <ul class="ps-list ps-list--compact">
                {% for spot in spots %}
                    <li class="ps-list-item">
                        <div class="ps-list-main">
                            <div class="ps-list-title">
                                {{ spot.lot.city }}, {{ spot.lot.name }} — {{ spot.name }}
                            </div>
                            <div class="ps-list-subtitle">
                                Тип: {{ spot.get_vehicle_type_display }} · {{ spot.hourly_price }} ₽/ч
                            </div>
                        </div>
                        <span class="ps-badge ps-badge--status-{{ spot.status }}">
                            {{ spot.get_status_display }}
                        </span>
                    </li>
                {% empty %}
                    <li class="ps-list-empty">
                        Мест пока нет.
                    </li>
                {% endfor %}
            </ul>
        </article>
    </div>

    <div class="ps-section">
        <div class="ps-section-header ps-section-header--stack">
            <div>
                <h2 class="ps-section-title">Бронирования по моим местам</h2>
                <p class="ps-section-subtitle">Кто сейчас бронирует и на какие суммы.</p>
            </div>
        </div>
        <div class="ps-reco-list">
            {% for booking in bookings %}
                <article class="ps-reco-card">
                    <div>
                        <div class="ps-reco-title">
                            {{ booking.spot.lot.city }}, {{ booking.spot.lot.name }} — {{ booking.spot.name }}
                        </div>
                        <div class="ps-reco-meta">
                            Пользователь: {{ booking.user.username }}
                        </div>
                        <div class="ps-reco-meta">
                            {{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
                        </div>
                        <div class="ps-reco-meta">
                            Сумма: {{ booking.total_price }} ₽
                        </div>
                    </div>
                    <span class="ps-chip ps-chip--soft">{{ booking.get_status_display }}</span>
                </article>
            {% empty %}
                <div class="ps-empty">
                    По вашим местам ещё не было бронирований.
                </div>
            {% endfor %}
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 213
PATH: templates\parking\pwa_install.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Установить ParkShare как приложение{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <h1 class="ps-section-title">Установите ParkShare RU на главный экран</h1>
            <p class="ps-section-subtitle">PWA работает оффлайн, даёт быстрый доступ к брони и чату.</p>
        </div>
    </div>

    <div class="ps-grid ps-grid--2col@lg ps-grid--gap-lg ps-grid--mobile-stack">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h3 class="ps-card-title">Android / Chrome</h3>
            </div>
            <div class="ps-card-body">
                <ol class="ps-list-ordered">
                    <li>Нажмите <strong>⋮</strong> в правом верхнем углу браузера.</li>
                    <li>Выберите пункт <strong>«Установить приложение»</strong> или <strong>«Добавить на главный экран»</strong>.</li>
                    <li>Подтвердите установку — ярлык появится рядом с другими приложениями.</li>
                </ol>
                <p class="ps-card-line ps-card-line--muted">Если видите баннер установки — нажмите «Установить» прямо в нём.</p>
            </div>
        </article>

        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h3 class="ps-card-title">iOS / Safari</h3>
            </div>
            <div class="ps-card-body">
                <ol class="ps-list-ordered">
                    <li>Нажмите кнопку «Поделиться» (квадрат со стрелкой вверх).</li>
                    <li>Прокрутите список и выберите <strong>«На экран “Домой”»</strong>.</li>
                    <li>Нажмите «Добавить» — появится значок ParkShare.</li>
                </ol>
                <p class="ps-card-line ps-card-line--muted">После добавления приложение работает без адресной строки и занимает весь экран.</p>
            </div>
        </article>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 214
PATH: templates\parking\user_dashboard.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Брони — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="bookings">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Брони</p>
            <h1 class="ps-section-title">Личный кабинет</h1>
            <p class="ps-section-subtitle">
                Машины, способы оплаты и активные бронирования в одном месте.
            </p>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'map_page' %}" class="ps-btn ps-btn-secondary ps-btn-sm">Открыть карту</a>
        </div>
    </div>
    <div class="ps-chip-row">
        <span class="ps-chip ps-chip--soft">Роль: {{ user.get_role_display }}</span>
        <span class="ps-chip ps-chip--soft">Брони: {{ bookings|length }}</span>
    </div>

    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Профиль</h2>
                <span class="ps-badge ps-badge--neutral">{{ user.get_role_display }}</span>
            </div>
            <div class="ps-card-body">
                <p class="ps-card-line">
                    <span class="ps-label">Логин:</span> {{ user.username }}
                </p>
                <div class="ps-progress-block">
                    <div class="ps-progress-header">
                        <span class="ps-badge">Уровень 1 · Новичок</span>
                        <span class="ps-progress-label">До следующего уровня: 3 бронирования</span>
                    </div>
                    <div class="ps-progress">
                        <div class="ps-progress-bar" style="width: 45%"></div>
                    </div>
                </div>
                <a href="{% url 'accounts:profile' %}" class="ps-btn ps-btn-full">
                    Настройки профиля
                </a>
            </div>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Способы оплаты</h2>
            </div>
            <div class="ps-card-body ps-card-body--spacing-lg">
                <div class="ps-payment-list" data-payment-methods>
                    <div class="ps-empty">Карты ещё не добавлены. Подключите карту, чтобы бронировать без ввода данных.</div>
                </div>
                <form class="ps-form ps-form-compact" method="post" action="#" data-payment-method-form>
                    <div class="ps-form-row">
                        <label class="ps-form-label">Номер карты / токен</label>
                        <input class="ps-input" type="text" name="card_number" placeholder="**** **** **** 1234" autocomplete="off">
                        <div class="ps-field-help">Данные токенизируются у провайдера, мы храним только маску.</div>
                    </div>
                    <div class="ps-form-row ps-form-row--inline">
                        <input class="ps-input" type="text" name="exp" placeholder="MM/YY">
                        <input class="ps-input" type="text" name="label" placeholder="Личная / Работа">
                    </div>
                    <div class="ps-form-row ps-form-row--inline">
                        <select class="ps-input" name="provider">
                            <option value="sber">Сбербанк</option>
                            <option value="tinkoff">Тинькофф</option>
                            <option value="other">YooKassa / другое</option>
                        </select>
                        <label class="ps-checkbox ps-checkbox--inline">
                            <input type="checkbox" name="is_default">
                            <span>Сделать по умолчанию</span>
                        </label>
                    </div>
                    <div class="ps-form-actions">
                        <button class="ps-btn ps-btn-primary ps-btn-full" type="submit">Сохранить карту</button>
                    </div>
                </form>
            </div>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Мои машины</h2>
            </div>
            <ul class="ps-list">
                {% for vehicle in vehicles %}
                    <li class="ps-list-item">
                        <div class="ps-list-main">
                            <div class="ps-list-title">
                                {{ vehicle.label|default:"Без названия" }}
                            </div>
                            <div class="ps-list-subtitle">
                                {{ vehicle.get_vehicle_type_display }}
                            </div>
                        </div>
                        <span class="ps-badge ps-badge--neutral">
                            {{ vehicle.created_at|date:"d.m.Y" }}
                        </span>
                    </li>
                {% empty %}
                    <li class="ps-list-empty">
                        Пока ни одной машины. Добавьте машину через мобильный интерфейс ParkShare RU.
                    </li>
                {% endfor %}
            </ul>
        </article>
    </div>

    <div class="ps-section">
        <div class="ps-section-header ps-section-header--stack">
            <div>
                <h2 class="ps-section-title">Мои бронирования</h2>
                <p class="ps-section-subtitle">История и активные сессии с быстрыми действиями.</p>
            </div>
        </div>
        <div class="ps-reco-list">
            {% for booking in bookings %}
                <article class="ps-reco-card ps-animate-fade-up">
                    <div>
                        <div class="ps-reco-title">
                            {{ booking.spot.lot.city }}, {{ booking.spot.lot.name }} — {{ booking.spot.name }}
                        </div>
                        <div class="ps-reco-meta">
                            {{ booking.get_booking_type_display }} · {{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
                        </div>
                        <div class="ps-reco-meta">
                            Сумма: {{ booking.total_price }} ₽
                        </div>
                        <div class="ps-reco-actions">
                            <a href="{% url 'map_page' %}" class="ps-btn ps-btn-secondary ps-btn-sm">На карте</a>
                            <a href="{% url 'ai_chat' %}" class="ps-btn ps-btn-ghost ps-btn-sm">Спросить ассистента</a>
                        </div>
                    </div>
                    <span class="ps-chip ps-chip--soft">{{ booking.get_status_display }}</span>
                </article>
            {% empty %}
                <div class="ps-empty">У вас пока нет бронирований.</div>
            {% endfor %}
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 215
PATH: vehicles\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 216
PATH: vehicles\admin.py
LANG: python
===== CONTENT START =====
# vehicles/admin.py

from django.contrib import admin

from .models import Vehicle


@admin.register(Vehicle)
class VehicleAdmin(admin.ModelAdmin):
    list_display = ("label", "owner", "vehicle_type", "created_at")
    list_filter = ("vehicle_type", "created_at")
    search_fields = ("label", "owner__username")
    readonly_fields = ("plate_hash", "created_at")

    def has_view_or_change_permission(self, request, obj=None):
        """
        В админку по умолчанию имеет доступ только персонал,
        так что дополнительных ограничений не вводим.
        """
        return super().has_view_or_change_permission(request, obj)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 217
PATH: vehicles\apps.py
LANG: python
===== CONTENT START =====
# vehicles/apps.py

from django.apps import AppConfig


class VehiclesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "vehicles"
    verbose_name = "Машины пользователей"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 218
PATH: vehicles\models.py
LANG: python
===== CONTENT START =====
import uuid

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


class Vehicle(TimeStampedModel):
    """
    Машина пользователя.

    Важно:
    - реальный госномер нигде не хранится;
    - в БД есть только хэш цифр номера и произвольная метка (label).
    """

    class VehicleType(models.TextChoices):
        CAR = "car", _("Легковой автомобиль")
        MOTO = "moto", _("Мотоцикл")
        COMMERCIAL = "commercial", _("Коммерческий транспорт")

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="vehicles",
        verbose_name=_("Владелец"),
    )
    label = models.CharField(
        _("Название/описание"),
        max_length=64,
        blank=True,
        help_text=_("Например: «Серая Toyota у дома»."),
    )
    vehicle_type = models.CharField(
        _("Тип транспорта"),
        max_length=16,
        choices=VehicleType.choices,
        default=VehicleType.CAR,
    )
    plate_hash = models.CharField(
        _("Хэш номера"),
        max_length=64,
        db_index=True,
        help_text=_("SHA‑256‑хэш цифр госномера с солью."),
    )

    class Meta:
        verbose_name = _("Машина")
        verbose_name_plural = _("Машины")
        unique_together = (("owner", "plate_hash"),)
        ordering = ("-created_at",)

    def __str__(self) -> str:
        if self.label:
            return f"{self.label} ({self.owner.username})"
        return f"Машина {self.pk}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 219
PATH: vehicles\serializers.py
LANG: python
===== CONTENT START =====
# vehicles/serializers.py

from django.utils.translation import gettext_lazy as _
from rest_framework import serializers

from core.utils import hash_plate_digits
from .models import Vehicle


class VehicleSerializer(serializers.ModelSerializer):
    """
    Сериализатор для машин.

    Вход:
    - plate_number (write_only) — строка номера, хэшируется на сервере;
    - label, vehicle_type.

    Выход:
    - id, label, vehicle_type, created_at.
    """

    plate_number = serializers.CharField(
        write_only=True,
        label=_("Госномер"),
        help_text=_(
            "Фактический номер будет преобразован в хэш и не будет храниться в открытом виде."
        ),
    )

    class Meta:
        model = Vehicle
        fields = ("id", "label", "vehicle_type", "plate_number", "created_at")
        read_only_fields = ("id", "created_at")

    def validate_plate_number(self, value: str) -> str:
        digits = "".join(ch for ch in value if ch.isdigit())
        if not digits:
            raise serializers.ValidationError(
                _("Нужно указать хотя бы одну цифру номера.")
            )
        return value

    def create(self, validated_data: dict) -> Vehicle:
        request = self.context["request"]
        user = request.user
        plate_number = validated_data.pop("plate_number")
        plate_hash = hash_plate_digits(plate_number)
        if Vehicle.objects.filter(owner=user, plate_hash=plate_hash).exists():
            raise serializers.ValidationError(
                {
                    "plate_number": _(
                        "Машина с таким номером уже добавлена в ваш список."
                    )
                }
            )
        vehicle = Vehicle.objects.create(
            owner=user,
            plate_hash=plate_hash,
            **validated_data,
        )
        return vehicle

    def update(self, instance: Vehicle, validated_data: dict) -> Vehicle:
        # Номер менять нельзя (потребует создания нового объекта),
        # поэтому игнорируем plate_number при обновлении.
        validated_data.pop("plate_number", None)
        return super().update(instance, validated_data)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 220
PATH: vehicles\urls.py
LANG: python
===== CONTENT START =====
# vehicles/urls.py

from django.contrib.auth.decorators import login_required
from django.urls import path
from django.views.generic import TemplateView

app_name = "vehicles"

urlpatterns = [
    # Простая HTML-страница «Мои машины» (можно использовать в будущем).
    path(
        "my/",
        login_required(
            TemplateView.as_view(template_name="vehicles/my_vehicles.html")
        ),
        name="my_vehicles",
    ),
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 221
PATH: vehicles\views.py
LANG: python
===== CONTENT START =====
# vehicles/views.py

from rest_framework import permissions, viewsets

from core.permissions import IsOwnerObject
from .models import Vehicle
from .serializers import VehicleSerializer


class VehicleViewSet(viewsets.ModelViewSet):
    """
    API для машин пользователя.

    - /api/vehicles/              (GET)   — список машин текущего пользователя
    - /api/vehicles/              (POST)  — создать машину (номер хэшируется)
    - /api/vehicles/{id}/         (GET)   — детали (только владелец)
    - /api/vehicles/{id}/         (PATCH/PUT/DELETE) — управление машиной (только владелец)
    """

    serializer_class = VehicleSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerObject]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return Vehicle.objects.none()
        return Vehicle.objects.filter(owner=user).order_by("-created_at")

    def perform_create(self, serializer: VehicleSerializer) -> None:
        # owner устанавливается в serializer.create()
        serializer.save()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 222
PATH: vehicles\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Vehicle',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('label', models.CharField(blank=True, help_text='Например: «Серая Toyota у дома».', max_length=64, verbose_name='Название/описание')),
                ('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
                ('plate_hash', models.CharField(db_index=True, help_text='SHA‑256‑хэш цифр госномера с солью.', max_length=64, verbose_name='Хэш номера')),
                ('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='vehicles', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
            ],
            options={
                'verbose_name': 'Машина',
                'verbose_name_plural': 'Машины',
                'ordering': ('-created_at',),
                'unique_together': {('owner', 'plate_hash')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 223
PATH: vehicles\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

