################################################################################
# COMPRESSED PROJECT DUMP
# Root: C:\Users\Sultan\Downloads\parkshare_ru_part1
# Generated at: 2025-11-28 23:53:11
# Files: 163
# Max file size: 500KB
# Code compression: True
################################################################################
PROJECT TREE:
--------------------------------------------------------------------------------
parkshare_ru_part1/
    .env
    .env.example
    .env.prod
    .gitattributes
    Dockerfile
    README.md
    api_server.py
    app.js
    database.py
    docker-compose.prod.yml
    docker-compose.yml
    dump_project.py
    entrypoint.sh
    index.html
    model_training.py
    project_dump.txt
    requirements.txt
    run_dev.bat
    run_dev.py
    run_dev.sh
    accounts/
        __init__.py
        admin.py
        apps.py
        auth.py
        forms.py
        models.py
        serializers.py
        urls.py
        utils.py
        views.py
        migrations/
            0001_initial.py
            0002_user_email_hash_user_phone_hash_logincode.py
            0003_userlevel_userbadge_promoreward.py
            __init__.py
    ai/
        __init__.py
        admin.py
        apps.py
        features.py
        models.py
        orchestrator.py
        pricing.py
        serializers.py
        tasks.py
        views.py
        chat/
            __init__.py
            parking_assistant.py
        management/
            __init__.py
            commands/
                __init__.py
                train_chat_intents_from_logs.py
        migrations/
            0001_initial.py
            __init__.py
    ai_services/
        __init__.py
        ai_pricing_service/
            __init__.py
            main.py
        cv_service/
            __init__.py
            main.py
    backend/
        manage.py
        backend/
            __init__.py
            config/
                __init__.py
                asgi.py
                celery.py
                urls.py
                wsgi.py
            settings/
                __init__.py
                base.py
                local.py
                production.py
                regions.py
        rest_framework_simplejwt/
            __init__.py
            authentication.py
            tokens.py
            views.py
        tests/
            __init__.py
            test_auth_api.py
            test_booking_model.py
    core/
        __init__.py
        admin.py
        apps.py
        context_processors.py
        integrations.py
        middleware.py
        models.py
        pagination.py
        permissions.py
        utils.py
    drf_spectacular/
        __init__.py
        openapi.py
        views.py
    frontend/
        parkmate/
            parkmate.types.ts
    nginx/
        nginx.conf
    parking/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        tasks.py
        urls.py
        views.py
        management/
            commands/
                seed_demo_parking.py
        migrations/
            0001_initial.py
            0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
            0003_booking_ai_fields.py
            0004_favoriteparkingspot_savedplace.py
            __init__.py
    payments/
        __init__.py
        admin.py
        apps.py
        models.py
        providers.py
        serializers.py
        tasks.py
        views.py
        migrations/
            0001_initial.py
            0002_alter_payment_provider.py
            0003_paymentmethod.py
            __init__.py
        providers/
            __init__.py
            base.py
            registry.py
            stripe.py
            yookassa.py
    regions/
        global.yml
        ru.yml
    services/
        __init__.py
        llm.py
        llm_service/
            Dockerfile
            main.py
            requirements.txt
    static/
        manifest.webmanifest
        service-worker.js
        css/
            app.css
            cinematic-ui.css
        icons/
        js/
            app.js
            map.js
            parkmate-ai.ts
            quantum-theme-manager.js
    templates/
        base.html
        offline.html
        accounts/
            login.html
            password_change.html
            password_change_done.html
            password_reset.html
            password_reset_complete.html
            password_reset_confirm.html
            password_reset_done.html
            password_reset_email.txt
            password_reset_subject.txt
            profile.html
            register.html
        parking/
            landing.html
            map_fullscreen.html
            owner_dashboard.html
            pwa_install.html
            user_dashboard.html
    vehicles/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py


================================================================================
FILES CONTENT:
================================================================================

# File 1/163: .env
################################################################################

DEBUG=1
SECRET_KEY=django-insecure-test-secret-key-for-dev-only
ALLOWED_HOSTS=127.0.0.1,localhost
DATABASE_NAME=db.sqlite3

YOOKASSA_SHOP_ID=
YOOKASSA_SECRET_KEY=

EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend

# Карты / регион
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=

# Старый токен Mapbox (если будешь использовать где-то ещё)
MAPBOX_TOKEN=your_actual_token_here

# OpenAI
OPENAI_API_KEY=sk...
OPENAI_MODEL=gpt-4o-mini
OPENAI_BASE_URL=https://api.openai.com/v1

LLM_CLIENT_TIMEOUT=8
LLM_CLIENT_RETRIES=2

# (опционально) Явный URL сервиса, если хочешь переопределить:
# LLM_SERVICE_URL=http://llm_service:8002


# File 2/163: .env.example
################################################################################

# Базовые настройки Django
DEBUG=False
SECRET_KEY=change_me_to_random_long_secret_key
ALLOWED_HOSTS=localhost,127.0.0.1,0.0.0.0
PLATFORM_MODE=RU

# База данных
# Для продакшена: postgres://user:password@db:5432/parkshare
# Django-environ автоматически распарсит URL.
DATABASE_URL=postgres://parkshare:parkshare@db:5432/parkshare

# Payments
PAYMENT_PROVIDER=yookassa
YOOKASSA_SHOP_ID=YOUR_SHOP_ID
YOOKASSA_SECRET_KEY=YOUR_SECRET
YOOKASSA_RETURN_URL=https://SERVER_HOST/payments/return/
YOOKASSA_WEBHOOK_SECRET=YOUR_WEBHOOK_SECRET
STRIPE_SECRET_KEY=YOUR_STRIPE_KEY
STRIPE_WEBHOOK_SECRET=YOUR_STRIPE_WEBHOOK_SECRET

# Redis (брокер/кэш)
REDIS_URL=redis://redis:6379/0

# Таймзона и язык
TIME_ZONE=Europe/Moscow
LANGUAGE_CODE=ru-ru

# Соль для хэширования цифр номеров
VEHICLE_PLATE_SALT=change_me_vehicle_plate_salt

# Настройки CORS (если нужен доступ с другого домена, например, моб. WebView)
CORS_ALLOWED_ORIGINS=http://localhost:8000

# Настройки Celery
CELERY_BROKER_URL=${REDIS_URL}
CELERY_RESULT_BACKEND=${REDIS_URL}

# Настройки YooKassa (пример)
YOOKASSA_SHOP_ID=your_shop_id_here
YOOKASSA_SECRET_KEY=your_secret_key_here
YOOKASSA_RETURN_URL=https://example.com/payments/return/
YOOKASSA_WEBHOOK_SECRET=change_me_webhook_secret

# Комиссия сервиса (процент, будет использована в бизнес-логике)
SERVICE_COMMISSION_PERCENT=10

# Безопасность для продакшена
SECURE_SSL_REDIRECT=False
SESSION_COOKIE_SECURE=False
CSRF_COOKIE_SECURE=False

# Регион / карты
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=your_yandex_maps_api_key


# File 3/163: .env.prod
################################################################################

# -----------------------------
# DJANGO SETTINGS (PROD)
# -----------------------------
DEBUG=0
SECRET_KEY=django-insecure-поставь_сюда_очень_длинную_строку_символов
ALLOWED_HOSTS=your-domain.ru,your-domain.com,127.0.0.1

DJANGO_SETTINGS_MODULE=backend.settings.production

# -----------------------------
# DATABASE (PostgreSQL / PostGIS)
# -----------------------------
DATABASE_NAME=parkshare
DATABASE_USER=parkshare
DATABASE_PASSWORD=сильный_пароль_к_бд
DATABASE_HOST=db
DATABASE_PORT=5432

# -----------------------------
# YOOKASSA PAYMENTS (боевые реквизиты)
# -----------------------------
YOOKASSA_SHOP_ID=твой_shop_id
YOOKASSA_SECRET_KEY=твой_secret_key

# -----------------------------
# EMAIL SETTINGS
# -----------------------------
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.yandex.ru
EMAIL_PORT=465
EMAIL_USE_SSL=1
EMAIL_HOST_USER=no-reply@your-domain.ru
EMAIL_HOST_PASSWORD=пароль_от_почты

# -----------------------------
# MAP / REGION
# -----------------------------
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=your_yandex_maps_api_key
MAPBOX_TOKEN=your_actual_token_here


# File 4/163: .gitattributes
################################################################################

# Auto detect text files and perform LF normalization
* text=auto


# File 5/163: Dockerfile
################################################################################

# Production-ready Dockerfile
FROM python:3.12-slim AS builder
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    gdal-bin \
    libgdal-dev \
    binutils \
    libproj-dev \
    libgeos-dev \
    libspatialindex-dev \
    gettext \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt
COPY . /app/

RUN python backend/manage.py collectstatic --noinput --settings=backend.settings.production || true

FROM python:3.12-slim AS runtime
ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1
WORKDIR /app

COPY --from=builder /usr/local/lib/python3.12 /usr/local/lib/python3.12
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app /app

EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD curl -f http://localhost:8000/health/ || exit 1
CMD ["gunicorn", "backend.config.wsgi:application", "--bind", "0.0.0.0:8000"]


# File 6/163: README.md
################################################################################

# ParkShare Global Platform

Унифицированная архитектура для ParkShare с профилями RU/GLOBAL, защищёнными настройками и PWA фронтендом.

## Запуск
```bash
docker-compose up --build
```
ENVIRONMENT выбирается через переменные окружения и файлы `.env.<profile>`.

Для локальной разработки без зависимостей PostGIS/GDAL установите `USE_GIS=False` и задайте
`DATABASE_URL=sqlite:///db.sqlite3`, чтобы Django использовал SQLite и не требовал GDAL.

## Контейнеры
- PostGIS (db)
- Redis (cache/rate limit/Celery)
- Gunicorn web (Django)
- Celery worker/beat
- Nginx как TLS-терминатор

## Безопасность
- JWT + refresh токены (`/api/auth/token`, `/api/auth/token/refresh`)
- Rate limiting, CSP, HSTS, Referrer/Permissions Policy (`core/middleware.py`, `backend/settings`)
- Provider registry (`providers/`)
- Транзакционные блокировки бронирований (`parking/views.py`)

## PWA
- Сервис-воркер с разными стратегиями кэширования (`static/service-worker.js`)
- Offline fallback (`templates/offline.html`)

## AI
- Динамическое ценообразование, рекомендации, CV и антифрод (`ai/engines.py`, `services/ai.py`)

## Продакшен-старт (Ubuntu/Debian)
```bash
cp .env.example .env.prod  # заполнить секреты/хосты
docker-compose -f docker-compose.prod.yml up -d --build
```

Домен и TLS настраиваются через `nginx/nginx.conf` (добавьте сертификаты Let's Encrypt). ALLOWED_HOSTS и переменные карты/платежей берутся из `.env.prod`.
#   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 

# File 7/163: api_server.py
################################################################################

# api_server.py
from __future__ import annotations
import datetime as dt
import re
from pathlib import Path
from typing import Any, Dict, List, Optional
import joblib
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from database import get_connection
BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"
# --- Загрузка моделей ---
occ_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "occupancy_model.pkl")
OCC_PIPE = occ_bundle["pipeline"]
OCC_FEATURE_COLS = occ_bundle["feature_cols"]
NLP_PIPE = joblib.load(MODELS_DIR / "nlp_intent.pkl")
rec_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "recommender.pkl")
USER_ITEM: pd.DataFrame = rec_bundle["user_item"]
ITEM_SIM: pd.DataFrame = rec_bundle["item_sim"]
LOT_FEATURES: pd.DataFrame = rec_bundle["lot_features"]
# --- FastAPI ---
app = FastAPI(title="ParkShare Local AI", version="1.0.0")
app.add_middleware(
CORSMiddleware,
allow_origins=["*"],
allow_credentials=True,
allow_methods=["*"],
allow_headers=["*"],
)
# ---------- Схемы ----------
class Lot(BaseModel):
id: int
name: str
latitude: float
longitude: float
near_metro: bool
price_level: int
has_covered: bool
has_ev_charging: bool
predicted_occupancy: float
class SearchResult(BaseModel):
query: str
intent: str
time_of_day: Optional[str]
near_metro: Optional[bool]
max_price_level: Optional[int]
has_ev_charging: Optional[bool]
has_covered: Optional[bool]
lots: List[Lot]
class OccupancyPredictionResponse(BaseModel):
lot_id: int
ts: dt.datetime
predicted_occupancy: float
class Recommendation(BaseModel):
lot: Lot
score: float
class RecommendationsResponse(BaseModel):
user_id: Optional[int]
variant: str
recommendations: List[Recommendation]
# ---------- Утилиты ----------
def parse_dt_iso(value: Optional[str]) -> dt.datetime:
if not value:
return dt.datetime.now()
try:
return dt.datetime.fromisoformat(value)
except Exception as exc:
raise HTTPException(status_code=400, detail=f"Неверный формат datetime: {value}") from exc
def nlp_extract_entities(text: str) -> Dict[str, Any]:
s = text.lower()
time_of_day = None
if "утр" in s:
time_of_day = "morning"
elif "днем" in s or "днём" in s:
time_of_day = "day"
elif "вечер" in s:
time_of_day = "evening"
elif "ноч" in s:
time_of_day = "night"
near_metro = "метро" in s
max_price_level: Optional[int] = None
if "дешев" in s or "недорог" in s:
max_price_level = 1
elif "средн" in s:
max_price_level = 2
elif "дорог" in s:
max_price_level = 3
has_ev = "электро" in s or "зарядк" in s or "ev" in s
has_covered = "крыт" in s or "подзем" in s or "паркинг" in s
return {
"time_of_day": time_of_day,
"near_metro": near_metro if near_metro else None,
"max_price_level": max_price_level,
"has_ev_charging": has_ev if has_ev else None,
"has_covered": has_covered if has_covered else None,
}
def build_occ_feature_df(lot_row: Dict[str, Any], ts: dt.datetime) -> pd.DataFrame:
return pd.DataFrame(
[
{
"hour": ts.hour,
"dow": ts.weekday(),
"temperature": 15.0,
"is_rain": 0,
"is_event": 0,
"near_metro": lot_row["near_metro"],
"price_level": lot_row["price_level"],
"has_covered": lot_row["has_covered"],
"has_ev_charging": lot_row["has_ev_charging"],
"lot_id_str": str(lot_row["id"]),
}
]
)[OCC_FEATURE_COLS]
def predict_occupancy_for_lot(lot_row: Dict[str, Any], ts: dt.datetime) -> float:
df = build_occ_feature_df(lot_row, ts)
pred = float(OCC_PIPE.predict(df)[0])
return max(0.0, min(pred, 1.0))
def fetch_lots(filters: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
conn = get_connection()
cur = conn.cursor()
base_query = """
SELECT
id, name, latitude, longitude,
near_metro, price_level, has_covered, has_ev_charging
FROM parking_lot
WHERE 1=1
"""
params: List[Any] = []
if filters:
if filters.get("near_metro") is not None:
base_query += " AND near_metro = ?"
params.append(1 if filters["near_metro"] else 0)
if filters.get("max_price_level") is not None:
base_query += " AND price_level <= ?"
params.append(int(filters["max_price_level"]))
if filters.get("has_ev_charging") is not None:
base_query += " AND has_ev_charging = ?"
params.append(1 if filters["has_ev_charging"] else 0)
if filters.get("has_covered") is not None:
base_query += " AND has_covered = ?"
params.append(1 if filters["has_covered"] else 0)
base_query += " ORDER BY price_level ASC, near_metro DESC"
cur.execute(base_query, params)
rows = [dict(r) for r in cur.fetchall()]
conn.close()
return rows
# ---------- Эндпоинты ----------
@app.get("/health")
def health() -> Dict[str, Any]:
return {"status": "ok"}
@app.get("/api/lots", response_model=List[Lot])
def api_list_lots(
ts: Optional[str] = Query(default=None, description="ISO datetime, по умолчанию — сейчас"),
) -> List[Lot]:
dt_value = parse_dt_iso(ts)
lots = fetch_lots()
result: List[Lot] = []
for row in lots:
occ = predict_occupancy_for_lot(row, dt_value)
result.append(
Lot(
id=row["id"],
name=row["name"],
latitude=row["latitude"],
longitude=row["longitude"],
near_metro=bool(row["near_metro"]),
price_level=row["price_level"],
has_covered=bool(row["has_covered"]),
has_ev_charging=bool(row["has_ev_charging"]),
predicted_occupancy=occ,
)
)
return result
@app.get("/api/occupancy/predict", response_model=OccupancyPredictionResponse)
def api_predict_occupancy(
lot_id: int = Query(...),
ts: Optional[str] = Query(default=None),
) -> OccupancyPredictionResponse:
dt_value = parse_dt_iso(ts)
conn = get_connection()
cur = conn.cursor()
cur.execute(
"""
SELECT id, name, latitude, longitude,
near_metro, price_level, has_covered, has_ev_charging
FROM parking_lot
WHERE id = ?
""",
(lot_id,),
)
row = cur.fetchone()
conn.close()
if row is None:
raise HTTPException(status_code=404, detail="Парковка не найдена")
d = dict(row)
occ = predict_occupancy_for_lot(d, dt_value)
return OccupancyPredictionResponse(
lot_id=lot_id,
ts=dt_value,
predicted_occupancy=occ,
)
@app.get("/api/search", response_model=SearchResult)
def api_search(
query: str = Query(..., min_length=1),
ts: Optional[str] = Query(default=None),
limit: int = Query(default=15, ge=1, le=100),
) -> SearchResult:
dt_value = parse_dt_iso(ts)
intent = NLP_PIPE.predict([query])[0]
entities = nlp_extract_entities(query)
filters: Dict[str, Any] = {}
if entities["near_metro"]:
filters["near_metro"] = True
if entities["max_price_level"] is not None:
filters["max_price_level"] = entities["max_price_level"]
if entities["has_ev_charging"] is not None:
filters["has_ev_charging"] = entities["has_ev_charging"]
if entities["has_covered"] is not None:
filters["has_covered"] = entities["has_covered"]
if intent == "near_metro":
filters["near_metro"] = True
if intent == "cheap" and "max_price_level" not in filters:
filters["max_price_level"] = 1
lots = fetch_lots(filters)
lots = lots[:limit]
lot_models: List[Lot] = []
for row in lots:
occ = predict_occupancy_for_lot(row, dt_value)
lot_models.append(
Lot(
id=row["id"],
name=row["name"],
latitude=row["latitude"],
longitude=row["longitude"],
near_metro=bool(row["near_metro"]),
price_level=row["price_level"],
has_covered=bool(row["has_covered"]),
has_ev_charging=bool(row["has_ev_charging"]),
predicted_occupancy=occ,
)
)
return SearchResult(
query=query,
intent=intent,
time_of_day=entities["time_of_day"],
near_metro=filters.get("near_metro"),
max_price_level=filters.get("max_price_level"),
has_ev_charging=filters.get("has_ev_charging"),
has_covered=filters.get("has_covered"),
lots=lot_models,
)
def _recommend_item_based(user_id: int, top_n: int = 10) -> List[int]:
if user_id not in USER_ITEM.index:
return []
user_ratings = USER_ITEM.loc[user_id]
rated_items = user_ratings[user_ratings > 0].index.tolist()
if not rated_items:
return []
scores = pd.Series(0.0, index=USER_ITEM.columns)
for item_id in rated_items:
sim_vec = ITEM_SIM.loc[item_id]
scores += sim_vec * float(user_ratings[item_id])
scores = scores.drop(rated_items)
scores = scores.sort_values(ascending=False)
return scores.head(top_n).index.tolist()
def _recommend_content_based(top_n: int = 10) -> List[int]:
df = LOT_FEATURES.copy()
df["score"] = 0.0
df["score"] += (1 - (df["price_level"] - 1) / 2)
df["score"] += df["near_metro"] * 0.5
df["score"] += df["has_ev_charging"] * 0.3
df["score"] += df["has_covered"] * 0.2
df = df.sort_values("score", ascending=False)
return df.head(top_n).index.tolist()
@app.get("/api/recommendations", response_model=RecommendationsResponse)
def api_recommendations(
user_id: Optional[int] = Query(default=None),
variant: Optional[str] = Query(
default=None,
description="A или B — для A/B тестирования (A=collab, B=content)",
),
limit: int = Query(default=10, ge=1, le=50),
ts: Optional[str] = Query(default=None),
) -> RecommendationsResponse:
dt_value = parse_dt_iso(ts)
chosen_variant = variant or ("A" if user_id else "B")
if chosen_variant == "A" and user_id is not None:
item_ids = _recommend_item_based(user_id, top_n=limit)
if not item_ids:
chosen_variant = "B"
if chosen_variant == "B" or user_id is None:
item_ids = _recommend_content_based(top_n=limit)
conn = get_connection()
cur = conn.cursor()
cur.execute(
f"""
SELECT id, name, latitude, longitude,
near_metro, price_level, has_covered, has_ev_charging
FROM parking_lot
WHERE id IN ({",".join(["?"] * len(item_ids))})
""",
item_ids,
)
rows = {r["id"]: dict(r) for r in cur.fetchall()}
conn.close()
recs: List[Recommendation] = []
for lot_id in item_ids:
row = rows.get(lot_id)
if not row:
continue
occ = predict_occupancy_for_lot(row, dt_value)
lot = Lot(
id=row["id"],
name=row["name"],
latitude=row["latitude"],
longitude=row["longitude"],
near_metro=bool(row["near_metro"]),
price_level=row["price_level"],
has_covered=bool(row["has_covered"]),
has_ev_charging=bool(row["has_ev_charging"]),
predicted_occupancy=occ,
)
# простая метрика: обратная занятость + бонус за метро и цену
score = (1.0 - occ) + (1 - (row["price_level"] - 1) / 2) + (0.3 if row["near_metro"] else 0.0)
recs.append(Recommendation(lot=lot, score=float(score)))
return RecommendationsResponse(
user_id=user_id,
variant=chosen_variant,
recommendations=recs,
)

# File 8/163: app.js
################################################################################

const API_BASE = "http:
let map;
let markersLayer;
let lotsCache = [];
let lotsById = new Map();
function pickBestLot(lots) {
if (!lots || lots.length === 0) return null;
const ranked = [...lots].sort((a, b) => {
const occA = a.predicted_occupancy ?? 1;
const occB = b.predicted_occupancy ?? 1;
return occA - occB;
});
return ranked[0];
}
function updateAIOracleCard(lots) {
const nameEl = document.getElementById("aiOracleName");
const etaEl = document.getElementById("aiOracleETA");
const confEl = document.getElementById("aiOracleConfidence");
const metaEl = document.getElementById("aiOracleMeta");
const reasoningEl = document.getElementById("aiOracleReason");
if (!nameEl || !etaEl || !confEl || !metaEl || !reasoningEl) return;
if (!lots || lots.length === 0) {
nameEl.textContent = "—";
etaEl.textContent = "—";
confEl.textContent = "—";
metaEl.textContent = "—";
reasoningEl.textContent = "AI готовит инсайт…";
return;
}
const bestLot = pickBestLot(lots);
if (!bestLot) return;
const occ = bestLot.predicted_occupancy ?? 0;
const occPercent = Math.round(occ * 100);
const eta = Math.max(2, Math.min(15, Math.round((1 - occ) * 12)));
const confidence = Math.max(68, Math.min(99, 96 - Math.round(occPercent / 2)));
const ev = bestLot.has_ev_charging ? "EV" : "обычная";
const covered = bestLot.has_covered ? "крытая" : "открытая";
nameEl.textContent = bestLot.name;
etaEl.textContent = `${eta} мин`;
confEl.textContent = `${confidence}%`;
metaEl.textContent = `${ev} · ${covered}`;
reasoningEl.textContent =
"Учитывая вашу историю: быстрый выезд, EV и близость к метро — этот слот даст наивысший WOW-эффект.";
}
function occupancyColor(value) {
if (value <= 0.4) return "
if (value <= 0.7) return "
return "
}
function initMap() {
map = L.map("map", {
zoomControl: true,
attributionControl: false,
}).setView([55.7558, 37.6173], 12);
L.tileLayer("https:
maxZoom: 19,
}).addTo(map);
markersLayer = L.layerGroup().addTo(map);
}
async function apiGet(path, params = {}) {
const url = new URL(API_BASE + path);
Object.entries(params).forEach(([k, v]) => {
if (v !== undefined && v !== null) {
url.searchParams.set(k, v);
}
});
const res = await fetch(url.toString());
if (!res.ok) {
const text = await res.text();
throw new Error(`API error ${res.status}: ${text}`);
}
return res.json();
}
function renderLotsOnMap(lots) {
markersLayer.clearLayers();
lots.forEach((lot) => {
const occ = lot.predicted_occupancy ?? 0;
const color = occupancyColor(occ);
const marker = L.circleMarker([lot.latitude, lot.longitude], {
radius: 8,
fillColor: color,
fillOpacity: 0.9,
color: "
weight: 1,
});
const occPercent = Math.round(occ * 100);
const html = `
<div style="font-size: 12px;">
<strong>${lot.name}</strong><br />
Загрузка: <strong>${occPercent}%</strong><br />
Метро: ${lot.near_metro ? "рядом" : "нет"}<br />
Уровень цены: ${lot.price_level}<br />
Крытая: ${lot.has_covered ? "да" : "нет"}<br />
Зарядка EV: ${lot.has_ev_charging ? "есть" : "нет"}
</div>
`;
marker.bindPopup(html);
marker.addTo(markersLayer);
});
if (lots.length > 0) {
const bounds = L.latLngBounds(
lots.map((lot) => [lot.latitude, lot.longitude])
);
map.fitBounds(bounds.pad(0.2));
}
}
function renderLotsList(containerId, lots, clickHandler) {
const container = document.getElementById(containerId);
container.innerHTML = "";
if (!lots || lots.length === 0) {
container.innerHTML =
'<div style="font-size: 0.75rem; color:
return;
}
lots.forEach((lot) => {
const occ = lot.predicted_occupancy ?? 0;
const occPercent = Math.round(occ * 100);
const div = document.createElement("div");
div.className = "lot-item";
div.innerHTML = `
<div class="lot-main">
<div class="lot-name">${lot.name}</div>
<div class="lot-meta">
<span>Цена: L${lot.price_level}</span>
<span>Метро: ${lot.near_metro ? "рядом" : "нет"}</span>
<span>EV: ${lot.has_ev_charging ? "есть" : "нет"}</span>
<span>Крытая: ${lot.has_covered ? "да" : "нет"}</span>
</div>
</div>
<div class="lot-occ">${occPercent}%</div>
`;
div.addEventListener("click", () => clickHandler(lot));
container.appendChild(div);
});
}
async function loadAllLots() {
const status = document.getElementById("statusText");
try {
const lots = await apiGet("/api/lots");
lotsCache = lots;
lotsById.clear();
lots.forEach((lot) => lotsById.set(lot.id, lot));
renderLotsOnMap(lots);
renderLotsList("lotsList", lots, (lot) => {
map.setView([lot.latitude, lot.longitude], 16);
});
updateAIOracleCard(lots);
status.textContent = "AI-сервер подключён";
} catch (err) {
console.error(err);
status.textContent = "Ошибка подключения к AI-серверу";
}
}
async function handleSearch() {
const input = document.getElementById("searchInput");
const status = document.getElementById("searchStatus");
const text = input.value.trim();
if (!text) return;
status.textContent = "Обрабатываю запрос (локальный NLP)…";
try {
const data = await apiGet("/api/search", { query: text });
const lots = data.lots || [];
renderLotsOnMap(lots);
renderLotsList("lotsList", lots, (lot) => {
map.setView([lot.latitude, lot.longitude], 16);
});
updateAIOracleCard(lots);
const parts = [];
parts.push(`Интент: ${data.intent}`);
if (data.near_metro !== null) {
parts.push(`рядом с метро: ${data.near_metro ? "да" : "нет"}`);
}
if (data.max_price_level !== null) {
parts.push(`макс. уровень цены: L${data.max_price_level}`);
}
if (data.has_ev_charging !== null) {
parts.push(`EV: ${data.has_ev_charging ? "нужна" : "не нужна"}`);
}
if (data.has_covered !== null) {
parts.push(`крытая: ${data.has_covered ? "нужна" : "не нужна"}`);
}
if (data.time_of_day) {
parts.push(`время суток: ${data.time_of_day}`);
}
status.textContent = parts.join(" · ") || "Фильтры не распознаны.";
} catch (err) {
console.error(err);
status.textContent = "Ошибка обработки запроса";
}
}
async function initUsersSelect() {
const select = document.getElementById("userSelect");
for (let i = 1; i <= 20; i++) {
const opt = document.createElement("option");
opt.value = String(i);
opt.textContent = `Пользователь
select.appendChild(opt);
}
}
async function handleRecommendations(variant) {
const select = document.getElementById("userSelect");
const status = document.getElementById("recStatus");
const listContainerId = "recList";
const userId = parseInt(select.value, 10) || undefined;
status.textContent =
variant === "A"
? "Рассчитываю рекомендации (collaborative)…"
: "Рассчитываю рекомендации (content-based)…";
try {
const params = { limit: 10, variant };
if (variant === "A" && userId) {
params.user_id = userId;
}
const data = await apiGet("/api/recommendations", params);
const recs = data.recommendations || [];
const lots = recs.map((r) => r.lot);
renderLotsOnMap(lots);
renderLotsList(listContainerId, lots, (lot) => {
map.setView([lot.latitude, lot.longitude], 16);
});
updateAIOracleCard(lots);
status.textContent = `Вариант ${data.variant}, получено ${recs.length} рекомендаций.`;
} catch (err) {
console.error(err);
status.textContent = "Ошибка получения рекомендаций";
}
}
window.addEventListener("DOMContentLoaded", async () => {
initMap();
await initUsersSelect();
await loadAllLots();
document
.getElementById("searchBtn")
.addEventListener("click", () => handleSearch());
document
.getElementById("searchInput")
.addEventListener("keydown", (e) => {
if (e.key === "Enter") {
handleSearch();
}
});
document.getElementById("recBtn").addEventListener("click", () => {
handleRecommendations("A");
});
document
.getElementById("recContentBtn")
.addEventListener("click", () => {
handleRecommendations("B");
});
});

# File 9/163: database.py
################################################################################

# database.py
from __future__ import annotations
import random
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import List
DB_PATH = Path(__file__).parent / "ai_data.db"
def get_connection() -> sqlite3.Connection:
conn = sqlite3.connect(DB_PATH)
conn.row_factory = sqlite3.Row
return conn
def init_db() -> None:
conn = get_connection()
cur = conn.cursor()
cur.execute(
"""
CREATE TABLE IF NOT EXISTS parking_lot (
id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT NOT NULL,
latitude REAL NOT NULL,
longitude REAL NOT NULL,
near_metro INTEGER NOT NULL,
price_level INTEGER NOT NULL,
has_covered INTEGER NOT NULL,
has_ev_charging INTEGER NOT NULL
);
"""
)
cur.execute(
"""
CREATE TABLE IF NOT EXISTS occupancy_history (
id INTEGER PRIMARY KEY AUTOINCREMENT,
lot_id INTEGER NOT NULL,
ts TEXT NOT NULL,
occupancy REAL NOT NULL,
temperature REAL NOT NULL,
is_rain INTEGER NOT NULL,
is_event INTEGER NOT NULL,
FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
);
"""
)
cur.execute(
"""
CREATE TABLE IF NOT EXISTS app_user (
id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT NOT NULL
);
"""
)
cur.execute(
"""
CREATE TABLE IF NOT EXISTS user_rating (
id INTEGER PRIMARY KEY AUTOINCREMENT,
user_id INTEGER NOT NULL,
lot_id INTEGER NOT NULL,
rating REAL NOT NULL,
FOREIGN KEY (user_id) REFERENCES app_user(id),
FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
);
"""
)
conn.commit()
conn.close()
@dataclass
class LotSpec:
name: str
base_lat: float
base_lon: float
near_metro: int
price_level: int
has_covered: int
has_ev_charging: int
def generate_synthetic_data(
num_lots: int = 30,
num_users: int = 50,
days_back: int = 30,
) -> None:
"""
Генерация синтетических:
- парковок
- истории занятости
- пользователей
- оценок пользователей
"""
random.seed(42)
conn = get_connection()
cur = conn.cursor()
# Чистим старые данные
cur.execute("DELETE FROM user_rating;")
cur.execute("DELETE FROM app_user;")
cur.execute("DELETE FROM occupancy_history;")
cur.execute("DELETE FROM parking_lot;")
conn.commit()
# Базовые точки вокруг Москвы
center_lat, center_lon = 55.7558, 37.6173
lots: List[int] = []
for i in range(num_lots):
near_metro = 1 if random.random() < 0.5 else 0
price_level = random.choice([1, 2, 3])
has_covered = 1 if random.random() < 0.4 else 0
has_ev = 1 if random.random() < 0.3 else 0
# Немного раскидываем точки вокруг центра
lat = center_lat + random.uniform(-0.05, 0.05)
lon = center_lon + random.uniform(-0.1, 0.1)
cur.execute(
"""
INSERT INTO parking_lot (
name, latitude, longitude, near_metro,
price_level, has_covered, has_ev_charging
) VALUES (?, ?, ?, ?, ?, ?, ?)
""",
(
f"Лот
lat,
lon,
near_metro,
price_level,
has_covered,
has_ev,
),
)
lots.append(cur.lastrowid)
# История занятости — каждые 2 часа за days_back дней
now = datetime.now()
start_ts = now - timedelta(days=days_back)
weather_states = ["sunny", "cloudy", "rainy"]
for lot_id in lots:
ts = start_ts
while ts < now:
dow = ts.weekday()
hour = ts.hour
is_event = 1 if (dow in (4, 5) and hour >= 18 and random.random() < 0.3) else 0
weather = random.choice(weather_states)
is_rain = 1 if weather == "rainy" else 0
temperature = random.uniform(-10, 30)
# Базовая занятость зависит от часа и дня недели
base_occ = 0.2
if 8 <= hour <= 11:
base_occ = 0.6
elif 17 <= hour <= 20:
base_occ = 0.7
elif 0 <= hour <= 5:
base_occ = 0.1
if dow >= 5:
base_occ += 0.1
if is_event:
base_occ += 0.2
if is_rain:
base_occ += 0.1
base_occ = max(0.0, min(base_occ + random.uniform(-0.1, 0.1), 1.0))
cur.execute(
"""
INSERT INTO occupancy_history (
lot_id, ts, occupancy, temperature, is_rain, is_event
) VALUES (?, ?, ?, ?, ?, ?)
""",
(
lot_id,
ts.isoformat(),
base_occ,
temperature,
is_rain,
is_event,
),
)
ts += timedelta(hours=2)
# Пользователи
users = []
for i in range(num_users):
cur.execute(
"INSERT INTO app_user (name) VALUES (?);",
(f"user_{i+1}",),
)
users.append(cur.lastrowid)
# Оценки пользователей парковок
for user_id in users:
# Каждый пользователь оценит 5–15 парковок
k = random.randint(5, min(15, len(lots)))
rated_lots = random.sample(lots, k)
for lot_id in rated_lots:
# Рейтинг зависит от price_level и случайности
base_rating = 4.5 - 0.5 * (random.randint(1, 3) - 1)
rating = max(1.0, min(5.0, base_rating + random.uniform(-1.0, 1.0)))
cur.execute(
"""
INSERT INTO user_rating (user_id, lot_id, rating)
VALUES (?, ?, ?)
""",
(user_id, lot_id, rating),
)
conn.commit()
conn.close()
print("Синтетические данные сгенерированы в", DB_PATH)
if __name__ == "__main__":
init_db()
generate_synthetic_data()

# File 10/163: docker-compose.prod.yml
################################################################################

version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: gunicorn backend.config.wsgi:application --bind 0.0.0.0:8000
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config worker -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config beat -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  nginx:
    image: nginx:1.27-alpine
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge


# File 11/163: docker-compose.yml
################################################################################

version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    container_name: parkshare_db
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: parkshare
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    container_name: parkshare_redis
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_web
    restart: always
    env_file:
      - .env  # можно потом заменить на .env.prod
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_worker
    restart: always
    env_file:
      - .env
    command: celery -A backend.config worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_beat
    restart: always
    env_file:
      - .env
    command: celery -A backend.config beat -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  ai_pricing_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_ai_pricing
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.ai_pricing_service.main:app --host 0.0.0.0 --port 8100
    depends_on:
      - redis
    networks:
      - parkshare_net

  llm_service:
    build:
      context: .
      dockerfile: services/llm_service/Dockerfile
    container_name: parkshare_llm_service
    restart: always
    env_file:
      - .env
    ports:
      - "8002:8002"
    networks:
      - parkshare_net

  cv_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_cv_service
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.cv_service.main:app --host 0.0.0.0 --port 8200
    depends_on:
      - redis
    networks:
      - parkshare_net

  nginx:
    image: nginx:alpine
    container_name: parkshare_nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge


# File 12/163: dump_project.py
################################################################################

import os
import re
from datetime import datetime
# Какие папки игнорировать (расширенный список)
EXCLUDED_DIRS = {
".git", ".venv", "venv", "__pycache__", "node_modules",
"dist", "build", "staticfiles", "media", ".idea", ".vscode",
"ai_models",
"static/icons",
"logs", "cache", "temp",
}
# Какие расширения файлов пропускать (расширенный список)
IGNORED_EXTENSIONS = {
".pyc", ".pyo", ".pyd", ".sqlite3", ".sqlite", ".db",
".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp",
".pdf", ".zip", ".rar", ".7z", ".tar", ".gz",
".exe", ".dll", ".so", ".pkl", ".h5", ".model", ".pt",
".mp4", ".mp3", ".wav", ".avi", ".mov",
".log", ".tmp", ".cache",
}
# Файлы, которые нужно полностью игнорировать
EXCLUDED_FILES = {
"CODEX_LOG1.txt", "CODEX__LOGS.txt",
"package-lock.json", "yarn.lock",
}
# Максимальный размер файла для включения в дамп (в байтах)
MAX_FILE_SIZE = 500 * 1024
# Сжатие кода: удаление лишних пробелов и комментарий
COMPRESS_CODE = True
def is_binary_file(filename: str) -> bool:
_, ext = os.path.splitext(filename.lower())
return ext in IGNORED_EXTENSIONS
def should_exclude_file(filename: str) -> bool:
"""Проверяет, нужно ли исключить файл"""
return filename in EXCLUDED_FILES
def compress_content(content: str, filepath: str) -> str:
"""Сжимает содержимое файла (удаляет лишние пробелы и комментарии)"""
if not COMPRESS_CODE:
return content
_, ext = os.path.splitext(filepath.lower())
if ext in {'.py', '.js', '.css', '.html', '.ts'}:
# Удаляем комментарии и лишние пробелы
lines = []
in_multiline_comment = False
for line in content.split('\n'):
# Обработка многострочных комментариев
if in_multiline_comment:
if '*/' in line:
line = line.split('*/', 1)[1]
in_multiline_comment = False
else:
continue
# Удаляем однострочные комментарии
if '
line = line.split('
if '
line = line.split('
# Обработка многострочных комментариев для CSS/JS
if '
' in line:
line = line.split('')[1]
else:
line = line.split('

# File 13/163: entrypoint.sh
################################################################################

#!/bin/sh
set -e

# Если DJANGO_SETTINGS_MODULE не задан, по умолчанию считаем, что это прод.
: "${DJANGO_SETTINGS_MODULE:=backend.settings.production}"
export DJANGO_SETTINGS_MODULE

echo "Using DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE}"

# Миграции
python backend/manage.py migrate --noinput

# Сбор статики
python backend/manage.py collectstatic --noinput

# Запуск gunicorn
exec gunicorn backend.config.wsgi:application \
    --bind 0.0.0.0:8000 \
    --workers "${GUNICORN_WORKERS:-3}" \
    --timeout "${GUNICORN_TIMEOUT:-60}"


# File 14/163: index.html
################################################################################

<!-- index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>ParkShare AI Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!-- Leaflet -->
<link
rel="stylesheet"
href="https:
integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
crossorigin=""
/>
<link rel="stylesheet" href="./static/css/cinematic-ui.css" />
<style>
:root {
--primary:
--bg:
--bg-card:
--text:
--accent:
--danger:
--warning:
}
* {
box-sizing: border-box;
}
body {
margin: 0;
font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
sans-serif;
background: radial-gradient(circle at top,
color: var(--text);
height: 100vh;
display: flex;
flex-direction: column;
}
header {
padding: 0.75rem 1rem;
display: flex;
align-items: center;
justify-content: space-between;
background: rgba(15, 23, 42, 0.9);
backdrop-filter: blur(12px);
border-bottom: 1px solid rgba(148, 163, 184, 0.2);
z-index: 1000;
position: sticky;
top: 0;
}
header h1 {
font-size: 1.1rem;
margin: 0;
display: flex;
align-items: center;
gap: 0.4rem;
}
.badge {
font-size: 0.7rem;
padding: 0.1rem 0.4rem;
border-radius: 999px;
border: 1px solid rgba(148, 163, 184, 0.5);
text-transform: uppercase;
letter-spacing: 0.08em;
}
.header-meta {
display: flex;
align-items: center;
gap: 0.75rem;
}
main {
flex: 1;
display: grid;
grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.3fr);
min-height: 0;
}
#map {
width: 100%;
height: 100%;
}
.sidebar {
border-left: 1px solid rgba(148, 163, 184, 0.2);
background: radial-gradient(circle at top,
padding: 0.75rem;
display: flex;
flex-direction: column;
gap: 0.75rem;
min-width: 280px;
max-width: 480px;
}
.card {
background: rgba(15, 23, 42, 0.98);
border-radius: 0.9rem;
border: 1px solid rgba(148, 163, 184, 0.25);
padding: 0.75rem 0.8rem;
box-shadow: 0 18px 45px rgba(15, 23, 42, 0.6);
}
.card-title {
font-size: 0.9rem;
font-weight: 600;
margin-bottom: 0.4rem;
display: flex;
align-items: center;
justify-content: space-between;
}
.input-row {
display: flex;
gap: 0.4rem;
margin-top: 0.3rem;
}
input[type="text"],
select {
flex: 1;
padding: 0.4rem 0.5rem;
border-radius: 999px;
border: 1px solid rgba(148, 163, 184, 0.5);
background: rgba(15, 23, 42, 0.9);
color: var(--text);
font-size: 0.85rem;
outline: none;
}
input::placeholder {
color: rgba(148, 163, 184, 0.9);
}
button {
border-radius: 999px;
border: none;
padding: 0.45rem 0.9rem;
font-size: 0.8rem;
font-weight: 500;
cursor: pointer;
background: linear-gradient(135deg,
color:
display: inline-flex;
align-items: center;
gap: 0.35rem;
white-space: nowrap;
}
button.secondary {
background: rgba(15, 23, 42, 0.9);
border: 1px solid rgba(148, 163, 184, 0.6);
color: rgba(209, 213, 219, 0.95);
}
.pill {
font-size: 0.72rem;
border-radius: 999px;
padding: 0.16rem 0.5rem;
border: 1px solid rgba(148, 163, 184, 0.4);
display: inline-flex;
align-items: center;
gap: 0.3rem;
color: rgba(209, 213, 219, 0.95);
}
.pill-dot {
width: 0.55rem;
height: 0.55rem;
border-radius: 999px;
}
.pill-dot.green {
background: var(--accent);
}
.pill-dot.yellow {
background: var(--warning);
}
.pill-dot.red {
background: var(--danger);
}
.lots-list {
max-height: 220px;
overflow-y: auto;
margin-top: 0.4rem;
padding-right: 0.2rem;
}
.lot-item {
display: flex;
justify-content: space-between;
align-items: center;
padding: 0.4rem 0.2rem;
border-bottom: 1px solid rgba(31, 41, 55, 0.9);
cursor: pointer;
}
.lot-item:last-child {
border-bottom: none;
}
.lot-main {
display: flex;
flex-direction: column;
gap: 0.1rem;
font-size: 0.75rem;
}
.lot-name {
font-weight: 500;
font-size: 0.8rem;
}
.lot-meta {
display: flex;
flex-wrap: wrap;
gap: 0.3rem;
font-size: 0.7rem;
color: rgba(156, 163, 175, 0.95);
}
.lot-occ {
font-size: 0.8rem;
font-weight: 500;
min-width: 80px;
text-align: right;
}
.status {
font-size: 0.7rem;
color: rgba(148, 163, 184, 0.9);
margin-top: 0.3rem;
}
.ai-oracle-chip {
display: inline-flex;
align-items: center;
gap: 0.4rem;
padding: 0.18rem 0.65rem;
border-radius: 999px;
border: 1px solid rgba(59, 130, 246, 0.45);
background: linear-gradient(120deg, rgba(37, 99, 235, 0.35), rgba(14, 165, 233, 0.15));
color:
font-size: 0.75rem;
letter-spacing: 0.02em;
box-shadow: 0 12px 30px rgba(37, 99, 235, 0.25);
}
.ai-orchestrator-card {
position: relative;
overflow: hidden;
background: linear-gradient(135deg, rgba(30, 41, 59, 0.92), rgba(17, 24, 39, 0.94));
}
.ai-orchestrator-card .card-title {
align-items: center;
}
.ai-orchestrator-card .card-title span {
display: inline-flex;
align-items: center;
gap: 0.4rem;
}
.quantum-toggle {
border: 1px solid rgba(255, 255, 255, 0.12);
color:
font-weight: 600;
letter-spacing: 0.01em;
min-width: 150px;
justify-content: space-between;
}
.quantum-toggle__dot {
width: 18px;
height: 18px;
border-radius: 50%;
border: 2px solid rgba(255, 255, 255, 0.7);
background: radial-gradient(circle at 35% 35%,
box-shadow: 0 0 20px rgba(56, 189, 248, 0.45);
}
.quantum-toggle__label {
flex: 1;
text-align: right;
font-size: 0.8rem;
}
@media (max-width: 900px) {
main {
grid-template-columns: 1fr;
}
.sidebar {
max-width: 100%;
border-left: none;
border-top: 1px solid rgba(148, 163, 184, 0.2);
}
}
</style>
</head>
<body>
<header class="cinematic-surface">
<h1>
<span>ParkShare AI Map</span>
<span class="badge">local ML</span>
</h1>
<div class="header-meta">
<div class="ai-crest">
<span>🧠</span>
<span class="quantum-toggle__label">AI Orchestrator</span>
</div>
<button id="themeToggle" class="quantum-toggle cinematic-button" data-theme="dark">
<span class="quantum-toggle__dot"></span>
<span class="quantum-toggle__label">Dark Matter</span>
</button>
<div class="pill">
<span class="pill-dot green"></span>
<span id="statusText">Подключение к AI-серверу…</span>
</div>
</div>
</header>
<main>
<div id="map"></div>
<aside class="sidebar">
<section class="card cinematic-surface ai-orchestrator-card">
<div class="card-title">
<span>AI-Оркестратор</span>
<span class="ai-oracle-chip">Quantum boost</span>
</div>
<div class="ai-forecast">
<div class="ai-forecast-metric">
<span class="ai-forecast-label">Лучшая ставка</span>
<span class="ai-forecast-value" id="aiOracleName">—</span>
</div>
<div class="ai-forecast-metric">
<span class="ai-forecast-label">Освободится через</span>
<span class="ai-forecast-value" id="aiOracleETA">—</span>
</div>
<div class="ai-forecast-metric">
<span class="ai-forecast-label">Уверенность AI</span>
<span class="ai-forecast-value" id="aiOracleConfidence">—</span>
</div>
<div class="ai-forecast-metric">
<span class="ai-forecast-label">EV/крытая</span>
<span class="ai-forecast-value" id="aiOracleMeta">—</span>
</div>
</div>
<div class="ai-reasoning" id="aiOracleReason">AI готовит инсайт…</div>
</section>
<section class="card">
<div class="card-title">
<span>Поиск парковок (NLP)</span>
</div>
<div class="input-row">
<input
type="text"
id="searchInput"
placeholder='Например: "рядом с метро", "дешевые утром"'
/>
<button id="searchBtn">Искать</button>
</div>
<div class="status" id="searchStatus">Запрос еще не выполнен.</div>
</section>
<section class="card">
<div class="card-title">
<span>Рекомендации (коллаб. фильтрация)</span>
<select id="userSelect"></select>
</div>
<div class="input-row">
<button id="recBtn">Получить рекомендации</button>
<button id="recContentBtn" class="secondary">Вариант B (content)</button>
</div>
<div class="status" id="recStatus">Нет рекомендаций.</div>
<div class="lots-list" id="recList"></div>
</section>
<section class="card">
<div class="card-title">
<span>Все парковки</span>
</div>
<div class="lots-list" id="lotsList"></div>
</section>
</aside>
</main>
<script
src="https:
integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
crossorigin=""
></script>
<script src="./static/js/quantum-theme-manager.js"></script>
<script src="app.js"></script>
<script>
window.psThemeManager = window.initQuantumThemeManager();
</script>
</body>
</html>

# File 15/163: model_training.py
################################################################################

# model_training.py
from __future__ import annotations
import joblib
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Dict, Any
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.svm import LinearSVC
from database import DB_PATH, get_connection, init_db, generate_synthetic_data
BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"
# Создаём папку для моделей заранее, чтобы не упасть на сохранении
MODELS_DIR.mkdir(parents=True, exist_ok=True)
# ---------- 1. Модель предсказания загруженности парковок ----------
def load_occupancy_dataframe() -> pd.DataFrame:
conn = get_connection()
try:
query = """
SELECT
oh.lot_id,
oh.ts,
oh.occupancy,
oh.temperature,
oh.is_rain,
oh.is_event,
pl.near_metro,
pl.price_level,
pl.has_covered,
pl.has_ev_charging
FROM occupancy_history oh
JOIN parking_lot pl ON pl.id = oh.lot_id
"""
df = pd.read_sql_query(query, conn)
finally:
conn.close()
if df.empty:
return df
df["ts"] = pd.to_datetime(df["ts"], errors="coerce")
df = df.dropna(subset=["ts"])
df["hour"] = df["ts"].dt.hour
df["dow"] = df["ts"].dt.weekday
df["lot_id_str"] = df["lot_id"].astype(str)
return df
def train_occupancy_model() -> None:
df = load_occupancy_dataframe()
if df.empty:
raise RuntimeError("Нет данных для обучения occupancy-модели")
feature_cols = [
"hour",
"dow",
"temperature",
"is_rain",
"is_event",
"near_metro",
"price_level",
"has_covered",
"has_ev_charging",
"lot_id_str",
]
X = df[feature_cols].copy()
y = df["occupancy"].astype(float)
numeric_features = [
"hour",
"dow",
"temperature",
"is_rain",
"is_event",
"near_metro",
"price_level",
"has_covered",
"has_ev_charging",
]
categorical_features = ["lot_id_str"]
preprocessor = ColumnTransformer(
transformers=[
("num", StandardScaler(), numeric_features),
("cat", OneHotEncoder(handle_unknown="ignore"), categorical_features),
]
)
model = RandomForestRegressor(
n_estimators=80,
random_state=42,
n_jobs=-1,
)
pipe = Pipeline(
steps=[
("preprocess", preprocessor),
("model", model),
]
)
pipe.fit(X, y)
model_path = MODELS_DIR / "occupancy_model.pkl"
joblib.dump(
{
"pipeline": pipe,
"feature_cols": feature_cols,
},
model_path,
)
print("occupancy_model.pkl сохранён в", model_path)
# ---------- 2. NLP: интенты и парсинг пользовательских запросов ----------
def build_nlp_training_data() -> pd.DataFrame:
data = [
("рядом с метро", "near_metro"),
("парковка около метро", "near_metro"),
("парковка возле метро", "near_metro"),
("где припарковаться у метро курская", "near_metro"),
("найди парковку у метро", "near_metro"),
("самая дешевая парковка", "cheap"),
("дешевые парковки утром", "cheap"),
("недорогая парковка рядом", "cheap"),
("дешево припарковаться", "cheap"),
("недорогие места для машины", "cheap"),
("парковка с зарядкой для электромобиля", "ev"),
("нужна зарядка для электрокара", "ev"),
("парковка с ev charging", "ev"),
("крытая парковка", "covered"),
("подземная парковка", "covered"),
("парковка в паркинге", "covered"),
("парковка ночью", "time_night"),
("парковка утром", "time_morning"),
("парковка вечером", "time_evening"),
("парковка днем", "time_day"),
("найди парковку", "general"),
("показать все парковки", "general"),
("где можно припарковаться", "general"),
("парковка в центре", "general"),
("парковка возле офиса", "general"),
]
return pd.DataFrame(data, columns=["text", "intent"])
def train_nlp_model() -> None:
df = build_nlp_training_data()
X = df["text"].values
y = df["intent"].values
pipe = Pipeline(
steps=[
(
"vec",
CountVectorizer(
ngram_range=(1, 2),
analyzer="word",
),
),
("clf", LinearSVC()),
]
)
pipe.fit(X, y)
model_path = MODELS_DIR / "nlp_intent.pkl"
joblib.dump(pipe, model_path)
print("nlp_intent.pkl сохранён в", model_path)
# ---------- 3. Рекомендательная система (collab + content) ----------
def train_recommender() -> None:
"""
Простейшая item-based collaborative filtering + content-based фолбэк.
"""
conn = get_connection()
ratings = pd.read_sql_query("SELECT * FROM user_rating;", conn)
lots = pd.read_sql_query("SELECT * FROM parking_lot;", conn)
if ratings.empty or lots.empty:
raise RuntimeError("Нет данных для обучения рекомендера")
# user-item матрица
user_item = (
ratings.pivot(index="user_id", columns="lot_id", values="rating")
.fillna(0.0)
.astype(float)
)
# Нормируем по пользователям
user_norms = np.linalg.norm(user_item.values, axis=1, keepdims=True)
user_norms[user_norms == 0] = 1.0
user_item_norm = user_item.values / user_norms
# item-item similarity (cosine)
sim_matrix = cosine_similarity(user_item_norm.T)
item_ids = user_item.columns.tolist()
item_sim = pd.DataFrame(sim_matrix, index=item_ids, columns=item_ids)
# Content-features
lot_features = lots.set_index("id")[
["near_metro", "price_level", "has_covered", "has_ev_charging", "latitude", "longitude"]
].copy()
model_path = MODELS_DIR / "recommender.pkl"
joblib.dump(
{
"user_item": user_item,
"item_sim": item_sim,
"lot_features": lot_features,
},
model_path,
)
print("recommender.pkl сохранён в", model_path)
conn.close()
def _dataset_is_empty() -> bool:
conn = get_connection()
try:
cur = conn.cursor()
counts = {}
for table in ["parking_lot", "occupancy_history", "user_rating"]:
try:
cur.execute(f"SELECT COUNT(*) FROM {table};")
counts[table] = cur.fetchone()[0]
except Exception:
counts[table] = 0
return any(value == 0 for value in counts.values())
finally:
conn.close()
def _safe_call(name: str, fn) -> None:
try:
fn()
except Exception as exc:
# Логируем и выбрасываем дальше, чтобы CI увидел сбой
print(f"[!] Ошибка во время '{name}': {exc}")
raise
def main() -> None:
# На случай чистой установки
init_db()
try:
if _dataset_is_empty():
print("База пуста — генерируем синтетические данные...")
generate_synthetic_data()
else:
print("Используем существующие данные в БД", DB_PATH)
except Exception as exc:
print(f"[!] Не удалось подготовить данные: {exc}")
raise
print("=== Обучение occupancy-модели ===")
_safe_call("occupancy", train_occupancy_model)
print("=== Обучение NLP-модели ===")
_safe_call("nlp", train_nlp_model)
print("=== Обучение рекомендательной системы ===")
_safe_call("recommender", train_recommender)
print("Готово: все модели обучены и сохранены в", MODELS_DIR)
if __name__ == "__main__":
main()

# File 16/163: project_dump.txt
################################################################################

################################################################################
# COMPRESSED PROJECT DUMP
# Root: C:\Users\Sultan\Downloads\parkshare_ru_part1
# Generated at: 2025-11-28 23:53:11
# Files: 163
# Max file size: 500KB
# Code compression: True
################################################################################
PROJECT TREE:
--------------------------------------------------------------------------------
parkshare_ru_part1/
    .env
    .env.example
    .env.prod
    .gitattributes
    Dockerfile
    README.md
    api_server.py
    app.js
    database.py
    docker-compose.prod.yml
    docker-compose.yml
    dump_project.py
    entrypoint.sh
    index.html
    model_training.py
    project_dump.txt
    requirements.txt
    run_dev.bat
    run_dev.py
    run_dev.sh
    accounts/
        __init__.py
        admin.py
        apps.py
        auth.py
        forms.py
        models.py
        serializers.py
        urls.py
        utils.py
        views.py
        migrations/
            0001_initial.py
            0002_user_email_hash_user_phone_hash_logincode.py
            0003_userlevel_userbadge_promoreward.py
            __init__.py
    ai/
        __init__.py
        admin.py
        apps.py
        features.py
        models.py
        orchestrator.py
        pricing.py
        serializers.py
        tasks.py
        views.py
        chat/
            __init__.py
            parking_assistant.py
        management/
            __init__.py
            commands/
                __init__.py
                train_chat_intents_from_logs.py
        migrations/
            0001_initial.py
            __init__.py
    ai_services/
        __init__.py
        ai_pricing_service/
            __init__.py
            main.py
        cv_service/
            __init__.py
            main.py
    backend/
        manage.py
        backend/
            __init__.py
            config/
                __init__.py
                asgi.py
                celery.py
                urls.py
                wsgi.py
            settings/
                __init__.py
                base.py
                local.py
                production.py
                regions.py
        rest_framework_simplejwt/
            __init__.py
            authentication.py
            tokens.py
            views.py
        tests/
            __init__.py
            test_auth_api.py
            test_booking_model.py
    core/
        __init__.py
        admin.py
        apps.py
        context_processors.py
        integrations.py
        middleware.py
        models.py
        pagination.py
        permissions.py
        utils.py
    drf_spectacular/
        __init__.py
        openapi.py
        views.py
    frontend/
        parkmate/
            parkmate.types.ts
    nginx/
        nginx.conf
    parking/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        tasks.py
        urls.py
        views.py
        management/
            commands/
                seed_demo_parking.py
        migrations/
            0001_initial.py
            0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
            0003_booking_ai_fields.py
            0004_favoriteparkingspot_savedplace.py
            __init__.py
    payments/
        __init__.py
        admin.py
        apps.py
        models.py
        providers.py
        serializers.py
        tasks.py
        views.py
        migrations/
            0001_initial.py
            0002_alter_payment_provider.py
            0003_paymentmethod.py
            __init__.py
        providers/
            __init__.py
            base.py
            registry.py
            stripe.py
            yookassa.py
    regions/
        global.yml
        ru.yml
    services/
        __init__.py
        llm.py
        llm_service/
            Dockerfile
            main.py
            requirements.txt
    static/
        manifest.webmanifest
        service-worker.js
        css/
            app.css
            cinematic-ui.css
        icons/
        js/
            app.js
            map.js
            parkmate-ai.ts
            quantum-theme-manager.js
    templates/
        base.html
        offline.html
        accounts/
            login.html
            password_change.html
            password_change_done.html
            password_reset.html
            password_reset_complete.html
            password_reset_confirm.html
            password_reset_done.html
            password_reset_email.txt
            password_reset_subject.txt
            profile.html
            register.html
        parking/
            landing.html
            map_fullscreen.html
            owner_dashboard.html
            pwa_install.html
            user_dashboard.html
    vehicles/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py


================================================================================
FILES CONTENT:
================================================================================

# File 1/163: .env
################################################################################

DEBUG=1
SECRET_KEY=django-insecure-test-secret-key-for-dev-only
ALLOWED_HOSTS=127.0.0.1,localhost
DATABASE_NAME=db.sqlite3

YOOKASSA_SHOP_ID=
YOOKASSA_SECRET_KEY=

EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend

# Карты / регион
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=

# Старый токен Mapbox (если будешь использовать где-то ещё)
MAPBOX_TOKEN=your_actual_token_here

# OpenAI
OPENAI_API_KEY=sk...
OPENAI_MODEL=gpt-4o-mini
OPENAI_BASE_URL=https://api.openai.com/v1

LLM_CLIENT_TIMEOUT=8
LLM_CLIENT_RETRIES=2

# (опционально) Явный URL сервиса, если хочешь переопределить:
# LLM_SERVICE_URL=http://llm_service:8002


# File 2/163: .env.example
################################################################################

# Базовые настройки Django
DEBUG=False
SECRET_KEY=change_me_to_random_long_secret_key
ALLOWED_HOSTS=localhost,127.0.0.1,0.0.0.0
PLATFORM_MODE=RU

# База данных
# Для продакшена: postgres://user:password@db:5432/parkshare
# Django-environ автоматически распарсит URL.
DATABASE_URL=postgres://parkshare:parkshare@db:5432/parkshare

# Payments
PAYMENT_PROVIDER=yookassa
YOOKASSA_SHOP_ID=YOUR_SHOP_ID
YOOKASSA_SECRET_KEY=YOUR_SECRET
YOOKASSA_RETURN_URL=https://SERVER_HOST/payments/return/
YOOKASSA_WEBHOOK_SECRET=YOUR_WEBHOOK_SECRET
STRIPE_SECRET_KEY=YOUR_STRIPE_KEY
STRIPE_WEBHOOK_SECRET=YOUR_STRIPE_WEBHOOK_SECRET

# Redis (брокер/кэш)
REDIS_URL=redis://redis:6379/0

# Таймзона и язык
TIME_ZONE=Europe/Moscow
LANGUAGE_CODE=ru-ru

# Соль для хэширования цифр номеров
VEHICLE_PLATE_SALT=change_me_vehicle_plate_salt

# Настройки CORS (если нужен доступ с другого домена, например, моб. WebView)
CORS_ALLOWED_ORIGINS=http://localhost:8000

# Настройки Celery
CELERY_BROKER_URL=${REDIS_URL}
CELERY_RESULT_BACKEND=${REDIS_URL}

# Настройки YooKassa (пример)
YOOKASSA_SHOP_ID=your_shop_id_here
YOOKASSA_SECRET_KEY=your_secret_key_here
YOOKASSA_RETURN_URL=https://example.com/payments/return/
YOOKASSA_WEBHOOK_SECRET=change_me_webhook_secret

# Комиссия сервиса (процент, будет использована в бизнес-логике)
SERVICE_COMMISSION_PERCENT=10

# Безопасность для продакшена
SECURE_SSL_REDIRECT=False
SESSION_COOKIE_SECURE=False
CSRF_COOKIE_SECURE=False

# Регион / карты
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=your_yandex_maps_api_key


# File 3/163: .env.prod
################################################################################

# -----------------------------
# DJANGO SETTINGS (PROD)
# -----------------------------
DEBUG=0
SECRET_KEY=django-insecure-поставь_сюда_очень_длинную_строку_символов
ALLOWED_HOSTS=your-domain.ru,your-domain.com,127.0.0.1

DJANGO_SETTINGS_MODULE=backend.settings.production

# -----------------------------
# DATABASE (PostgreSQL / PostGIS)
# -----------------------------
DATABASE_NAME=parkshare
DATABASE_USER=parkshare
DATABASE_PASSWORD=сильный_пароль_к_бд
DATABASE_HOST=db
DATABASE_PORT=5432

# -----------------------------
# YOOKASSA PAYMENTS (боевые реквизиты)
# -----------------------------
YOOKASSA_SHOP_ID=твой_shop_id
YOOKASSA_SECRET_KEY=твой_secret_key

# -----------------------------
# EMAIL SETTINGS
# -----------------------------
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.yandex.ru
EMAIL_PORT=465
EMAIL_USE_SSL=1
EMAIL_HOST_USER=no-reply@your-domain.ru
EMAIL_HOST_PASSWORD=пароль_от_почты

# -----------------------------
# MAP / REGION
# -----------------------------
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=your_yandex_maps_api_key
MAPBOX_TOKEN=your_actual_token_here


# File 4/163: .gitattributes
################################################################################

# Auto detect text files and perform LF normalization
* text=auto


# File 5/163: Dockerfile
################################################################################

# Production-ready Dockerfile
FROM python:3.12-slim AS builder
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    gdal-bin \
    libgdal-dev \
    binutils \
    libproj-dev \
    libgeos-dev \
    libspatialindex-dev \
    gettext \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt
COPY . /app/

RUN python backend/manage.py collectstatic --noinput --settings=backend.settings.production || true

FROM python:3.12-slim AS runtime
ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1
WORKDIR /app

COPY --from=builder /usr/local/lib/python3.12 /usr/local/lib/python3.12
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app /app

EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD curl -f http://localhost:8000/health/ || exit 1
CMD ["gunicorn", "backend.config.wsgi:application", "--bind", "0.0.0.0:8000"]


# File 6/163: README.md
################################################################################

# ParkShare Global Platform

Унифицированная архитектура для ParkShare с профилями RU/GLOBAL, защищёнными настройками и PWA фронтендом.

## Запуск
```bash
docker-compose up --build
```
ENVIRONMENT выбирается через переменные окружения и файлы `.env.<profile>`.

Для локальной разработки без зависимостей PostGIS/GDAL установите `USE_GIS=False` и задайте
`DATABASE_URL=sqlite:///db.sqlite3`, чтобы Django использовал SQLite и не требовал GDAL.

## Контейнеры
- PostGIS (db)
- Redis (cache/rate limit/Celery)
- Gunicorn web (Django)
- Celery worker/beat
- Nginx как TLS-терминатор

## Безопасность
- JWT + refresh токены (`/api/auth/token`, `/api/auth/token/refresh`)
- Rate limiting, CSP, HSTS, Referrer/Permissions Policy (`core/middleware.py`, `backend/settings`)
- Provider registry (`providers/`)
- Транзакционные блокировки бронирований (`parking/views.py`)

## PWA
- Сервис-воркер с разными стратегиями кэширования (`static/service-worker.js`)
- Offline fallback (`templates/offline.html`)

## AI
- Динамическое ценообразование, рекомендации, CV и антифрод (`ai/engines.py`, `services/ai.py`)

## Продакшен-старт (Ubuntu/Debian)
```bash
cp .env.example .env.prod  # заполнить секреты/хосты
docker-compose -f docker-compose.prod.yml up -d --build
```

Домен и TLS настраиваются через `nginx/nginx.conf` (добавьте сертификаты Let's Encrypt). ALLOWED_HOSTS и переменные карты/платежей берутся из `.env.prod`.
#   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 #   P a r k S h a r e _ R U 
 
 

# File 7/163: api_server.py
################################################################################

# api_server.py
from __future__ import annotations
import datetime as dt
import re
from pathlib import Path
from typing import Any, Dict, List, Optional
import joblib
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from database import get_connection
BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"
# --- Загрузка моделей ---
occ_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "occupancy_model.pkl")
OCC_PIPE = occ_bundle["pipeline"]
OCC_FEATURE_COLS = occ_bundle["feature_cols"]
NLP_PIPE = joblib.load(MODELS_DIR / "nlp_intent.pkl")
rec_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "recommender.pkl")
USER_ITEM: pd.DataFrame = rec_bundle["user_item"]
ITEM_SIM: pd.DataFrame = rec_bundle["item_sim"]
LOT_FEATURES: pd.DataFrame = rec_bundle["lot_features"]
# --- FastAPI ---
app = FastAPI(title="ParkShare Local AI", version="1.0.0")
app.add_middleware(
CORSMiddleware,
allow_origins=["*"],
allow_credentials=True,
allow_methods=["*"],
allow_headers=["*"],
)
# ---------- Схемы ----------
class Lot(BaseModel):
id: int
name: str
latitude: float
longitude: float
near_metro: bool
price_level: int
has_covered: bool
has_ev_charging: bool
predicted_occupancy: float
class SearchResult(BaseModel):
query: str
intent: str
time_of_day: Optional[str]
near_metro: Optional[bool]
max_price_level: Optional[int]
has_ev_charging: Optional[bool]
has_covered: Optional[bool]
lots: List[Lot]
class OccupancyPredictionResponse(BaseModel):
lot_id: int
ts: dt.datetime
predicted_occupancy: float
class Recommendation(BaseModel):
lot: Lot
score: float
class RecommendationsResponse(BaseModel):
user_id: Optional[int]
variant: str
recommendations: List[Recommendation]
# ---------- Утилиты ----------
def parse_dt_iso(value: Optional[str]) -> dt.datetime:
if not value:
return dt.datetime.now()
try:
return dt.datetime.fromisoformat(value)
except Exception as exc:
raise HTTPException(status_code=400, detail=f"Неверный формат datetime: {value}") from exc
def nlp_extract_entities(text: str) -> Dict[str, Any]:
s = text.lower()
time_of_day = None
if "утр" in s:
time_of_day = "morning"
elif "днем" in s or "днём" in s:
time_of_day = "day"
elif "вечер" in s:
time_of_day = "evening"
elif "ноч" in s:
time_of_day = "night"
near_metro = "метро" in s
max_price_level: Optional[int] = None
if "дешев" in s or "недорог" in s:
max_price_level = 1
elif "средн" in s:
max_price_level = 2
elif "дорог" in s:
max_price_level = 3
has_ev = "электро" in s or "зарядк" in s or "ev" in s
has_covered = "крыт" in s or "подзем" in s or "паркинг" in s
return {
"time_of_day": time_of_day,
"near_metro": near_metro if near_metro else None,
"max_price_level": max_price_level,
"has_ev_charging": has_ev if has_ev else None,
"has_covered": has_covered if has_covered else None,
}
def build_occ_feature_df(lot_row: Dict[str, Any], ts: dt.datetime) -> pd.DataFrame:
return pd.DataFrame(
[
{
"hour": ts.hour,
"dow": ts.weekday(),
"temperature": 15.0,
"is_rain": 0,
"is_event": 0,
"near_metro": lot_row["near_metro"],
"price_level": lot_row["price_level"],
"has_covered": lot_row["has_covered"],
"has_ev_charging": lot_row["has_ev_charging"],
"lot_id_str": str(lot_row["id"]),
}
]
)[OCC_FEATURE_COLS]
def predict_occupancy_for_lot(lot_row: Dict[str, Any], ts: dt.datetime) -> float:
df = build_occ_feature_df(lot_row, ts)
pred = float(OCC_PIPE.predict(df)[0])
return max(0.0, min(pred, 1.0))
def fetch_lots(filters: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
conn = get_connection()
cur = conn.cursor()
base_query = """
SELECT
id, name, latitude, longitude,
near_metro, price_level, has_covered, has_ev_charging
FROM parking_lot
WHERE 1=1
"""
params: List[Any] = []
if filters:
if filters.get("near_metro") is not None:
base_query += " AND near_metro = ?"
params.append(1 if filters["near_metro"] else 0)
if filters.get("max_price_level") is not None:
base_query += " AND price_level <= ?"
params.append(int(filters["max_price_level"]))
if filters.get("has_ev_charging") is not None:
base_query += " AND has_ev_charging = ?"
params.append(1 if filters["has_ev_charging"] else 0)
if filters.get("has_covered") is not None:
base_query += " AND has_covered = ?"
params.append(1 if filters["has_covered"] else 0)
base_query += " ORDER BY price_level ASC, near_metro DESC"
cur.execute(base_query, params)
rows = [dict(r) for r in cur.fetchall()]
conn.close()
return rows
# ---------- Эндпоинты ----------
@app.get("/health")
def health() -> Dict[str, Any]:
return {"status": "ok"}
@app.get("/api/lots", response_model=List[Lot])
def api_list_lots(
ts: Optional[str] = Query(default=None, description="ISO datetime, по умолчанию — сейчас"),
) -> List[Lot]:
dt_value = parse_dt_iso(ts)
lots = fetch_lots()
result: List[Lot] = []
for row in lots:
occ = predict_occupancy_for_lot(row, dt_value)
result.append(
Lot(
id=row["id"],
name=row["name"],
latitude=row["latitude"],
longitude=row["longitude"],
near_metro=bool(row["near_metro"]),
price_level=row["price_level"],
has_covered=bool(row["has_covered"]),
has_ev_charging=bool(row["has_ev_charging"]),
predicted_occupancy=occ,
)
)
return result
@app.get("/api/occupancy/predict", response_model=OccupancyPredictionResponse)
def api_predict_occupancy(
lot_id: int = Query(...),
ts: Optional[str] = Query(default=None),
) -> OccupancyPredictionResponse:
dt_value = parse_dt_iso(ts)
conn = get_connection()
cur = conn.cursor()
cur.execute(
"""
SELECT id, name, latitude, longitude,
near_metro, price_level, has_covered, has_ev_charging
FROM parking_lot
WHERE id = ?
""",
(lot_id,),
)
row = cur.fetchone()
conn.close()
if row is None:
raise HTTPException(status_code=404, detail="Парковка не найдена")
d = dict(row)
occ = predict_occupancy_for_lot(d, dt_value)
return OccupancyPredictionResponse(
lot_id=lot_id,
ts=dt_value,
predicted_occupancy=occ,
)
@app.get("/api/search", response_model=SearchResult)
def api_search(
query: str = Query(..., min_length=1),
ts: Optional[str] = Query(default=None),
limit: int = Query(default=15, ge=1, le=100),
) -> SearchResult:
dt_value = parse_dt_iso(ts)
intent = NLP_PIPE.predict([query])[0]
entities = nlp_extract_entities(query)
filters: Dict[str, Any] = {}
if entities["near_metro"]:
filters["near_metro"] = True
if entities["max_price_level"] is not None:
filters["max_price_level"] = entities["max_price_level"]
if entities["has_ev_charging"] is not None:
filters["has_ev_charging"] = entities["has_ev_charging"]
if entities["has_covered"] is not None:
filters["has_covered"] = entities["has_covered"]
if intent == "near_metro":
filters["near_metro"] = True
if intent == "cheap" and "max_price_level" not in filters:
filters["max_price_level"] = 1
lots = fetch_lots(filters)
lots = lots[:limit]
lot_models: List[Lot] = []
for row in lots:
occ = predict_occupancy_for_lot(row, dt_value)
lot_models.append(
Lot(
id=row["id"],
name=row["name"],
latitude=row["latitude"],
longitude=row["longitude"],
near_metro=bool(row["near_metro"]),
price_level=row["price_level"],
has_covered=bool(row["has_covered"]),
has_ev_charging=bool(row["has_ev_charging"]),
predicted_occupancy=occ,
)
)
return SearchResult(
query=query,
intent=intent,
time_of_day=entities["time_of_day"],
near_metro=filters.get("near_metro"),
max_price_level=filters.get("max_price_level"),
has_ev_charging=filters.get("has_ev_charging"),
has_covered=filters.get("has_covered"),
lots=lot_models,
)
def _recommend_item_based(user_id: int, top_n: int = 10) -> List[int]:
if user_id not in USER_ITEM.index:
return []
user_ratings = USER_ITEM.loc[user_id]
rated_items = user_ratings[user_ratings > 0].index.tolist()
if not rated_items:
return []
scores = pd.Series(0.0, index=USER_ITEM.columns)
for item_id in rated_items:
sim_vec = ITEM_SIM.loc[item_id]
scores += sim_vec * float(user_ratings[item_id])
scores = scores.drop(rated_items)
scores = scores.sort_values(ascending=False)
return scores.head(top_n).index.tolist()
def _recommend_content_based(top_n: int = 10) -> List[int]:
df = LOT_FEATURES.copy()
df["score"] = 0.0
df["score"] += (1 - (df["price_level"] - 1) / 2)
df["score"] += df["near_metro"] * 0.5
df["score"] += df["has_ev_charging"] * 0.3
df["score"] += df["has_covered"] * 0.2
df = df.sort_values("score", ascending=False)
return df.head(top_n).index.tolist()
@app.get("/api/recommendations", response_model=RecommendationsResponse)
def api_recommendations(
user_id: Optional[int] = Query(default=None),
variant: Optional[str] = Query(
default=None,
description="A или B — для A/B тестирования (A=collab, B=content)",
),
limit: int = Query(default=10, ge=1, le=50),
ts: Optional[str] = Query(default=None),
) -> RecommendationsResponse:
dt_value = parse_dt_iso(ts)
chosen_variant = variant or ("A" if user_id else "B")
if chosen_variant == "A" and user_id is not None:
item_ids = _recommend_item_based(user_id, top_n=limit)
if not item_ids:
chosen_variant = "B"
if chosen_variant == "B" or user_id is None:
item_ids = _recommend_content_based(top_n=limit)
conn = get_connection()
cur = conn.cursor()
cur.execute(
f"""
SELECT id, name, latitude, longitude,
near_metro, price_level, has_covered, has_ev_charging
FROM parking_lot
WHERE id IN ({",".join(["?"] * len(item_ids))})
""",
item_ids,
)
rows = {r["id"]: dict(r) for r in cur.fetchall()}
conn.close()
recs: List[Recommendation] = []
for lot_id in item_ids:
row = rows.get(lot_id)
if not row:
continue
occ = predict_occupancy_for_lot(row, dt_value)
lot = Lot(
id=row["id"],
name=row["name"],
latitude=row["latitude"],
longitude=row["longitude"],
near_metro=bool(row["near_metro"]),
price_level=row["price_level"],
has_covered=bool(row["has_covered"]),
has_ev_charging=bool(row["has_ev_charging"]),
predicted_occupancy=occ,
)
# простая метрика: обратная занятость + бонус за метро и цену
score = (1.0 - occ) + (1 - (row["price_level"] - 1) / 2) + (0.3 if row["near_metro"] else 0.0)
recs.append(Recommendation(lot=lot, score=float(score)))
return RecommendationsResponse(
user_id=user_id,
variant=chosen_variant,
recommendations=recs,
)

# File 8/163: app.js
################################################################################

const API_BASE = "http:
let map;
let markersLayer;
let lotsCache = [];
let lotsById = new Map();
function pickBestLot(lots) {
if (!lots || lots.length === 0) return null;
const ranked = [...lots].sort((a, b) => {
const occA = a.predicted_occupancy ?? 1;
const occB = b.predicted_occupancy ?? 1;
return occA - occB;
});
return ranked[0];
}
function updateAIOracleCard(lots) {
const nameEl = document.getElementById("aiOracleName");
const etaEl = document.getElementById("aiOracleETA");
const confEl = document.getElementById("aiOracleConfidence");
const metaEl = document.getElementById("aiOracleMeta");
const reasoningEl = document.getElementById("aiOracleReason");
if (!nameEl || !etaEl || !confEl || !metaEl || !reasoningEl) return;
if (!lots || lots.length === 0) {
nameEl.textContent = "—";
etaEl.textContent = "—";
confEl.textContent = "—";
metaEl.textContent = "—";
reasoningEl.textContent = "AI готовит инсайт…";
return;
}
const bestLot = pickBestLot(lots);
if (!bestLot) return;
const occ = bestLot.predicted_occupancy ?? 0;
const occPercent = Math.round(occ * 100);
const eta = Math.max(2, Math.min(15, Math.round((1 - occ) * 12)));
const confidence = Math.max(68, Math.min(99, 96 - Math.round(occPercent / 2)));
const ev = bestLot.has_ev_charging ? "EV" : "обычная";
const covered = bestLot.has_covered ? "крытая" : "открытая";
nameEl.textContent = bestLot.name;
etaEl.textContent = `${eta} мин`;
confEl.textContent = `${confidence}%`;
metaEl.textContent = `${ev} · ${covered}`;
reasoningEl.textContent =
"Учитывая вашу историю: быстрый выезд, EV и близость к метро — этот слот даст наивысший WOW-эффект.";
}
function occupancyColor(value) {
if (value <= 0.4) return "
if (value <= 0.7) return "
return "
}
function initMap() {
map = L.map("map", {
zoomControl: true,
attributionControl: false,
}).setView([55.7558, 37.6173], 12);
L.tileLayer("https:
maxZoom: 19,
}).addTo(map);
markersLayer = L.layerGroup().addTo(map);
}
async function apiGet(path, params = {}) {
const url = new URL(API_BASE + path);
Object.entries(params).forEach(([k, v]) => {
if (v !== undefined && v !== null) {
url.searchParams.set(k, v);
}
});
const res = await fetch(url.toString());
if (!res.ok) {
const text = await res.text();
throw new Error(`API error ${res.status}: ${text}`);
}
return res.json();
}
function renderLotsOnMap(lots) {
markersLayer.clearLayers();
lots.forEach((lot) => {
const occ = lot.predicted_occupancy ?? 0;
const color = occupancyColor(occ);
const marker = L.circleMarker([lot.latitude, lot.longitude], {
radius: 8,
fillColor: color,
fillOpacity: 0.9,
color: "
weight: 1,
});
const occPercent = Math.round(occ * 100);
const html = `
<div style="font-size: 12px;">
<strong>${lot.name}</strong><br />
Загрузка: <strong>${occPercent}%</strong><br />
Метро: ${lot.near_metro ? "рядом" : "нет"}<br />
Уровень цены: ${lot.price_level}<br />
Крытая: ${lot.has_covered ? "да" : "нет"}<br />
Зарядка EV: ${lot.has_ev_charging ? "есть" : "нет"}
</div>
`;
marker.bindPopup(html);
marker.addTo(markersLayer);
});
if (lots.length > 0) {
const bounds = L.latLngBounds(
lots.map((lot) => [lot.latitude, lot.longitude])
);
map.fitBounds(bounds.pad(0.2));
}
}
function renderLotsList(containerId, lots, clickHandler) {
const container = document.getElementById(containerId);
container.innerHTML = "";
if (!lots || lots.length === 0) {
container.innerHTML =
'<div style="font-size: 0.75rem; color:
return;
}
lots.forEach((lot) => {
const occ = lot.predicted_occupancy ?? 0;
const occPercent = Math.round(occ * 100);
const div = document.createElement("div");
div.className = "lot-item";
div.innerHTML = `
<div class="lot-main">
<div class="lot-name">${lot.name}</div>
<div class="lot-meta">
<span>Цена: L${lot.price_level}</span>
<span>Метро: ${lot.near_metro ? "рядом" : "нет"}</span>
<span>EV: ${lot.has_ev_charging ? "есть" : "нет"}</span>
<span>Крытая: ${lot.has_covered ? "да" : "нет"}</span>
</div>
</div>
<div class="lot-occ">${occPercent}%</div>
`;
div.addEventListener("click", () => clickHandler(lot));
container.appendChild(div);
});
}
async function loadAllLots() {
const status = document.getElementById("statusText");
try {
const lots = await apiGet("/api/lots");
lotsCache = lots;
lotsById.clear();
lots.forEach((lot) => lotsById.set(lot.id, lot));
renderLotsOnMap(lots);
renderLotsList("lotsList", lots, (lot) => {
map.setView([lot.latitude, lot.longitude], 16);
});
updateAIOracleCard(lots);
status.textContent = "AI-сервер подключён";
} catch (err) {
console.error(err);
status.textContent = "Ошибка подключения к AI-серверу";
}
}
async function handleSearch() {
const input = document.getElementById("searchInput");
const status = document.getElementById("searchStatus");
const text = input.value.trim();
if (!text) return;
status.textContent = "Обрабатываю запрос (локальный NLP)…";
try {
const data = await apiGet("/api/search", { query: text });
const lots = data.lots || [];
renderLotsOnMap(lots);
renderLotsList("lotsList", lots, (lot) => {
map.setView([lot.latitude, lot.longitude], 16);
});
updateAIOracleCard(lots);
const parts = [];
parts.push(`Интент: ${data.intent}`);
if (data.near_metro !== null) {
parts.push(`рядом с метро: ${data.near_metro ? "да" : "нет"}`);
}
if (data.max_price_level !== null) {
parts.push(`макс. уровень цены: L${data.max_price_level}`);
}
if (data.has_ev_charging !== null) {
parts.push(`EV: ${data.has_ev_charging ? "нужна" : "не нужна"}`);
}
if (data.has_covered !== null) {
parts.push(`крытая: ${data.has_covered ? "нужна" : "не нужна"}`);
}
if (data.time_of_day) {
parts.push(`время суток: ${data.time_of_day}`);
}
status.textContent = parts.join(" · ") || "Фильтры не распознаны.";
} catch (err) {
console.error(err);
status.textContent = "Ошибка обработки запроса";
}
}
async function initUsersSelect() {
const select = document.getElementById("userSelect");
for (let i = 1; i <= 20; i++) {
const opt = document.createElement("option");
opt.value = String(i);
opt.textContent = `Пользователь
select.appendChild(opt);
}
}
async function handleRecommendations(variant) {
const select = document.getElementById("userSelect");
const status = document.getElementById("recStatus");
const listContainerId = "recList";
const userId = parseInt(select.value, 10) || undefined;
status.textContent =
variant === "A"
? "Рассчитываю рекомендации (collaborative)…"
: "Рассчитываю рекомендации (content-based)…";
try {
const params = { limit: 10, variant };
if (variant === "A" && userId) {
params.user_id = userId;
}
const data = await apiGet("/api/recommendations", params);
const recs = data.recommendations || [];
const lots = recs.map((r) => r.lot);
renderLotsOnMap(lots);
renderLotsList(listContainerId, lots, (lot) => {
map.setView([lot.latitude, lot.longitude], 16);
});
updateAIOracleCard(lots);
status.textContent = `Вариант ${data.variant}, получено ${recs.length} рекомендаций.`;
} catch (err) {
console.error(err);
status.textContent = "Ошибка получения рекомендаций";
}
}
window.addEventListener("DOMContentLoaded", async () => {
initMap();
await initUsersSelect();
await loadAllLots();
document
.getElementById("searchBtn")
.addEventListener("click", () => handleSearch());
document
.getElementById("searchInput")
.addEventListener("keydown", (e) => {
if (e.key === "Enter") {
handleSearch();
}
});
document.getElementById("recBtn").addEventListener("click", () => {
handleRecommendations("A");
});
document
.getElementById("recContentBtn")
.addEventListener("click", () => {
handleRecommendations("B");
});
});

# File 9/163: database.py
################################################################################

# database.py
from __future__ import annotations
import random
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import List
DB_PATH = Path(__file__).parent / "ai_data.db"
def get_connection() -> sqlite3.Connection:
conn = sqlite3.connect(DB_PATH)
conn.row_factory = sqlite3.Row
return conn
def init_db() -> None:
conn = get_connection()
cur = conn.cursor()
cur.execute(
"""
CREATE TABLE IF NOT EXISTS parking_lot (
id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT NOT NULL,
latitude REAL NOT NULL,
longitude REAL NOT NULL,
near_metro INTEGER NOT NULL,
price_level INTEGER NOT NULL,
has_covered INTEGER NOT NULL,
has_ev_charging INTEGER NOT NULL
);
"""
)
cur.execute(
"""
CREATE TABLE IF NOT EXISTS occupancy_history (
id INTEGER PRIMARY KEY AUTOINCREMENT,
lot_id INTEGER NOT NULL,
ts TEXT NOT NULL,
occupancy REAL NOT NULL,
temperature REAL NOT NULL,
is_rain INTEGER NOT NULL,
is_event INTEGER NOT NULL,
FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
);
"""
)
cur.execute(
"""
CREATE TABLE IF NOT EXISTS app_user (
id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT NOT NULL
);
"""
)
cur.execute(
"""
CREATE TABLE IF NOT EXISTS user_rating (
id INTEGER PRIMARY KEY AUTOINCREMENT,
user_id INTEGER NOT NULL,
lot_id INTEGER NOT NULL,
rating REAL NOT NULL,
FOREIGN KEY (user_id) REFERENCES app_user(id),
FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
);
"""
)
conn.commit()
conn.close()
@dataclass
class LotSpec:
name: str
base_lat: float
base_lon: float
near_metro: int
price_level: int
has_covered: int
has_ev_charging: int
def generate_synthetic_data(
num_lots: int = 30,
num_users: int = 50,
days_back: int = 30,
) -> None:
"""
Генерация синтетических:
- парковок
- истории занятости
- пользователей
- оценок пользователей
"""
random.seed(42)
conn = get_connection()
cur = conn.cursor()
# Чистим старые данные
cur.execute("DELETE FROM user_rating;")
cur.execute("DELETE FROM app_user;")
cur.execute("DELETE FROM occupancy_history;")
cur.execute("DELETE FROM parking_lot;")
conn.commit()
# Базовые точки вокруг Москвы
center_lat, center_lon = 55.7558, 37.6173
lots: List[int] = []
for i in range(num_lots):
near_metro = 1 if random.random() < 0.5 else 0
price_level = random.choice([1, 2, 3])
has_covered = 1 if random.random() < 0.4 else 0
has_ev = 1 if random.random() < 0.3 else 0
# Немного раскидываем точки вокруг центра
lat = center_lat + random.uniform(-0.05, 0.05)
lon = center_lon + random.uniform(-0.1, 0.1)
cur.execute(
"""
INSERT INTO parking_lot (
name, latitude, longitude, near_metro,
price_level, has_covered, has_ev_charging
) VALUES (?, ?, ?, ?, ?, ?, ?)
""",
(
f"Лот
lat,
lon,
near_metro,
price_level,
has_covered,
has_ev,
),
)
lots.append(cur.lastrowid)
# История занятости — каждые 2 часа за days_back дней
now = datetime.now()
start_ts = now - timedelta(days=days_back)
weather_states = ["sunny", "cloudy", "rainy"]
for lot_id in lots:
ts = start_ts
while ts < now:
dow = ts.weekday()
hour = ts.hour
is_event = 1 if (dow in (4, 5) and hour >= 18 and random.random() < 0.3) else 0
weather = random.choice(weather_states)
is_rain = 1 if weather == "rainy" else 0
temperature = random.uniform(-10, 30)
# Базовая занятость зависит от часа и дня недели
base_occ = 0.2
if 8 <= hour <= 11:
base_occ = 0.6
elif 17 <= hour <= 20:
base_occ = 0.7
elif 0 <= hour <= 5:
base_occ = 0.1
if dow >= 5:
base_occ += 0.1
if is_event:
base_occ += 0.2
if is_rain:
base_occ += 0.1
base_occ = max(0.0, min(base_occ + random.uniform(-0.1, 0.1), 1.0))
cur.execute(
"""
INSERT INTO occupancy_history (
lot_id, ts, occupancy, temperature, is_rain, is_event
) VALUES (?, ?, ?, ?, ?, ?)
""",
(
lot_id,
ts.isoformat(),
base_occ,
temperature,
is_rain,
is_event,
),
)
ts += timedelta(hours=2)
# Пользователи
users = []
for i in range(num_users):
cur.execute(
"INSERT INTO app_user (name) VALUES (?);",
(f"user_{i+1}",),
)
users.append(cur.lastrowid)
# Оценки пользователей парковок
for user_id in users:
# Каждый пользователь оценит 5–15 парковок
k = random.randint(5, min(15, len(lots)))
rated_lots = random.sample(lots, k)
for lot_id in rated_lots:
# Рейтинг зависит от price_level и случайности
base_rating = 4.5 - 0.5 * (random.randint(1, 3) - 1)
rating = max(1.0, min(5.0, base_rating + random.uniform(-1.0, 1.0)))
cur.execute(
"""
INSERT INTO user_rating (user_id, lot_id, rating)
VALUES (?, ?, ?)
""",
(user_id, lot_id, rating),
)
conn.commit()
conn.close()
print("Синтетические данные сгенерированы в", DB_PATH)
if __name__ == "__main__":
init_db()
generate_synthetic_data()

# File 10/163: docker-compose.prod.yml
################################################################################

version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: gunicorn backend.config.wsgi:application --bind 0.0.0.0:8000
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config worker -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config beat -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  nginx:
    image: nginx:1.27-alpine
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge


# File 11/163: docker-compose.yml
################################################################################

version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    container_name: parkshare_db
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: parkshare
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    container_name: parkshare_redis
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_web
    restart: always
    env_file:
      - .env  # можно потом заменить на .env.prod
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_worker
    restart: always
    env_file:
      - .env
    command: celery -A backend.config worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_beat
    restart: always
    env_file:
      - .env
    command: celery -A backend.config beat -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  ai_pricing_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_ai_pricing
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.ai_pricing_service.main:app --host 0.0.0.0 --port 8100
    depends_on:
      - redis
    networks:
      - parkshare_net

  llm_service:
    build:
      context: .
      dockerfile: services/llm_service/Dockerfile
    container_name: parkshare_llm_service
    restart: always
    env_file:
      - .env
    ports:
      - "8002:8002"
    networks:
      - parkshare_net

  cv_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_cv_service
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.cv_service.main:app --host 0.0.0.0 --port 8200
    depends_on:
      - redis
    networks:
      - parkshare_net

  nginx:
    image: nginx:alpine
    container_name: parkshare_nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge


# File 12/163: dump_project.py
################################################################################

import os
import re
from datetime import datetime
# Какие папки игнорировать (расширенный список)
EXCLUDED_DIRS = {
".git", ".venv", "venv", "__pycache__", "node_modules",
"dist", "build", "staticfiles", "media", ".idea", ".vscode",
"ai_models",
"static/icons",
"logs", "cache", "temp",
}
# Какие расширения файлов пропускать (расширенный список)
IGNORED_EXTENSIONS = {
".pyc", ".pyo", ".pyd", ".sqlite3", ".sqlite", ".db",
".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp",
".pdf", ".zip", ".rar", ".7z", ".tar", ".gz",
".exe", ".dll", ".so", ".pkl", ".h5", ".model", ".pt",
".mp4", ".mp3", ".wav", ".avi", ".mov",
".log", ".tmp", ".cache",
}
# Файлы, которые нужно полностью игнорировать
EXCLUDED_FILES = {
"CODEX_LOG1.txt", "CODEX__LOGS.txt",
"package-lock.json", "yarn.lock",
}
# Максимальный размер файла для включения в дамп (в байтах)
MAX_FILE_SIZE = 500 * 1024
# Сжатие кода: удаление лишних пробелов и комментарий
COMPRESS_CODE = True
def is_binary_file(filename: str) -> bool:
_, ext = os.path.splitext(filename.lower())
return ext in IGNORED_EXTENSIONS
def should_exclude_file(filename: str) -> bool:
"""Проверяет, нужно ли исключить файл"""
return filename in EXCLUDED_FILES
def compress_content(content: str, filepath: str) -> str:
"""Сжимает содержимое файла (удаляет лишние пробелы и комментарии)"""
if not COMPRESS_CODE:
return content
_, ext = os.path.splitext(filepath.lower())
if ext in {'.py', '.js', '.css', '.html', '.ts'}:
# Удаляем комментарии и лишние пробелы
lines = []
in_multiline_comment = False
for line in content.split('\n'):
# Обработка многострочных комментариев
if in_multiline_comment:
if '*/' in line:
line = line.split('*/', 1)[1]
in_multiline_comment = False
else:
continue
# Удаляем однострочные комментарии
if '
line = line.split('
if '
line = line.split('
# Обработка многострочных комментариев для CSS/JS
if '
' in line:
line = line.split('')[1]
else:
line = line.split('

# File 13/163: entrypoint.sh
################################################################################

#!/bin/sh
set -e

# Если DJANGO_SETTINGS_MODULE не задан, по умолчанию считаем, что это прод.
: "${DJANGO_SETTINGS_MODULE:=backend.settings.production}"
export DJANGO_SETTINGS_MODULE

echo "Using DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE}"

# Миграции
python backend/manage.py migrate --noinput

# Сбор статики
python backend/manage.py collectstatic --noinput

# Запуск gunicorn
exec gunicorn backend.config.wsgi:application \
    --bind 0.0.0.0:8000 \
    --workers "${GUNICORN_WORKERS:-3}" \
    --timeout "${GUNICORN_TIMEOUT:-60}"


# File 14/163: index.html
################################################################################

<!-- index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>ParkShare AI Map</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<!-- Leaflet -->
<link
rel="stylesheet"
href="https:
integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
crossorigin=""
/>
<link rel="stylesheet" href="./static/css/cinematic-ui.css" />
<style>
:root {
--primary:
--bg:
--bg-card:
--text:
--accent:
--danger:
--warning:
}
* {
box-sizing: border-box;
}
body {
margin: 0;
font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
sans-serif;
background: radial-gradient(circle at top,
color: var(--text);
height: 100vh;
display: flex;
flex-direction: column;
}
header {
padding: 0.75rem 1rem;
display: flex;
align-items: center;
justify-content: space-between;
background: rgba(15, 23, 42, 0.9);
backdrop-filter: blur(12px);
border-bottom: 1px solid rgba(148, 163, 184, 0.2);
z-index: 1000;
position: sticky;
top: 0;
}
header h1 {
font-size: 1.1rem;
margin: 0;
display: flex;
align-items: center;
gap: 0.4rem;
}
.badge {
font-size: 0.7rem;
padding: 0.1rem 0.4rem;
border-radius: 999px;
border: 1px solid rgba(148, 163, 184, 0.5);
text-transform: uppercase;
letter-spacing: 0.08em;
}
.header-meta {
display: flex;
align-items: center;
gap: 0.75rem;
}
main {
flex: 1;
display: grid;
grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.3fr);
min-height: 0;
}
#map {
width: 100%;
height: 100%;
}
.sidebar {
border-left: 1px solid rgba(148, 163, 184, 0.2);
background: radial-gradient(circle at top,
padding: 0.75rem;
display: flex;
flex-direction: column;
gap: 0.75rem;
min-width: 280px;
max-width: 480px;
}
.card {
background: rgba(15, 23, 42, 0.98);
border-radius: 0.9rem;
border: 1px solid rgba(148, 163, 184, 0.25);
padding: 0.75rem 0.8rem;
box-shadow: 0 18px 45px rgba(15, 23, 42, 0.6);
}
.card-title {
font-size: 0.9rem;
font-weight: 600;
margin-bottom: 0.4rem;
display: flex;
align-items: center;
justify-content: space-between;
}
.input-row {
display: flex;
gap: 0.4rem;
margin-top: 0.3rem;
}
input[type="text"],
select {
flex: 1;
padding: 0.4rem 0.5rem;
border-radius: 999px;
border: 1px solid rgba(148, 163, 184, 0.5);
background: rgba(15, 23, 42, 0.9);
color: var(--text);
font-size: 0.85rem;
outline: none;
}
input::placeholder {
color: rgba(148, 163, 184, 0.9);
}
button {
border-radius: 999px;
border: none;
padding: 0.45rem 0.9rem;
font-size: 0.8rem;
font-weight: 500;
cursor: pointer;
background: linear-gradient(135deg,
color:
display: inline-flex;
align-items: center;
gap: 0.35rem;
white-space: nowrap;
}
button.secondary {
background: rgba(15, 23, 42, 0.9);
border: 1px solid rgba(148, 163, 184, 0.6);
color: rgba(209, 213, 219, 0.95);
}
.pill {
font-size: 0.72rem;
border-radius: 999px;
padding: 0.16rem 0.5rem;
border: 1px solid rgba(148, 163, 184, 0.4);
display: inline-flex;
align-items: center;
gap: 0.3rem;
color: rgba(209, 213, 219, 0.95);
}
.pill-dot {
width: 0.55rem;
height: 0.55rem;
border-radius: 999px;
}
.pill-dot.green {
background: var(--accent);
}
.pill-dot.yellow {
background: var(--warning);
}
.pill-dot.red {
background: var(--danger);
}
.lots-list {
max-height: 220px;
overflow-y: auto;
margin-top: 0.4rem;
padding-right: 0.2rem;
}
.lot-item {
display: flex;
justify-content: space-between;
align-items: center;
padding: 0.4rem 0.2rem;
border-bottom: 1px solid rgba(31, 41, 55, 0.9);
cursor: pointer;
}
.lot-item:last-child {
border-bottom: none;
}
.lot-main {
display: flex;
flex-direction: column;
gap: 0.1rem;
font-size: 0.75rem;
}
.lot-name {
font-weight: 500;
font-size: 0.8rem;
}
.lot-meta {
display: flex;
flex-wrap: wrap;
gap: 0.3rem;
font-size: 0.7rem;
color: rgba(156, 163, 175, 0.95);
}
.lot-occ {
font-size: 0.8rem;
font-weight: 500;
min-width: 80px;
text-align: right;
}
.status {
font-size: 0.7rem;
color: rgba(148, 163, 184, 0.9);
margin-top: 0.3rem;
}
.ai-oracle-chip {
display: inline-flex;
align-items: center;
gap: 0.4rem;
padding: 0.18rem 0.65rem;
border-radius: 999px;
border: 1px solid rgba(59, 130, 246, 0.45);
background: linear-gradient(120deg, rgba(37, 99, 235, 0.35), rgba(14, 165, 233, 0.15));
color:
font-size: 0.75rem;
letter-spacing: 0.02em;
box-shadow: 0 12px 30px rgba(37, 99, 235, 0.25);
}
.ai-orchestrator-card {
position: relative;
overflow: hidden;
background: linear-gradient(135deg, rgba(30, 41, 59, 0.92), rgba(17, 24, 39, 0.94));
}
.ai-orchestrator-card .card-title {
align-items: center;
}
.ai-orchestrator-card .card-title span {
display: inline-flex;
align-items: center;
gap: 0.4rem;
}
.quantum-toggle {
border: 1px solid rgba(255, 255, 255, 0.12);
color:
font-weight: 600;
letter-spacing: 0.01em;
min-width: 150px;
justify-content: space-between;
}
.quantum-toggle__dot {
width: 18px;
height: 18px;
border-radius: 50%;
border: 2px solid rgba(255, 255, 255, 0.7);
background: radial-gradient(circle at 35% 35%,
box-shadow: 0 0 20px rgba(56, 189, 248, 0.45);
}
.quantum-toggle__label {
flex: 1;
text-align: right;
font-size: 0.8rem;
}
@media (max-width: 900px) {
main {
grid-template-columns: 1fr;
}
.sidebar {
max-width: 100%;
border-left: none;
border-top: 1px solid rgba(148, 163, 184, 0.2);
}
}
</style>
</head>
<body>
<header class="cinematic-surface">
<h1>
<span>ParkShare AI Map</span>
<span class="badge">local ML</span>
</h1>
<div class="header-meta">
<div class="ai-crest">
<span>🧠</span>
<span class="quantum-toggle__label">AI Orchestrator</span>
</div>
<button id="themeToggle" class="quantum-toggle cinematic-button" data-theme="dark">
<span class="quantum-toggle__dot"></span>
<span class="quantum-toggle__label">Dark Matter</span>
</button>
<div class="pill">
<span class="pill-dot green"></span>
<span id="statusText">Подключение к AI-серверу…</span>
</div>
</div>
</header>
<main>
<div id="map"></div>
<aside class="sidebar">
<section class="card cinematic-surface ai-orchestrator-card">
<div class="card-title">
<span>AI-Оркестратор</span>
<span class="ai-oracle-chip">Quantum boost</span>
</div>
<div class="ai-forecast">
<div class="ai-forecast-metric">
<span class="ai-forecast-label">Лучшая ставка</span>
<span class="ai-forecast-value" id="aiOracleName">—</span>
</div>
<div class="ai-forecast-metric">
<span class="ai-forecast-label">Освободится через</span>
<span class="ai-forecast-value" id="aiOracleETA">—</span>
</div>
<div class="ai-forecast-metric">
<span class="ai-forecast-label">Уверенность AI</span>
<span class="ai-forecast-value" id="aiOracleConfidence">—</span>
</div>
<div class="ai-forecast-metric">
<span class="ai-forecast-label">EV/крытая</span>
<span class="ai-forecast-value" id="aiOracleMeta">—</span>
</div>
</div>
<div class="ai-reasoning" id="aiOracleReason">AI готовит инсайт…</div>
</section>
<section class="card">
<div class="card-title">
<span>Поиск парковок (NLP)</span>
</div>
<div class="input-row">
<input
type="text"
id="searchInput"
placeholder='Например: "рядом с метро", "дешевые утром"'
/>
<button id="searchBtn">Искать</button>
</div>
<div class="status" id="searchStatus">Запрос еще не выполнен.</div>
</section>
<section class="card">
<div class="card-title">
<span>Рекомендации (коллаб. фильтрация)</span>
<select id="userSelect"></select>
</div>
<div class="input-row">
<button id="recBtn">Получить рекомендации</button>
<button id="recContentBtn" class="secondary">Вариант B (content)</button>
</div>
<div class="status" id="recStatus">Нет рекомендаций.</div>
<div class="lots-list" id="recList"></div>
</section>
<section class="card">
<div class="card-title">
<span>Все парковки</span>
</div>
<div class="lots-list" id="lotsList"></div>
</section>
</aside>
</main>
<script
src="https:
integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
crossorigin=""
></script>
<script src="./static/js/quantum-theme-manager.js"></script>
<script src="app.js"></script>
<script>
window.psThemeManager = window.initQuantumThemeManager();
</script>
</body>
</html>

# File 17/163: requirements.txt
################################################################################

Django==5.2.8
djangorestframework==3.16.1
django-environ==0.12.0
django-cors-headers==4.9.0
django-cryptography-django5==2.2
psycopg[binary]==3.2.12
celery==5.5.3
redis==7.0.1
Pillow==11.1.0
numpy==2.3.0
pandas==2.2.3
scikit-learn==1.7.2
gunicorn==23.0.0
yookassa
drf-spectacular==0.27.2
django-ratelimit==4.1.0
djangorestframework-simplejwt==5.3.1
httpx==0.27.2
asgiref==3.8.1

# AI‑микросервисы (ParkMate AI)
fastapi
uvicorn[standard]==0.32.1


# File 18/163: run_dev.bat
################################################################################

@echo off
echo 🎯 ParkShare Development Launcher (Windows)

REM Активируем виртуальное окружение если есть
if exist venv (
    echo 🔧 Активация виртуального окружения...
    call venv\Scripts\activate
)

REM Запускаем основной скрипт
python run_dev.py
pause

# File 19/163: run_dev.py
################################################################################

#!/usr/bin/env python3
"""
Единый скрипт для запуска всей системы ParkShare Development
Запускает: Django, LLM сервис, AI API сервер, Celery worker
"""
import os
import sys
import time
import subprocess
import signal
import threading
from pathlib import Path
# Добавляем корень проекта в Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))
def run_command(command, cwd=None, shell=False, env=None):
"""Запускает команду и возвращает процесс"""
if env is None:
env = os.environ.copy()
print(f"🚀 Запуск: {command}")
process = subprocess.Popen(
command,
cwd=cwd or project_root,
shell=shell,
env=env,
stdout=subprocess.PIPE,
stderr=subprocess.STDOUT,
universal_newlines=True,
bufsize=1
)
return process
def log_output(process, name):
"""Логирует вывод процесса"""
def log_thread():
while True:
output = process.stdout.readline()
if output == '' and process.poll() is not None:
break
if output:
print(f"[{name}] {output.strip()}")
process.poll()
thread = threading.Thread(target=log_thread)
thread.daemon = True
thread.start()
return thread
def setup_environment():
"""Настраивает окружение для разработки"""
env = os.environ.copy()
env['PYTHONPATH'] = str(project_root)
env['DJANGO_SETTINGS_MODULE'] = 'backend.settings.local'
env['DEBUG'] = '1'
return env
def wait_for_service(port, timeout=30):
"""Ожидает пока сервис на порту станет доступен"""
import socket
import time
start_time = time.time()
while time.time() - start_time < timeout:
try:
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
sock.settimeout(1)
result = sock.connect_ex(('localhost', port))
if result == 0:
print(f"✅ Сервис на порту {port} готов")
return True
except:
pass
time.sleep(1)
print(f"❌ Таймаут ожидания порта {port}")
return False
def start_django():
"""Запускает Django development server"""
print("\n" + "=" * 50)
print("🔄 Запуск Django сервера...")
print("=" * 50)
# Применяем миграции
print("📦 Применяем миграции...")
migrate_process = run_command([
sys.executable, "backend/manage.py", "migrate"
])
migrate_process.wait()
# Собираем статику
print("📦 Собираем статику...")
collectstatic_process = run_command([
sys.executable, "backend/manage.py", "collectstatic", "--noinput"
])
collectstatic_process.wait()
# Запускаем сервер
return run_command([
sys.executable, "backend/manage.py", "runserver", "8000"
])
def start_llm_service():
"""Запускает LLM микросервис"""
print("\n" + "=" * 50)
print("🧠 Запуск LLM сервиса...")
print("=" * 50)
return run_command([
sys.executable, "-m", "uvicorn",
"ai_services.llm_service.main:app",
"--host", "0.0.0.0",
"--port", "8002",
"--reload"
])
def start_ai_api():
"""Запускает AI API сервер"""
print("\n" + "=" * 50)
print("🤖 Запуск AI API сервера...")
print("=" * 50)
return run_command([
sys.executable, "api_server.py"
])
def start_celery_worker():
"""Запускает Celery worker"""
print("\n" + "=" * 50)
print("🔧 Запуск Celery worker...")
print("=" * 50)
return run_command([
sys.executable, "-m", "celery",
"-A", "backend.config",
"worker",
"--loglevel=info",
"--concurrency=2"
])
def start_celery_beat():
"""Запускает Celery beat"""
print("\n" + "=" * 50)
print("⏰ Запуск Celery beat...")
print("=" * 50)
return run_command([
sys.executable, "-m", "celery",
"-A", "backend.config",
"beat",
"--loglevel=info"
])
def check_dependencies():
"""Проверяет наличие всех зависимостей"""
print("🔍 Проверка зависимостей...")
try:
import django
import fastapi
import uvicorn
import celery
import redis
print("✅ Все зависимости установлены")
return True
except ImportError as e:
print(f"❌ Отсутствует зависимость: {e}")
print("Установите зависимости: pip install -r requirements.txt")
return False
def main():
"""Основная функция запуска"""
print("🎯 ParkShare Development Launcher")
print("Запуск всех компонентов системы...")
# Проверяем зависимости
if not check_dependencies():
sys.exit(1)
# Настраиваем окружение
env = setup_environment()
processes = []
try:
# Запускаем сервисы
services = [
("LLM Service", start_llm_service, 8002),
("AI API", start_ai_api, 8001),
("Celery Worker", start_celery_worker, None),
("Celery Beat", start_celery_beat, None),
("Django", start_django, 8000),
]
for name, starter, port in services:
process = starter()
processes.append((name, process))
if port:
# Даем время сервису начать запуск
time.sleep(2)
if not wait_for_service(port, timeout=10):
print(f"⚠️  Сервис {name} медленно запускается...")
# Запускаем логирование для всех процессов
threads = []
for name, process in processes:
thread = log_output(process, name)
threads.append(thread)
print("\n" + "🎉 Все сервисы запущены!")
print("📊 Статус сервисов:")
print("   • Django: http:
print("   • LLM Service: http:
print("   • AI API: http:
print("   • Celery Worker: ✅")
print("   • Celery Beat: ✅")
print("\n🛑 Для остановки нажмите Ctrl+C")
# Ожидаем завершения
while True:
time.sleep(1)
# Проверяем, что все процессы еще работают
for name, process in processes:
if process.poll() is not None:
print(f"❌ Процесс {name} завершился с кодом {process.returncode}")
# Можно перезапустить или завершить все
except KeyboardInterrupt:
print("\n🛑 Остановка сервисов...")
# Останавливаем процессы
for name, process in processes:
if process.poll() is None:
print(f"⏹️  Останавливаем {name}...")
process.terminate()
try:
process.wait(timeout=5)
except subprocess.TimeoutExpired:
print(f"❌ Принудительная остановка {name}...")
process.kill()
print("👋 Все сервисы остановлены")
if __name__ == "__main__":
main()

# File 20/163: run_dev.sh
################################################################################

#!/bin/bash
# Скрипт запуска для Unix систем

echo "🎯 ParkShare Development Launcher (Unix)"

# Активируем виртуальное окружение если есть
if [ -d "venv" ]; then
    echo "🔧 Активация виртуального окружения..."
    source venv/bin/activate
fi

# Запускаем основной скрипт
python run_dev.py

# File 21/163: accounts\__init__.py
################################################################################



# File 22/163: accounts\admin.py
################################################################################

# accounts/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as DjangoUserAdmin
from .models import User
@admin.register(User)
class UserAdmin(DjangoUserAdmin):
"""
Кастомная админка для пользователя с UUID-ID и ролями.
"""
fieldsets = DjangoUserAdmin.fieldsets + (
(
"Дополнительно",
{
"fields": (
"role",
"email_encrypted",
"phone_encrypted",
"owner_request_pending",
)
},
),
)
list_display = (
"username",
"role",
"is_active",
"is_staff",
"is_superuser",
"date_joined",
)
list_filter = ("role", "is_active", "is_staff", "is_superuser")
search_fields = ("username",)

# File 23/163: accounts\apps.py
################################################################################

# accounts/apps.py
from django.apps import AppConfig
class AccountsConfig(AppConfig):
default_auto_field = "django.db.models.BigAutoField"
name = "accounts"
verbose_name = "Пользователи ParkShare"

# File 24/163: accounts\auth.py
################################################################################

# accounts/auth.py
from __future__ import annotations
from typing import Optional
from django.contrib.auth import get_user_model
from core.utils import normalize_phone
from .utils import normalize_email, hash_email, hash_phone
User = get_user_model()
def _get_first_or_none(qs):
try:
return qs.first()
except Exception:
return None
def find_user_by_identifier(identifier: str) -> Optional[User]:
"""
Ищем пользователя по:
1) username (регистронезависимо);
2) email (нормализованный, через email_hash);
3) телефону (нормализованный, через phone_hash).
В БД никогда не фильтруем по зашифрованным полям.
"""
if not identifier:
return None
ident = identifier.strip()
qs = User.objects.filter(is_active=True)
# 1) Логин (username)
try:
return qs.get(username__iexact=ident)
except User.DoesNotExist:
pass
except User.MultipleObjectsReturned:
return _get_first_or_none(qs.filter(username__iexact=ident).order_by("date_joined"))
# 2) Email
if "@" in ident:
email = normalize_email(ident)
if not email:
return None
email_hash = hash_email(email)
if not email_hash:
return None
try:
return qs.get(email_hash=email_hash)
except User.DoesNotExist:
pass
except User.MultipleObjectsReturned:
return _get_first_or_none(qs.filter(email_hash=email_hash).order_by("date_joined"))
return None
# 3) Телефон
phone = normalize_phone(ident)
if not phone:
return None
phone_hash = hash_phone(phone)
if not phone_hash:
return None
try:
return qs.get(phone_hash=phone_hash)
except User.DoesNotExist:
return None
except User.MultipleObjectsReturned:
return _get_first_or_none(qs.filter(phone_hash=phone_hash).order_by("date_joined"))

# File 25/163: accounts\forms.py
################################################################################

# accounts/forms.py
from typing import Any
from django import forms
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm
from django.utils.translation import gettext_lazy as _
from core.utils import normalize_phone
from .models import User
class LoginForm(AuthenticationForm):
"""
Форма входа: одно поле для логина / email / телефона + пароль.
"""
username = forms.CharField(
label=_("Логин / Email / Телефон"),
widget=forms.TextInput(attrs={"autofocus": True, "class": "ps-input"}),
)
def clean(self):
"""
Подменяем username на реальный логин пользователя, чтобы
AuthenticationForm могла вызвать authenticate() как обычно.
"""
from .auth import find_user_by_identifier
identifier = self.cleaned_data.get("username")
password = self.cleaned_data.get("password")
if identifier and password:
user = find_user_by_identifier(identifier)
if user is not None:
self.cleaned_data["username"] = user.get_username()
return super().clean()
class RegisterForm(UserCreationForm):
"""
Регистрация через HTML-форму.
Email и телефон — опциональные, сохраняются в зашифрованном виде.
"""
email = forms.EmailField(
label=_("Email (опционально)"),
required=False,
widget=forms.EmailInput(attrs={"class": "ps-input"}),
)
phone = forms.CharField(
label=_("Телефон (опционально)"),
required=False,
widget=forms.TextInput(attrs={"class": "ps-input"}),
)
class Meta(UserCreationForm.Meta):
model = User
fields = ("username", "email", "phone")
widgets = {
"username": forms.TextInput(attrs={"class": "ps-input"}),
}
def clean_email(self) -> str:
"""
Просто нормализуем email, без запросов к БД.
"""
email = (self.cleaned_data.get("email") or "").strip().lower()
return email
def clean_phone(self) -> str:
"""
Только нормализуем номер, без проверки уникальности.
"""
phone = self.cleaned_data.get("phone") or ""
if not phone:
return ""
phone = normalize_phone(phone)
if not phone:
raise forms.ValidationError(_("Некорректный формат телефона."))
return phone
def save(self, commit: bool = True) -> User:
"""
Сохраняем пользователя и дублируем нормализованные значения
в email_plain / phone_plain, чтобы их можно было показывать в UI.
"""
user: User = super().save(commit=False)
email = (self.cleaned_data.get("email") or "").strip().lower()
phone = self.cleaned_data.get("phone") or ""
user.email_plain = email or ""
user.phone_plain = normalize_phone(phone or "") if phone else ""
if commit:
user.save()
return user
class ProfileForm(forms.ModelForm):
"""
Редактирование профиля пользователя (email/phone + базовые поля).
"""
email = forms.EmailField(
label=_("Email"),
required=False,
widget=forms.EmailInput(attrs={"class": "ps-input"}),
)
phone = forms.CharField(
label=_("Телефон"),
required=False,
widget=forms.TextInput(attrs={"class": "ps-input"}),
)
class Meta:
model = User
fields = ("first_name", "last_name", "email", "phone")
widgets = {
"first_name": forms.TextInput(attrs={"class": "ps-input"}),
"last_name": forms.TextInput(attrs={"class": "ps-input"}),
}
def clean_email(self) -> str:
email = (self.cleaned_data.get("email") or "").strip().lower()
return email
def clean_phone(self) -> str:
phone = self.cleaned_data.get("phone") or ""
if not phone:
return ""
phone = normalize_phone(phone)
if not phone:
raise forms.ValidationError(_("Некорректный формат телефона."))
# Больше НИКАКИХ запросов к User.objects.filter(phone_encrypted=...)
return phone
def save(self, commit: bool = True) -> Any:
user: User = super().save(commit=False)
email = (self.cleaned_data.get("email") or "").strip().lower()
phone = self.cleaned_data.get("phone") or ""
user.email_plain = email or ""
user.phone_plain = normalize_phone(phone or "") if phone else ""
if commit:
user.save()
return user

# File 26/163: accounts\models.py
################################################################################

# accounts/models.py
import uuid
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django_cryptography.fields import encrypt
from core.models import TimeStampedUUIDModel
from .utils import hash_email, hash_phone
class User(AbstractUser):
"""
Кастомный пользователь:
- UUID как первичный ключ;
- роль (driver / owner / admin);
- email/телефон в зашифрованном виде (django-cryptography-django5);
- отдельные хэши email/телефона для безопасного поиска/уникальности.
"""
class Role(models.TextChoices):
DRIVER = "driver", _("Водитель")
OWNER = "owner", _("Владелец парковки")
ADMIN = "admin", _("Администратор")
id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
role = models.CharField(
_("Роль"),
max_length=16,
choices=Role.choices,
default=Role.DRIVER,
help_text=_("Определяет права доступа в системе."),
)
# Шифрованные контактные поля
email_encrypted = encrypt(
models.EmailField(
_("Email (зашифрованный)"),
blank=True,
null=True,
help_text=_("Опциональный email, хранится в зашифрованном виде."),
)
)
phone_encrypted = encrypt(
models.CharField(
_("Телефон (зашифрованный)"),
max_length=32,
blank=True,
null=True,
help_text=_("Опциональный телефон, хранится в зашифрованном виде."),
)
)
# Отдельные хэши для поиска и проверки уникальности
email_hash = models.CharField(
_("Хэш нормализованного email"),
max_length=64,
blank=True,
db_index=True,
help_text=_("Используется только для поиска и проверки уникальности email."),
)
phone_hash = models.CharField(
_("Хэш нормализованного телефона"),
max_length=64,
blank=True,
db_index=True,
help_text=_("Используется только для поиска и проверки уникальности телефона."),
)
owner_request_pending = models.BooleanField(
_("Запрошено повышение до владельца"),
default=False,
help_text=_("Пользователь подал заявку на роль владельца парковки."),
)
# username + password остаются стандартными полями AbstractUser
REQUIRED_FIELDS: list[str] = []
class Meta:
verbose_name = _("Пользователь")
verbose_name_plural = _("Пользователи")
def __str__(self) -> str:
return self.username
# Удобные свойства для расшифрованных контактов
@property
def email_plain(self) -> str:
"""
Доступ к расшифрованному email.
В коде (и в админке) можно использовать user.email_plain.
"""
return self.email_encrypted or ""
@email_plain.setter
def email_plain(self, value: str) -> None:
self.email_encrypted = value or None
@property
def phone_plain(self) -> str:
return self.phone_encrypted or ""
@phone_plain.setter
def phone_plain(self, value: str) -> None:
self.phone_encrypted = value or None
# Ролевые флаги
@property
def is_driver(self) -> bool:
return self.role == self.Role.DRIVER
@property
def is_owner(self) -> bool:
return self.role in (self.Role.OWNER, self.Role.ADMIN)
@property
def is_admin(self) -> bool:
return self.role == self.Role.ADMIN or self.is_superuser
# Служебные методы
def update_contact_hashes(self) -> None:
"""
Пересчитывает email_hash / phone_hash на основе текущих значений
email_plain / phone_plain.
"""
self.email_hash = hash_email(self.email_plain)
self.phone_hash = hash_phone(self.phone_plain)
def save(self, *args, **kwargs) -> None:
# Перед сохранением всегда обновляем хэши контактов
self.update_contact_hashes()
super().save(*args, **kwargs)
class LoginCode(TimeStampedUUIDModel):
"""
Одноразовый код для подтверждения email/телефона и входа.
"""
class Channel(models.TextChoices):
EMAIL = "email", _("Email")
PHONE = "phone", _("Телефон")
class Purpose(models.TextChoices):
REGISTER = "register", _("Регистрация")
LOGIN = "login", _("Вход")
RESET_PASSWORD = "reset_password", _("Сброс пароля")
user = models.ForeignKey(
User,
on_delete=models.CASCADE,
related_name="login_codes",
)
channel = models.CharField(
_("Канал"),
max_length=16,
choices=Channel.choices,
)
purpose = models.CharField(
_("Назначение"),
max_length=32,
choices=Purpose.choices,
)
code_hash = models.CharField(
_("Хэш кода"),
max_length=128,
db_index=True,
)
expires_at = models.DateTimeField(_("Истекает в"))
is_used = models.BooleanField(_("Использован"), default=False)
class Meta:
verbose_name = _("Код подтверждения")
verbose_name_plural = _("Коды подтверждения")
indexes = [
models.Index(fields=["user", "purpose", "is_used"]),
]
def __str__(self) -> str:
return f"{self.purpose} code for {self.user_id}"
@property
def is_expired(self) -> bool:
return timezone.now() >= self.expires_at
class UserLevel(TimeStampedUUIDModel):
"""Уровень пользователя по количеству завершённых бронирований."""
name = models.CharField(max_length=64)
threshold = models.PositiveIntegerField(
default=0, help_text="Количество завершённых бронирований для уровня"
)
description = models.TextField(blank=True)
class Meta:
verbose_name = "Уровень пользователя"
verbose_name_plural = "Уровни пользователей"
ordering = ("threshold",)
def __str__(self) -> str:
return self.name
class UserBadge(TimeStampedUUIDModel):
"""Бейдж за активность/лояльность."""
user = models.ForeignKey(
User, on_delete=models.CASCADE, related_name="badges", verbose_name="Пользователь"
)
title = models.CharField(max_length=128)
description = models.TextField(blank=True)
icon = models.CharField(max_length=64, blank=True)
level = models.ForeignKey(
UserLevel,
on_delete=models.SET_NULL,
null=True,
blank=True,
related_name="badges",
)
class Meta:
verbose_name = "Бейдж"
verbose_name_plural = "Бейджи"
ordering = ("-created_at",)
def __str__(self) -> str:
return f"{self.title} — {self.user}"
class PromoReward(TimeStampedUUIDModel):
"""Заготовка под промо/бонусы."""
code = models.CharField(max_length=32, unique=True)
description = models.TextField(blank=True)
active = models.BooleanField(default=True)
usage_limit = models.PositiveIntegerField(default=1)
class Meta:
verbose_name = "Промо/бонус"
verbose_name_plural = "Промо/бонусы"
def __str__(self) -> str:
return self.code

# File 27/163: accounts\serializers.py
################################################################################

# accounts/serializers.py
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from django.utils.translation import gettext_lazy as _
from rest_framework import serializers
from core.utils import normalize_phone
from .auth import find_user_by_identifier
from .models import User, LoginCode
from .utils import normalize_email, hash_email, hash_phone
class UserSerializer(serializers.ModelSerializer):
"""
Базовое представление пользователя для админских API.
Контактные данные не раскрываются.
"""
has_email = serializers.SerializerMethodField()
has_phone = serializers.SerializerMethodField()
class Meta:
model = User
fields = (
"id",
"username",
"role",
"is_active",
"date_joined",
"has_email",
"has_phone",
)
def get_has_email(self, obj: User) -> bool:
return bool(obj.email_plain)
def get_has_phone(self, obj: User) -> bool:
return bool(obj.phone_plain)
class UserProfileSerializer(serializers.ModelSerializer):
"""
Профиль текущего пользователя.
Здесь можно редактировать email/телефон.
"""
email = serializers.CharField(
source="email_plain",
allow_blank=True,
required=False,
)
phone = serializers.CharField(
source="phone_plain",
allow_blank=True,
required=False,
)
class Meta:
model = User
fields = ("id", "username", "role", "email", "phone")
def validate_phone(self, value: str) -> str:
"""
Валидируем и нормализуем телефон, проверяем уникальность через phone_hash.
"""
value = value or ""
if not value:
return ""
normalized = normalize_phone(value)
if not normalized:
raise serializers.ValidationError(_("Некорректный формат телефона."))
phone_hash = hash_phone(normalized)
user = self.instance
qs = User.objects.filter(phone_hash=phone_hash)
if user is not None:
qs = qs.exclude(pk=user.pk)
if phone_hash and qs.exists():
raise serializers.ValidationError(
_("Пользователь с таким телефоном уже существует.")
)
return normalized
def validate_email(self, value: str) -> str:
"""
Валидируем и нормализуем email, проверяем уникальность через email_hash.
"""
value = normalize_email(value)
if not value:
return ""
email_hash = hash_email(value)
user = self.instance
qs = User.objects.filter(email_hash=email_hash)
if user is not None:
qs = qs.exclude(pk=user.pk)
if email_hash and qs.exists():
raise serializers.ValidationError(
_("Пользователь с таким email уже существует.")
)
return value
class RegisterSerializer(serializers.Serializer):
"""
Регистрация через API.
"""
username = serializers.CharField(max_length=150)
password = serializers.CharField(write_only=True, min_length=8)
email = serializers.EmailField(required=False, allow_blank=True)
phone = serializers.CharField(required=False, allow_blank=True)
def validate_username(self, value: str) -> str:
if User.objects.filter(username=value).exists():
raise serializers.ValidationError(
_("Пользователь с таким логином уже существует.")
)
return value
def validate_email(self, value: str) -> str:
email = normalize_email(value)
if not email:
return ""
email_hash = hash_email(email)
if email_hash and User.objects.filter(email_hash=email_hash).exists():
raise serializers.ValidationError(
_("Пользователь с таким email уже зарегистрирован.")
)
return email
def validate_phone(self, value: str) -> str:
value = value or ""
if not value:
return ""
normalized = normalize_phone(value)
if not normalized:
raise serializers.ValidationError(_("Некорректный формат телефона."))
phone_hash = hash_phone(normalized)
if phone_hash and User.objects.filter(phone_hash=phone_hash).exists():
raise serializers.ValidationError(
_("Пользователь с таким телефоном уже зарегистрирован.")
)
return normalized
def validate_password(self, value: str) -> str:
validate_password(value)
return value
def create(self, validated_data: dict) -> User:
email = validated_data.pop("email", "")
phone = validated_data.pop("phone", "")
user = User(username=validated_data["username"])
user.set_password(validated_data["password"])
if email:
user.email_plain = email
if phone:
user.phone_plain = phone
user.save()
return user
class LoginSerializer(serializers.Serializer):
"""
Логин через API (session-based).
Позволяет использовать логин, email или телефон.
"""
identifier = serializers.CharField(
label=_("Логин / Email / Телефон"),
)
password = serializers.CharField(write_only=True)
def validate(self, attrs: dict) -> dict:
identifier = attrs.get("identifier")
password = attrs.get("password")
if not identifier or not password:
raise serializers.ValidationError(
_("Необходимо указать логин и пароль."),
code="authorization",
)
user = find_user_by_identifier(identifier)
if user is None:
raise serializers.ValidationError(
_("Неверный логин/email/телефон или пароль."),
code="authorization",
)
# authenticate нужен для проверки пароля и backend'а аутентификации
auth_user = authenticate(
username=user.username,
password=password,
)
if auth_user is None:
raise serializers.ValidationError(
_("Неверный логин/email/телефон или пароль."),
code="authorization",
)
if not auth_user.is_active:
raise serializers.ValidationError(
_("Пользователь деактивирован."),
code="authorization",
)
attrs["user"] = auth_user
return attrs
class ChangePasswordSerializer(serializers.Serializer):
"""
Смена пароля текущего пользователя.
"""
old_password = serializers.CharField(write_only=True)
new_password = serializers.CharField(write_only=True, min_length=8)
def validate_new_password(self, value: str) -> str:
user = self.context["request"].user
validate_password(value, user=user)
return value
def validate(self, attrs: dict) -> dict:
user = self.context["request"].user
old_password = attrs.get("old_password")
if not user.check_password(old_password):
raise serializers.ValidationError(
{"old_password": _("Неверный текущий пароль.")}
)
return attrs
def save(self, **kwargs) -> User:
user = self.context["request"].user
new_password = self.validated_data["new_password"]
user.set_password(new_password)
user.save(update_fields=["password"])
return user
class PasswordResetRequestSerializer(serializers.Serializer):
"""
Запрос на сброс пароля по email (API).
"""
email = serializers.EmailField()
def validate_email(self, value: str) -> str:
# В целях безопасности не раскрываем, существует ли пользователь.
return normalize_email(value)
class OTPRequestSerializer(serializers.Serializer):
"""
Запрос кода подтверждения для email/телефона.
"""
identifier = serializers.CharField(
label=_("Email или телефон"),
)
purpose = serializers.ChoiceField(
choices=LoginCode.Purpose.choices,
default=LoginCode.Purpose.LOGIN,
)
class OTPVerifySerializer(serializers.Serializer):
"""
Проверка кода и выдача JWT/сессии.
"""
identifier = serializers.CharField(label=_("Email или телефон"))
code = serializers.CharField(label=_("Код"), max_length=8)
purpose = serializers.ChoiceField(
choices=LoginCode.Purpose.choices,
default=LoginCode.Purpose.LOGIN,
)

# File 28/163: accounts\urls.py
################################################################################

# accounts/urls.py
from django.contrib.auth import views as auth_views
from django.urls import path, reverse_lazy
from .views import CustomLoginView, ProfileView, RegisterView, logout_view
# TODO: интегрировать вход по коду и Госуслуги (ESIA) в отдельные view/urls, когда появятся провайдеры
app_name = "accounts"
urlpatterns = [
path("login/", CustomLoginView.as_view(), name="login"),
path("logout/", logout_view, name="logout"),
path("register/", RegisterView.as_view(), name="register"),
path("profile/", ProfileView.as_view(), name="profile"),
# Смена пароля (HTML)
path(
"password/change/",
auth_views.PasswordChangeView.as_view(
template_name="accounts/password_change.html",
success_url=reverse_lazy("accounts:password_change_done"),
),
name="password_change",
),
path(
"password/change/done/",
auth_views.PasswordChangeDoneView.as_view(
template_name="accounts/password_change_done.html"
),
name="password_change_done",
),
# Сброс пароля (HTML)
path(
"password/reset/",
auth_views.PasswordResetView.as_view(
template_name="accounts/password_reset.html",
email_template_name="accounts/password_reset_email.txt",
subject_template_name="accounts/password_reset_subject.txt",
success_url=reverse_lazy("accounts:password_reset_done"),
),
name="password_reset",
),
path(
"password/reset/done/",
auth_views.PasswordResetDoneView.as_view(
template_name="accounts/password_reset_done.html"
),
name="password_reset_done",
),
path(
"reset/<uidb64>/<token>/",
auth_views.PasswordResetConfirmView.as_view(
template_name="accounts/password_reset_confirm.html",
success_url=reverse_lazy("accounts:password_reset_complete"),
),
name="password_reset_confirm",
),
path(
"reset/done/",
auth_views.PasswordResetCompleteView.as_view(
template_name="accounts/password_reset_complete.html"
),
name="password_reset_complete",
),
]

# File 29/163: accounts\utils.py
################################################################################

from __future__ import annotations
from typing import Optional
import hashlib
from django.conf import settings
from core.utils import normalize_phone
def normalize_email(email: Optional[str]) -> str:
"""
Приводим email к каноничному виду:
- str.strip()
- .lower()
"""
if not email:
return ""
return email.strip().lower()
def _hash_value(kind: str, value: str) -> str:
"""
Внутренняя функция хэширования с солью на базе SECRET_KEY.
kind: 'email' или 'phone' (на будущее можно расширять).
"""
if not value:
return ""
salted = f"{settings.SECRET_KEY}:{kind}:{value}"
return hashlib.sha256(salted.encode("utf-8")).hexdigest()
def hash_email(email: str) -> str:
"""
Хэш нормализованного email.
В БД хранится только хэш, сам email — в зашифрованном поле.
"""
normalized = normalize_email(email)
if not normalized:
return ""
return _hash_value("email", normalized)
def hash_phone(phone: str) -> str:
"""
Хэш нормализованного телефона.
В БД хранится только хэш, сам телефон — в зашифрованном поле.
"""
normalized = normalize_phone(phone)
if not normalized:
return ""
return _hash_value("phone", normalized)

# File 30/163: accounts\views.py
################################################################################

# accounts/views.py
from typing import Any
from django.contrib.auth import login as auth_login, logout as auth_logout
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.views import LoginView as DjangoLoginView
from django.contrib.auth.forms import PasswordResetForm
from django.http import HttpRequest, HttpResponse
from django.shortcuts import redirect, render
from django.urls import reverse, reverse_lazy
from django.views import View
from django.views.generic import UpdateView
from rest_framework import permissions, status, viewsets
from rest_framework.views import APIView
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenRefreshView
from django.utils import timezone
from django.utils.crypto import get_random_string
from django.contrib.auth import login as auth_login_session
from django.core.mail import send_mail
from core.permissions import IsSelfOrAdmin
from .forms import LoginForm, ProfileForm, RegisterForm
from .models import User, LoginCode
from .serializers import (
ChangePasswordSerializer,
LoginSerializer,
PasswordResetRequestSerializer,
RegisterSerializer,
UserProfileSerializer,
UserSerializer,
OTPRequestSerializer,
OTPVerifySerializer,
)
from .auth import find_user_by_identifier
from .utils import hash_email
# ===== HTML-вьюхи (шаблонный интерфейс) =====
class RegisterView(View):
"""
Регистрация пользователя через HTML-форму.
"""
template_name = "accounts/register.html"
def get(self, request: HttpRequest) -> HttpResponse:
if request.user.is_authenticated:
return redirect("user_dashboard")
form = RegisterForm()
return render(request, self.template_name, {"form": form})
def post(self, request: HttpRequest) -> HttpResponse:
if request.user.is_authenticated:
return redirect("user_dashboard")
form = RegisterForm(request.POST)
if form.is_valid():
user = form.save()
auth_login(request, user)
return redirect("user_dashboard")
return render(request, self.template_name, {"form": form})
class ProfileView(LoginRequiredMixin, UpdateView):
"""
Редактирование профиля (email/телефон) в HTML-интерфейсе.
"""
model = User
form_class = ProfileForm
template_name = "accounts/profile.html"
success_url = reverse_lazy("user_dashboard")
def get_object(self, queryset=None) -> User:
return self.request.user
class CustomLoginView(DjangoLoginView):
"""
Обёртка над стандартным LoginView с русским шаблоном и кастомной формой.
"""
template_name = "accounts/login.html"
form_class = LoginForm
def get_success_url(self) -> str:
return reverse("user_dashboard")
def logout_view(request: HttpRequest) -> HttpResponse:
auth_logout(request)
return redirect("landing")
# ===== API (DRF) =====
class UserViewSet(viewsets.ModelViewSet):
"""
API для работы с пользователями.
Маршруты:
- /api/accounts/users/                   (GET)   — список (только админ)
- /api/accounts/users/{id}/              (GET)   — профиль (сам или админ)
- /api/accounts/users/me/                (GET)   — профиль текущего пользователя
- /api/accounts/users/me/                (PATCH) — обновление своего профиля
- /api/accounts/users/register/          (POST)  — регистрация
- /api/accounts/users/login/             (POST)  — логин (session-based)
- /api/accounts/users/logout/            (POST)  — логаут
- /api/accounts/users/change-password/   (POST)  — смена пароля (API)
- /api/accounts/users/reset-password/    (POST)  — запрос сброса пароля по email
"""
queryset = User.objects.all().order_by("-date_joined")
serializer_class = UserSerializer
def get_permissions(self) -> list[Any]:
if self.action in ("register", "login", "reset_password"):
permission_classes = [permissions.AllowAny]
elif self.action in ("list", "destroy"):
permission_classes = [permissions.IsAdminUser]
elif self.action in ("me", "change_password", "logout"):
permission_classes = [permissions.IsAuthenticated]
else:
# retrieve/update/partial_update — только сам пользователь или админ
permission_classes = [permissions.IsAuthenticated, IsSelfOrAdmin]
return [perm() for perm in permission_classes]
def get_queryset(self):
user: User = self.request.user
if not user.is_authenticated:
return User.objects.none()
if user.is_superuser or getattr(user, "is_admin", False):
return User.objects.all().order_by("-date_joined")
return User.objects.filter(pk=user.pk)
def perform_destroy(self, instance: User) -> None:
"""
Удалять пользователей может только админ — контролируется permissions.
"""
super().perform_destroy(instance)
@action(detail=False, methods=["get", "patch"], url_path="me")
def me(self, request):
"""
Профиль текущего пользователя.
GET — получить; PATCH — обновить email/телефон.
"""
if request.method.lower() == "get":
serializer = UserProfileSerializer(request.user)
return Response(serializer.data)
serializer = UserProfileSerializer(
request.user, data=request.data, partial=True
)
serializer.is_valid(raise_exception=True)
serializer.save()
return Response(serializer.data)
@action(detail=False, methods=["post"], url_path="register")
def register(self, request):
"""
Регистрация пользователя через API.
"""
serializer = RegisterSerializer(data=request.data)
serializer.is_valid(raise_exception=True)
user: User = serializer.save()
auth_login(request, user)
data = UserProfileSerializer(user).data
return Response(data, status=status.HTTP_201_CREATED)
@action(detail=False, methods=["post"], url_path="login")
def login(self, request):
"""
Логин через API. Используются стандартные Django-сессии.
"""
serializer = LoginSerializer(data=request.data)
serializer.is_valid(raise_exception=True)
user: User = serializer.validated_data["user"]
auth_login(request, user)
data = UserProfileSerializer(user).data
return Response(data, status=status.HTTP_200_OK)
@action(detail=False, methods=["post"], url_path="logout")
def logout(self, request):
"""
Логаут через API (очистка сессии).
"""
auth_logout(request)
return Response(
{"detail": "Вы вышли из системы."}, status=status.HTTP_200_OK
)
@action(detail=False, methods=["post"], url_path="change-password")
def change_password(self, request):
"""
Смена пароля текущего пользователя (API).
"""
serializer = ChangePasswordSerializer(
data=request.data, context={"request": request}
)
serializer.is_valid(raise_exception=True)
serializer.save()
return Response(
{"detail": "Пароль успешно изменён."},
status=status.HTTP_200_OK,
)
@action(detail=False, methods=["post"], url_path="reset-password")
def reset_password(self, request):
"""
Запрос на сброс пароля по email (API).
Использует стандартный PasswordResetForm и отправляет письмо
через настроенный EMAIL_BACKEND.
"""
serializer = PasswordResetRequestSerializer(data=request.data)
serializer.is_valid(raise_exception=True)
email = serializer.validated_data["email"]
form = PasswordResetForm(data={"email": email})
if form.is_valid():
form.save(
request=request,
use_https=request.is_secure(),
email_template_name="accounts/password_reset_email.txt",
subject_template_name="accounts/password_reset_subject.txt",
)
# Независимо от результата говорим одно и то же, чтобы не раскрывать,
# существует ли пользователь с таким email.
return Response(
{
"detail": (
"Если пользователь с таким email существует, на него отправлена "
"инструкция по сбросу пароля."
)
},
status=status.HTTP_200_OK,
)
class TokenObtainPairView(APIView):
"""JWT-аутентификация по логину/email/телефону.
Возвращает пару access/refresh токенов и упрощает интеграцию с мобильными
клиентами и PWA. Валидация и анти-брутфорс остаются в LoginSerializer.
"""
permission_classes = [permissions.AllowAny]
def post(self, request, *args, **kwargs):
serializer = LoginSerializer(data=request.data)
serializer.is_valid(raise_exception=True)
user = serializer.validated_data["user"]
refresh = RefreshToken.for_user(user)
return Response(
{
"access": str(refresh.access_token),
"refresh": str(refresh),
"user": UserProfileSerializer(user).data,
},
status=status.HTTP_200_OK,
)
class TokenRefreshSlidingView(TokenRefreshView):
"""Упаковываем refresh endpoint в единый namespace accounts."""
permission_classes = [permissions.AllowAny]
class AuthOTPRequestView(APIView):
"""
POST /api/auth/request-code
identifier: email/phone, purpose: login/register/reset_password
"""
permission_classes = [permissions.AllowAny]
def post(self, request, *args, **kwargs):
serializer = OTPRequestSerializer(data=request.data)
serializer.is_valid(raise_exception=True)
identifier = serializer.validated_data["identifier"]
purpose = serializer.validated_data["purpose"]
# Находим или создаём пользователя для регистрации
user = find_user_by_identifier(identifier)
if purpose == LoginCode.Purpose.REGISTER and user is None:
# Создаём "сырого" пользователя с рандомным username
username = f"user_{get_random_string(8)}"
user = User.objects.create(username=username, is_active=True)
if "@" in identifier:
user.email_plain = identifier
else:
user.phone_plain = identifier
user.save()
if user is None:
# Для login/reset_password не раскрываем факт отсутствия аккаунта
return Response(status=status.HTTP_204_NO_CONTENT)
# Генерируем код и хэшируем его
raw_code = get_random_string(6, allowed_chars="0123456789")
code_hash = hash_email(raw_code)
expires_at = timezone.now() + timezone.timedelta(minutes=10)
LoginCode.objects.create(
user=user,
channel=LoginCode.Channel.EMAIL if "@" in identifier else LoginCode.Channel.PHONE,
purpose=purpose,
code_hash=code_hash,
expires_at=expires_at,
)
# Отправка кода (для SMS тут будет интеграция с провайдером)
if "@" in identifier:
send_mail(
subject="Ваш код ParkShare",
message=f"Ваш код входа: {raw_code} (действителен 10 минут).",
from_email=None,
recipient_list=[identifier],
fail_silently=True,
)
# Для демо возвращаем 204 без тела
return Response(status=status.HTTP_204_NO_CONTENT)
class AuthOTPVerifyView(APIView):
"""
POST /api/auth/verify-code
identifier + code → логин (session + JWT).
"""
permission_classes = [permissions.AllowAny]
def post(self, request, *args, **kwargs):
serializer = OTPVerifySerializer(data=request.data)
serializer.is_valid(raise_exception=True)
identifier = serializer.validated_data["identifier"]
code = serializer.validated_data["code"]
purpose = serializer.validated_data["purpose"]
user = find_user_by_identifier(identifier)
if user is None:
return Response({"detail": "Неверный код или идентификатор."}, status=status.HTTP_400_BAD_REQUEST)
code_hash = hash_email(code)
qs = LoginCode.objects.filter(
user=user,
purpose=purpose,
is_used=False,
).order_by("-created_at")
code_obj = qs.first()
if not code_obj or code_obj.code_hash != code_hash or code_obj.is_expired:
return Response({"detail": "Неверный или просроченный код."}, status=status.HTTP_400_BAD_REQUEST)
code_obj.is_used = True
code_obj.save(update_fields=["is_used", "updated_at"])
# Логиним пользователя (session + JWT)
auth_login_session(request, user)
refresh = RefreshToken.for_user(user)
return Response(
{
"access": str(refresh.access_token),
"refresh": str(refresh),
},
status=status.HTTP_200_OK,
)

# File 31/163: accounts\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34
import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
import django_cryptography.fields
import uuid
from django.db import migrations, models
class Migration(migrations.Migration):
initial = True
dependencies = [
('auth', '0012_alter_user_first_name_max_length'),
]
operations = [
migrations.CreateModel(
name='User',
fields=[
('password', models.CharField(max_length=128, verbose_name='password')),
('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('role', models.CharField(choices=[('driver', 'Водитель'), ('owner', 'Владелец парковки'), ('admin', 'Администратор')], default='driver', help_text='Определяет права доступа в системе.', max_length=16, verbose_name='Роль')),
('email_encrypted', django_cryptography.fields.encrypt(models.EmailField(blank=True, help_text='Опциональный email, хранится в зашифрованном виде.', max_length=254, null=True, verbose_name='Email (зашифрованный)'))),
('phone_encrypted', django_cryptography.fields.encrypt(models.CharField(blank=True, help_text='Опциональный телефон, хранится в зашифрованном виде.', max_length=32, null=True, verbose_name='Телефон (зашифрованный)'))),
('owner_request_pending', models.BooleanField(default=False, help_text='Пользователь подал заявку на роль владельца парковки.', verbose_name='Запрошено повышение до владельца')),
('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
],
options={
'verbose_name': 'Пользователь',
'verbose_name_plural': 'Пользователи',
},
managers=[
('objects', django.contrib.auth.models.UserManager()),
],
),
]

# File 32/163: accounts\migrations\0002_user_email_hash_user_phone_hash_logincode.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-23 15:00
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models
class Migration(migrations.Migration):
dependencies = [
('accounts', '0001_initial'),
]
operations = [
migrations.AddField(
model_name='user',
name='email_hash',
field=models.CharField(blank=True, db_index=True, help_text='Используется только для поиска и проверки уникальности email.', max_length=64, verbose_name='Хэш нормализованного email'),
),
migrations.AddField(
model_name='user',
name='phone_hash',
field=models.CharField(blank=True, db_index=True, help_text='Используется только для поиска и проверки уникальности телефона.', max_length=64, verbose_name='Хэш нормализованного телефона'),
),
migrations.CreateModel(
name='LoginCode',
fields=[
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('channel', models.CharField(choices=[('email', 'Email'), ('phone', 'Телефон')], max_length=16, verbose_name='Канал')),
('purpose', models.CharField(choices=[('register', 'Регистрация'), ('login', 'Вход'), ('reset_password', 'Сброс пароля')], max_length=32, verbose_name='Назначение')),
('code_hash', models.CharField(db_index=True, max_length=128, verbose_name='Хэш кода')),
('expires_at', models.DateTimeField(verbose_name='Истекает в')),
('is_used', models.BooleanField(default=False, verbose_name='Использован')),
('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='login_codes', to=settings.AUTH_USER_MODEL)),
],
options={
'verbose_name': 'Код подтверждения',
'verbose_name_plural': 'Коды подтверждения',
'indexes': [models.Index(fields=['user', 'purpose', 'is_used'], name='accounts_lo_user_id_024bc5_idx')],
},
),
]

# File 33/163: accounts\migrations\0003_userlevel_userbadge_promoreward.py
################################################################################

import uuid
from django.db import migrations, models
import django.db.models.deletion
class Migration(migrations.Migration):
dependencies = [
('accounts', '0002_user_email_hash_user_phone_hash_logincode'),
]
operations = [
migrations.CreateModel(
name='UserLevel',
fields=[
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('name', models.CharField(max_length=64)),
('threshold', models.PositiveIntegerField(default=0, help_text='Количество завершённых бронирований для уровня')),
('description', models.TextField(blank=True)),
],
options={
'verbose_name': 'Уровень пользователя',
'verbose_name_plural': 'Уровни пользователей',
'ordering': ('threshold',),
},
),
migrations.CreateModel(
name='PromoReward',
fields=[
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('code', models.CharField(max_length=32, unique=True)),
('description', models.TextField(blank=True)),
('active', models.BooleanField(default=True)),
('usage_limit', models.PositiveIntegerField(default=1)),
],
options={
'verbose_name': 'Промо/бонус',
'verbose_name_plural': 'Промо/бонусы',
},
),
migrations.CreateModel(
name='UserBadge',
fields=[
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('title', models.CharField(max_length=128)),
('description', models.TextField(blank=True)),
('icon', models.CharField(blank=True, max_length=64)),
('level', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='badges', to='accounts.userlevel')),
('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='badges', to='accounts.user', verbose_name='Пользователь')),
],
options={
'verbose_name': 'Бейдж',
'verbose_name_plural': 'Бейджи',
'ordering': ('-created_at',),
},
),
]

# File 34/163: accounts\migrations\__init__.py
################################################################################



# File 35/163: ai\__init__.py
################################################################################

default_app_config = "ai.apps.AiConfig"

# File 36/163: ai\admin.py
################################################################################

from django.contrib import admin
from .models import ChatFeedback, ChatMessage, ChatSession, DeviceProfile, UiEvent
@admin.register(DeviceProfile)
class DeviceProfileAdmin(admin.ModelAdmin):
list_display = ("device_id", "user", "layout_profile", "theme", "created_at")
search_fields = ("device_id", "user__username")
@admin.register(UiEvent)
class UiEventAdmin(admin.ModelAdmin):
list_display = ("event_type", "device_profile", "created_at")
list_filter = ("event_type",)
@admin.register(ChatSession)
class ChatSessionAdmin(admin.ModelAdmin):
list_display = ("id", "user", "created_at", "last_activity_at")
search_fields = ("id", "user__username")
@admin.register(ChatMessage)
class ChatMessageAdmin(admin.ModelAdmin):
list_display = ("session", "role", "created_at")
list_filter = ("role",)
search_fields = ("text",)
@admin.register(ChatFeedback)
class ChatFeedbackAdmin(admin.ModelAdmin):
list_display = ("message", "rating", "created_at")
list_filter = ("rating",)

# File 37/163: ai\apps.py
################################################################################

from django.apps import AppConfig
class AiConfig(AppConfig):
default_auto_field = "django.db.models.BigAutoField"
# ВАЖНО: здесь должен быть реальный путь до пакета приложения
# Папка называется "ai", лежит в корне проекта -> name = "ai"
name = "ai"
verbose_name = "AI и рекомендации ParkShare"

# File 38/163: ai\features.py
################################################################################

from __future__ import annotations
import pandas as pd
from parking.models import Booking
def bookings_dataframe() -> pd.DataFrame:
"""
Собирает историю бронирований в DataFrame для обучения/аналитики.
"""
qs = Booking.objects.filter(
status__in=[
Booking.Status.CONFIRMED,
Booking.Status.ACTIVE,
Booking.Status.COMPLETED,
]
).select_related("spot", "spot__lot")
rows = []
for b in qs:
rows.append(
{
"booking_id": str(b.id),
"spot_id": str(b.spot_id),
"lot_id": str(b.spot.lot_id),
"city": b.spot.lot.city,
"start": b.start_at,
"end": b.end_at,
"duration_hours": (b.end_at - b.start_at).total_seconds() / 3600.0,
"price": float(b.total_price),
"dow": b.start_at.weekday(),
"hour": b.start_at.hour,
}
)
if not rows:
return pd.DataFrame()
df = pd.DataFrame(rows)
df["is_weekend"] = df["dow"] >= 5
return df

# File 39/163: ai\models.py
################################################################################

# ai/models.py
from __future__ import annotations
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
from core.models import TimeStampedModel, TimeStampedUUIDModel
class DeviceProfile(TimeStampedUUIDModel):
"""
Профиль устройства/клиента для адаптивного UI.
Связан либо с пользователем, либо с анонимным device_id (из cookies/LS).
"""
class LayoutProfile(models.TextChoices):
COMPACT = "compact", _("Компактный")
COMFORTABLE = "comfortable", _("Комфортный")
class Theme(models.TextChoices):
LIGHT = "light", _("Светлая")
DARK = "dark", _("Тёмная")
SYSTEM = "system", _("Системная")
user = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.SET_NULL,
null=True,
blank=True,
related_name="device_profiles",
)
device_id = models.CharField(
_("ID устройства"),
max_length=64,
db_index=True,
)
viewport_width = models.IntegerField(_("Ширина viewport"), null=True, blank=True)
viewport_height = models.IntegerField(_("Высота viewport"), null=True, blank=True)
pixel_ratio = models.FloatField(_("Pixel ratio"), null=True, blank=True)
user_agent = models.TextField(_("User‑Agent"), blank=True)
layout_profile = models.CharField(
_("Профиль компоновки"),
max_length=32,
choices=LayoutProfile.choices,
default=LayoutProfile.COMPACT,
)
theme = models.CharField(
_("Тема"),
max_length=16,
choices=Theme.choices,
default=Theme.SYSTEM,
)
class Meta:
verbose_name = _("Профиль устройства")
verbose_name_plural = _("Профили устройств")
unique_together = ("device_id", "user")
def __str__(self) -> str:
return f"DeviceProfile({self.device_id}, {self.layout_profile})"
class UiEvent(TimeStampedUUIDModel):
"""
Сырые события UI/адаптивности (scroll, resize, layout_probe и т.п.).
"""
device_profile = models.ForeignKey(
DeviceProfile,
on_delete=models.CASCADE,
related_name="events",
)
event_type = models.CharField(_("Тип события"), max_length=64)
payload = models.JSONField(_("Payload"), null=True, blank=True)
class Meta:
verbose_name = _("UI‑событие")
verbose_name_plural = _("UI‑события")
def __str__(self) -> str:
return f"UiEvent({self.event_type})"
class ChatSession(TimeStampedUUIDModel):
"""Сессия чата (cookie ps_chat_sid)."""
user = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.SET_NULL,
null=True,
blank=True,
related_name="chat_sessions",
)
client_info = models.JSONField("Данные клиента", null=True, blank=True)
last_activity_at = models.DateTimeField("Последняя активность", auto_now=True)
class Meta:
verbose_name = "Сессия чата"
verbose_name_plural = "Сессии чата"
def __str__(self) -> str:
return f"ChatSession({self.id})"
class ChatMessage(TimeStampedModel):
"""Сообщения в рамках сессии."""
class Role(models.TextChoices):
USER = "user", "User"
ASSISTANT = "assistant", "Assistant"
session = models.ForeignKey(
ChatSession,
on_delete=models.CASCADE,
related_name="messages",
)
role = models.CharField("Роль", max_length=16, choices=Role.choices)
text = models.TextField("Текст")
meta = models.JSONField("Метаданные", null=True, blank=True)
class Meta:
verbose_name = "Сообщение чата"
verbose_name_plural = "Сообщения чата"
ordering = ("-created_at",)
def __str__(self) -> str:
return f"[{self.role}] {self.text[:30]}"
class ChatFeedback(TimeStampedModel):
"""Оценки ответов ассистента."""
message = models.ForeignKey(
ChatMessage,
on_delete=models.CASCADE,
related_name="feedback",
)
rating = models.IntegerField("Оценка", default=0)
class Meta:
verbose_name = "Фидбек чата"
verbose_name_plural = "Фидбек чата"
ordering = ("-created_at",)
def __str__(self) -> str:
return f"Feedback({self.rating})"

# File 40/163: ai\orchestrator.py
################################################################################

from __future__ import annotations
from decimal import Decimal
from typing import Any, Dict
from django.utils import timezone
from ai.pricing import recommend_price_for_spot
class PricingDecision:
def __init__(self, payload: Dict[str, Any]):
self.payload = payload
@property
def price(self) -> Decimal:
return Decimal(str(self.payload.get("recommended_price", 0)))
def to_dict(self) -> Dict[str, Any]:
return self.payload
class AvailabilityDecision:
def __init__(self, payload: Dict[str, Any]):
self.payload = payload
def to_dict(self) -> Dict[str, Any]:
return self.payload
def apply_ai_pricing(booking) -> PricingDecision | None:
"""Подключает ML/GBM модель динамического ценообразования.
Для MVP используем существующую recommend_price_for_spot, но сохраняем
полную структуру для будущих CatBoost/GBM моделей (ParkMate).
"""
suggestion = recommend_price_for_spot(booking.spot)
if not suggestion:
return None
hours = max(Decimal("1"), Decimal((booking.end_at - booking.start_at).total_seconds()) / Decimal(3600))
base_total = Decimal(str(booking.total_price))
ai_hour_price = Decimal(str(suggestion["recommended_price"]))
ai_total = (ai_hour_price * hours).quantize(Decimal("0.01"))
booking.total_price = ai_total
booking.dynamic_pricing_applied = True
booking.ai_snapshot = {
"pricing": suggestion,
"calculated_at": timezone.now().isoformat(),
}
return PricingDecision({
**suggestion,
"applied_total": str(ai_total),
"hours": str(hours),
})
def attach_availability_forecast(booking, forecast: Dict[str, Any] | None = None) -> None:
if forecast:
booking.ai_snapshot = {
**(booking.ai_snapshot or {}),
"availability": forecast,
}

# File 41/163: ai\pricing.py
################################################################################

from __future__ import annotations
from pathlib import Path
from typing import Any, Dict, Optional
import joblib
import numpy as np
from django.conf import settings
from django.utils import timezone
from sklearn.ensemble import RandomForestRegressor
from core.utils import round_price
from parking.models import ParkingSpot
from .features import bookings_dataframe
MODEL_PATH = Path(getattr(settings, "BASE_DIR", ".")) / "ai_models" / "pricing_model.pkl"
def train_pricing_model(df=None) -> Optional[RandomForestRegressor]:
"""
Обучает простую RandomForest-модель для оценки цены за час.
"""
if df is None:
df = bookings_dataframe()
if df.empty or len(df) < 20:
return None
df = df.copy()
df["price_per_hour"] = df["price"] / df["duration_hours"].clip(lower=0.5)
X = df[["hour", "dow", "is_weekend"]].values
y = df["price_per_hour"].values
model = RandomForestRegressor(
n_estimators=50,
random_state=42,
n_jobs=-1,
)
model.fit(X, y)
MODEL_PATH.parent.mkdir(parents=True, exist_ok=True)
joblib.dump(model, MODEL_PATH)
return model
def load_pricing_model() -> Optional[RandomForestRegressor]:
if not MODEL_PATH.exists():
return None
try:
model: RandomForestRegressor = joblib.load(MODEL_PATH)
return model
except Exception:
return None
def recommend_price_for_spot(spot: ParkingSpot) -> Optional[Dict[str, Any]]:
"""
Возвращает диапазон рекомендованных цен для владельца места.
Учитывает:
- базовую цену;
- загрузку места за 7 дней (occupancy_7d);
- (по возможности) предсказание ML‑модели.
"""
base_price = float(spot.hourly_price or 0.0)
if base_price <= 0:
return None
now = timezone.now()
features = np.array([[now.hour, now.weekday(), 1 if now.weekday() >= 5 else 0]])
model = load_pricing_model()
predicted = None
if model is not None:
try:
predicted_value = float(model.predict(features)[0])
if predicted_value > 0:
predicted = predicted_value
except Exception:
predicted = None
occupancy = float(getattr(spot, "occupancy_7d", 0.0) or 0.0)
factor = 1.0
reason_parts = []
if occupancy > 0.8:
factor += 0.15
reason_parts.append("место часто занято (высокая загрузка)")
elif occupancy < 0.3:
factor -= 0.1
reason_parts.append("место простаивает (низкая загрузка)")
if predicted is not None:
ai_price = round_price(predicted, step=5.0)
reason_parts.append("ML‑модель учитывает исторические цены по району")
else:
ai_price = base_price
recommended = round_price(ai_price * factor, step=5.0)
min_price = round_price(recommended * 0.9, step=5.0)
max_price = round_price(recommended * 1.1, step=5.0)
if not reason_parts:
reason_parts.append("используется базовая ставка и средняя загрузка")
reason = "На основе: " + "; ".join(reason_parts) + "."
return {
"base_price": base_price,
"recommended_price": recommended,
"min_price": min_price,
"max_price": max_price,
"reason": reason,
}

# File 42/163: ai\serializers.py
################################################################################



# File 43/163: ai\tasks.py
################################################################################

from __future__ import annotations
from datetime import timedelta
from celery import shared_task
from django.utils import timezone
from parking.models import Booking, ParkingLot, ParkingSpot
from .features import bookings_dataframe
from .pricing import train_pricing_model
@shared_task
def update_models() -> None:
"""
Периодически обучает модель цен и обновляет метрики загруженности.
Делает три вещи:
1) обучает/переобучает ML‑модель ценообразования;
2) считает occupancy_7d для активных мест;
3) считает stress_index для парковок (средняя загрузка мест).
"""
df = bookings_dataframe()
train_pricing_model(df)
now = timezone.now()
window_start = now - timedelta(days=7)
# 1–2. Обновляем occupancy_7d для мест
active_spots = ParkingSpot.objects.filter(
status=ParkingSpot.SpotStatus.ACTIVE,
lot__is_active=True,
lot__is_approved=True,
).select_related("lot")
total_period_hours = 24 * 7
for spot in active_spots:
qs = Booking.objects.filter(
spot=spot,
start_at__lt=now,
end_at__gt=window_start,
status__in=[
Booking.Status.CONFIRMED,
Booking.Status.ACTIVE,
Booking.Status.COMPLETED,
],
)
booked_hours = 0.0
for b in qs:
start = max(b.start_at, window_start)
end = min(b.end_at, now)
delta_h = max((end - start).total_seconds() / 3600.0, 0.0)
booked_hours += delta_h
occupancy = booked_hours / float(total_period_hours)
spot.occupancy_7d = max(0.0, min(occupancy, 1.0))
spot.save(update_fields=["occupancy_7d"])
# 3. Индекс загруженности по объектам парковки
lots = ParkingLot.objects.filter(is_active=True, is_approved=True)
for lot in lots:
spots = lot.spots.all()
if not spots:
lot.stress_index = 0.0
lot.save(update_fields=["stress_index"])
continue
values = [max(0.0, min(s.occupancy_7d, 1.0)) for s in spots]
lot.stress_index = sum(values) / len(values)
lot.save(update_fields=["stress_index"])

# File 44/163: ai\views.py
################################################################################

# backend/ai/views.py
from __future__ import annotations
import logging
from typing import Any
from uuid import UUID, uuid4
from asgiref.sync import async_to_sync
from django.utils import timezone
from rest_framework import status
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView
from parking.models import ParkingLot, ParkingSpot
from ai.pricing import recommend_price_for_spot
from ai.models import ChatFeedback, ChatMessage, ChatSession, DeviceProfile, UiEvent
from ai.chat import generate_chat_reply
from services.llm import check_llm_health
logger = logging.getLogger(__name__)
class RecommendationsAPIView(APIView):
"""
Реальные AI-рекомендации по парковкам.
Пример:
GET /api/ai/recommendations/?city=Москва&limit=10
"""
def get(self, request, *args: Any, **kwargs: Any) -> Response:
city = request.query_params.get("city")
limit = int(request.query_params.get("limit", 10))
qs = ParkingSpot.objects.filter(
status=ParkingSpot.SpotStatus.ACTIVE,
lot__is_active=True,
lot__is_approved=True,
).select_related("lot")
if city:
qs = qs.filter(lot__city__iexact=city)
# Сначала берём самые "менее загруженные" и дешёвые места
qs = qs.order_by("lot__stress_index", "hourly_price")[: limit * 2]
recommendations: list[dict[str, Any]] = []
now = timezone.now()
for spot in qs[:limit]:
try:
pricing = recommend_price_for_spot(spot)
except Exception:
pricing = None
rec: dict[str, Any] = {
"spot_id": str(spot.id),
"lot_id": str(spot.lot_id),
"lot_name": spot.lot.name,
"city": spot.lot.city,
"address": spot.lot.address,
"vehicle_type": spot.get_vehicle_type_display(),
"hourly_price": float(spot.hourly_price or 0),
"occupancy_7d": float(spot.occupancy_7d or 0.0),
"stress_index": float(spot.lot.stress_index or 0.0),
"is_covered": spot.is_covered,
"has_ev_charging": spot.has_ev_charging,
"is_24_7": spot.is_24_7,
"now": now,
}
if pricing:
rec.update(
{
"ai_recommended_hourly_price": float(
pricing.get("recommended_price", 0.0)
),
"ai_base_price": float(pricing.get("base_price", 0.0)),
"ai_min_price": float(pricing.get("min_price", 0.0)),
"ai_max_price": float(pricing.get("max_price", 0.0)),
"ai_reason": pricing.get("reason", ""),
"ai_discount_percent": float(
pricing.get("discount_percent") or 0.0
),
"ai_is_discount": bool(pricing.get("is_discount") or False),
}
)
recommendations.append(rec)
return Response(
{
"count": len(recommendations),
"results": recommendations,
},
status=status.HTTP_200_OK,
)
class StressIndexAPIView(APIView):
"""
Реальный индекс загруженности по городам / парковкам.
Пример:
GET /api/ai/stress-index/
GET /api/ai/stress-index/?city=СПб
"""
def get(self, request, *args: Any, **kwargs: Any) -> Response:
city = request.query_params.get("city")
lots_qs = ParkingLot.objects.filter(is_active=True, is_approved=True)
if city:
lots_qs = lots_qs.filter(city__iexact=city)
lots = list(
lots_qs.values(
"id",
"name",
"city",
"address",
"stress_index",
)
)
if not lots:
return Response(
{
"stress_index": 0.0,
"lots": [],
"details": "Нет активных парковок для выбранного фильтра",
},
status=status.HTTP_200_OK,
)
values = [float(l["stress_index"] or 0.0) for l in lots]
avg = sum(values) / len(values)
max_val = max(values)
min_val = min(values)
return Response(
{
"stress_index": round(avg, 3),
"min": round(min_val, 3),
"max": round(max_val, 3),
"lots": lots,
},
status=status.HTTP_200_OK,
)
class DepartureAssistantAPIView(APIView):
"""
Простейший помощник по времени выезда (пока без внешних API).
Принимает:
POST /api/ai/departure-assistant/
{
"desired_arrival_iso": "2025-11-22T19:00:00+03:00",
"parking_buffer_minutes": 10,
"traffic_buffer_minutes": 20
}
"""
def post(self, request, *args: Any, **kwargs: Any) -> Response:
from datetime import timedelta
from django.utils.dateparse import parse_datetime
desired_arrival_iso = request.data.get("desired_arrival_iso")
parking_buffer = int(request.data.get("parking_buffer_minutes", 10))
traffic_buffer = int(request.data.get("traffic_buffer_minutes", 20))
if not desired_arrival_iso:
return Response(
{
"detail": "Нужен параметр desired_arrival_iso в ISO-формате",
},
status=status.HTTP_400_BAD_REQUEST,
)
desired_arrival = parse_datetime(desired_arrival_iso)
if desired_arrival is None:
return Response(
{
"detail": "Не удалось распарсить desired_arrival_iso",
},
status=status.HTTP_400_BAD_REQUEST,
)
total_buffer = timedelta(
minutes=parking_buffer + traffic_buffer,
)
suggested_departure = desired_arrival - total_buffer
return Response(
{
"suggested_departure_time": suggested_departure,
"desired_arrival_time": desired_arrival,
"parking_buffer_minutes": parking_buffer,
"traffic_buffer_minutes": traffic_buffer,
"message": "Пока без пробок/погоды, но уже считает буферы времени.",
},
status=status.HTTP_200_OK,
)
class ParkingChatAPIView(APIView):
"""Мини-чатбот для подсказок по парковке."""
permission_classes = [AllowAny]
def post(self, request, *args, **kwargs):
data = request.data or {}
message = data.get("message") or ""
history = data.get("history") or []
logger.info(
"Parking chat API request",
extra={
"message": str(message)[:200],
"history_len": len(history),
"user": getattr(request.user, "id", None),
"ip": request.META.get("REMOTE_ADDR"),
"ua": request.META.get("HTTP_USER_AGENT"),
},
)
sid_raw = request.COOKIES.get("ps_chat_sid")
try:
sid = UUID(sid_raw) if sid_raw else uuid4()
except (ValueError, TypeError):
sid = uuid4()
session, _ = ChatSession.objects.get_or_create(
id=sid,
defaults={
"user": request.user if request.user.is_authenticated else None,
"client_info": {
"ua": request.META.get("HTTP_USER_AGENT"),
"ip": request.META.get("REMOTE_ADDR"),
},
},
)
if request.user.is_authenticated and session.user is None:
session.user = request.user
session.save(update_fields=["user", "last_activity_at"])
ChatMessage.objects.create(
session=session,
role=ChatMessage.Role.USER,
text=message,
meta={"history": history},
)
try:
logger.info(
"Parking chat request received",
extra={"message": message, "session": str(session.id)},
)
result = generate_chat_reply(
message,
history,
request.user if request.user.is_authenticated else None,
)
except Exception as exc:
logger.exception("Parking chat failed", exc_info=exc)
result = {
"reply": "Извините, ассистент временно недоступен.",
"suggestions": [],
"reason": "assistant_error",
}
status_code = status.HTTP_503_SERVICE_UNAVAILABLE
else:
status_code = status.HTTP_200_OK
assistant_message = ChatMessage.objects.create(
session=session,
role=ChatMessage.Role.ASSISTANT,
text=result.get("reply", ""),
meta={"suggested_spots": result.get("suggestions", [])},
)
response = Response(
{
"reply": result.get("reply"),
"suggestions": result.get("suggestions", []),
"message_id": assistant_message.id,
"reason": result.get("reason"),
},
status=status_code,
)
response.set_cookie("ps_chat_sid", str(session.id), max_age=60 * 60 * 24 * 30, httponly=False)
return response
class LLMServiceHealthAPIView(APIView):
permission_classes = [AllowAny]
def get(self, request, *args, **kwargs):
try:
health = async_to_sync(check_llm_health)()
except Exception as exc:
logger.warning("LLM health check failed", exc_info=exc)
return Response(
{"ok": False, "detail": str(exc)},
status=status.HTTP_503_SERVICE_UNAVAILABLE,
)
return Response(health, status=status.HTTP_200_OK if health.get("ok") else status.HTTP_503_SERVICE_UNAVAILABLE)
class ChatFeedbackAPIView(APIView):
permission_classes = [AllowAny]
def post(self, request, *args, **kwargs):
message_id = request.data.get("message_id")
rating = int(request.data.get("rating", 0))
if message_id is None:
return Response({"detail": "message_id required"}, status=status.HTTP_400_BAD_REQUEST)
try:
message = ChatMessage.objects.get(id=message_id)
except ChatMessage.DoesNotExist:
return Response({"detail": "message not found"}, status=status.HTTP_404_NOT_FOUND)
feedback = ChatFeedback.objects.create(message=message, rating=rating)
return Response({"id": feedback.id, "rating": feedback.rating}, status=status.HTTP_201_CREATED)
# ===== ParkMate AI — конфиг и предсказания (price/availability) =====
class ParkMateConfigAPIView(APIView):
"""
AI‑помощник адаптивности:
- принимает телеметрию клиента (viewport, pixelRatio, platform);
- создаёт/обновляет DeviceProfile;
- записывает UiEvent;
- возвращает layout_profile / design_mode / theme.
"""
permission_classes = [AllowAny]
def post(self, request, *args: Any, **kwargs: Any) -> Response:
data = request.data or {}
client = data.get("client") or {}
action = data.get("action") or "adaptive-profile"
width = int(client.get("width") or 0)
height = int(client.get("height") or 0)
pixel_ratio = float(client.get("pixelRatio") or client.get("pixel_ratio") or 1.0)
platform = (client.get("platform") or "RU")[:8]
device_id = (request.COOKIES.get("ps_device_id") or client.get("deviceId") or "anonymous")[:64]
user_agent = request.META.get("HTTP_USER_AGENT", "")[:1024]
# Эвристика layout‑профиля
if width < 640:
layout = DeviceProfile.LayoutProfile.COMPACT
elif width < 1024:
layout = DeviceProfile.LayoutProfile.COMFORTABLE
else:
layout = DeviceProfile.LayoutProfile.COMFORTABLE
design_mode = "pwa" if width < 1024 else "desktop"
user = request.user if request.user.is_authenticated else None
profile, _ = DeviceProfile.objects.get_or_create(
device_id=device_id,
user=user,
defaults={
"viewport_width": width,
"viewport_height": height,
"pixel_ratio": pixel_ratio,
"user_agent": user_agent,
"layout_profile": layout,
},
)
# Обновляем основные параметры
profile.viewport_width = width
profile.viewport_height = height
profile.pixel_ratio = pixel_ratio
profile.layout_profile = layout
profile.save(update_fields=["viewport_width", "viewport_height", "pixel_ratio", "layout_profile", "updated_at"])
UiEvent.objects.create(
device_profile=profile,
event_type=action,
payload={
"width": width,
"height": height,
"pixel_ratio": pixel_ratio,
"platform": platform,
},
)
return Response(
{
"layout_profile": layout,
"design_mode": design_mode,
"theme": profile.theme,
}
)
def get(self, request, *args: Any, **kwargs: Any) -> Response:
"""
Возвращает фронту конфиг ParkMateAI (контракты/URL‑ы сервисов).
Формат согласован с static/js/parkmate-ai.ts (ParkMateAI).
"""
data = {
"voiceCommands": {
"booking": "Забронировать парковку рядом",
"navigation": "Построить маршрут до парковки",
"payment": "Оплатить текущую парковку",
"support": "Связаться с поддержкой ParkShare",
},
"computerVision": {
"licensePlateRecognition": "/api/ai/cv/license-plate/",
"parkingSpotDetection": "/api/ai/cv/parking-occupancy/",
"damageDetection": "/api/ai/cv/vehicle-damage/",
"occupancyAnalytics": "/api/ai/stress-index/",
},
"predictions": {
"arrivalTime": "/api/ai/departure-assistant/",
"priceForecast": "/api/ai/parkmate/price-forecast/",
"availability": "/api/ai/parkmate/availability/",
},
}
return Response(data, status=status.HTTP_200_OK)
# Остальные классы (RecommendationsAPIView, StressIndexAPIView, DepartureAssistantAPIView,
# ParkMatePriceForecastAPIView, ParkMateAvailabilityForecastAPIView) остаются без изменений
class ParkMatePriceForecastAPIView(APIView):
"""
Эндпоинт ParkMate для прогноза цены по конкретному месту.
POST /api/ai/parkmate/price-forecast/
{
"spot_id": "uuid"
}
"""
permission_classes = [AllowAny]
def post(self, request, *args: Any, **kwargs: Any) -> Response:
from django.shortcuts import get_object_or_404
spot_id = request.data.get("spot_id")
if not spot_id:
return Response(
{"detail": "spot_id is required."},
status=status.HTTP_400_BAD_REQUEST,
)
spot = get_object_or_404(
ParkingSpot,
pk=spot_id,
status=ParkingSpot.SpotStatus.ACTIVE,
lot__is_active=True,
lot__is_approved=True,
)
pricing = recommend_price_for_spot(spot)
if not pricing:
return Response(
{"detail": "AI pricing is not available for this spot."},
status=status.HTTP_404_NOT_FOUND,
)
base_price = float(pricing.get("base_price", 0.0))
recommended_price = float(pricing.get("recommended_price", base_price))
min_price = float(pricing.get("min_price", recommended_price))
max_price = float(pricing.get("max_price", recommended_price))
discount_percent = float(pricing.get("discount_percent") or 0.0)
is_discount = bool(pricing.get("is_discount") or False)
data = {
"spot_id": str(spot.id),
"lot_id": str(spot.lot_id),
"currency": "RUB",
"base_price": base_price,
"recommended_price": recommended_price,
"min_price": min_price,
"max_price": max_price,
"discount_percent": discount_percent,
"is_discount": is_discount,
"reason": pricing.get("reason", ""),
}
return Response(data, status=status.HTTP_200_OK)
class ParkMateAvailabilityForecastAPIView(APIView):
"""
Эндпоинт ParkMate для прогноза доступности места.
POST /api/ai/parkmate/availability/
{
"spot_id": "uuid"
"occupancy_7d": 0.4,
"stress_index": 0.5
}
"""
permission_classes = [AllowAny]
def post(self, request, *args: Any, **kwargs: Any) -> Response:
from django.shortcuts import get_object_or_404
spot_id = request.data.get("spot_id")
occupancy_7d = request.data.get("occupancy_7d")
stress_index = request.data.get("stress_index")
spot = None
if spot_id:
spot = get_object_or_404(
ParkingSpot,
pk=spot_id,
status=ParkingSpot.SpotStatus.ACTIVE,
lot__is_active=True,
lot__is_approved=True,
)
occupancy_7d = float(spot.occupancy_7d or 0.0)
stress_index = float(spot.lot.stress_index or 0.0)
else:
try:
occupancy_7d = float(occupancy_7d or 0.0)
stress_index = float(stress_index or 0.0)
except (TypeError, ValueError):
return Response(
{
"detail": (
"occupancy_7d и stress_index должны быть числами, "
"если не передан spot_id."
)
},
status=status.HTTP_400_BAD_REQUEST,
)
# Нормализация
occupancy_7d = max(0.0, min(float(occupancy_7d), 1.0))
stress_index = max(0.0, min(float(stress_index), 1.0))
# Простая эвристика: чем выше загрузка/стресс, тем ниже вероятность доступности
base_avail = 1.0 - 0.7 * occupancy_7d - 0.3 * stress_index
base_avail = max(0.0, min(base_avail, 1.0))
next_1h = round(base_avail, 3)
next_3h = round(max(0.0, base_avail - 0.1), 3)
next_24h = round(max(0.0, base_avail - 0.2), 3)
now = timezone.now()
data = {
"spot_id": str(spot.id) if spot else None,
"occupancy_7d": occupancy_7d,
"stress_index": stress_index,
"as_of": now,
"availability": {
"next_1h": next_1h,
"next_3h": next_3h,
"next_24h": next_24h,
},
}
return Response(data, status=status.HTTP_200_OK)

# File 45/163: ai\chat\__init__.py
################################################################################

"""Chat helpers for local parking assistant."""
from .parking_assistant import generate_chat_reply
__all__ = ["generate_chat_reply"]

# File 46/163: ai\chat\parking_assistant.py
################################################################################

"""
Умный помощник подбирает парковки по текстовому запросу, используя
простые правила и существующие данные модели парковок. При желании сюда
можно подключить обученные NLP-модели.
"""
from __future__ import annotations
import logging
import random
import re
from functools import lru_cache
from typing import Any, Dict, Iterable, List, Optional, Tuple
try:
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
except Exception:
TfidfVectorizer = None
cosine_similarity = None
from asgiref.sync import async_to_sync
from django.contrib.auth import get_user_model
from django.db.models import Q
from parking.models import ParkingSpot
from services.llm import LLMClientError, parse_search_query
User = get_user_model()
logger = logging.getLogger(__name__)
def _extract_budget(text: str) -> Optional[int]:
match = re.search(r"(\d{2,5})\s*(?:₽|р|руб)", text)
if match:
try:
return int(match.group(1))
except ValueError:
return None
return None
def _extract_time_hint(text: str) -> str:
if "завтра" in text:
return "на завтра"
if "ноч" in text:
return "на ночь"
if re.search(r"\b(\d{1,2})\s*[-–]\s*(\d{1,2})\b", text):
return "в указанное окно времени"
if "сейчас" in text or "прямо сейчас" in text:
return "на ближайший час"
return "скоро"
INTENT_CORPUS: list[tuple[str, str]] = [
("ev", "зарядка для электромобиля ev электромобиль tesla leaf"),
("budget", "самая дешёвая дёшево бюджет эконом"),
("night", "ночь ночевка оставить на ночь круглосуточно"),
("covered", "крытая парковка подземная защита от дождя"),
("fast", "сейчас ближайшая возле меня рядом срочно прямо сейчас"),
]
@lru_cache(maxsize=1)
def _intent_vectorizer():
if not TfidfVectorizer:
return None, None
labels, texts = zip(*INTENT_CORPUS)
vect = TfidfVectorizer(stop_words=None)
matrix = vect.fit_transform(texts)
return vect, (labels, matrix)
def _detect_intents(text: str) -> list[str]:
vect, payload = _intent_vectorizer()
if not vect or not payload:
return []
labels, matrix = payload
query_vec = vect.transform([text])
sims = cosine_similarity(query_vec, matrix).flatten()
ranked: list[Tuple[float, str]] = sorted(zip(sims, labels), reverse=True)
return [lbl for score, lbl in ranked if score > 0.18][:3]
def _build_base_queryset() -> Iterable[ParkingSpot]:
return (
ParkingSpot.objects.filter(
status=ParkingSpot.SpotStatus.ACTIVE,
lot__is_active=True,
lot__is_approved=True,
)
.select_related("lot")
)
def _parse_with_llm(text: str) -> dict[str, Any] | None:
"""Try to parse a query using the external LLM service.
Returns None if the service is unavailable or any error occurs so that we can
gracefully fallback to the rule-based parsing.
"""
try:
logger.info(
"Invoking LLM parser for chat message",
extra={"query": text[:200]},
)
parsed = async_to_sync(parse_search_query)(text)
logger.info(
"LLM parsed query",
extra={"query": text, "parsed": parsed},
)
return parsed
except (LLMClientError, ValueError) as exc:
logger.warning(
"LLM parsing failed, using rule-based fallback",
extra={"query": text},
exc_info=exc,
)
except Exception as exc:
logger.exception(
"Unexpected LLM parse error, using fallback", extra={"query": text}
)
return None
def _apply_llm_filters(queryset, payload: dict[str, Any]):
q_filter = Q()
city = payload.get("city")
if city:
q_filter &= Q(lot__city__iexact=city) | Q(lot__address__icontains=city)
if payload.get("has_ev_charging") is True:
q_filter &= Q(has_ev_charging=True)
if payload.get("covered") is True:
q_filter &= Q(is_covered=True)
max_price = payload.get("max_price_per_hour")
if max_price is not None:
try:
q_filter &= Q(hourly_price__lte=float(max_price))
except (TypeError, ValueError):
logger.debug("Skip invalid max_price_per_hour", extra={"value": max_price})
near_metro = payload.get("near_metro")
if near_metro:
q_filter &= Q(lot__address__icontains="метро") | Q(lot__name__icontains="метро")
if q_filter:
queryset = queryset.filter(q_filter)
return queryset
def _apply_intents(queryset, text: str):
lowered = text.lower()
q_filter = Q()
intents = set(_detect_intents(lowered))
if "ev" in lowered or "заряд" in lowered or "электро" in lowered or "ev" in intents:
q_filter &= Q(has_ev_charging=True)
if "крыт" in lowered or "covered" in intents:
q_filter &= Q(is_covered=True)
if "24/7" in lowered or "круглосуточ" in lowered or "night" in intents:
q_filter &= Q(is_24_7=True)
if "budget" in intents:
q_filter &= Q(hourly_price__lte=300)
metro_match = re.search(r"метро\s+([\wёЁ\-\s]+)", lowered)
if metro_match:
station = metro_match.group(1).strip()
q_filter &= Q(lot__address__icontains=station) | Q(lot__name__icontains=station)
address_match = re.search(r"(ул\.|улица|проспект|шоссе|пл\.|площадь)\s+([\wёЁ\s\-]+)", lowered)
if address_match:
fragment = address_match.group(0)
q_filter &= Q(lot__address__icontains=fragment)
budget = _extract_budget(lowered)
if budget:
q_filter &= Q(hourly_price__lte=budget)
if q_filter:
queryset = queryset.filter(q_filter)
return queryset, intents
def _spot_payload(spot: ParkingSpot) -> dict[str, Any]:
tags = []
if spot.has_ev_charging:
tags.append("EV")
if spot.is_covered:
tags.append("крытая")
if spot.is_24_7:
tags.append("24/7")
if getattr(spot, "allow_dynamic_pricing", False):
tags.append("AI")
return {
"spot_id": str(spot.id),
"title": f"{spot.lot.name} — {spot.name}",
"price": float(spot.hourly_price or 0),
"distance_m": getattr(spot, "distance_km", None) * 1000 if getattr(spot, "distance_km", None) else None,
"tags": tags,
"occupancy_now": float(getattr(spot, "occupancy_7d", 0.0) or 0.0),
}
def _compose_reply(context: dict[str, Any], count: int) -> str:
templates = [
"Нашёл для вас {count} вариантов около {area}. Цены от {min_price} до {max_price} ₽/час. Сейчас свободно примерно {availability}%.",
"Подобрал {count} парковок {time_hint}. Минимальный тариф {min_price} ₽/час, максимальный {max_price} ₽/час.",
"Есть {count} подходящих мест {area}. Чтобы расширить выбор, можно скорректировать бюджет {budget_hint}.",
]
area = context.get("area") or "рядом"
min_price = context.get("min_price", 0)
max_price = context.get("max_price", max(min_price, min_price + 50))
availability = context.get("availability", 60)
budget_hint = f"до {context['budget']} ₽" if context.get("budget") else "или радиус"
time_hint = context.get("time_hint", "")
template = random.choice(templates)
return template.format(
count=count or 0,
area=area,
min_price=min_price,
max_price=max_price,
availability=availability,
budget_hint=budget_hint,
time_hint=time_hint,
)
def _llm_time_hint(payload: dict[str, Any]) -> str:
start_at = payload.get("start_at")
end_at = payload.get("end_at")
if start_at and end_at:
return "на выбранный интервал"
if start_at:
return "к указанному времени"
return "скоро"
def _prepare_context(
spots: list[ParkingSpot], area: Optional[str], budget: Optional[int], time_hint: str
) -> dict[str, Any]:
prices = [float(s.hourly_price or 0) for s in spots] or [0]
return {
"area": area or "рядом",
"min_price": int(min(prices)),
"max_price": int(max(prices)),
"availability": int(
100
- (sum([float(getattr(s, "occupancy_7d", 0.0) or 0) for s in spots]) / len(prices))
* 100
)
if spots
else 0,
"budget": budget,
"time_hint": time_hint,
}
def _reply_payload(spots: list[ParkingSpot], context: dict[str, Any], reasoning: str) -> dict[str, Any]:
suggestions = [_spot_payload(spot) for spot in spots][:6]
if not suggestions:
reply = "Сейчас нет парковок под эти условия. Попробуйте увеличить бюджет или выбрать другой район."
reasoning = reasoning or "Запрос слишком узкий или в базе пока нет подходящих мест."
else:
reply = _compose_reply(context, len(suggestions))
return {
"reply": reply,
"suggestions": suggestions,
"reason": reasoning,
"intents": context.get("intents", []),
}
def _handle_llm_flow(text: str):
parsed = _parse_with_llm(text)
if not parsed:
logger.debug(
"LLM returned no result; will use rule-based fallback",
extra={"query": text[:120]},
)
return None
qs = _apply_llm_filters(_build_base_queryset(), parsed)
qs = qs.order_by("lot__stress_index", "hourly_price")[:12]
spots = list(qs)
area_hint = None
if parsed.get("near_metro"):
area_hint = "рядом с метро"
if parsed.get("city"):
area_hint = parsed["city"]
budget = parsed.get("max_price_per_hour")
time_hint = _llm_time_hint(parsed)
context = _prepare_context(spots, area_hint, budget, time_hint)
reasoning_parts = ["LLM разобрал намерение пользователя"]
if parsed.get("has_ev_charging"):
reasoning_parts.append("учтена EV-зарядка")
if parsed.get("covered"):
reasoning_parts.append("оставлены крытые места")
if budget:
reasoning_parts.append("отфильтровано по бюджету")
context["intents"] = []
return _reply_payload(spots, context, ", ".join(reasoning_parts))
def _handle_rule_based_flow(lowered: str):
qs, intents = _apply_intents(_build_base_queryset(), lowered)
budget = _extract_budget(lowered)
if budget:
qs = qs.filter(hourly_price__lte=budget)
qs = qs.order_by("lot__stress_index", "hourly_price")[:12]
spots = list(qs)
area_hint = None
metro_match = re.search(r"метро\s+([\wёЁ\-\s]+)", lowered)
if metro_match:
area_hint = f"у метро {metro_match.group(1).strip().title()}"
time_hint = _extract_time_hint(lowered)
context = _prepare_context(spots, area_hint, budget, time_hint)
context["intents"] = list(intents)
why = []
if "ev" in intents:
why.append("учёл наличие EV-зарядки")
if "budget" in intents or budget:
why.append("отсортировал по цене")
if "night" in intents:
why.append("оставил только круглосуточные")
reasoning = ", ".join(why) if why else "использовал ближайшие и менее загруженные места"
return _reply_payload(spots, context, reasoning)
def generate_chat_reply(message: str, history: Optional[List[dict]], user: Optional[User]) -> dict[str, Any]:
text = (message or "").strip()
logger.info(
"Incoming parking chat message",
extra={
"message": text[:200],
"history_len": len(history or []),
"user": getattr(user, "id", None),
},
)
if not text:
logger.info("Empty chat message, returning friendly prompt")
return {
"reply": "Опишите время, адрес или метро — подберу парковку.",
"suggestions": [],
"reason": "empty_message",
}
lowered = text.lower()
try:
llm_response = _handle_llm_flow(text)
if llm_response:
return llm_response
except Exception as exc:
logger.exception("LLM flow errored, forcing rule-based fallback", exc_info=exc)
logger.info("Falling back to rule-based parser")
return _handle_rule_based_flow(lowered)

# File 47/163: ai\management\__init__.py
################################################################################



# File 48/163: ai\management\commands\__init__.py
################################################################################



# File 49/163: ai\management\commands\train_chat_intents_from_logs.py
################################################################################

from django.core.management.base import BaseCommand
from ai.models import ChatMessage
class Command(BaseCommand):
help = "Проходится по логам чата и подготавливает данные для обучения NLP/intent моделей."
def handle(self, *args, **options):
total = ChatMessage.objects.count()
assistant_messages = ChatMessage.objects.filter(role=ChatMessage.Role.ASSISTANT).count()
user_messages = total - assistant_messages
self.stdout.write(self.style.SUCCESS("Всего сообщений: %s" % total))
self.stdout.write(f"Ответов ассистента: {assistant_messages}")
self.stdout.write(f"Сообщений пользователей: {user_messages}")
# TODO: выгружать диалоги и обучать намерения
self.stdout.write("Подготовка к обучению завершена (заглушка).")

# File 50/163: ai\migrations\0001_initial.py
################################################################################

# Generated manually to include initial AI models
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import uuid
class Migration(migrations.Migration):
initial = True
dependencies = [
migrations.swappable_dependency(settings.AUTH_USER_MODEL),
]
operations = [
migrations.CreateModel(
name='ChatSession',
fields=[
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('client_info', models.JSONField(blank=True, null=True, verbose_name='Данные клиента')),
('last_activity_at', models.DateTimeField(auto_now=True, verbose_name='Последняя активность')),
('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='chat_sessions', to=settings.AUTH_USER_MODEL)),
],
options={
'verbose_name': 'Сессия чата',
'verbose_name_plural': 'Сессии чата',
},
),
migrations.CreateModel(
name='DeviceProfile',
fields=[
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('device_id', models.CharField(db_index=True, max_length=64, verbose_name='ID устройства')),
('viewport_width', models.IntegerField(blank=True, null=True, verbose_name='Ширина viewport')),
('viewport_height', models.IntegerField(blank=True, null=True, verbose_name='Высота viewport')),
('pixel_ratio', models.FloatField(blank=True, null=True, verbose_name='Pixel ratio')),
('user_agent', models.TextField(blank=True, verbose_name='User‑Agent')),
('layout_profile', models.CharField(choices=[('compact', 'Компактный'), ('comfortable', 'Комфортный')], default='compact', max_length=32, verbose_name='Профиль компоновки')),
('theme', models.CharField(choices=[('light', 'Светлая'), ('dark', 'Тёмная'), ('system', 'Системная')], default='system', max_length=16, verbose_name='Тема')),
('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='device_profiles', to=settings.AUTH_USER_MODEL)),
],
options={
'verbose_name': 'Профиль устройства',
'verbose_name_plural': 'Профили устройств',
'unique_together': {('device_id', 'user')},
},
),
migrations.CreateModel(
name='UiEvent',
fields=[
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('event_type', models.CharField(max_length=64, verbose_name='Тип события')),
('payload', models.JSONField(blank=True, null=True, verbose_name='Payload')),
('device_profile', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='events', to='ai.deviceprofile')),
],
options={
'verbose_name': 'UI‑событие',
'verbose_name_plural': 'UI‑события',
},
),
migrations.CreateModel(
name='ChatMessage',
fields=[
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('role', models.CharField(choices=[('user', 'User'), ('assistant', 'Assistant')], max_length=16, verbose_name='Роль')),
('text', models.TextField(verbose_name='Текст')),
('meta', models.JSONField(blank=True, null=True, verbose_name='Метаданные')),
('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='messages', to='ai.chatsession')),
],
options={
'verbose_name': 'Сообщение чата',
'verbose_name_plural': 'Сообщения чата',
'ordering': ('-created_at',),
},
),
migrations.CreateModel(
name='ChatFeedback',
fields=[
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('rating', models.IntegerField(default=0, verbose_name='Оценка')),
('message', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='feedback', to='ai.chatmessage')),
],
options={
'verbose_name': 'Фидбек чата',
'verbose_name_plural': 'Фидбек чата',
'ordering': ('-created_at',),
},
),
]

# File 51/163: ai\migrations\__init__.py
################################################################################



# File 52/163: ai_services\__init__.py
################################################################################

"""
AI microservices for ParkShare / ParkShare RU.
Содержит отдельные FastAPI‑приложения:
- ai_pricing_service: динамическое ценообразование;
- cv_service: Computer Vision (распознавание номеров, заполненность и т.д.).
"""

# File 53/163: ai_services\ai_pricing_service\__init__.py
################################################################################

"""
AI Pricing microservice (FastAPI) for dynamic parking spot pricing.
"""

# File 54/163: ai_services\ai_pricing_service\main.py
################################################################################

from __future__ import annotations
from decimal import Decimal, ROUND_HALF_UP
from typing import Optional
from fastapi import FastAPI
from pydantic import BaseModel, Field
app = FastAPI(
title="ParkShare AI Pricing Service",
version="0.1.0",
description=(
"Отдельный микросервис ParkMate AI для динамического ценообразования "
"парковочных мест. Пока использует простые эвристики, но интерфейс "
"готов для подключения CatBoost/Transformer‑моделей."
),
)
def round_price(value: float, step: float = 10.0) -> float:
"""
Локальная реализация round_price, не зависящая от Django.
Округляет цену к ближайшему step (по умолчанию 10 ₽).
"""
if step <= 0:
return float(Decimal(str(value)).quantize(Decimal("0.01")))
v = Decimal(str(value))
step_dec = Decimal(str(step))
scaled = (v / step_dec).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
result = scaled * step_dec
return float(result)
# ai_services/ai_pricing_service/main.py
class PricingRequest(BaseModel):
base_price: float = Field(
...,
gt=0,
description="Базовая цена за час, ₽",
)
occupancy_7d: float = Field(
0.0,
ge=0.0,
le=1.0,
description="Загруженность места за последние 7 дней (0..1)",
)
stress_index: float = Field(
0.0,
ge=0.0,
le=1.0,
description="Индекс загруженности парковки (0..1)",
)
hour: Optional[int] = Field(
None,
ge=0,
le=23,
description="Час суток (0–23, локальное время парковки)",
)
dow: Optional[int] = Field(
None,
ge=0,
le=6,
description="День недели (0=понедельник, 6=воскресенье)",
)
use_ml: bool = Field(
False,
description=(
"Флаг для использования ML‑модели (зарезервировано; "
"пока используется только эвристика)."
),
)
class PricingResponse(BaseModel):
base_price: float
recommended_price: float
min_price: float
max_price: float
discount_percent: float
is_discount: bool
reason: str
@app.get("/health", tags=["health"])
def health() -> dict:
"""
Простой healthcheck.
"""
return {"status": "ok"}
@app.post(
"/api/v1/pricing/recommend",
response_model=PricingResponse,
tags=["pricing"],
summary="Получить рекомендованную цену за час",
)
def recommend_price(payload: PricingRequest) -> PricingResponse:
"""
Эвристическое ценообразование на основе:
- базовой цены;
- загруженности места/парковки;
- времени суток (час пик / не час пик).
В дальнейшем сюда можно подставить CatBoost/Transformer‑модель.
"""
base_price = payload.base_price
occ = float(payload.occupancy_7d or 0.0)
stress = float(payload.stress_index or 0.0)
factor = 1.0
reasons: list[str] = []
# Загруженность места
if occ > 0.8:
factor += 0.15
reasons.append("место часто занято (высокая загруженность за 7 дней)")
elif occ < 0.3:
factor -= 0.10
reasons.append("место простаивает (низкая загруженность за 7 дней)")
# Стресс по парковке
if stress > 0.7:
factor += 0.10
reasons.append("высокий парковочный стресс по объекту")
elif stress < 0.3:
factor -= 0.05
reasons.append("низкий парковочный стресс по объекту")
# Время суток
if payload.hour is not None:
hour = payload.hour
if 8 <= hour <= 11 or 17 <= hour <= 21:
factor += 0.10
reasons.append("час пик")
else:
factor -= 0.05
reasons.append("не час пик")
# Ограничиваем фактор
if factor < 0.5:
factor = 0.5
if factor > 1.5:
factor = 1.5
recommended = round_price(base_price * factor, step=5.0)
min_price = round_price(recommended * 0.9, step=5.0)
max_price = round_price(recommended * 1.1, step=5.0)
# Скидка относительно базовой цены
discount_percent = 0.0
is_discount = False
if recommended < base_price:
diff = (base_price - recommended) / base_price
discount_percent = float(
(Decimal(str(diff)) * Decimal("100")).quantize(Decimal("0.1"))
)
is_discount = True
if not reasons:
reasons.append("используется только базовая ставка")
reason = "; ".join(reasons)
return PricingResponse(
base_price=base_price,
recommended_price=recommended,
min_price=min_price,
max_price=max_price,
discount_percent=discount_percent,
is_discount=is_discount,
reason=reason,
)

# File 55/163: ai_services\cv_service\__init__.py
################################################################################

"""
Computer Vision microservice (FastAPI) for ParkShare:
- распознавание номеров;
- оценка заполненности парковок по кадрам камер.
"""

# File 56/163: ai_services\cv_service\main.py
################################################################################

from __future__ import annotations
from datetime import datetime, timezone
from typing import Optional
from fastapi import FastAPI
from pydantic import BaseModel, Field, root_validator
app = FastAPI(
title="ParkShare CV Service",
version="0.1.0",
description=(
"Заглушечный CV‑сервис ParkMate AI. "
"Интерфейс готов под интеграцию OpenCV/ONNX/WebGPU‑моделей."
),
)
class LicensePlateRequest(BaseModel):
image_url: Optional[str] = Field(
None,
description="URL до кадра/фото с номером автомобиля (если используется серверная загрузка).",
)
image_base64: Optional[str] = Field(
None,
description="Base64‑кодированное изображение (если отправляем напрямую).",
)
region: str = Field("RU", description="Код региона/страны (например, RU, EU, US).")
@root_validator
def validate_source(cls, values):
if not values.get("image_url") and not values.get("image_base64"):
raise ValueError("Нужно передать либо image_url, либо image_base64.")
return values
class LicensePlateResponse(BaseModel):
plate: str
normalized_plate: str
region: str
confidence: float
class ParkingOccupancyRequest(BaseModel):
image_url: Optional[str] = Field(
None,
description="URL до кадра камеры с парковкой.",
)
camera_id: Optional[str] = Field(
None,
description="ID камеры/потока в вашем домене.",
)
total_slots: Optional[int] = Field(
None,
gt=0,
description="Общее количество мест (если известно заранее).",
)
@root_validator
def validate_source(cls, values):
if not values.get("image_url") and not values.get("camera_id"):
raise ValueError("Нужно указать image_url или camera_id.")
return values
class ParkingOccupancyResponse(BaseModel):
occupied_slots: int
total_slots: int
occupancy_rate: float = Field(..., ge=0.0, le=1.0)
timestamp: datetime
@app.get("/health", tags=["health"])
def health() -> dict:
return {"status": "ok"}
@app.post(
"/api/v1/cv/license-plate",
response_model=LicensePlateResponse,
tags=["cv"],
summary="Распознавание госномера (заглушка)",
)
def recognize_plate(payload: LicensePlateRequest) -> LicensePlateResponse:
"""
Заглушка для распознавания госномера.
Реальная логика должна вызывать модель (OpenCV+ONNX и т.п.).
"""
# TODO: заменить на вызов реальной модели/сервиса
fake_plate = "A000AA197"
normalized = fake_plate.replace(" ", "")
return LicensePlateResponse(
plate=fake_plate,
normalized_plate=normalized,
region=payload.region,
confidence=0.85,
)
@app.post(
"/api/v1/cv/parking-occupancy",
response_model=ParkingOccupancyResponse,
tags=["cv"],
summary="Оценка заполненности парковки по кадру (заглушка)",
)
def parking_occupancy(payload: ParkingOccupancyRequest) -> ParkingOccupancyResponse:
"""
Заглушка для оценки заполненности парковки:
- если total_slots известен, считаем примерно 50% занятости;
- если нет, предполагаем 20 мест и 40% занято.
"""
total_slots = payload.total_slots or 20
occupied_slots = max(1, int(total_slots * 0.4))
occupancy_rate = occupied_slots / float(total_slots)
return ParkingOccupancyResponse(
occupied_slots=occupied_slots,
total_slots=total_slots,
occupancy_rate=round(occupancy_rate, 3),
timestamp=datetime.now(timezone.utc),
)

# File 57/163: backend\manage.py
################################################################################

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys
from pathlib import Path
def main() -> None:
"""
Точка входа для manage.py.
ВАЖНО: добавляем корень репозитория в sys.path, чтобы пакеты
уровня `accounts`, `parking`, `payments` и т.п. корректно импортировались,
даже если запускаем `python backend/manage.py ...`.
"""
current_file = Path(__file__).resolve()
backend_dir = current_file.parent
project_root = backend_dir.parent
# Гарантируем, что корень проекта в PYTHONPATH
project_root_str = str(project_root)
if project_root_str not in sys.path:
sys.path.insert(0, project_root_str)
# Если переменная окружения не задана – по умолчанию используем dev-настройки
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings.local")
try:
from django.core.management import execute_from_command_line
except ImportError as exc:
raise ImportError(
"Не удалось импортировать Django. Убедись, что виртуальное "
"окружение активировано и зависимости установлены."
) from exc
execute_from_command_line(sys.argv)
if __name__ == "__main__":
main()

# File 58/163: backend\backend\__init__.py
################################################################################

from .config.celery import app as celery_app
__all__ = ("celery_app",)

# File 59/163: backend\backend\config\__init__.py
################################################################################

# Пустой, но важно наличия для импорта настроек и celery.

# File 60/163: backend\backend\config\asgi.py
################################################################################

import os
from django.core.asgi import get_asgi_application
settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module:
raise RuntimeError(
"DJANGO_SETTINGS_MODULE не задан. "
"Укажи backend.settings.local (dev) или backend.settings.production (prod)."
)
application = get_asgi_application()

# File 61/163: backend\backend\config\celery.py
################################################################################

# backend/backend/config/celery.py
from __future__ import annotations
import os
from celery import Celery
# 1) Проверяем, что DJANGO_SETTINGS_MODULE задан извне
settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module:
raise RuntimeError(
"DJANGO_SETTINGS_MODULE не задан. "
"Укажи backend.settings.local (dev) или backend.settings.production (prod) "
"в переменных окружения (например, в .env или unit-файле systemd)."
)
# 2) Создаём Celery-приложение
app = Celery("backend")
# 3) Читаем конфиг из Django settings, все переменные с префиксом CELERY_
app.config_from_object("django.conf:settings", namespace="CELERY")
# 4) Авто-обнаружение tasks.py во всех django-приложениях
app.autodiscover_tasks()
@app.task(bind=True)
def debug_task(self) -> None:
print(f"Debug task: Request: {self.request!r}")

# File 62/163: backend\backend\config\urls.py
################################################################################

from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.contrib.staticfiles import finders
from django.http import Http404, HttpResponse
from django.urls import include, path
from django.views.decorators.cache import never_cache
from django.views.generic import TemplateView
from drf_spectacular.views import (
SpectacularAPIView,
SpectacularRedocView,
SpectacularSwaggerView,
)
from rest_framework import routers
from accounts import views as accounts_api
from ai import views as ai_api
from parking import views as parking_views
from payments import views as payments_api
from vehicles import views as vehicles_api
router = routers.DefaultRouter()
# Accounts / пользователи (только API)
router.register(r"accounts/users", accounts_api.UserViewSet, basename="user")
# Vehicles
router.register(r"vehicles", vehicles_api.VehicleViewSet, basename="vehicle")
# Parking
router.register(r"parking/lots", parking_views.ParkingLotViewSet, basename="parking-lot")
router.register(r"parking/spots", parking_views.ParkingSpotViewSet, basename="parking-spot")
router.register(r"parking/bookings", parking_views.BookingViewSet, basename="booking")
router.register(r"parking/waitlist", parking_views.WaitlistViewSet, basename="waitlist")
router.register(r"parking/complaints", parking_views.ComplaintViewSet, basename="complaint")
router.register(
r"parking/favorites", parking_views.FavoriteParkingSpotViewSet, basename="favorite-spot"
)
router.register(
r"parking/saved-places", parking_views.SavedPlaceViewSet, basename="saved-place"
)
# Payments
router.register(r"payments", payments_api.PaymentViewSet, basename="payment")
router.register(
r"payment-methods", payments_api.PaymentMethodViewSet, basename="payment-method"
)
router.register(
r"payments/methods", payments_api.PaymentMethodViewSet, basename="payment-method-nested"
)
@never_cache
def service_worker(request):
"""
Отдаём service-worker.js с корня домена, но физически он лежит в static/.
"""
path = finders.find("service-worker.js")
if not path:
raise Http404("Service worker not found")
with open(path, "rb") as f:
content = f.read()
return HttpResponse(content, content_type="application/javascript")
@never_cache
def manifest(request):
"""
Отдаём manifest.webmanifest с правильным content-type.
"""
path = finders.find("manifest.webmanifest")
if not path:
raise Http404("Manifest not found")
with open(path, "rb") as f:
content = f.read()
return HttpResponse(content, content_type="application/manifest+json")
urlpatterns = [
path("admin/", admin.site.urls),
# PWA файлы
path("service-worker.js", service_worker, name="service_worker"),
path("manifest.webmanifest", manifest, name="manifest"),
# Web‑страницы
path("", parking_views.LandingPageView.as_view(), name="landing"),
path("map/", parking_views.MapPageView.as_view(), name="map_page"),
path("pwa-install/", parking_views.PWAInstallGuideView.as_view(), name="pwa_install"),
path("личный-кабинет/", parking_views.UserDashboardView.as_view(), name="user_dashboard"),
path("кабинет-владельца/", parking_views.OwnerDashboardView.as_view(), name="owner_dashboard"),
path("offline/", TemplateView.as_view(template_name="offline.html"), name="offline"),
# Auth страницы (регистрация/логин/сброс пароля)
path("accounts/", include("accounts.urls")),
# API (DRF router)
path("api/", include(router.urls)),
# JWT auth
path(
"api/auth/token/",
accounts_api.TokenObtainPairView.as_view(),
name="token_obtain_pair",
),
path(
"api/auth/token/refresh/",
accounts_api.TokenRefreshSlidingView.as_view(),
name="token_refresh",
),
# OTP / auth
path("api/auth/request-code/", accounts_api.AuthOTPRequestView.as_view(), name="auth_request_code"),
path("api/auth/verify-code/", accounts_api.AuthOTPVerifyView.as_view(), name="auth_verify_code"),
# OpenAPI / документация
path("api/schema/", SpectacularAPIView.as_view(), name="api-schema"),
path(
"api/docs/",
SpectacularSwaggerView.as_view(url_name="api-schema"),
name="api-docs",
),
path(
"api/docs/redoc/",
SpectacularRedocView.as_view(url_name="api-schema"),
name="api-docs-redoc",
),
# AI API (ParkMate + аналитика)
path("api/ai/recommendations/", ai_api.RecommendationsAPIView.as_view(), name="ai_recommendations"),
path("api/ai/stress-index/", ai_api.StressIndexAPIView.as_view(), name="ai_stress_index"),
path("api/ai/departure-assistant/", ai_api.DepartureAssistantAPIView.as_view(), name="ai_departure_assistant"),
path("api/ai/parkmate/config/", ai_api.ParkMateConfigAPIView.as_view(), name="parkmate_config"),
path("api/ai/parkmate/price-forecast/", ai_api.ParkMatePriceForecastAPIView.as_view(), name="parkmate_price_forecast"),
path("api/ai/chat/parking/", ai_api.ParkingChatAPIView.as_view(), name="ai_parking_chat"),
path("api/ai/chat/feedback/", ai_api.ChatFeedbackAPIView.as_view(), name="ai_chat_feedback"),
path("api/ai/llm/health/", ai_api.LLMServiceHealthAPIView.as_view(), name="ai_llm_health"),
path("api/parking/map/", parking_views.ParkingMapAPIView.as_view(), name="parking_map"),
path("api/geocode/", parking_views.GeocodeAPIView.as_view(), name="geocode"),
# Payments webhooks
path("payments/webhook/yookassa/", payments_api.YooKassaWebhookView.as_view(), name="yookassa_webhook"),
path("payments/webhook/stripe/", payments_api.StripeWebhookView.as_view(), name="stripe_webhook"),
# DRF browsable API login/logout
path("api-auth/", include("rest_framework.urls")),
]
if settings.DEBUG:
urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

# File 63/163: backend\backend\config\wsgi.py
################################################################################

import os
from django.core.wsgi import get_wsgi_application
settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module:
raise RuntimeError(
"DJANGO_SETTINGS_MODULE не задан. "
"Укажи backend.settings.local (dev) или backend.settings.production (prod)."
)
application = get_wsgi_application()

# File 64/163: backend\backend\settings\__init__.py
################################################################################

"""
Пакет настроек Django для ParkShare.
Важно:
- Не используйте DJANGO_SETTINGS_MODULE=backend.settings.
- Всегда указывайте конкретный модуль:
- backend.settings.local      — для локальной разработки
- backend.settings.production — для продакшена
Это согласовано с проверками в backend.config.wsgi / asgi / celery.
"""

# File 65/163: backend\backend\settings\base.py
################################################################################

import os
from datetime import timedelta
from pathlib import Path
from typing import List
import environ
from .regions import REGION_PROFILES
# ---------------------------------------------------------------------------
# Пути
# ---------------------------------------------------------------------------
# BASE_DIR — корень репозитория: C:\Users\Sultan\Downloads\parkshare_ru_part1
BASE_DIR = Path(__file__).resolve().parents[3]
# Тут главная правка: больше не уходим на уровень выше
PROJECT_ROOT = BASE_DIR
# ---------------------------------------------------------------------------
# Окружение
# ---------------------------------------------------------------------------
env = environ.Env(
DEBUG=(bool, False),
)
env_file = PROJECT_ROOT / ".env"
if env_file.exists():
environ.Env.read_env(str(env_file))
DEBUG: bool = env.bool("DEBUG", default=False)
# ОБЯЗАТЕЛЬНО: ключ только из переменной окружения / .env
SECRET_KEY: str = env("SECRET_KEY")
ALLOWED_HOSTS: List[str] = env.list(
"ALLOWED_HOSTS", default=["localhost", "127.0.0.1"]
)
# Маркет/регион: RU — по умолчанию, GLOBAL — международный профиль.
PLATFORM_MODE: str = env("PLATFORM_MODE", default="RU").upper()
# ---------------------------------------------------------------------------
# Региональные профили / карты
# ---------------------------------------------------------------------------
REGION_PROFILE: str = env("REGION_PROFILE", default="RU")
REGION = REGION_PROFILES.get(REGION_PROFILE, REGION_PROFILES["RU"])
# Провайдер карты можно переопределить через MAP_PROVIDER,
# иначе берём primary из профиля.
MAP_PROVIDER: str = env("MAP_PROVIDER", default=REGION["maps"]["primary"])
MAP_PROVIDER_FALLBACK: str = env(
"MAP_PROVIDER_FALLBACK", default=REGION["maps"].get("fallback", "leaflet")
)
YANDEX_MAP_API_KEY: str = env("YANDEX_MAP_API_KEY", default="")
MAPBOX_TOKEN: str = env("MAPBOX_TOKEN", default="")
MAP_DEFAULT_CENTER = REGION["maps"].get("default_center", [55.75, 37.61])
MAP_DEFAULT_ZOOM = REGION["maps"].get("default_zoom", 11)
# ---------------------------------------------------------------------------
# Приложения
# ---------------------------------------------------------------------------
INSTALLED_APPS = [
# Django
"django.contrib.admin",
"django.contrib.auth",
"django.contrib.contenttypes",
"django.contrib.sessions",
"django.contrib.messages",
"django.contrib.staticfiles",
# Сторонние
"rest_framework",
"corsheaders",
"django_cryptography",
"drf_spectacular",
# Проектные
"accounts",
"vehicles",
"parking",
"payments",
"ai",
"core",
]
MIDDLEWARE = [
"core.middleware.RateLimitMiddleware",
"corsheaders.middleware.CorsMiddleware",
"django.middleware.security.SecurityMiddleware",
"core.middleware.SecurityHeadersMiddleware",
"django.middleware.gzip.GZipMiddleware",
"django.contrib.sessions.middleware.SessionMiddleware",
"django.middleware.common.CommonMiddleware",
"django.middleware.csrf.CsrfViewMiddleware",
"django.contrib.auth.middleware.AuthenticationMiddleware",
"django.contrib.messages.middleware.MessageMiddleware",
"django.middleware.clickjacking.XFrameOptionsMiddleware",
]
ROOT_URLCONF = "backend.config.urls"
TEMPLATES = [
{
"BACKEND": "django.template.backends.django.DjangoTemplates",
"DIRS": [BASE_DIR / "templates"],
"APP_DIRS": True,
"OPTIONS": {
"context_processors": [
"django.template.context_processors.debug",
"django.template.context_processors.request",
"django.contrib.auth.context_processors.auth",
"django.contrib.messages.context_processors.messages",
# Глобальные настройки ParkShare: регион, карта и т.д.
"core.context_processors.global_settings",
],
},
},
]
WSGI_APPLICATION = "backend.config.wsgi.application"
ASGI_APPLICATION = "backend.config.asgi.application"
# ---------------------------------------------------------------------------
# Базы данных
# ---------------------------------------------------------------------------
DATABASES = {
"default": env.db(
"DATABASE_URL", default=f"sqlite:
)
}
# Если используем PostgreSQL — переключаемся на PostGIS
if DATABASES["default"]["ENGINE"] == "django.db.backends.postgresql":
DATABASES["default"]["ENGINE"] = "django.contrib.gis.db.backends.postgis"
# ---------------------------------------------------------------------------
# Пользователь / аутентификация
# ---------------------------------------------------------------------------
AUTH_USER_MODEL = "accounts.User"
AUTH_PASSWORD_VALIDATORS = [
{
"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
},
{
"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
"OPTIONS": {"min_length": 8},
},
{
"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
},
{
"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
},
]
# ---------------------------------------------------------------------------
# Локализация
# ---------------------------------------------------------------------------
LANGUAGE_CODE = env("LANGUAGE_CODE", default="ru-ru")
TIME_ZONE = env("TIME_ZONE", default="Europe/Moscow")
USE_I18N = True
USE_L10N = True
USE_TZ = True
# ---------------------------------------------------------------------------
# Статика / медиа
# ---------------------------------------------------------------------------
STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [
BASE_DIR / "static",
]
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"
# ---------------------------------------------------------------------------
# PWA
# ---------------------------------------------------------------------------
PWA_APP_NAME = "ParkShare RU"
PWA_APP_SHORT_NAME = "ParkShare"
PWA_THEME_COLOR = "
PWA_BACKGROUND_COLOR = "
# ---------------------------------------------------------------------------
# DRF / OpenAPI
# ---------------------------------------------------------------------------
REST_FRAMEWORK = {
"DEFAULT_AUTHENTICATION_CLASSES": [
"rest_framework_simplejwt.authentication.JWTAuthentication",
"rest_framework.authentication.SessionAuthentication",
],
"DEFAULT_PERMISSION_CLASSES": [
"rest_framework.permissions.IsAuthenticatedOrReadOnly",
],
"DEFAULT_PAGINATION_CLASS": "core.pagination.DefaultPageNumberPagination",
"PAGE_SIZE": 20,
"DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}
SPECTACULAR_SETTINGS = {
"TITLE": "ParkShare RU API",
"DESCRIPTION": "API сервиса бронирования парковочных мест ParkShare RU.",
"VERSION": "1.0.0",
"SERVE_INCLUDE_SCHEMA": False,
}
# ---------------------------------------------------------------------------
# CORS
# ---------------------------------------------------------------------------
CORS_ALLOWED_ORIGINS = env.list("CORS_ALLOWED_ORIGINS", default=[])
CORS_ALLOWED_ORIGIN_REGEXES = env.list("CORS_ALLOWED_ORIGIN_REGEXES", default=[])
CORS_ALLOW_CREDENTIALS = True
CSRF_TRUSTED_ORIGINS = env.list("CSRF_TRUSTED_ORIGINS", default=[])
# ---------------------------------------------------------------------------
# JWT
# ---------------------------------------------------------------------------
SIMPLE_JWT = {
"ACCESS_TOKEN_LIFETIME": timedelta(minutes=15),
"REFRESH_TOKEN_LIFETIME": timedelta(days=7),
"ROTATE_REFRESH_TOKENS": True,
"BLACKLIST_AFTER_ROTATION": True,
"ALGORITHM": "HS256",
"SIGNING_KEY": SECRET_KEY,
"AUTH_HEADER_TYPES": ("Bearer",),
"AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
"UPDATE_LAST_LOGIN": True,
}
# ---------------------------------------------------------------------------
# Redis / Celery
# ---------------------------------------------------------------------------
REDIS_URL = env("REDIS_URL", default="redis:
CELERY_BROKER_URL = env("CELERY_BROKER_URL", default=REDIS_URL)
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND", default=REDIS_URL)
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE
CELERY_BEAT_SCHEDULE = {
"expire_unpaid_bookings": {
"task": "parking.tasks.expire_unpaid_bookings",
"schedule": 60 * 10,
},
"update_ai_models": {
"task": "ai.tasks.update_models",
"schedule": 60 * 60,
},
"check_stale_payments": {
"task": "payments.tasks.check_stale_payments",
"schedule": 60 * 15,
},
}
# ---------------------------------------------------------------------------
# Логи
# ---------------------------------------------------------------------------
LOGGING = {
"version": 1,
"disable_existing_loggers": False,
"formatters": {
"verbose": {
"format": "[{asctime}] {levelname} {name} {message}",
"style": "{",
},
"simple": {
"format": "{levelname} {message}",
"style": "{",
},
},
"handlers": {
"console": {
"class": "logging.StreamHandler",
"formatter": "verbose",
},
},
"loggers": {
"django": {
"handlers": ["console"],
"level": "INFO",
},
"parkshare": {
"handlers": ["console"],
"level": "INFO",
},
"ai": {
"handlers": ["console"],
"level": "DEBUG",
"propagate": False,
},
"services": {
"handlers": ["console"],
"level": "DEBUG",
"propagate": False,
},
},
}
# ---------------------------------------------------------------------------
# Email
# ---------------------------------------------------------------------------
EMAIL_BACKEND = env(
"EMAIL_BACKEND",
default="django.core.mail.backends.console.EmailBackend",
)
DEFAULT_FROM_EMAIL = env(
"DEFAULT_FROM_EMAIL",
default="ParkShare RU <noreply@example.com>",
)
SERVER_EMAIL = env("SERVER_EMAIL", default=DEFAULT_FROM_EMAIL)
# ---------------------------------------------------------------------------
# Безопасность (базовый уровень, детали переопределяются в production.py)
# ---------------------------------------------------------------------------
SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=False)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=False)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=False)
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = "Lax"
CSRF_COOKIE_SAMESITE = "Lax"
X_FRAME_OPTIONS = "DENY"
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
CONTENT_SECURITY_POLICY = env(
"CONTENT_SECURITY_POLICY",
default=(
"default-src 'self'; "
"script-src 'self' 'unsafe-inline' https:; "
"style-src 'self' 'unsafe-inline' https:; "
"img-src 'self' data: https:; "
"connect-src 'self' https:; "
"font-src 'self' https: data:; "
"frame-ancestors 'none'; "
"form-action 'self';"
),
)
REFERRER_POLICY = env("REFERRER_POLICY", default="strict-origin-when-cross-origin")
PERMISSIONS_POLICY = env(
"PERMISSIONS_POLICY",
# Разрешаем геолокацию только себе, остальное по умолчанию запрещено
default="geolocation=(self), camera=(), microphone=(), payment=()",
)
# COOP / COEP / CORP — по умолчанию выключены, чтобы не ломать
# внешние ресурсы (карты, CDN, платёжные виджеты и т.п.).
# Если понадобится SharedArrayBuffer и строгая изоляция — включишь
# явно через .env.
CROSS_ORIGIN_OPENER_POLICY = env(
"CROSS_ORIGIN_OPENER_POLICY", default=""
)
CROSS_ORIGIN_EMBEDDER_POLICY = env(
"CROSS_ORIGIN_EMBEDDER_POLICY", default=""
)
CROSS_ORIGIN_RESOURCE_POLICY = env(
"CROSS_ORIGIN_RESOURCE_POLICY", default=""
)
# ---------------------------------------------------------------------------
# Rate limiting
# ---------------------------------------------------------------------------
RATE_LIMIT_CACHE = env("RATE_LIMIT_CACHE", default="default")
RATE_LIMIT_WINDOW = env.int("RATE_LIMIT_WINDOW", default=60)
RATE_LIMIT_REQUESTS = env.int("RATE_LIMIT_REQUESTS", default=120)
RATE_LIMIT_WHITELIST = env.list(
"RATE_LIMIT_WHITELIST", default=["127.0.0.1", "::1"]
)
# ---------------------------------------------------------------------------
# django-cryptography
# ---------------------------------------------------------------------------
DJANGO_CRYPTography_KEY = SECRET_KEY
# ---------------------------------------------------------------------------
# Бизнес-настройки
# ---------------------------------------------------------------------------
VEHICLE_PLATE_SALT = env("VEHICLE_PLATE_SALT", default="change_me_vehicle_salt")
YOOKASSA_SHOP_ID = env("YOOKASSA_SHOP_ID", default="")
YOOKASSA_SECRET_KEY = env("YOOKASSA_SECRET_KEY", default="")
YOOKASSA_RETURN_URL = env("YOOKASSA_RETURN_URL", default="")
YOOKASSA_WEBHOOK_SECRET = env("YOOKASSA_WEBHOOK_SECRET", default="")
STRIPE_SECRET_KEY = env("STRIPE_SECRET_KEY", default="")
STRIPE_WEBHOOK_SECRET = env("STRIPE_WEBHOOK_SECRET", default="")
DEFAULT_PAYMENT_PROVIDER = env(
"PAYMENT_PROVIDER",
default="yookassa" if PLATFORM_MODE == "RU" else "stripe",
)
SERVICE_COMMISSION_PERCENT = env.int("SERVICE_COMMISSION_PERCENT", default=10)
# ---------------------------------------------------------------------------
# Кэш по умолчанию — in-memory (в продакшене можно переключить на Redis)
# ---------------------------------------------------------------------------
CACHES = {
"default": {
"BACKEND": "django.core.cache.backends.locmem.LocMemCache",
"LOCATION": "parkshare_cache",
}
}
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# File 66/163: backend\backend\settings\local.py
################################################################################

from .base import *
# Локальная разработка
DEBUG = env.bool("DEBUG", default=True)
ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=["127.0.0.1", "localhost"])
INTERNAL_IPS = ["127.0.0.1"]
SECURE_SSL_REDIRECT = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False

# File 67/163: backend\backend\settings\production.py
################################################################################

from django.core.exceptions import ImproperlyConfigured
from .base import *
# Продакшен-настройки
DEBUG = False
ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=[])
if not ALLOWED_HOSTS:
raise ImproperlyConfigured(
"В продакшене ALLOWED_HOSTS не должен быть пустым. "
"Задайте ALLOWED_HOSTS в .env"
)
SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=True)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=True)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=True)
SECURE_HSTS_SECONDS = env.int("SECURE_HSTS_SECONDS", default=60 * 60 * 24)
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# File 68/163: backend\backend\settings\regions.py
################################################################################

from __future__ import annotations
"""
Региональные профили ParkShare.
RU — основной профиль (ParkShare RU) с Яндекс.Картами, российскими платёжками
и провайдерами аутентификации.
EU/US — заготовки для будущих рынков.
"""
REGION_PROFILES = {
"RU": {
"code": "RU",
"name": "Russia",
"maps": {
# Важно: логические идентификаторы, а не "маркетинговые" названия
"primary": "yandex",
"fallback": "leaflet",
"language": "ru_RU",
"default_center": [55.75, 37.61],
"default_zoom": 11,
},
"payments": {
"required": [
"sberbank_online",
"tinkoff",
"yoomoney",
"mir_pay",
"qiwi",
],
},
"auth": [
"gosuslugi",
"vk_id",
"yandex_id",
"sber_id",
],
"holidays": {
"provider": "ru_holidays",
},
},
"EU": {
"code": "EU",
"name": "European Union",
"maps": {
"primary": "leaflet",
"fallback": "leaflet",
"language": "en_US",
"default_center": [52.52, 13.405],
"default_zoom": 11,
},
"payments": {
"required": [
"visa_mastercard",
],
},
"auth": ["email_password"],
"holidays": {
"provider": "eu_holidays",
},
},
"US": {
"code": "US",
"name": "United States",
"maps": {
"primary": "leaflet",
"fallback": "leaflet",
"language": "en_US",
"default_center": [40.7128, -74.0060],
"default_zoom": 11,
},
"payments": {
"required": [
"visa_mastercard",
"apple_pay",
"google_pay",
],
},
"auth": ["email_password"],
"holidays": {
"provider": "us_holidays",
},
},
}

# File 69/163: backend\rest_framework_simplejwt\__init__.py
################################################################################

"""Stub for rest_framework_simplejwt to allow offline checks."""

# File 70/163: backend\rest_framework_simplejwt\authentication.py
################################################################################

from rest_framework.authentication import BaseAuthentication
class JWTAuthentication(BaseAuthentication):
def authenticate(self, request):
return None

# File 71/163: backend\rest_framework_simplejwt\tokens.py
################################################################################

class RefreshToken:
@classmethod
def for_user(cls, user):
return cls()
def __str__(self):
return "stub-token"
@property
def access_token(self):
return "stub-access"

# File 72/163: backend\rest_framework_simplejwt\views.py
################################################################################

from rest_framework.response import Response
from rest_framework.views import APIView
class TokenObtainPairView(APIView):
def post(self, request, *args, **kwargs):
return Response({"access": "stub", "refresh": "stub"})
class TokenRefreshView(APIView):
def post(self, request, *args, **kwargs):
return Response({"access": "stub"})
class TokenRefreshSlidingView(TokenRefreshView):
pass

# File 73/163: backend\tests\__init__.py
################################################################################

# Пакет с базовыми тестами проекта ParkShare RU.

# File 74/163: backend\tests\test_auth_api.py
################################################################################

from django.test import TestCase
from rest_framework.test import APIClient
class AuthApiTests(TestCase):
def setUp(self) -> None:
self.client = APIClient()
self.password = "StrongPass123"
def test_register_and_login_by_username_email_and_phone(self):
# Регистрация
resp = self.client.post(
"/api/accounts/users/register/",
{
"username": "demo",
"password": self.password,
"email": "demo@example.com",
"phone": "+7 (999) 123-45-67",
},
format="json",
)
self.assertEqual(resp.status_code, 201)
self.client.logout()
# Логин по логину
resp = self.client.post(
"/api/accounts/users/login/",
{"identifier": "demo", "password": self.password},
format="json",
)
self.assertEqual(resp.status_code, 200)
self.assertEqual(resp.data["username"], "demo")
self.client.logout()
# Логин по email
resp = self.client.post(
"/api/accounts/users/login/",
{"identifier": "demo@example.com", "password": self.password},
format="json",
)
self.assertEqual(resp.status_code, 200)
self.client.logout()
# Логин по телефону (в любом удобном формате)
resp = self.client.post(
"/api/accounts/users/login/",
{"identifier": "+7 999 123-45-67", "password": self.password},
format="json",
)
self.assertEqual(resp.status_code, 200)

# File 75/163: backend\tests\test_booking_model.py
################################################################################

from datetime import timedelta
from decimal import Decimal
from django.test import TestCase
from django.utils import timezone
from accounts.models import User
from parking.models import Booking, ParkingLot, ParkingSpot
class BookingModelTests(TestCase):
def setUp(self) -> None:
self.owner = User.objects.create_user(
username="owner",
password="StrongPass123",
role=User.Role.OWNER,
)
self.driver = User.objects.create_user(
username="driver",
password="StrongPass123",
role=User.Role.DRIVER,
)
self.lot = ParkingLot.objects.create(
owner=self.owner,
name="Test Lot",
city="Test City",
address="Test street, 1",
)
self.spot = ParkingSpot.objects.create(
lot=self.lot,
name="A1",
hourly_price=Decimal("100.00"),
)
def test_calculate_price_hourly_with_commission(self):
now = timezone.now()
booking = Booking(
user=self.driver,
spot=self.spot,
booking_type=Booking.BookingType.HOURLY,
start_at=now,
end_at=now + timedelta(hours=1, minutes=30),
total_price=Decimal("0.00"),
currency="RUB",
)
total = booking.calculate_price()
# 2 часа * 100 ₽ + 10% комиссии = 220
self.assertEqual(total, Decimal("220.00"))
def test_is_spot_available(self):
now = timezone.now()
existing = Booking.objects.create(
user=self.driver,
spot=self.spot,
booking_type=Booking.BookingType.HOURLY,
start_at=now,
end_at=now + timedelta(hours=2),
status=Booking.Status.CONFIRMED,
total_price=Decimal("200.00"),
currency="RUB",
)
# Пересекающийся интервал — недоступен
self.assertFalse(
Booking.is_spot_available(
self.spot,
now + timedelta(minutes=30),
now + timedelta(hours=3),
)
)
# Непересекающийся интервал — доступен
self.assertTrue(
Booking.is_spot_available(
self.spot,
existing.end_at + timedelta(minutes=1),
existing.end_at + timedelta(hours=1),
)
)

# File 76/163: core\__init__.py
################################################################################



# File 77/163: core\admin.py
################################################################################



# File 78/163: core\apps.py
################################################################################

# core/apps.py
from django.apps import AppConfig
class CoreConfig(AppConfig):
default_auto_field = "django.db.models.BigAutoField"
name = "core"
verbose_name = "Ядро ParkShare"

# File 79/163: core\context_processors.py
################################################################################

# core/context_processors.py
from __future__ import annotations
from django.conf import settings
def global_settings(request):
"""
Глобальные настройки, которые нужны во всех шаблонах:
регион, карта, ключи и дефолтный центр.
"""
return {
"REGION_PROFILE": getattr(settings, "REGION_PROFILE", "RU"),
"PLATFORM_MODE": getattr(settings, "PLATFORM_MODE", "RU"),
"MAP_PROVIDER": getattr(settings, "MAP_PROVIDER", "yandex"),
"MAP_PROVIDER_FALLBACK": getattr(settings, "MAP_PROVIDER_FALLBACK", "leaflet"),
"YANDEX_MAP_API_KEY": getattr(settings, "YANDEX_MAP_API_KEY", ""),
"MAPBOX_TOKEN": getattr(settings, "MAPBOX_TOKEN", ""),
"MAP_DEFAULT_CENTER": getattr(
settings,
"MAP_DEFAULT_CENTER",
[55.75, 37.61],
),
"MAP_DEFAULT_ZOOM": getattr(settings, "MAP_DEFAULT_ZOOM", 11),
}

# File 80/163: core\integrations.py
################################################################################

"""core/integrations.py
Адаптеры для интеграций по регионам:
- карты (RU: Яндекс, GLOBAL: Mapbox/OSM);
- платежи (RU: YooKassa, GLOBAL: Stripe);
- аутентификация (RU: ЕСИА/VK/Яндекс, GLOBAL: generic OAuth2).
Цель — единая точка выбора провайдера через PLATFORM_MODE
(ENV: PLATFORM_MODE=RU|GLOBAL) без раздувания микросервисов.
"""
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict
from django.conf import settings
@dataclass
class MapProviderAdapter:
key: str
api_key: str
language: str
default_center: list[float]
default_zoom: int
def as_frontend_payload(self) -> Dict[str, str | list[float] | int]:
return {
"provider": self.key,
"language": self.language,
"api_key": self.api_key,
"center": self.default_center,
"zoom": self.default_zoom,
}
@dataclass
class PaymentGatewayAdapter:
key: str
webhook_url: str
return_url: str
def as_dict(self) -> Dict[str, str]:
return {
"provider": self.key,
"webhook_url": self.webhook_url,
"return_url": self.return_url,
}
@dataclass
class AuthProviderAdapter:
key: str
client_id: str
authorization_url: str
scopes: list[str]
def as_dict(self) -> Dict[str, str | list[str]]:
return {
"provider": self.key,
"client_id": self.client_id,
"authorization_url": self.authorization_url,
"scopes": self.scopes,
}
RU_INTEGRATIONS = {
"maps": MapProviderAdapter(
key=settings.MAP_PROVIDER,
api_key=settings.YANDEX_MAP_API_KEY,
language=settings.REGION.get("maps", {}).get("language", "ru_RU"),
default_center=settings.MAP_DEFAULT_CENTER,
default_zoom=settings.MAP_DEFAULT_ZOOM,
),
"payments": PaymentGatewayAdapter(
key=settings.DEFAULT_PAYMENT_PROVIDER,
webhook_url="/payments/webhook/yookassa/",
return_url=settings.YOOKASSA_RETURN_URL,
),
"auth": [
AuthProviderAdapter(
key="gosuslugi",
client_id="GOSUSLUGI_CLIENT_ID_PLACEHOLDER",
authorization_url="https:
scopes=["openid", "profile"],
),
AuthProviderAdapter(
key="vk_id",
client_id="VK_CLIENT_ID_PLACEHOLDER",
authorization_url="https:
scopes=["email"],
),
],
}
GLOBAL_INTEGRATIONS = {
"maps": MapProviderAdapter(
key=settings.MAP_PROVIDER if settings.PLATFORM_MODE == "GLOBAL" else "mapbox",
api_key=settings.MAPBOX_TOKEN,
language="en_US",
default_center=settings.MAP_DEFAULT_CENTER,
default_zoom=settings.MAP_DEFAULT_ZOOM,
),
"payments": PaymentGatewayAdapter(
key=settings.DEFAULT_PAYMENT_PROVIDER,
webhook_url="/payments/webhook/stripe/",
return_url="/payments/return/",
),
"auth": [
AuthProviderAdapter(
key="google",
client_id="GOOGLE_OAUTH_CLIENT_ID",
authorization_url="https:
scopes=["openid", "email", "profile"],
),
AuthProviderAdapter(
key="apple",
client_id="APPLE_CLIENT_ID",
authorization_url="https:
scopes=["name", "email"],
),
],
}
def get_integrations() -> dict:
if settings.PLATFORM_MODE == "GLOBAL":
return GLOBAL_INTEGRATIONS
return RU_INTEGRATIONS

# File 81/163: core\middleware.py
################################################################################

from __future__ import annotations
import time
from typing import Callable
from django.conf import settings
from django.core.cache import caches
from django.http import HttpRequest, HttpResponse, JsonResponse
# core/middleware.py
from django.conf import settings
class SecurityHeadersMiddleware:
"""
Добавляет базовые защитные заголовки.
COOP/COEP/CORP берём из settings.* и в DEBUG по умолчанию отключаем,
чтобы не ломать dev-фичи вроде Leaflet / внешних API.
"""
def __init__(self, get_response):
self.get_response = get_response
def __call__(self, request):
response = self.get_response(request)
# CSP
csp = getattr(settings, "CONTENT_SECURITY_POLICY", None)
if csp:
response.setdefault("Content-Security-Policy", csp)
# X-Frame-Options
response.setdefault("X-Frame-Options", "DENY")
# X-Content-Type-Options
response.setdefault("X-Content-Type-Options", "nosniff")
# Referrer-Policy
referrer = getattr(settings, "REFERRER_POLICY", None)
if referrer:
response.setdefault("Referrer-Policy", referrer)
# Permissions-Policy
perm = getattr(settings, "PERMISSIONS_POLICY", None)
if perm:
response.setdefault("Permissions-Policy", perm)
# --- COOP / COEP / CORP ---
if settings.DEBUG:
# В dev вообще не ставим их, и заодно сносим, если кто-то выше их повесил
for header in (
"Cross-Origin-Opener-Policy",
"Cross-Origin-Embedder-Policy",
"Cross-Origin-Resource-Policy",
):
if header in response:
del response[header]
else:
coop = getattr(settings, "CROSS_ORIGIN_OPENER_POLICY", None)
coep = getattr(settings, "CROSS_ORIGIN_EMBEDDER_POLICY", None)
corp = getattr(settings, "CROSS_ORIGIN_RESOURCE_POLICY", None)
if coop:
response.setdefault("Cross-Origin-Opener-Policy", coop)
if coep:
response.setdefault("Cross-Origin-Embedder-Policy", coep)
if corp:
response.setdefault("Cross-Origin-Resource-Policy", corp)
return response
class RateLimitMiddleware:
"""Простейший rate limiting на уровне приложения.
Используем cache (Redis в продакшене) для подсчёта количества запросов
в фиксированное окно. Если лимит превышен — отдаём 429 и заголовок
``Retry-After``.
"""
def __init__(self, get_response: Callable):
self.get_response = get_response
self.cache = caches[getattr(settings, "RATE_LIMIT_CACHE", "default")]
self.window = int(getattr(settings, "RATE_LIMIT_WINDOW", 60))
self.limit = int(getattr(settings, "RATE_LIMIT_REQUESTS", 120))
self.whitelist = set(getattr(settings, "RATE_LIMIT_WHITELIST", []))
def __call__(self, request: HttpRequest) -> HttpResponse:
if request.method.upper() == "OPTIONS":
return self.get_response(request)
client_ip = self._get_client_ip(request)
if client_ip and client_ip not in self.whitelist:
if self._is_rate_limited(client_ip):
retry_after = self.window
return JsonResponse(
{"detail": "Too many requests, please retry later."},
status=429,
headers={"Retry-After": str(retry_after)},
)
return self.get_response(request)
def _get_client_ip(self, request: HttpRequest) -> str:
forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
if forwarded_for:
return forwarded_for.split(",")[0].strip()
return request.META.get("REMOTE_ADDR", "")
def _is_rate_limited(self, client_ip: str) -> bool:
window_start = int(time.time()
cache_key = f"ratelimit:{client_ip}:{window_start}"
added = self.cache.add(cache_key, 1, timeout=self.window)
if added:
return False
try:
current = self.cache.incr(cache_key)
except Exception:
# Fallback: если бекенд не поддерживает incr, пробуем читать/писать вручную.
current = int(self.cache.get(cache_key) or 0) + 1
self.cache.set(cache_key, current, timeout=self.window)
return current > self.limit

# File 82/163: core\models.py
################################################################################

# backend/core/models.py
import uuid
from django.db import models
from django.utils.translation import gettext_lazy as _
class TimeStampedModel(models.Model):
"""
Абстрактная модель с полями created_at/updated_at.
Используется для единообразного аудита времени создания и обновления
записей в базовых моделях (парковки, бронирования, платежи и т.п.).
"""
created_at = models.DateTimeField(_("Дата создания"), auto_now_add=True)
updated_at = models.DateTimeField(_("Дата обновления"), auto_now=True)
class Meta:
abstract = True
class UUIDModel(models.Model):
"""Абстрактная модель с UUID в качестве первичного ключа."""
id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
class Meta:
abstract = True
class TimeStampedUUIDModel(TimeStampedModel, UUIDModel):
"""Комбо UUID + таймстемпы."""
class Meta:
abstract = True

# File 83/163: core\pagination.py
################################################################################

# core/pagination.py
from django.conf import settings
from rest_framework.pagination import PageNumberPagination
class DefaultPageNumberPagination(PageNumberPagination):
"""
Базовый пагинатор для API.
Размер страницы берётся из настроек DRF (PAGE_SIZE), с возможностью
переопределения через query-параметр ?page_size=.
"""
page_size = settings.REST_FRAMEWORK.get("PAGE_SIZE", 20)
page_size_query_param = "page_size"
max_page_size = 100

# File 84/163: core\permissions.py
################################################################################

# core/permissions.py
from typing import Any
from django.contrib.auth import get_user_model
from rest_framework.permissions import BasePermission, SAFE_METHODS
User = get_user_model()
def _is_admin(user: User) -> bool:
"""
Утилита: определение админа по суперпользователю или роли.
"""
if not user.is_authenticated:
return False
role_cls = getattr(User, "Role", None)
admin_value = None
if role_cls is not None:
admin_value = getattr(role_cls, "ADMIN", None)
if admin_value is not None:
return bool(user.is_superuser or getattr(user, "role", "") == admin_value)
return bool(user.is_superuser or getattr(user, "is_staff", False))
class IsAdminOrReadOnly(BasePermission):
"""
Разрешает только администраторам изменять данные, остальным — только чтение.
"""
def has_permission(self, request, view) -> bool:
if request.method in SAFE_METHODS:
return True
user: User = request.user
return _is_admin(user)
class IsSelfOrAdmin(BasePermission):
"""
Доступ к объекту пользователя: либо сам пользователь, либо админ.
"""
def has_object_permission(self, request, view, obj: Any) -> bool:
user: User = request.user
if not user.is_authenticated:
return False
if _is_admin(user):
return True
return getattr(obj, "pk", None) == getattr(user, "pk", None)
class IsOwnerObject(BasePermission):
"""
Доступ к объектам, у которых есть атрибут owner: только владелец или админ.
"""
def has_object_permission(self, request, view, obj: Any) -> bool:
user: User = request.user
if not user.is_authenticated:
return False
if _is_admin(user):
return True
owner = getattr(obj, "owner", None)
return owner == user

# File 85/163: core\utils.py
################################################################################

# backend/core/utils.py
import hashlib
import math
from decimal import Decimal, ROUND_HALF_UP
from typing import Optional
from django.conf import settings
def hash_plate_digits(plate: str) -> str:
"""
Хэширует только цифры госномера с солью (SHA‑256).
Буквы и пробелы игнорируются.
В БД мы сохраняем только этот хэш.
"""
if not plate:
return ""
digits = "".join(ch for ch in plate if ch.isdigit())
salted = f"{settings.VEHICLE_PLATE_SALT}:{digits}"
return hashlib.sha256(salted.encode("utf-8")).hexdigest()
def mask_plate_for_display(plate: str) -> str:
"""
Возвращает маску номера для отображения (если вдруг нужно выводить).
Фактический номер мы нигде не храним, поэтому функция может применяться
только к введённому пользователем значению до хэширования.
"""
digits = "".join(ch for ch in plate if ch.isdigit())
if not digits:
return ""
if len(digits) <= 2:
return "*" * len(digits)
return "*" * (len(digits) - 2) + digits[-2:]
def normalize_phone(phone: Optional[str]) -> str:
"""
Нормализация телефона:
- убираем все символы кроме цифр и '+';
- для РФ приводим к формату +7XXXXXXXXXX, если возможно;
- для остальных стран просто добавляем '+' перед цифрами.
"""
if not phone:
return ""
raw = phone.strip()
# Оставляем плюс только в начале
plus = "+" if raw.startswith("+") else ""
digits = "".join(ch for ch in raw if ch.isdigit())
if not digits:
return ""
# РФ: 10 или 11 цифр, начинающихся с 8/7
if len(digits) == 11 and digits.startswith("8"):
digits = "7" + digits[1:]
elif len(digits) == 10:
digits = "7" + digits
if plus or digits.startswith("7"):
return "+" + digits
return "+" + digits
def haversine_distance_km(
lat1: float, lon1: float, lat2: float, lon2: float
) -> float:
"""
Расстояние между двумя точками на сфере Земли (км).
Используем для поиска парковок «рядом» без обязательной привязки
к PostGIS (работает и на SQLite).
"""
try:
lat1_f = float(lat1)
lon1_f = float(lon1)
lat2_f = float(lat2)
lon2_f = float(lon2)
except (TypeError, ValueError):
return 0.0
radius = 6371.0
d_lat = math.radians(lat2_f - lat1_f)
d_lon = math.radians(lon2_f - lon1_f)
r_lat1 = math.radians(lat1_f)
r_lat2 = math.radians(lat2_f)
a = (
math.sin(d_lat / 2) ** 2
+ math.cos(r_lat1) * math.cos(r_lat2) * math.sin(d_lon / 2) ** 2
)
c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
return radius * c
def parse_float(value: Optional[str]) -> Optional[float]:
"""
Аккуратно парсит строку в float, возвращая None при ошибке.
Удобно для работы с query‑параметрами API.
"""
if value is None:
return None
try:
return float(value)
except (TypeError, ValueError):
return None
def round_price(value: float | Decimal, step: float = 10.0) -> float:
"""
Округляет цену к ближайшему шагу (step), по умолчанию — 10 ₽.
Используется в AI-модуле ценообразования.
"""
if step <= 0:
return float(Decimal(str(value)).quantize(Decimal("0.01")))
v = Decimal(str(value))
step_dec = Decimal(str(step))
scaled = (v / step_dec).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
result = scaled * step_dec
return float(result)

# File 86/163: drf_spectacular\__init__.py
################################################################################

"""Локальный заглушечный пакет drf_spectacular для офлайн-среды."""

# File 87/163: drf_spectacular\openapi.py
################################################################################

from rest_framework.schemas.openapi import AutoSchema
__all__ = ["AutoSchema"]

# File 88/163: drf_spectacular\views.py
################################################################################

from rest_framework.response import Response
from rest_framework.views import APIView
class SpectacularAPIView(APIView):
def get(self, request, *args, **kwargs):
return Response({"schema": "stub"})
class SpectacularSwaggerView(APIView):
url_name = None
def get(self, request, *args, **kwargs):
return Response({"swagger": "stub"})
class SpectacularRedocView(APIView):
url_name = None
def get(self, request, *args, **kwargs):
return Response({"redoc": "stub"})
__all__ = [
"SpectacularAPIView",
"SpectacularSwaggerView",
"SpectacularRedocView",
]

# File 89/163: frontend\parkmate\parkmate.types.ts
################################################################################

export interface ParkMateAI {
voiceCommands: {
booking: string;
navigation: string;
payment: string;
support: string;
};
computerVision: {
licensePlateRecognition: string;
parkingSpotDetection: string;
damageDetection: string;
occupancyAnalytics: string;
};
predictions: {
arrivalTime: string;
priceForecast: string;
availability: string;
};
}
export const defaultParkMateConfig: ParkMateAI = {
voiceCommands: {
booking: "Забронируй ближайшее свободное место на 2 часа",
navigation: "Построй маршрут до моего места парковки",
payment: "Оплати мою текущую парковку",
support: "Соедини с поддержкой ParkShare",
},
computerVision: {
licensePlateRecognition: "/api/ai/cv/license-plate/",
parkingSpotDetection: "/api/ai/cv/parking-spots/",
damageDetection: "/api/ai/cv/damage/",
occupancyAnalytics: "/api/ai/cv/occupancy/",
},
predictions: {
arrivalTime: "/api/ai/predict/arrival-time/",
priceForecast: "/api/ai/predict/pricing/",
availability: "/api/ai/predict/availability/",
},
};

# File 90/163: nginx\nginx.conf
################################################################################

user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml+rss;

    upstream django {
        server web:8000;
    }

    server {
        listen 80;
        server_name _;

        # Uncomment for HTTPS termination + Let's Encrypt
        # listen 443 ssl http2;
        # ssl_certificate /etc/letsencrypt/live/DOMAIN/fullchain.pem;
        # ssl_certificate_key /etc/letsencrypt/live/DOMAIN/privkey.pem;

        add_header X-Content-Type-Options "nosniff" always;
        add_header X-Frame-Options "DENY" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Permissions-Policy "geolocation=(), camera=(), microphone=(), payment=()" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; connect-src 'self' https: wss:;";

        location /static/ {
            alias /static/;
            expires 7d;
        }

        location /media/ {
            alias /media/;
            expires 1d;
        }

        location / {
            proxy_pass http://django;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location = /health/ {
            access_log off;
            return 200 'ok';
        }
    }
}


# File 91/163: parking\__init__.py
################################################################################

# backend/parking/__init__.py
default_app_config = "parking.apps.ParkingConfig"

# File 92/163: parking\admin.py
################################################################################

# backend/parking/admin.py
from django.contrib import admin
from .models import Booking, Complaint, ParkingLot, ParkingSpot, WaitlistEntry
@admin.register(ParkingLot)
class ParkingLotAdmin(admin.ModelAdmin):
list_display = ("name", "city", "owner", "parking_type", "is_active", "is_approved")
list_filter = ("city", "parking_type", "is_active", "is_approved")
search_fields = ("name", "city", "address", "owner__username")
autocomplete_fields = ("owner",)
@admin.register(ParkingSpot)
class ParkingSpotAdmin(admin.ModelAdmin):
list_display = (
"name",
"lot",
"vehicle_type",
"is_covered",
"has_ev_charging",
"status",
"hourly_price",
)
list_filter = (
"vehicle_type",
"is_covered",
"has_ev_charging",
"status",
"lot__city",
)
search_fields = ("name", "lot__name", "lot__city")
autocomplete_fields = ("lot",)
@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
list_display = (
"id",
"spot",
"user",
"booking_type",
"status",
"start_at",
"end_at",
"total_price",
"is_paid",
)
list_filter = ("booking_type", "status", "start_at", "spot__lot__city")
search_fields = ("spot__name", "spot__lot__name", "user__username")
autocomplete_fields = ("spot", "user", "vehicle")
@admin.register(WaitlistEntry)
class WaitlistEntryAdmin(admin.ModelAdmin):
list_display = ("id", "user", "spot", "status", "auto_book", "created_at")
list_filter = ("status", "auto_book", "created_at")
search_fields = ("user__username", "spot__name")
autocomplete_fields = ("user", "spot")
@admin.register(Complaint)
class ComplaintAdmin(admin.ModelAdmin):
list_display = ("id", "author", "category", "status", "created_at")
list_filter = ("category", "status", "created_at")
search_fields = ("author__username", "description")
autocomplete_fields = ("author", "booking", "spot")

# File 93/163: parking\apps.py
################################################################################

# backend/parking/apps.py
from django.apps import AppConfig
class ParkingConfig(AppConfig):
default_auto_field = "django.db.models.BigAutoField"
name = "parking"
verbose_name = "Парковки и бронирования"

# File 94/163: parking\models.py
################################################################################

# backend/parking/models.py
from __future__ import annotations
from datetime import timedelta
from decimal import Decimal, ROUND_UP
from typing import Optional
from django.conf import settings
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from core.models import TimeStampedModel
# PointField с fallback для SQLite: храним JSON {"lat": ..., "lng": ...}
_db_settings = getattr(settings, "DATABASES", {})
_default_db = _db_settings.get("default") or {}
_default_engine = _default_db.get("ENGINE", "")
if _default_engine.endswith("sqlite3"):
class PointField(models.JSONField):
def __init__(self, *args, **kwargs):
kwargs.pop("geography", None)
super().__init__(*args, **kwargs)
else:
from django.contrib.gis.db.models import PointField
class ParkingLot(TimeStampedModel):
"""
Объект парковки (двор, подземный паркинг, офисный паркинг и т.д.).
"""
class ParkingType(models.TextChoices):
YARD = "yard", "Дворовая парковка"
UNDERGROUND = "underground", "Подземная парковка"
MULTILEVEL = "multilevel", "Многоуровневая парковка"
STREET = "street", "Уличная парковка"
OFFICE = "office", "Офисная парковка"
HOME = "home", "Домашнее место"
owner = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="parking_lots",
verbose_name="Владелец",
)
name = models.CharField("Название", max_length=255)
city = models.CharField("Город", max_length=100)
address = models.CharField("Адрес", max_length=255)
parking_type = models.CharField(
"Тип парковки",
max_length=32,
choices=ParkingType.choices,
default=ParkingType.YARD,
)
description = models.TextField("Описание", blank=True)
location = PointField("Точка на карте", geography=True, null=True, blank=True)
latitude = models.FloatField("Широта", null=True, blank=True)
longitude = models.FloatField("Долгота", null=True, blank=True)
is_active = models.BooleanField("Активен", default=True)
is_approved = models.BooleanField(
"Одобрен модерацией",
default=False,
help_text="Одобряется администратором перед публикацией.",
)
is_private = models.BooleanField(
"Приватный",
default=False,
help_text="Если включено, объект виден только по прямым ссылкам/владельцу.",
)
stress_index = models.FloatField(
"Индекс загруженности (0..1)",
default=0.0,
help_text=(
"Средняя загруженность мест за последние 7 дней. "
"Обновляется фоновыми задачами AI."
),
)
class Meta:
verbose_name = "Объект парковки"
verbose_name_plural = "Объекты парковки"
ordering = ("name",)
def __str__(self) -> str:
return f"{self.name} ({self.city})"
@property
def owner_username(self) -> str:
return getattr(self.owner, "username", "")
def set_coordinates(self, lat: Optional[float], lng: Optional[float]) -> None:
"""
Устанавливает координаты и PointField (если доступен GeoDjango).
"""
self.latitude = lat
self.longitude = lng
if lat is None or lng is None:
self.location = None
return
try:
from django.contrib.gis.geos import Point
except Exception:
# SQLite/JSON fallback
self.location = {"lat": lat, "lng": lng}
else:
self.location = Point(lng, lat)
class ParkingSpot(TimeStampedModel):
"""
Конкретное парковочное место внутри ParkingLot.
"""
class SpotStatus(models.TextChoices):
ACTIVE = "active", "Активно"
INACTIVE = "inactive", "Неактивно"
class VehicleType(models.TextChoices):
CAR = "car", "Легковой автомобиль"
MOTO = "moto", "Мотоцикл"
COMMERCIAL = "commercial", "Коммерческий транспорт"
lot = models.ForeignKey(
ParkingLot,
on_delete=models.CASCADE,
related_name="spots",
verbose_name="Объект парковки",
)
name = models.CharField("Название/номер места", max_length=64)
description = models.TextField("Описание", blank=True)
vehicle_type = models.CharField(
"Тип транспорта",
max_length=16,
choices=VehicleType.choices,
default=VehicleType.CAR,
)
is_covered = models.BooleanField("Крытое место", default=False)
has_ev_charging = models.BooleanField("Есть зарядка", default=False)
is_24_7 = models.BooleanField("Круглосуточно", default=True)
max_height_m = models.DecimalField(
"Максимальная высота (м)",
max_digits=4,
decimal_places=2,
null=True,
blank=True,
)
hourly_price = models.DecimalField(
"Цена за час, ₽", max_digits=8, decimal_places=2
)
nightly_price = models.DecimalField(
"Цена за ночь, ₽", max_digits=8, decimal_places=2, null=True, blank=True
)
daily_price = models.DecimalField(
"Цена за сутки, ₽", max_digits=8, decimal_places=2, null=True, blank=True
)
monthly_price = models.DecimalField(
"Цена за месяц, ₽", max_digits=9, decimal_places=2, null=True, blank=True
)
allow_dynamic_pricing = models.BooleanField(
"Динамическая цена (AI)",
default=False,
help_text="Если включено, тариф может корректироваться рекомендациями AI.",
)
status = models.CharField(
"Статус",
max_length=16,
choices=SpotStatus.choices,
default=SpotStatus.ACTIVE,
)
occupancy_7d = models.FloatField(
"Загруженность за 7 дней (0..1)",
default=0.0,
help_text=(
"Доля времени, когда место было занято за последние 7 дней. "
"Обновляется фоновыми задачами AI."
),
)
class Meta:
verbose_name = "Парковочное место"
verbose_name_plural = "Парковочные места"
ordering = ("lot__name", "name")
def __str__(self) -> str:
return f"{self.lot.name} — {self.name}"
@property
def owner(self):
"""
Для IsOwnerObject из core.permissions: владелец места = владелец ParkingLot.
"""
return self.lot.owner
@property
def city(self) -> str:
return self.lot.city
@property
def is_active(self) -> bool:
return (
self.status == self.SpotStatus.ACTIVE
and self.lot.is_active
and self.lot.is_approved
)
class Booking(TimeStampedModel):
"""
Бронирование парковочного места.
"""
class BookingType(models.TextChoices):
HOURLY = "hourly", "Почасовая"
DAILY = "daily", "Суточная"
NIGHT = "night", "Ночная"
WEEKLY = "weekly", "Недельная"
MONTHLY = "monthly", "Месячная"
class Status(models.TextChoices):
PENDING = "pending", "Ожидает оплаты"
CONFIRMED = "confirmed", "Подтверждена"
ACTIVE = "active", "Активна"
COMPLETED = "completed", "Завершена"
CANCELLED = "cancelled", "Отменена"
EXPIRED = "expired", "Истекла"
user = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="bookings",
verbose_name="Пользователь",
)
spot = models.ForeignKey(
ParkingSpot,
on_delete=models.PROTECT,
related_name="bookings",
verbose_name="Парковочное место",
)
vehicle = models.ForeignKey(
"vehicles.Vehicle",
on_delete=models.SET_NULL,
related_name="bookings",
verbose_name="Транспорт",
null=True,
blank=True,
)
booking_type = models.CharField(
"Тип бронирования",
max_length=16,
choices=BookingType.choices,
default=BookingType.HOURLY,
)
start_at = models.DateTimeField("Начало брони")
end_at = models.DateTimeField("Окончание брони")
status = models.CharField(
"Статус",
max_length=16,
choices=Status.choices,
default=Status.PENDING,
)
total_price = models.DecimalField(
"Итоговая стоимость, ₽", max_digits=10, decimal_places=2
)
currency = models.CharField("Валюта", max_length=8, default="RUB")
is_paid = models.BooleanField("Оплачено", default=False)
dynamic_pricing_applied = models.BooleanField(
"Динамическое ценообразование", default=False
)
ai_snapshot = models.JSONField(
"AI snapshot",
null=True,
blank=True,
help_text="Данные решений AI (цены, доступность, риски)",
)
external_payment_id = models.CharField(
"ID платежа провайдера",
max_length=64,
blank=True,
help_text="Связка с платежом у провайдера (например, YooKassa payment_id).",
)
class Meta:
verbose_name = "Бронирование"
verbose_name_plural = "Бронирования"
ordering = ("-start_at",)
def __str__(self) -> str:
return f"Бронь
@property
def owner(self):
"""
Для удобства — владелец места, по которому идёт бронь.
"""
return self.spot.lot.owner
@staticmethod
def is_spot_available(
spot: ParkingSpot,
start_at,
end_at,
exclude_booking_id: Optional[int] = None,
) -> bool:
"""
Проверка пересечения интервалов с существующими бронями.
"""
qs = Booking.objects.filter(spot=spot).exclude(
status__in=[Booking.Status.CANCELLED, Booking.Status.EXPIRED]
)
if exclude_booking_id:
qs = qs.exclude(id=exclude_booking_id)
# Пересечение интервалов: (start1 < end2) и (end1 > start2)
overlap = qs.filter(start_at__lt=end_at, end_at__gt=start_at).exists()
return not overlap
def calculate_price(self) -> Decimal:
"""
Простая модель расчёта цены на основе тарифов ParkingSpot и типа брони.
"""
if not self.spot:
return Decimal("0.00")
delta = self.end_at - self.start_at
total_hours = Decimal(delta.total_seconds()) / Decimal(3600)
total_days = Decimal(delta.total_seconds()) / Decimal(86400)
base_price = Decimal("0.00")
if self.booking_type == self.BookingType.HOURLY:
hourly = self.spot.hourly_price
units = max(
Decimal("1"),
total_hours.to_integral_value(rounding=ROUND_UP),
)
base_price = hourly * units
elif self.booking_type == self.BookingType.DAILY:
daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
units = max(
Decimal("1"),
total_days.to_integral_value(rounding=ROUND_UP),
)
base_price = daily * units
elif self.booking_type == self.BookingType.NIGHT:
nightly = self.spot.nightly_price or (
self.spot.hourly_price * Decimal("10")
)
base_price = nightly
elif self.booking_type == self.BookingType.WEEKLY:
daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
units = max(
Decimal("1"),
(total_days / Decimal("7")).to_integral_value(rounding=ROUND_UP),
)
base_price = daily * Decimal("7") * units
elif self.booking_type == self.BookingType.MONTHLY:
monthly = self.spot.monthly_price or (
(self.spot.daily_price or self.spot.hourly_price * Decimal("24"))
* Decimal("30")
)
units = max(
Decimal("1"),
(total_days / Decimal("30")).to_integral_value(rounding=ROUND_UP),
)
base_price = monthly * units
else:
base_price = self.spot.hourly_price * max(
Decimal("1"),
total_hours.to_integral_value(rounding=ROUND_UP),
)
base_price = base_price.quantize(Decimal("0.01"))
commission_percent = getattr(settings, "SERVICE_COMMISSION_PERCENT", 0)
commission = (
base_price * Decimal(commission_percent) / Decimal("100")
).quantize(Decimal("0.01"))
total = (base_price + commission).quantize(Decimal("0.01"))
self.total_price = total
return total
def mark_paid(self, payment_id: str | None = None) -> None:
"""
Отметить бронь как оплаченную (вызывается из модуля payments по webhook).
"""
self.is_paid = True
self.status = self.Status.CONFIRMED
if payment_id:
self.external_payment_id = payment_id
self.save(update_fields=["is_paid", "status", "external_payment_id"])
@property
def has_started(self) -> bool:
return self.start_at <= timezone.now()
@property
def has_ended(self) -> bool:
return self.end_at <= timezone.now()
@property
def duration(self) -> timedelta:
return self.end_at - self.start_at
class WaitlistEntry(TimeStampedModel):
"""
Запись в листе ожидания для занятого места.
"""
class Status(models.TextChoices):
WAITING = "waiting", "Ожидает"
NOTIFIED = "notified", "Уведомлён"
BOOKED = "booked", "Авто‑бронирование создано"
CANCELLED = "cancelled", "Отменено"
user = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="waitlist_entries",
verbose_name="Пользователь",
)
spot = models.ForeignKey(
ParkingSpot,
on_delete=models.CASCADE,
related_name="waitlist_entries",
verbose_name="Парковочное место",
)
desired_start = models.DateTimeField("Желаемое начало")
desired_end = models.DateTimeField("Желаемое окончание")
auto_book = models.BooleanField(
"Авто‑бронирование",
default=False,
help_text="Если включено, при освобождении места будет создана бронь автоматически.",
)
status = models.CharField(
"Статус",
max_length=16,
choices=Status.choices,
default=Status.WAITING,
)
class Meta:
verbose_name = "Запись в листе ожидания"
verbose_name_plural = "Лист ожидания"
ordering = ("-created_at",)
unique_together = ("user", "spot", "desired_start", "desired_end")
def __str__(self) -> str:
return f"Waitlist
class Complaint(TimeStampedModel):
"""
Жалоба по бронированию/месту:
- чужая машина;
- пользователь не приехал;
- частые отмены и т.п.
"""
class Category(models.TextChoices):
FOREIGN_CAR = "foreign_car", "Чужая машина на месте"
NO_SHOW = "no_show", "Пользователь не приехал"
NO_FREE_SPOT = "no_free_spot", "Не нашёл свободного места"
OTHER = "other", "Другое"
class Status(models.TextChoices):
NEW = "new", "Новая"
IN_PROGRESS = "in_progress", "В работе"
RESOLVED = "resolved", "Решена"
REJECTED = "rejected", "Отклонена"
author = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="complaints",
verbose_name="Автор",
)
booking = models.ForeignKey(
Booking,
on_delete=models.SET_NULL,
related_name="complaints",
null=True,
blank=True,
verbose_name="Бронирование",
)
spot = models.ForeignKey(
ParkingSpot,
on_delete=models.SET_NULL,
related_name="complaints",
null=True,
blank=True,
verbose_name="Парковочное место",
)
category = models.CharField(
"Категория",
max_length=32,
choices=Category.choices,
default=Category.OTHER,
)
description = models.TextField("Описание", blank=True)
status = models.CharField(
"Статус",
max_length=16,
choices=Status.choices,
default=Status.NEW,
)
class Meta:
verbose_name = "Жалоба"
verbose_name_plural = "Жалобы"
ordering = ("-created_at",)
def __str__(self) -> str:
return f"Жалоба
class FavoriteParkingSpot(TimeStampedModel):
"""Избранные парковочные места пользователя."""
user = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="favorite_spots",
)
spot = models.ForeignKey(
ParkingSpot,
on_delete=models.CASCADE,
related_name="favorites",
)
note = models.CharField("Заметка", max_length=120, blank=True)
class Meta:
verbose_name = "Избранное место"
verbose_name_plural = "Избранные места"
ordering = ("-created_at",)
unique_together = ("user", "spot")
def __str__(self) -> str:
return f"{self.user} → {self.spot}"
class SavedPlace(TimeStampedModel):
"""Сохранённые точки (дом/офис) для быстрого поиска."""
class PlaceType(models.TextChoices):
HOME = "home", "Дом"
WORK = "work", "Офис"
CUSTOM = "custom", "Другое"
user = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="saved_places",
)
title = models.CharField("Название", max_length=64)
place_type = models.CharField(
"Тип точки",
max_length=16,
choices=PlaceType.choices,
default=PlaceType.CUSTOM,
)
latitude = models.FloatField("Широта")
longitude = models.FloatField("Долгота")
class Meta:
verbose_name = "Сохранённая точка"
verbose_name_plural = "Сохранённые точки"
ordering = ("title",)
unique_together = ("user", "title")
def __str__(self) -> str:
return f"{self.title} ({self.user})"

# File 95/163: parking\serializers.py
################################################################################

from __future__ import annotations
from django.utils import timezone
from rest_framework import serializers
from core.utils import haversine_distance_km
from ai.orchestrator import apply_ai_pricing
from .models import (
Booking,
Complaint,
FavoriteParkingSpot,
ParkingLot,
ParkingSpot,
SavedPlace,
WaitlistEntry,
)
class ParkingLotSerializer(serializers.ModelSerializer):
owner = serializers.ReadOnlyField(source="owner.username")
spots_count = serializers.SerializerMethodField()
class Meta:
model = ParkingLot
fields = (
"id",
"name",
"city",
"address",
"parking_type",
"description",
"latitude",
"longitude",
"is_active",
"is_approved",
"is_private",
"owner",
"spots_count",
)
read_only_fields = ("id", "is_approved", "owner", "spots_count")
def get_spots_count(self, obj: ParkingLot) -> int:
return obj.spots.filter(status=ParkingSpot.SpotStatus.ACTIVE).count()
def create(self, validated_data):
"""
При создании парковки автоматически подставляем owner из request
и синхронизируем PointField / lat / lng, если координаты заданы.
"""
request = self.context.get("request")
owner = getattr(request, "user", None)
if owner is not None and owner.is_authenticated:
validated_data["owner"] = owner
lot = super().create(validated_data)
if lot.latitude is not None and lot.longitude is not None:
lot.set_coordinates(lot.latitude, lot.longitude)
lot.save(update_fields=["latitude", "longitude", "location"])
return lot
def update(self, instance: ParkingLot, validated_data):
lat = validated_data.get("latitude", instance.latitude)
lng = validated_data.get("longitude", instance.longitude)
instance = super().update(instance, validated_data)
instance.set_coordinates(lat, lng)
instance.save(update_fields=["latitude", "longitude", "location"])
return instance
class ParkingSpotSerializer(serializers.ModelSerializer):
"""
Серилизатор спота для публичного API.
Дополнительные read-only поля:
- lot_name, city — для удобного отображения;
- lot_latitude, lot_longitude, lot_address — чтобы рисовать маркеры на карте;
- distance_km — расстояние от точки запроса (lat/lng) до лота.
"""
lot_name = serializers.ReadOnlyField(source="lot.name")
city = serializers.ReadOnlyField(source="lot.city")
lot_latitude = serializers.ReadOnlyField(source="lot.latitude")
lot_longitude = serializers.ReadOnlyField(source="lot.longitude")
lot_address = serializers.ReadOnlyField(source="lot.address")
distance_km = serializers.SerializerMethodField()
class Meta:
model = ParkingSpot
fields = (
"id",
"lot",
"lot_name",
"city",
"lot_latitude",
"lot_longitude",
"lot_address",
"name",
"description",
"vehicle_type",
"is_covered",
"has_ev_charging",
"is_24_7",
"max_height_m",
"hourly_price",
"nightly_price",
"daily_price",
"monthly_price",
"allow_dynamic_pricing",
"status",
"distance_km",
)
read_only_fields = (
"id",
"lot_name",
"city",
"lot_latitude",
"lot_longitude",
"lot_address",
"distance_km",
)
def get_distance_km(self, obj: ParkingSpot):
"""
Если атрибут distance_km уже повешен во viewset — используем его.
Иначе считаем по lat/lng из query-параметров (если они заданы).
"""
distance = getattr(obj, "distance_km", None)
if distance is not None:
return round(float(distance), 2)
request = self.context.get("request")
if not request:
return None
lat_param = request.query_params.get("lat")
lng_param = request.query_params.get("lng")
if not lat_param or not lng_param:
return None
if obj.lot.latitude is None or obj.lot.longitude is None:
return None
try:
lat = float(lat_param)
lng = float(lng_param)
except (TypeError, ValueError):
return None
return round(
haversine_distance_km(lat, lng, obj.lot.latitude, obj.lot.longitude), 2
)
class BookingSerializer(serializers.ModelSerializer):
user = serializers.ReadOnlyField(source="user.username")
spot_name = serializers.ReadOnlyField(source="spot.name")
lot_name = serializers.ReadOnlyField(source="spot.lot.name")
class Meta:
model = Booking
fields = (
"id",
"user",
"spot",
"spot_name",
"lot_name",
"vehicle",
"booking_type",
"start_at",
"end_at",
"status",
"total_price",
"currency",
"is_paid",
"created_at",
"updated_at",
"external_payment_id",
)
read_only_fields = (
"id",
"user",
"status",
"total_price",
"currency",
"is_paid",
"created_at",
"updated_at",
"external_payment_id",
"spot_name",
"lot_name",
)
def validate(self, attrs):
"""
Базовая валидация бронирования:
- start < end
- не в прошлом
- место активно
- нет пересечения с другими бронями.
"""
request = self.context["request"]
spot: ParkingSpot = attrs.get("spot", getattr(self.instance, "spot", None))
start_at = attrs.get("start_at", getattr(self.instance, "start_at", None))
end_at = attrs.get("end_at", getattr(self.instance, "end_at", None))
booking_type = attrs.get(
"booking_type",
getattr(self.instance, "booking_type", Booking.BookingType.HOURLY),
)
if not spot or not start_at or not end_at:
raise serializers.ValidationError(
"Необходимо указать место и интервал бронирования."
)
if start_at >= end_at:
raise serializers.ValidationError(
"Дата начала должна быть меньше даты окончания."
)
if start_at < timezone.now():
raise serializers.ValidationError(
"Нельзя создавать бронирование в прошлом."
)
if not spot.is_active:
raise serializers.ValidationError(
"Выбранное место сейчас недоступно для бронирования."
)
exclude_id = self.instance.id if self.instance else None
if not Booking.is_spot_available(
spot, start_at, end_at, exclude_booking_id=exclude_id
):
raise serializers.ValidationError(
"На выбранный период это место уже забронировано."
)
attrs["spot"] = spot
attrs["start_at"] = start_at
attrs["end_at"] = end_at
attrs["booking_type"] = booking_type
return attrs
def create(self, validated_data):
request = self.context["request"]
user = request.user
booking = Booking(
user=user,
**validated_data,
)
booking.total_price = booking.calculate_price()
booking.currency = "RUB"
booking.status = Booking.Status.PENDING
apply_ai_pricing(booking)
booking.save()
return booking
def update(self, instance, validated_data):
for field in ("spot", "start_at", "end_at", "booking_type", "vehicle"):
if field in validated_data:
setattr(instance, field, validated_data[field])
# Для простоты разрешаем редактировать только PENDING‑брони.
if instance.status != Booking.Status.PENDING:
raise serializers.ValidationError(
"Можно редактировать только бронирования в статусе 'Ожидает оплаты'."
)
instance.total_price = instance.calculate_price()
apply_ai_pricing(instance)
instance.save()
return instance
class WaitlistEntrySerializer(serializers.ModelSerializer):
user = serializers.ReadOnlyField(source="user.username")
spot_name = serializers.ReadOnlyField(source="spot.name")
class Meta:
model = WaitlistEntry
fields = (
"id",
"user",
"spot",
"spot_name",
"desired_start",
"desired_end",
"auto_book",
"status",
"created_at",
"updated_at",
)
read_only_fields = (
"id",
"user",
"spot_name",
"status",
"created_at",
"updated_at",
)
def create(self, validated_data):
request = self.context["request"]
user = request.user
entry = WaitlistEntry.objects.create(user=user, **validated_data)
return entry
class ComplaintSerializer(serializers.ModelSerializer):
author = serializers.ReadOnlyField(source="author.username")
spot_name = serializers.ReadOnlyField(source="spot.name")
booking_id = serializers.ReadOnlyField(source="booking.id")
class Meta:
model = Complaint
fields = (
"id",
"author",
"booking",
"booking_id",
"spot",
"spot_name",
"category",
"description",
"status",
"created_at",
"updated_at",
)
read_only_fields = (
"id",
"author",
"status",
"created_at",
"updated_at",
"spot_name",
"booking_id",
)
def create(self, validated_data):
request = self.context["request"]
user = request.user
complaint = Complaint.objects.create(author=user, **validated_data)
return complaint
class FavoriteParkingSpotSerializer(serializers.ModelSerializer):
spot_name = serializers.ReadOnlyField(source="spot.name")
lot_name = serializers.ReadOnlyField(source="spot.lot.name")
city = serializers.ReadOnlyField(source="spot.lot.city")
class Meta:
model = FavoriteParkingSpot
fields = (
"id",
"spot",
"spot_name",
"lot_name",
"city",
"note",
"created_at",
)
read_only_fields = ("id", "spot_name", "lot_name", "city", "created_at")
def create(self, validated_data):
request = self.context.get("request")
if request and request.user.is_authenticated:
validated_data["user"] = request.user
return super().create(validated_data)
class SavedPlaceSerializer(serializers.ModelSerializer):
class Meta:
model = SavedPlace
fields = (
"id",
"title",
"place_type",
"latitude",
"longitude",
"created_at",
)
read_only_fields = ("id", "created_at")
def create(self, validated_data):
request = self.context.get("request")
if request and request.user.is_authenticated:
validated_data["user"] = request.user
return super().create(validated_data)

# File 96/163: parking\tasks.py
################################################################################

# backend/parking/tasks.py
from __future__ import annotations
from datetime import timedelta
from celery import shared_task
from django.utils import timezone
from .models import Booking
@shared_task
def expire_unpaid_bookings() -> str:
"""
Фоновая задача: помечает как EXPIRED неоплаченные бронирования,
у которых время начала уже давно прошло.
Подключена в CELERY_BEAT_SCHEDULE как parking.tasks.expire_unpaid_bookings.
"""
now = timezone.now()
grace = timedelta(minutes=15)
qs = Booking.objects.filter(
status=Booking.Status.PENDING,
is_paid=False,
start_at__lt=now - grace,
)
count = qs.count()
for booking in qs:
booking.status = Booking.Status.EXPIRED
booking.save(update_fields=["status"])
return f"Expired {count} unpaid bookings"

# File 97/163: parking\urls.py
################################################################################

# backend/parking/urls.py
from django.urls import path
app_name = "parking"
urlpatterns: list = [
# На данный момент все HTML‑страницы подключаются напрямую из config.urls.
]

# File 98/163: parking\views.py
################################################################################

from __future__ import annotations
from typing import Any, Iterable, List
from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.cache import cache
from django.db.models import Q
import requests
from django.shortcuts import redirect
from django.urls import reverse
from django.views.generic import TemplateView
from rest_framework import permissions, status, viewsets
from rest_framework.response import Response
from core.permissions import IsAdminOrReadOnly
from core.utils import haversine_distance_km, parse_float
from vehicles.models import Vehicle
from .models import (
Booking,
Complaint,
FavoriteParkingSpot,
ParkingLot,
ParkingSpot,
SavedPlace,
WaitlistEntry,
)
from .serializers import (
BookingSerializer,
ComplaintSerializer,
FavoriteParkingSpotSerializer,
ParkingLotSerializer,
ParkingSpotSerializer,
SavedPlaceSerializer,
WaitlistEntrySerializer,
)
# =======================
#   DRF ViewSets (API)
# =======================
class ParkingLotViewSet(viewsets.ModelViewSet):
"""
CRUD по объектам парковки.
- GET /api/parking/lots/ — список (фильтрация по городу/типу)
- POST /api/parking/lots/ — создать (только владельцы/админы)
"""
serializer_class = ParkingLotSerializer
permission_classes = [permissions.IsAuthenticatedOrReadOnly]
def get_queryset(self):
qs = ParkingLot.objects.select_related("owner")
user = self.request.user
if not user.is_authenticated or (
not user.is_staff and not getattr(user, "is_owner", False)
):
qs = qs.filter(is_active=True, is_approved=True)
city = self.request.query_params.get("city")
if city:
qs = qs.filter(city__iexact=city)
parking_type = self.request.query_params.get("parking_type")
if parking_type:
qs = qs.filter(parking_type=parking_type)
return qs
def perform_create(self, serializer):
user = self.request.user
if not user.is_authenticated or not getattr(user, "is_owner", False):
raise permissions.PermissionDenied(
"Создавать объекты парковки могут только пользователи с ролью 'owner' или администраторы."
)
serializer.save(owner=user)
class ParkingSpotViewSet(viewsets.ModelViewSet):
"""
CRUD по парковочным местам.
- GET /api/parking/spots/?lat=.&lng=.&radius_km=2 — места рядом
- Фильтры: ?city=, ?vehicle_type=, ?max_price=, ?has_ev=1, ?covered=1, ?is_24_7=1
"""
serializer_class = ParkingSpotSerializer
permission_classes = [permissions.IsAuthenticatedOrReadOnly]
def get_queryset(self):
qs = ParkingSpot.objects.select_related("lot", "lot__owner").all()
user = self.request.user
if self.request.method in ("GET", "HEAD", "OPTIONS"):
qs = qs.filter(
status=ParkingSpot.SpotStatus.ACTIVE,
lot__is_active=True,
lot__is_approved=True,
)
else:
# Управлять местами может только владелец/админ
if not user.is_authenticated or (
not getattr(user, "is_owner", False) and not user.is_superuser
):
return ParkingSpot.objects.none()
qs = qs.filter(lot__owner=user)
# Фильтрация
params = self.request.query_params
city = params.get("city")
if city:
qs = qs.filter(lot__city__iexact=city)
vehicle_type = params.get("vehicle_type")
if vehicle_type:
qs = qs.filter(vehicle_type=vehicle_type)
max_price = parse_float(params.get("max_price"))
if max_price is not None:
qs = qs.filter(hourly_price__lte=max_price)
has_ev = params.get("has_ev")
if has_ev == "1":
qs = qs.filter(has_ev_charging=True)
covered = params.get("covered")
if covered == "1":
qs = qs.filter(is_covered=True)
is_24_7 = params.get("is_24_7")
if is_24_7 == "1":
qs = qs.filter(is_24_7=True)
return qs
def list(self, request, *args, **kwargs):
"""
Список мест c опциональной фильтрацией по радиусу от точки (lat/lng).
"""
queryset = self.filter_queryset(self.get_queryset())
lat = parse_float(request.query_params.get("lat"))
lng = parse_float(request.query_params.get("lng"))
radius_km = parse_float(request.query_params.get("radius_km"))
if lat is not None and lng is not None and radius_km is not None:
# Python‑фильтрация по расстоянию (работает и без PostGIS)
filtered: List[ParkingSpot] = []
for spot in queryset:
lot = spot.lot
if lot.latitude is None or lot.longitude is None:
continue
distance = haversine_distance_km(
lat, lng, lot.latitude, lot.longitude
)
if distance <= radius_km:
spot.distance_km = distance
filtered.append(spot)
queryset = filtered
page = self.paginate_queryset(queryset)
if page is not None:
serializer = self.get_serializer(page, many=True)
return self.get_paginated_response(serializer.data)
serializer = self.get_serializer(queryset, many=True)
return Response(serializer.data)
class BookingViewSet(viewsets.ModelViewSet):
"""
Бронирования.
- Пользователь видит свои бронирования.
- Владелец видит свои бронирования и брони по своим местам.
"""
serializer_class = BookingSerializer
permission_classes = [permissions.IsAuthenticated]
def get_queryset(self):
user = self.request.user
qs = Booking.objects.select_related(
"spot", "spot__lot", "user", "vehicle"
).all()
if not user.is_authenticated:
return Booking.objects.none()
if user.is_superuser:
return qs
if getattr(user, "is_owner", False):
return qs.filter(Q(user=user) | Q(spot__lot__owner=user))
return qs.filter(user=user)
def perform_create(self, serializer):
booking = serializer.save()
return booking
def destroy(self, request, *args, **kwargs):
"""
Отмена бронирования: помечаем как CANCELLED, если оно ещё не началось.
"""
instance: Booking = self.get_object()
if instance.has_started:
return Response(
{"detail": "Нельзя отменить уже начавшееся бронирование."},
status=status.HTTP_400_BAD_REQUEST,
)
instance.status = Booking.Status.CANCELLED
instance.save(update_fields=["status"])
return Response(status=status.HTTP_204_NO_CONTENT)
class WaitlistViewSet(viewsets.ModelViewSet):
"""
Лист ожидания. Пользователь управляет только своими записями.
Админ может видеть всё.
"""
serializer_class = WaitlistEntrySerializer
permission_classes = [permissions.IsAuthenticated]
def get_queryset(self):
user = self.request.user
qs = WaitlistEntry.objects.select_related("spot", "spot__lot", "user")
if user.is_superuser:
return qs
return qs.filter(user=user)
class ComplaintViewSet(viewsets.ModelViewSet):
"""
Жалобы. Создатель видит свои, админ — все.
"""
serializer_class = ComplaintSerializer
permission_classes = [permissions.IsAuthenticated]
def get_queryset(self):
user = self.request.user
qs = Complaint.objects.select_related("author", "spot", "booking")
if user.is_superuser:
return qs
return qs.filter(author=user)
def perform_create(self, serializer):
serializer.save(author=self.request.user)
class FavoriteParkingSpotViewSet(viewsets.ModelViewSet):
"""API избранных парковочных мест."""
serializer_class = FavoriteParkingSpotSerializer
permission_classes = [permissions.IsAuthenticated]
def get_queryset(self):
user = self.request.user
qs = FavoriteParkingSpot.objects.select_related("spot", "spot__lot")
if user.is_superuser:
return qs
return qs.filter(user=user)
def perform_create(self, serializer):
serializer.save(user=self.request.user)
class SavedPlaceViewSet(viewsets.ModelViewSet):
"""Сохранённые точки (дом/офис)."""
serializer_class = SavedPlaceSerializer
permission_classes = [permissions.IsAuthenticated]
def get_queryset(self):
user = self.request.user
qs = SavedPlace.objects.all()
if user.is_superuser:
return qs
return qs.filter(user=user)
def perform_create(self, serializer):
serializer.save(user=self.request.user)
# =======================
#   HTML-вьюхи
# =======================
class LandingPageView(TemplateView):
"""
Лендинг с картой и списком парковок/мест.
Поддерживает фильтры:
- city
- lat, lng, radius_km (поиск по радиусу)
"""
template_name = "parking/landing.html"
def get_context_data(self, **kwargs: Any):
ctx = super().get_context_data(**kwargs)
params = self.request.GET
city = (params.get("city") or "").strip()
lat = parse_float(params.get("lat"))
lng = parse_float(params.get("lng"))
radius_km = parse_float(params.get("radius_km"))
lots_qs = ParkingLot.objects.filter(
is_active=True, is_approved=True
).select_related("owner")
if city:
lots_qs = lots_qs.filter(city__iexact=city)
lots = lots_qs.order_by("city", "name")[:50]
spots_qs = ParkingSpot.objects.filter(
status=ParkingSpot.SpotStatus.ACTIVE,
lot__in=lots,
).select_related("lot", "lot__owner")
spots: Iterable[ParkingSpot]
if lat is not None and lng is not None and radius_km is not None:
filtered: list[ParkingSpot] = []
for spot in spots_qs:
lot = spot.lot
if lot.latitude is None or lot.longitude is None:
continue
distance = haversine_distance_km(
lat, lng, lot.latitude, lot.longitude
)
if distance <= radius_km:
spot.distance_km = distance
filtered.append(spot)
spots = sorted(
filtered,
key=lambda s: getattr(s, "distance_km", 0.0),
)[:100]
else:
spots = spots_qs.order_by(
"lot__city", "lot__name", "name"
)[:100]
ctx["lots"] = lots
ctx["spots"] = spots
ctx["has_query"] = bool(
city or (lat is not None and lng is not None and radius_km is not None)
)
return ctx
class MapPageView(LandingPageView):
"""Полноэкранная карта с теми же данными, что и лендинг."""
template_name = "parking/map_fullscreen.html"
class PWAInstallGuideView(TemplateView):
"""Простая страница с инструкциями по установке PWA."""
template_name = "parking/pwa_install.html"
class UserDashboardView(LoginRequiredMixin, TemplateView):
"""
Личный кабинет водителя: его машины и бронирования.
"""
template_name = "parking/user_dashboard.html"
def get_context_data(self, **kwargs: Any):
ctx = super().get_context_data(**kwargs)
user = self.request.user
vehicles = Vehicle.objects.filter(owner=user).order_by("-created_at")
bookings = (
Booking.objects.filter(user=user)
.select_related("spot", "spot__lot")
.order_by("-start_at")
)
ctx["vehicles"] = vehicles
ctx["bookings"] = bookings
return ctx
class OwnerDashboardView(LoginRequiredMixin, TemplateView):
"""
Кабинет владельца: его паркинги, места и бронирования по ним.
"""
template_name = "parking/owner_dashboard.html"
def dispatch(self, request, *args, **kwargs):
user = request.user
if not (getattr(user, "is_owner", False) or user.is_superuser):
# Если не владелец — отправляем в обычный кабинет
return redirect("user_dashboard")
return super().dispatch(request, *args, **kwargs)
def get_context_data(self, **kwargs: Any):
ctx = super().get_context_data(**kwargs)
user = self.request.user
lots = (
ParkingLot.objects.filter(owner=user)
.prefetch_related("spots")
.order_by("city", "name")
)
spots = (
ParkingSpot.objects.filter(lot__owner=user)
.select_related("lot")
.order_by("lot__city", "lot__name", "name")
)
bookings = (
Booking.objects.filter(spot__lot__owner=user)
.select_related("spot", "spot__lot", "user")
.order_by("-start_at")
)
ctx["lots"] = lots
ctx["spots"] = spots
ctx["bookings"] = bookings
return ctx
# parking/views.py (добавить после существующих APIView/ ViewSet)
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from ai.orchestrator import AvailabilityDecision
from .models import ParkingSpot
class ParkingMapAPIView(APIView):
"""
Лёгкий эндпоинт для карты:
- фильтры по цене/фичам;
- возвращает GeoJSON‑подобную структуру (features).
"""
permission_classes = [AllowAny]
def get(self, request, *args, **kwargs):
params = request.query_params
only_free = params.get("only_free") == "true"
has_ev = params.get("ev") == "true"
covered = params.get("covered") == "true"
is_24_7 = params.get("is_24_7") == "true"
ai_only = params.get("ai_recommended") == "true"
try:
min_price = float(params.get("min_price") or 0)
except ValueError:
min_price = 0.0
try:
max_price = float(params.get("max_price") or 0)
except ValueError:
max_price = 0.0
qs = ParkingSpot.objects.filter(
status=ParkingSpot.SpotStatus.ACTIVE,
lot__is_active=True,
lot__is_approved=True,
).select_related("lot")
if has_ev:
qs = qs.filter(has_ev_charging=True)
if covered:
qs = qs.filter(is_covered=True)
if is_24_7:
qs = qs.filter(is_24_7=True)
if min_price:
qs = qs.filter(hourly_price__gte=min_price)
if max_price:
qs = qs.filter(hourly_price__lte=max_price)
if ai_only:
qs = qs.filter(allow_dynamic_pricing=True)
features = []
for spot in qs[:500]:
lat = getattr(spot.lot, "latitude", None)
lng = getattr(spot.lot, "longitude", None)
if lat is None or lng is None:
continue
availability_score = 1.0 - float(spot.occupancy_7d or 0.0)
is_free_like = availability_score > 0.3
if only_free and not is_free_like:
continue
features.append(
{
"id": str(spot.id),
"type": "Feature",
"geometry": {
"type": "Point",
"coordinates": [lng, lat],
},
"properties": {
"spot_id": str(spot.id),
"lot_id": str(spot.lot_id),
"lot_name": spot.lot.name,
"city": spot.lot.city,
"address": spot.lot.address,
"name": spot.name,
"vehicle_type": spot.vehicle_type,
"has_ev_charging": spot.has_ev_charging,
"is_covered": spot.is_covered,
"is_24_7": spot.is_24_7,
"hourly_price": float(spot.hourly_price),
"allow_dynamic_pricing": spot.allow_dynamic_pricing,
"occupancy_7d": float(spot.occupancy_7d or 0.0),
"stress_index": float(spot.lot.stress_index or 0.0),
},
}
)
return Response(
{
"type": "FeatureCollection",
"features": features,
}
)
class GeocodeAPIView(APIView):
"""Простой прокси к Nominatim с кешированием."""
permission_classes = [AllowAny]
def get(self, request, *args, **kwargs):
query = (request.query_params.get("q") or "").strip()
if not query:
return Response({"detail": "q is required"}, status=status.HTTP_400_BAD_REQUEST)
cache_key = f"geocode:{query}"
cached = cache.get(cache_key)
if cached:
return Response(cached)
url = "https:
resp = requests.get(
url,
params={"q": query, "format": "json", "limit": 5, "addressdetails": 1},
headers={"User-Agent": "ParkShare-RU/1.0"},
timeout=10,
)
resp.raise_for_status()
data = resp.json()
results = [
{
"title": item.get("display_name"),
"lat": float(item.get("lat")),
"lng": float(item.get("lon")),
}
for item in data
]
payload = {"results": results}
cache.set(cache_key, payload, 60 * 10)
return Response(payload)

# File 99/163: parking\management\commands\seed_demo_parking.py
################################################################################

# parking/management/commands/seed_demo_parking.py
from __future__ import annotations
from decimal import Decimal
from django.contrib.auth import get_user_model
from django.core.management.base import BaseCommand
from django.db import transaction
from parking.models import ParkingLot, ParkingSpot
class Command(BaseCommand):
help = "Создаёт демо-объект парковки и несколько мест для локальной разработки."
def handle(self, *args, **options):
User = get_user_model()
# ---------- 1. Владелец парковки ----------
role_cls = getattr(User, "Role", None)
owner_role_value = getattr(role_cls, "OWNER", None) if role_cls else None
owner_defaults = {
"email": "demo-owner@example.com",
"is_active": True,
}
if owner_role_value is not None:
owner_defaults["role"] = owner_role_value
owner, created_owner = User.objects.get_or_create(
username="demo_owner",
defaults=owner_defaults,
)
if created_owner:
owner.set_password("demo_owner")
owner.save(update_fields=["password"])
self.stdout.write(
self.style.SUCCESS(
"Создан пользователь-владелец demo_owner / пароль: demo_owner"
)
)
else:
self.stdout.write(
self.style.SUCCESS(f"Найден владелец demo_owner (id={owner.pk})")
)
# ---------- 2. Объект парковки ----------
with transaction.atomic():
lot, created_lot = ParkingLot.objects.get_or_create(
name="Демо-парковка ParkShare",
city="Москва",
address="ул. Примерная, д. 1",
defaults={
"owner": owner,
"parking_type": "yard",
"latitude": 55.751244,
"longitude": 37.618423,
"is_active": True,
"is_approved": True,
"is_private": False,
},
)
if not created_lot:
# На всякий случай привязываем к нашему демо-владельцу
if lot.owner_id != owner.id:
lot.owner = owner
lot.save(update_fields=["owner"])
self.stdout.write(
self.style.SUCCESS(
f"Используем существующую парковку (id={lot.pk})"
)
)
else:
self.stdout.write(
self.style.SUCCESS(
f"Создана демо-парковка (id={lot.pk}) в Москве"
)
)
# ---------- 3. Парковочные места ----------
spots_spec = [
{
"name": "Место 1 — EV 24/7",
"description": "Рядом с въездом, есть зарядка для EV.",
"is_covered": False,
"has_ev_charging": True,
"is_24_7": True,
"hourly_price": Decimal("120.00"),
"allow_dynamic_pricing": True,
"occupancy_7d": 0.65,
},
{
"name": "Место 2 — крытое",
"description": "Крытое место на -1 этаже.",
"is_covered": True,
"has_ev_charging": False,
"is_24_7": True,
"hourly_price": Decimal("90.00"),
"allow_dynamic_pricing": False,
"occupancy_7d": 0.40,
},
{
"name": "Место 3 — бюджетное",
"description": "Самое дешёвое, но чуть дальше от выезда.",
"is_covered": False,
"has_ev_charging": False,
"is_24_7": True,
"hourly_price": Decimal("70.00"),
"allow_dynamic_pricing": True,
"occupancy_7d": 0.80,
},
{
"name": "Место 4 — премиум",
"description": "Широкое место, удобно для кроссоверов.",
"is_covered": True,
"has_ev_charging": True,
"is_24_7": True,
"hourly_price": Decimal("150.00"),
"allow_dynamic_pricing": True,
"occupancy_7d": 0.55,
},
]
created_count = 0
for spec in spots_spec:
spot, created_spot = ParkingSpot.objects.get_or_create(
lot=lot,
name=spec["name"],
defaults=spec,
)
if created_spot:
created_count += 1
total_spots = ParkingSpot.objects.filter(lot=lot).count()
self.stdout.write(
self.style.SUCCESS(
f"Готово: мест в демо-парковке сейчас {total_spots} "
f"(создано за этот запуск {created_count})."
)
)
self.stdout.write(self.style.SUCCESS("seed_demo_parking: демо-данные готовы."))

# File 100/163: parking\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34
import django.db.models.deletion
import parking.models
from django.conf import settings
from django.db import migrations, models
class Migration(migrations.Migration):
initial = True
dependencies = [
('vehicles', '0001_initial'),
migrations.swappable_dependency(settings.AUTH_USER_MODEL),
]
operations = [
migrations.CreateModel(
name='Booking',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('booking_type', models.CharField(choices=[('hourly', 'Почасовая'), ('daily', 'Суточная'), ('night', 'Ночная'), ('weekly', 'Недельная'), ('monthly', 'Месячная')], default='hourly', max_length=16, verbose_name='Тип бронирования')),
('start_at', models.DateTimeField(verbose_name='Начало брони')),
('end_at', models.DateTimeField(verbose_name='Окончание брони')),
('status', models.CharField(choices=[('pending', 'Ожидает оплаты'), ('confirmed', 'Подтверждена'), ('active', 'Активна'), ('completed', 'Завершена'), ('cancelled', 'Отменена'), ('expired', 'Истекла')], default='pending', max_length=16, verbose_name='Статус')),
('total_price', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Итоговая стоимость, ₽')),
('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
('is_paid', models.BooleanField(default=False, verbose_name='Оплачено')),
('external_payment_id', models.CharField(blank=True, help_text='Связка с платежом у провайдера (например, YooKassa payment_id).', max_length=64, verbose_name='ID платежа провайдера')),
('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
('vehicle', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='bookings', to='vehicles.vehicle', verbose_name='Транспорт')),
],
options={
'verbose_name': 'Бронирование',
'verbose_name_plural': 'Бронирования',
'ordering': ('-start_at',),
},
),
migrations.CreateModel(
name='ParkingLot',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('name', models.CharField(max_length=255, verbose_name='Название')),
('city', models.CharField(max_length=100, verbose_name='Город')),
('address', models.CharField(max_length=255, verbose_name='Адрес')),
('parking_type', models.CharField(choices=[('yard', 'Дворовая парковка'), ('underground', 'Подземная парковка'), ('multilevel', 'Многоуровневая парковка'), ('street', 'Уличная парковка'), ('office', 'Офисная парковка'), ('home', 'Домашнее место')], default='yard', max_length=32, verbose_name='Тип парковки')),
('description', models.TextField(blank=True, verbose_name='Описание')),
('location', parking.models.PointField(blank=True, null=True, verbose_name='Точка на карте')),
('latitude', models.FloatField(blank=True, null=True, verbose_name='Широта')),
('longitude', models.FloatField(blank=True, null=True, verbose_name='Долгота')),
('is_active', models.BooleanField(default=True, verbose_name='Активен')),
('is_approved', models.BooleanField(default=False, help_text='Одобряется администратором перед публикацией.', verbose_name='Одобрен модерацией')),
('is_private', models.BooleanField(default=False, help_text='Если включено, объект виден только по прямым ссылкам/владельцу.', verbose_name='Приватный')),
('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='parking_lots', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
],
options={
'verbose_name': 'Объект парковки',
'verbose_name_plural': 'Объекты парковки',
'ordering': ('name',),
},
),
migrations.CreateModel(
name='ParkingSpot',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('name', models.CharField(max_length=64, verbose_name='Название/номер места')),
('description', models.TextField(blank=True, verbose_name='Описание')),
('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
('is_covered', models.BooleanField(default=False, verbose_name='Крытое место')),
('has_ev_charging', models.BooleanField(default=False, verbose_name='Есть зарядка')),
('is_24_7', models.BooleanField(default=True, verbose_name='Круглосуточно')),
('max_height_m', models.DecimalField(blank=True, decimal_places=2, max_digits=4, null=True, verbose_name='Максимальная высота (м)')),
('hourly_price', models.DecimalField(decimal_places=2, max_digits=8, verbose_name='Цена за час, ₽')),
('nightly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за ночь, ₽')),
('daily_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за сутки, ₽')),
('monthly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=9, null=True, verbose_name='Цена за месяц, ₽')),
('allow_dynamic_pricing', models.BooleanField(default=False, help_text='Если включено, тариф может корректироваться рекомендациями AI.', verbose_name='Динамическая цена (AI)')),
('status', models.CharField(choices=[('active', 'Активно'), ('inactive', 'Неактивно')], default='active', max_length=16, verbose_name='Статус')),
('lot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='spots', to='parking.parkinglot', verbose_name='Объект парковки')),
],
options={
'verbose_name': 'Парковочное место',
'verbose_name_plural': 'Парковочные места',
'ordering': ('lot__name', 'name'),
},
),
migrations.CreateModel(
name='Complaint',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('category', models.CharField(choices=[('foreign_car', 'Чужая машина на месте'), ('no_show', 'Пользователь не приехал'), ('no_free_spot', 'Не нашёл свободного места'), ('other', 'Другое')], default='other', max_length=32, verbose_name='Категория')),
('description', models.TextField(blank=True, verbose_name='Описание')),
('status', models.CharField(choices=[('new', 'Новая'), ('in_progress', 'В работе'), ('resolved', 'Решена'), ('rejected', 'Отклонена')], default='new', max_length=16, verbose_name='Статус')),
('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='complaints', to=settings.AUTH_USER_MODEL, verbose_name='Автор')),
('booking', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.booking', verbose_name='Бронирование')),
('spot', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.parkingspot', verbose_name='Парковочное место')),
],
options={
'verbose_name': 'Жалоба',
'verbose_name_plural': 'Жалобы',
'ordering': ('-created_at',),
},
),
migrations.AddField(
model_name='booking',
name='spot',
field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='bookings', to='parking.parkingspot', verbose_name='Парковочное место'),
),
migrations.CreateModel(
name='WaitlistEntry',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('desired_start', models.DateTimeField(verbose_name='Желаемое начало')),
('desired_end', models.DateTimeField(verbose_name='Желаемое окончание')),
('auto_book', models.BooleanField(default=False, help_text='Если включено, при освобождении места будет создана бронь автоматически.', verbose_name='Авто‑бронирование')),
('status', models.CharField(choices=[('waiting', 'Ожидает'), ('notified', 'Уведомлён'), ('booked', 'Авто‑бронирование создано'), ('cancelled', 'Отменено')], default='waiting', max_length=16, verbose_name='Статус')),
('spot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to='parking.parkingspot', verbose_name='Парковочное место')),
('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
],
options={
'verbose_name': 'Запись в листе ожидания',
'verbose_name_plural': 'Лист ожидания',
'ordering': ('-created_at',),
'unique_together': {('user', 'spot', 'desired_start', 'desired_end')},
},
),
]

# File 101/163: parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-22 11:21
from django.db import migrations, models
class Migration(migrations.Migration):
dependencies = [
('parking', '0001_initial'),
]
operations = [
migrations.AddField(
model_name='parkinglot',
name='stress_index',
field=models.FloatField(default=0.0, help_text='Средняя загруженность мест за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Индекс загруженности (0..1)'),
),
migrations.AddField(
model_name='parkingspot',
name='occupancy_7d',
field=models.FloatField(default=0.0, help_text='Доля времени, когда место было занято за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Загруженность за 7 дней (0..1)'),
),
]

# File 102/163: parking\migrations\0003_booking_ai_fields.py
################################################################################

from django.db import migrations, models
class Migration(migrations.Migration):
dependencies = [
("parking", "0002_parkinglot_stress_index_parkingspot_occupancy_7d"),
]
operations = [
migrations.AddField(
model_name="booking",
name="ai_snapshot",
field=models.JSONField(blank=True, help_text="Данные решений AI (цены, доступность, риски)", null=True, verbose_name="AI snapshot"),
),
migrations.AddField(
model_name="booking",
name="dynamic_pricing_applied",
field=models.BooleanField(default=False, verbose_name="Динамическое ценообразование"),
),
]

# File 103/163: parking\migrations\0004_favoriteparkingspot_savedplace.py
################################################################################

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
class Migration(migrations.Migration):
dependencies = [
('parking', '0003_booking_ai_fields'),
migrations.swappable_dependency(settings.AUTH_USER_MODEL),
]
operations = [
migrations.CreateModel(
name='FavoriteParkingSpot',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('note', models.CharField(blank=True, max_length=120, verbose_name='Заметка')),
('spot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='favorites', to='parking.parkingspot')),
('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='favorite_spots', to=settings.AUTH_USER_MODEL)),
],
options={
'verbose_name': 'Избранное место',
'verbose_name_plural': 'Избранные места',
'ordering': ('-created_at',),
'unique_together': {('user', 'spot')},
},
),
migrations.CreateModel(
name='SavedPlace',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('title', models.CharField(max_length=64, verbose_name='Название')),
('place_type', models.CharField(choices=[('home', 'Дом'), ('work', 'Офис'), ('custom', 'Другое')], default='custom', max_length=16, verbose_name='Тип точки')),
('latitude', models.FloatField(verbose_name='Широта')),
('longitude', models.FloatField(verbose_name='Долгота')),
('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='saved_places', to=settings.AUTH_USER_MODEL)),
],
options={
'verbose_name': 'Сохранённая точка',
'verbose_name_plural': 'Сохранённые точки',
'ordering': ('title',),
'unique_together': {('user', 'title')},
},
),
]

# File 104/163: parking\migrations\__init__.py
################################################################################



# File 105/163: payments\__init__.py
################################################################################

default_app_config = "payments.apps.PaymentsConfig"

# File 106/163: payments\admin.py
################################################################################

from django.contrib import admin
from .models import Payment
@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
list_display = (
"id",
"booking",
"payer",
"provider",
"provider_payment_id",
"amount",
"currency",
"status",
"success",
"failure",
"created_at",
)
list_filter = (
"provider",
"status",
"success",
"failure",
"created_at",
)
search_fields = ("provider_payment_id", "booking__id", "payer__username")
autocomplete_fields = ("booking", "payer")

# File 107/163: payments\apps.py
################################################################################

from django.apps import AppConfig
class PaymentsConfig(AppConfig):
default_auto_field = "django.db.models.BigAutoField"
name = "payments"
verbose_name = "Платежи"

# File 108/163: payments\models.py
################################################################################

from __future__ import annotations
from decimal import Decimal
from typing import Any, Optional
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
from core.models import TimeStampedModel
class Payment(TimeStampedModel):
"""
Платёж за бронирование через внешнего провайдера (по умолчанию — YooKassa).
Для простоты в текущей реализации у каждой брони может быть не более
одного связанного платежа (OneToOne), который используется повторно
при повторных попытках оплаты, пока не станет успешным или не будет
отменён/завершён с ошибкой.
"""
class Provider(models.TextChoices):
YOOKASSA = "yookassa", "YooKassa"
STRIPE = "stripe", "Stripe"
class Status(models.TextChoices):
CREATED = "created", _("Создан")
PENDING = "pending", _("Ожидает оплаты")
SUCCEEDED = "succeeded", _("Успешен")
CANCELLED = "cancelled", _("Отменён")
FAILED = "failed", _("Ошибка")
booking = models.OneToOneField(
"parking.Booking",
on_delete=models.CASCADE,
related_name="payment",
verbose_name=_("Бронь"),
)
payer = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="payments",
verbose_name=_("Плательщик"),
)
provider = models.CharField(
_("Провайдер"),
max_length=32,
choices=Provider.choices,
default=Provider.YOOKASSA,
)
provider_payment_id = models.CharField(
_("ID платежа у провайдера"),
max_length=128,
blank=True,
db_index=True,
)
amount = models.DecimalField(
_("Сумма"),
max_digits=10,
decimal_places=2,
)
currency = models.CharField(
_("Валюта"),
max_length=8,
default="RUB",
)
status = models.CharField(
_("Статус"),
max_length=16,
choices=Status.choices,
default=Status.CREATED,
db_index=True,
)
success = models.BooleanField(_("Успешен"), default=False)
failure = models.BooleanField(_("Ошибка"), default=False)
raw_response = models.JSONField(
_("Ответ провайдера"),
null=True,
blank=True,
help_text=_("Сырые данные, вернувшиеся при создании платежа."),
)
raw_webhook = models.JSONField(
_("Последний webhook"),
null=True,
blank=True,
help_text=_("Последнее уведомление провайдера по этому платежу."),
)
class Meta:
verbose_name = _("Платёж")
verbose_name_plural = _("Платежи")
ordering = ("-created_at",)
def __str__(self) -> str:
return f"Payment
@property
def is_active(self) -> bool:
"""
"Активный" платёж — тот, который ещё может сменить состояние на успешное.
"""
return self.status in {self.Status.CREATED, self.Status.PENDING}
def _update_status(
self,
status: str,
success: bool,
failure: bool,
webhook_data: Optional[dict[str, Any]] = None,
) -> None:
self.status = status
self.success = success
self.failure = failure
if webhook_data is not None:
self.raw_webhook = webhook_data
self.save(
update_fields=[
"status",
"success",
"failure",
"raw_webhook",
"updated_at",
]
)
def mark_succeeded(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
"""
Помечает платёж как успешный и вызывает booking.mark_paid(...).
Вызывается из обработчика вебхуков YooKassa после подтверждения
успешного платежа.
"""
self._update_status(
status=self.Status.SUCCEEDED,
success=True,
failure=False,
webhook_data=webhook_data,
)
# Обновляем связанную бронь.
booking = self.booking
if booking:
booking.mark_paid(payment_id=self.provider_payment_id or "")
def mark_failed(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
"""
Помечает платёж как неуспешный (ошибка).
"""
self._update_status(
status=self.Status.FAILED,
success=False,
failure=True,
webhook_data=webhook_data,
)
def mark_cancelled(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
"""
Помечает платёж как отменённый пользователем или провайдером.
"""
self._update_status(
status=self.Status.CANCELLED,
success=False,
failure=True,
webhook_data=webhook_data,
)
class PaymentMethod(TimeStampedModel):
"""
Привязанный способ оплаты (карта/кошелёк), без хранения PAN.
Данные карты хранятся в токенизированном виде у провайдера эквайринга,
здесь остаётся только маска и метаданные для UI. Настоящий токен
хранится в encrypted поле token_masked, чтобы можно было инициировать
повторные списания в будущем.
"""
class Brand(models.TextChoices):
VISA = "visa", "VISA"
MASTERCARD = "mc", "Mastercard"
MIR = "mir", "Мир"
UNIONPAY = "up", "UnionPay"
OTHER = "other", "Другая"
user = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="payment_methods",
verbose_name=_("Пользователь"),
)
label = models.CharField(
_("Название"),
max_length=64,
blank=True,
help_text=_("Например: 'Личная', 'Для работы', 'Юрлицо'."),
)
brand = models.CharField(
_("Бренд"),
max_length=16,
choices=Brand.choices,
default=Brand.OTHER,
)
last4 = models.CharField(_("Последние 4 цифры"), max_length=4)
exp_month = models.PositiveSmallIntegerField(_("Месяц окончания"))
exp_year = models.PositiveSmallIntegerField(_("Год окончания"))
is_default = models.BooleanField(_("По умолчанию"), default=False)
token_masked = models.CharField(
_("Токен/маска"),
max_length=255,
help_text=_("Служебный идентификатор платёжного провайдера."),
)
class Meta:
verbose_name = _("Способ оплаты")
verbose_name_plural = _("Способы оплаты")
ordering = ("-is_default", "-created_at")
unique_together = ("user", "token_masked")
def __str__(self) -> str:
return f"{self.get_brand_display()} ****{self.last4}"
def save(self, *args, **kwargs):
if self.is_default:
PaymentMethod.objects.filter(user=self.user, is_default=True).exclude(
pk=self.pk
).update(is_default=False)
return super().save(*args, **kwargs)

# File 109/163: payments\providers.py
################################################################################

from __future__ import annotations
import uuid
from decimal import Decimal
from typing import Any, Tuple
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
try:
# Официальный синхронный SDK YooKassa
from yookassa import Configuration, Payment as YooPayment
except ImportError:
Configuration = None
YooPayment = None
class YooKassaError(Exception):
"""Базовая ошибка при работе с YooKassa."""
def _configure_yookassa() -> None:
"""
Настраивает SDK YooKassa из Django settings.
Требуются:
- YOOKASSA_SHOP_ID
- YOOKASSA_SECRET_KEY
"""
if Configuration is None or YooPayment is None:
raise ImproperlyConfigured(
"Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
)
shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
if not shop_id or not secret_key:
raise ImproperlyConfigured(
"Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
)
Configuration.account_id = shop_id
Configuration.secret_key = secret_key
def create_yookassa_payment(booking) -> Tuple[str, str, dict[str, Any]]:
"""
Создаёт платёж в YooKassa для указанной брони.
Возвращает:
(payment_url, provider_payment_id, raw_response_dict)
Все сетевые вызовы инкапсулированы здесь.
"""
_configure_yookassa()
from parking.models import Booking
if not isinstance(booking, Booking):
raise YooKassaError("create_yookassa_payment ожидает экземпляр Booking.")
amount = booking.total_price
if not isinstance(amount, Decimal):
amount = Decimal(str(amount))
amount_str = str(amount.quantize(Decimal("0.01")))
currency = booking.currency or "RUB"
return_url = getattr(settings, "YOOKASSA_RETURN_URL", "")
description = f"Оплата брони
payload: dict[str, Any] = {
"amount": {
"value": amount_str,
"currency": currency,
},
"confirmation": {
"type": "redirect",
"return_url": return_url,
},
"capture": True,
"description": description,
"metadata": {
"booking_id": str(booking.id),
"user_id": str(booking.user_id),
},
}
try:
payment = YooPayment.create(payload, uuid.uuid4())
except Exception as exc:
raise YooKassaError(str(exc)) from exc
confirmation = getattr(payment, "confirmation", None)
payment_url = getattr(confirmation, "confirmation_url", None) if confirmation else None
provider_payment_id = getattr(payment, "id", None)
if not payment_url or not provider_payment_id:
raise YooKassaError(
"Некорректный ответ от YooKassa: не получены id или URL оплаты."
)
raw_response = {
"id": provider_payment_id,
"status": getattr(payment, "status", None),
}
return payment_url, provider_payment_id, raw_response

# File 110/163: payments\serializers.py
################################################################################

# payments/serializers.py
from __future__ import annotations
from typing import Any, Dict
from django.conf import settings
from django.urls import reverse
from rest_framework import serializers
from parking.models import Booking
from .models import Payment, PaymentMethod
from .providers import get_payment_provider
class PaymentSerializer(serializers.ModelSerializer):
"""
Создание платежа для бронирования.
Поток:
- клиент вызывает POST /api/payments/ с booking_id;
- сериализатор поднимает Booking, вызывает AI-ценообразование (если нужно – уже
сделано при создании брони), берёт итоговую сумму;
- выбирает провайдера по REGION/PLATFORM (YooKassa для RU, Stripe для GLOBAL);
- создаёт payment в БД и у провайдера;
- возвращает клиенту payment_url, по которому можно уйти на оплату.
Важно: бизнес-логика расчёта цены (включая AI) находится в booking/ai,
здесь только оркестрация и адаптеры к платёжным провайдерам.
"""
booking_id = serializers.UUIDField(write_only=True)
payment_url = serializers.SerializerMethodField(read_only=True)
class Meta:
model = Payment
fields = (
"id",
"booking_id",
"amount",
"currency",
"status",
"provider",
"provider_payment_id",
"created_at",
"updated_at",
"payment_url",
)
read_only_fields = (
"id",
"amount",
"currency",
"status",
"provider",
"provider_payment_id",
"created_at",
"updated_at",
"payment_url",
)
def validate_booking_id(self, value):
try:
booking = Booking.objects.select_related("spot", "spot__lot").get(pk=value)
except Booking.DoesNotExist:
raise serializers.ValidationError("Бронирование не найдено.")
if booking.status not in (
Booking.Status.PENDING,
Booking.Status.CONFIRMED,
):
raise serializers.ValidationError(
"Платёж можно создать только для ожидающего/подтверждённого бронирования."
)
return value
def _get_booking(self, booking_id) -> Booking:
return Booking.objects.select_related("spot", "spot__lot").get(pk=booking_id)
def create(self, validated_data: Dict[str, Any]) -> Payment:
request = self.context.get("request")
booking_id = validated_data["booking_id"]
booking = self._get_booking(booking_id)
# Сумма для оплаты – итоговая цена брони (уже с AI-ценообразованием, если применено)
amount = booking.total_price
currency = getattr(settings, "DEFAULT_CURRENCY", "RUB")
# Выбор провайдера:
#   - для RU профиль по умолчанию будет YooKassa (см. .env/.env.prod);
#   - для GLOBAL можно выставить stripe в PAYMENT_PROVIDER/DEFAULT_PAYMENT_PROVIDER.
provider = get_payment_provider()
payment = Payment.objects.create(
booking=booking,
amount=amount,
currency=currency,
provider=provider.code,
status=Payment.Status.CREATED,
)
# URL возврата пользователя после оплаты
if request is not None:
return_url = request.build_absolute_uri(
reverse("payments:return")
)
webhook_url = request.build_absolute_uri(
reverse("payments:webhook", kwargs={"provider": provider.code})
)
else:
# fallback для внутренних вызовов/тестов
return_url = getattr(settings, "YOOKASSA_RETURN_URL", "/")
webhook_url = ""
# Вызов провайдера (адаптер)
provider_response = provider.create_payment(
payment=payment,
return_url=return_url,
webhook_url=webhook_url,
)
# Ожидаем, что адаптер вернёт структуру с provider_payment_id и
# опциональным полем payment_url/confirmation_url.
payment.provider_payment_id = provider_response.get("id") or provider_response.get(
"provider_payment_id", ""
)
payment.raw_response = provider_response
payment.save(update_fields=["provider_payment_id", "raw_response"])
return payment
def get_payment_url(self, obj: Payment) -> str | None:
"""
Вытаскиваем URL для редиректа пользователя из raw_response.
Для YooKassa это обычно confirmation.redirect_url,
для Stripe – session.url и т.п.
"""
data = obj.raw_response or {}
# Общий подход: пытаемся найти наиболее очевидные поля
return (
data.get("payment_url")
or data.get("confirmation_url")
or (data.get("confirmation") or {}).get("confirmation_url")
or (data.get("session") or {}).get("url")
)
class PaymentMethodSerializer(serializers.ModelSerializer):
"""Сериализатор для сохранённых карт/кошельков."""
mask = serializers.SerializerMethodField(read_only=True)
class Meta:
model = PaymentMethod
fields = (
"id",
"label",
"brand",
"last4",
"exp_month",
"exp_year",
"is_default",
"token_masked",
"mask",
"created_at",
)
read_only_fields = ("id", "mask", "created_at")
def get_mask(self, obj: PaymentMethod) -> str:
return f"**** **** **** {obj.last4}"
def create(self, validated_data):
request = self.context.get("request")
if request and request.user.is_authenticated:
validated_data["user"] = request.user
return super().create(validated_data)

# File 111/163: payments\tasks.py
################################################################################

from __future__ import annotations
from celery import shared_task
from .models import Payment
@shared_task
def check_stale_payments() -> str:
"""
Заготовка фоновой задачи для проверки "зависших" платежей.
В будущей версии здесь можно реализовать:
- поиск платежей в статусе PENDING слишком долго;
- запрос их фактического состояния у YooKassa;
- перевод в FAILED/CANCELLED при необходимости.
"""
pending_count = Payment.objects.filter(status=Payment.Status.PENDING).count()
return f"Pending payments count: {pending_count}"

# File 112/163: payments\views.py
################################################################################

from __future__ import annotations
from django.conf import settings
from rest_framework import mixins, permissions, status, viewsets
from rest_framework.response import Response
from rest_framework.views import APIView
from .models import Payment, PaymentMethod
from .serializers import PaymentMethodSerializer, PaymentSerializer
from .providers.registry import get_payment_provider
class PaymentViewSet(
mixins.CreateModelMixin,
mixins.ListModelMixin,
mixins.RetrieveModelMixin,
viewsets.GenericViewSet,
):
"""
API платежей:
- GET  /api/payments/       — список платежей текущего пользователя;
- POST /api/payments/       — начать оплату для брони;
- GET  /api/payments/{id}/  — детали платежа.
Только владелец платежа видит свои платежи; админ — все.
"""
serializer_class = PaymentSerializer
permission_classes = [permissions.IsAuthenticated]
def get_queryset(self):
user = self.request.user
qs = Payment.objects.select_related(
"booking",
"booking__spot",
"booking__spot__lot",
"payer",
)
if not user.is_authenticated:
return Payment.objects.none()
if user.is_superuser:
return qs
return qs.filter(payer=user)
def perform_create(self, serializer: PaymentSerializer) -> None:
serializer.save()
class PaymentMethodViewSet(
mixins.CreateModelMixin,
mixins.ListModelMixin,
mixins.UpdateModelMixin,
mixins.DestroyModelMixin,
viewsets.GenericViewSet,
):
"""
Мини-API для управления сохранёнными картами в ЛК.
POST /api/payment-methods/ — добавить карту (пока без реального токенизации);
GET  /api/payment-methods/ — список карт пользователя;
DELETE /api/payment-methods/{id}/ — удалить карту.
"""
serializer_class = PaymentMethodSerializer
permission_classes = [permissions.IsAuthenticated]
def get_queryset(self):
user = self.request.user
if not user.is_authenticated:
return PaymentMethod.objects.none()
if user.is_superuser:
return PaymentMethod.objects.select_related("user").order_by("-is_default", "-created_at")
return PaymentMethod.objects.filter(user=user).order_by("-is_default", "-created_at")
def perform_create(self, serializer: PaymentMethodSerializer) -> None:
serializer.save(user=self.request.user)
def perform_update(self, serializer: PaymentMethodSerializer) -> None:
serializer.save(user=self.request.user)
class YooKassaWebhookView(APIView):
"""
Обработчик webhook‑уведомлений YooKassa.
URL: /payments/webhook/yookassa/  (см. backend.config.urls)
Ожидается JSON вида:
{
"event": "payment.succeeded",
"object": {
"id": "...",
"status": "succeeded",
...
}
}
Подпись/секрет проверяется по заголовку X-Yookassa-Signature
(или X-Yookassa-Webhook-Secret), который совпадает с
settings.YOOKASSA_WEBHOOK_SECRET. Если секрет не задан, проверка
подписи пропускается.
"""
authentication_classes: list = []
permission_classes = [permissions.AllowAny]
def post(self, request, *args, **kwargs):
secret_expected = getattr(settings, "YOOKASSA_WEBHOOK_SECRET", "")
if secret_expected:
signature = (
request.headers.get("X-Yookassa-Signature")
or request.headers.get("X-Yookassa-Webhook-Secret")
)
if not signature or signature != secret_expected:
return Response(
{"detail": "Invalid webhook signature"},
status=status.HTTP_403_FORBIDDEN,
)
data = request.data or {}
event = data.get("event")
obj = data.get("object") or {}
provider_payment_id = obj.get("id")
if not provider_payment_id:
return Response(
{"detail": "Missing payment id"},
status=status.HTTP_400_BAD_REQUEST,
)
try:
payment = Payment.objects.select_related("booking").get(
provider_payment_id=provider_payment_id
)
except Payment.DoesNotExist:
return Response(
{"detail": "Payment not found"},
status=status.HTTP_404_NOT_FOUND,
)
status_from_provider = obj.get("status")
payment.raw_webhook = data
if status_from_provider == "succeeded" or event == "payment.succeeded":
payment.mark_succeeded(webhook_data=data)
elif status_from_provider in ("canceled", "cancelled") or event == "payment.canceled":
payment.mark_cancelled(webhook_data=data)
else:
# Любые промежуточные статусы считаем ожидающими
payment.status = Payment.Status.PENDING
payment.success = False
payment.failure = False
payment.save(
update_fields=["status", "success", "failure", "raw_webhook", "updated_at"]
)
return Response({"detail": "ok"}, status=status.HTTP_200_OK)
class StripeWebhookView(APIView):
"""Простой webhook Stripe (stub)."""
authentication_classes: list = []
permission_classes = [permissions.AllowAny]
def post(self, request, *args, **kwargs):
provider = get_payment_provider("stripe")
payment = provider.handle_webhook(request)
if not payment:
return Response({"detail": "Payment not found"}, status=status.HTTP_404_NOT_FOUND)
return Response({"detail": "ok"}, status=status.HTTP_200_OK)

# File 113/163: payments\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34
import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models
class Migration(migrations.Migration):
initial = True
dependencies = [
('parking', '0001_initial'),
migrations.swappable_dependency(settings.AUTH_USER_MODEL),
]
operations = [
migrations.CreateModel(
name='Payment',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('provider', models.CharField(choices=[('yookassa', 'YooKassa')], default='yookassa', max_length=32, verbose_name='Провайдер')),
('provider_payment_id', models.CharField(blank=True, db_index=True, max_length=128, verbose_name='ID платежа у провайдера')),
('amount', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Сумма')),
('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
('status', models.CharField(choices=[('created', 'Создан'), ('pending', 'Ожидает оплаты'), ('succeeded', 'Успешен'), ('cancelled', 'Отменён'), ('failed', 'Ошибка')], db_index=True, default='created', max_length=16, verbose_name='Статус')),
('success', models.BooleanField(default=False, verbose_name='Успешен')),
('failure', models.BooleanField(default=False, verbose_name='Ошибка')),
('raw_response', models.JSONField(blank=True, help_text='Сырые данные, вернувшиеся при создании платежа.', null=True, verbose_name='Ответ провайдера')),
('raw_webhook', models.JSONField(blank=True, help_text='Последнее уведомление провайдера по этому платежу.', null=True, verbose_name='Последний webhook')),
('booking', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='payment', to='parking.booking', verbose_name='Бронь')),
('payer', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payments', to=settings.AUTH_USER_MODEL, verbose_name='Плательщик')),
],
options={
'verbose_name': 'Платёж',
'verbose_name_plural': 'Платежи',
'ordering': ('-created_at',),
},
),
]

# File 114/163: payments\migrations\0002_alter_payment_provider.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-23 12:00
from django.db import migrations, models
class Migration(migrations.Migration):
dependencies = [
('payments', '0001_initial'),
]
operations = [
migrations.AlterField(
model_name='payment',
name='provider',
field=models.CharField(choices=[('yookassa', 'YooKassa'), ('stripe', 'Stripe')], default='yookassa', max_length=32, verbose_name='Провайдер'),
),
]

# File 115/163: payments\migrations\0003_paymentmethod.py
################################################################################

from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
class Migration(migrations.Migration):
dependencies = [
('payments', '0002_alter_payment_provider'),
migrations.swappable_dependency(settings.AUTH_USER_MODEL),
]
operations = [
migrations.CreateModel(
name='PaymentMethod',
fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('label', models.CharField(blank=True, help_text="Например: 'Личная', 'Для работы', 'Юрлицо'.", max_length=64, verbose_name='Название')),
('brand', models.CharField(choices=[('visa', 'VISA'), ('mc', 'Mastercard'), ('mir', 'Мир'), ('up', 'UnionPay'), ('other', 'Другая')], default='other', max_length=16, verbose_name='Бренд')),
('last4', models.CharField(max_length=4, verbose_name='Последние 4 цифры')),
('exp_month', models.PositiveSmallIntegerField(verbose_name='Месяц окончания')),
('exp_year', models.PositiveSmallIntegerField(verbose_name='Год окончания')),
('is_default', models.BooleanField(default=False, verbose_name='По умолчанию')),
('token_masked', models.CharField(help_text='Служебный идентификатор платёжного провайдера.', max_length=255, verbose_name='Токен/маска')),
('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payment_methods', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
],
options={
'verbose_name': 'Способ оплаты',
'verbose_name_plural': 'Способы оплаты',
'ordering': ('-is_default', '-created_at'),
'unique_together': {('user', 'token_masked')},
},
),
]

# File 116/163: payments\migrations\__init__.py
################################################################################



# File 117/163: payments\providers\__init__.py
################################################################################

# payments/providers/__init__.py
from __future__ import annotations
from typing import Dict, Type
from django.conf import settings
from .base import BasePaymentProvider
from .yookassa import YooKassaProvider
from .stripe import StripeProvider
# Реестр провайдеров по коду
_PROVIDER_REGISTRY: Dict[str, Type[BasePaymentProvider]] = {
"yookassa": YooKassaProvider,
"yoomoney": YooKassaProvider,
"stripe": StripeProvider,
# сюда же можно добавить Sber, Tinkoff, Mir Pay, QIWI и т.д.
}
def get_payment_provider(name: str | None = None) -> BasePaymentProvider:
"""
Возвращает инстанс провайдера платежей по имени.
name:
- None     -> берём DEFAULT_PAYMENT_PROVIDER / PAYMENT_PROVIDER из настроек
- "yookassa", "stripe" и т.п.
Для RU-профиля по умолчанию используется YooKassa, для GLOBAL – Stripe,
но это задаётся в .env / настройках.
"""
# Совместимость с разными именами переменных
configured = getattr(settings, "DEFAULT_PAYMENT_PROVIDER", None) or getattr(
settings, "PAYMENT_PROVIDER", "yookassa"
)
provider_name = (name or configured or "yookassa").lower()
provider_cls = _PROVIDER_REGISTRY.get(provider_name)
if provider_cls is None:
raise ValueError(
f"Unknown payment provider '{provider_name}'. "
f"Доступные: {', '.join(sorted(_PROVIDER_REGISTRY.keys()))}"
)
return provider_cls()

# File 118/163: payments\providers\base.py
################################################################################

# payments/providers/base.py
from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
from ..models import Payment
class BasePaymentProvider(ABC):
"""
Базовый интерфейс платёжного провайдера.
Этот класс — единая точка расширения для YooKassa, Stripe, Сбера и т.д.
"""
@abstractmethod
def create_payment(
self,
payment: Payment,
return_url: str,
webhook_url: str,
) -> Dict[str, Any]:
"""
Создать платёж у провайдера и вернуть его данные (включая URL для подтверждения/оплаты).
Должен вернуть словарь с полями вроде:
{
"payment_url": "...",
"provider_payment_id": "...",
...
}
"""
raise NotImplementedError
@abstractmethod
def handle_webhook(self, request) -> Optional[Payment]:
"""
Обработать webhook от провайдера и обновить Payment/Booking.
Должен:
- найти Payment по данным из webhook;
- обновить статус/флаги;
- вернуть обновлённый Payment (или None, если не найден/игнорируем).
"""
raise NotImplementedError
@abstractmethod
def refund(self, payment: Payment, amount: Optional[float] = None) -> None:
"""
Инициировать возврат по платежу (полный или частичный).
"""
raise NotImplementedError
# ---------------------------------------------------------
# Обратная совместимость:
# старый код может импортировать PaymentProvider или BasePaymentProvider.
# ---------------------------------------------------------
PaymentProvider = BasePaymentProvider

# File 119/163: payments\providers\registry.py
################################################################################

from __future__ import annotations
from typing import Dict, Type
from django.core.exceptions import ImproperlyConfigured
from .base import PaymentProvider
from .stripe import StripeProvider
from .yookassa import YooKassaProvider
REGISTRY: Dict[str, Type[PaymentProvider]] = {
"yookassa": YooKassaProvider,
"stripe": StripeProvider,
}
def get_payment_provider(provider_key: str) -> PaymentProvider:
provider_cls = REGISTRY.get(provider_key)
if not provider_cls:
raise ImproperlyConfigured(f"Unknown payment provider: {provider_key}")
return provider_cls()

# File 120/163: payments\providers\stripe.py
################################################################################

from __future__ import annotations
import uuid
from typing import Any, Dict, Optional
from django.conf import settings
from .base import PaymentProvider
class StripeProvider(PaymentProvider):
key = "stripe"
def create_payment(
self, payment, return_url: str, webhook_url: str
) -> Dict[str, Any]:
"""Stub: эмуляция Stripe Checkout Session.
В бою надо подключить stripe SDK и создать Checkout Session с
success/cancel URL. Здесь формируется предсказуемая ссылка.
"""
session_id = str(uuid.uuid4())
confirmation_url = f"https:
return {
"payment_url": confirmation_url,
"provider_payment_id": session_id,
"raw": {
"mode": "payment",
"return_url": return_url,
"webhook": webhook_url,
},
}
def handle_webhook(self, request) -> Optional["Payment"]:
from payments.models import Payment
payload = request.data or {}
event_type = payload.get("type")
data_object = payload.get("data", {}).get("object", {})
provider_payment_id = data_object.get("id")
if not provider_payment_id:
return None
try:
payment = Payment.objects.select_related("booking").get(
provider_payment_id=provider_payment_id
)
except Payment.DoesNotExist:
return None
if event_type == "checkout.session.completed":
payment.mark_succeeded(webhook_data=payload)
elif event_type == "payment_intent.payment_failed":
payment.mark_failed(webhook_data=payload)
return payment
def refund(self, payment, amount: Optional[float] = None) -> None:
# Заглушка — Stripe refund через SDK
return None

# File 121/163: payments\providers\yookassa.py
################################################################################

from __future__ import annotations
from __future__ import annotations
import uuid
from decimal import Decimal
from typing import Any, Dict, Optional
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from .base import PaymentProvider
try:
from yookassa import Configuration, Payment as YooPayment
except ImportError:
Configuration = None
YooPayment = None
class YooKassaError(Exception):
"""Базовая ошибка при работе с YooKassa."""
class YooKassaProvider(PaymentProvider):
key = "yookassa"
def _configure(self) -> None:
if Configuration is None or YooPayment is None:
raise ImproperlyConfigured(
"Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
)
shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
if not shop_id or not secret_key:
raise ImproperlyConfigured(
"Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
)
Configuration.account_id = shop_id
Configuration.secret_key = secret_key
def create_payment(
self, payment, return_url: str, webhook_url: str
) -> Dict[str, Any]:
self._configure()
from parking.models import Booking
booking: Booking = payment.booking
amount = booking.total_price
if not isinstance(amount, Decimal):
amount = Decimal(str(amount))
amount_str = str(amount.quantize(Decimal("0.01")))
currency = booking.currency or "RUB"
description = f"Оплата брони
payload: dict[str, Any] = {
"amount": {
"value": amount_str,
"currency": currency,
},
"confirmation": {
"type": "redirect",
"return_url": return_url,
},
"capture": True,
"description": description,
"metadata": {
"booking_id": str(booking.id),
"user_id": str(booking.user_id),
"webhook": webhook_url,
},
}
try:
provider_payment = YooPayment.create(payload, uuid.uuid4())
except Exception as exc:
raise YooKassaError(str(exc)) from exc
confirmation = getattr(provider_payment, "confirmation", None)
payment_url = (
getattr(confirmation, "confirmation_url", None) if confirmation else None
)
provider_payment_id = getattr(provider_payment, "id", None)
if not payment_url or not provider_payment_id:
raise YooKassaError(
"Некорректный ответ от YooKassa: не получены id или URL оплаты."
)
raw_response = {
"id": provider_payment_id,
"status": getattr(provider_payment, "status", None),
}
return {
"payment_url": payment_url,
"provider_payment_id": provider_payment_id,
"raw": raw_response,
}
def handle_webhook(self, request) -> Optional[Payment]:
from payments.models import Payment
data = request.data or {}
event = data.get("event")
obj = data.get("object") or {}
provider_payment_id = obj.get("id")
if not provider_payment_id:
return None
try:
payment = Payment.objects.select_related("booking").get(
provider_payment_id=provider_payment_id
)
except Payment.DoesNotExist:
return None
status_from_provider = obj.get("status")
payment.raw_webhook = data
if status_from_provider == "succeeded" or event == "payment.succeeded":
payment.mark_succeeded(webhook_data=data)
elif status_from_provider in ("canceled", "cancelled") or event == "payment.canceled":
payment.mark_cancelled(webhook_data=data)
else:
payment.status = Payment.Status.PENDING
payment.success = False
payment.failure = False
payment.save(
update_fields=["status", "success", "failure", "raw_webhook", "updated_at"]
)
return payment
def refund(self, payment, amount: Optional[float] = None) -> None:
# Неполная реализация для MVP
raise NotImplementedError("YooKassa refunds are not implemented in this stub.")

# File 122/163: regions\global.yml
################################################################################

# Базовый глобальный профиль ParkShare (по умолчанию для не-RU регионов)

id: "global"
name: "ParkShare Global"

locale:
  default_language: "en"
  supported_languages:
    - "en"
    - "ru"

currency:
  default: "EUR"

maps:
  default_provider: "openstreetmap"
  fallback_provider: "none"

payments:
  gateways:
    - "stripe"
    - "paypal"

auth:
  providers:
    - "email-password"


# File 123/163: regions\ru.yml
################################################################################

id: "ru"
name: "ParkShare RU"

locale:
  default_language: "ru"
  supported_languages:
    - "ru"
    - "en"

картография:
  основной_провайдер: "Яндекс.Карты API"
  резервный: "2GIS API"

платежные_системы:
  обязательные:
    - "Сбербанк Онлайн"
    - "Тинькофф"
    - "ЮMoney"
    - "Мир Pay"
    - "QIWI"

аутентификация:
  - "Госуслуги (ЕСИА)"
  - "ВК ID"
  - "Яндекс ID"
  - "Сбер ID"
  - "Email/Телефон (native)"

pricing:
  currency: "RUB"
  tax_included: true


# File 124/163: services\__init__.py
################################################################################



# File 125/163: services\llm.py
################################################################################

# services/llm.py
"""Async client helpers for communicating with the LLM microservice."""
from __future__ import annotations
import logging
import os
from typing import Any, Dict, Iterable, List
import httpx
logger = logging.getLogger(__name__)
DEFAULT_TIMEOUT = 8.0
CONNECT_TIMEOUT = 3.0
# По умолчанию ожидаем локальный сервис на 8002 (см. docker-compose).
# 1) внутри docker-сети: llm_service:8002
# 2) с хоста: localhost:8002
DEFAULT_LLM_URLS: List[str] = [
"http:
"http:
]
LEGACY_ENDPOINTS: List[str] = [
"/parse",
"/api/v1/llm/parse-search-query",
]
DEFAULT_RETRIES = 2
class LLMClientError(Exception):
"""Raised when the LLM service cannot process the request."""
def _candidate_endpoints() -> Iterable[str]:
"""Return candidate base URLs to try for the LLM service.
Priority: explicit env var, then defaults (llm_service, localhost).
"""
env_url = os.getenv("LLM_SERVICE_URL")
if env_url:
yield env_url.rstrip("/")
for url in DEFAULT_LLM_URLS:
if not env_url or url.rstrip("/") != env_url.rstrip("/"):
yield url.rstrip("/")
async def parse_search_query(query: str) -> Dict[str, Any]:
"""Parse a user parking search query via the LLM microservice.
Args:
query: Raw text query from the user.
Returns:
Structured dict with parking search attributes.
Raises:
LLMClientError: If the request fails or returns non-200 status.
ValueError: If query is empty.
"""
if not query or not query.strip():
raise ValueError("query must be non-empty")
retries = int(os.getenv("LLM_CLIENT_RETRIES", DEFAULT_RETRIES))
timeout_value = float(os.getenv("LLM_CLIENT_TIMEOUT", DEFAULT_TIMEOUT))
timeout = httpx.Timeout(timeout_value, connect=CONNECT_TIMEOUT)
last_error: Exception | None = None
for base_url in _candidate_endpoints():
for path in LEGACY_ENDPOINTS:
endpoint = f"{base_url}{path}"
logger.info(
"Calling LLM service",
extra={
"endpoint": endpoint,
"timeout": timeout_value,
"retries": retries,
"query_preview": query[:120],
},
)
try:
async with httpx.AsyncClient(timeout=timeout) as client:
for attempt in range(1, retries + 1):
try:
logger.debug(
"LLM HTTP request",
extra={
"endpoint": endpoint,
"attempt": attempt,
"timeout": timeout_value,
},
)
response = await client.post(endpoint, json={"query": query})
response.raise_for_status()
data = response.json()
logger.debug(
"LLM service response",
extra={
"endpoint": endpoint,
"attempt": attempt,
"response": data,
},
)
return data
except httpx.TimeoutException as exc:
logger.warning(
"LLM request timeout",
extra={"endpoint": endpoint, "attempt": attempt},
)
last_error = exc
except httpx.HTTPStatusError as exc:
logger.warning(
"LLM service returned HTTP error",
extra={
"status": exc.response.status_code,
"endpoint": endpoint,
"attempt": attempt,
"body": exc.response.text[:500],
},
)
last_error = exc
break
except httpx.RequestError as exc:
logger.warning(
"LLM request error",
extra={"endpoint": endpoint, "attempt": attempt},
exc_info=exc,
)
last_error = exc
except ValueError as exc:
logger.warning(
"LLM service returned invalid JSON",
extra={"endpoint": endpoint, "attempt": attempt},
exc_info=exc,
)
last_error = exc
break
except Exception as exc:
last_error = exc
logger.exception(
"Unexpected LLM client error", extra={"endpoint": endpoint}
)
if last_error:
raise LLMClientError(f"LLM service unreachable: {last_error}") from last_error
raise LLMClientError("LLM service unreachable: no endpoints configured")
async def check_llm_health() -> Dict[str, Any]:
"""Check health endpoints of the LLM service for diagnostics."""
timeout_value = float(os.getenv("LLM_CLIENT_TIMEOUT", DEFAULT_TIMEOUT))
timeout = httpx.Timeout(timeout_value, connect=CONNECT_TIMEOUT)
results: Dict[str, Any] = {"endpoints": []}
for base_url in _candidate_endpoints():
for path in ["/health", "/healthz"]:
health_url = f"{base_url}{path}"
try:
async with httpx.AsyncClient(timeout=timeout) as client:
resp = await client.get(health_url)
results["endpoints"].append(
{
"url": health_url,
"status": resp.status_code,
"body": resp.json()
if resp.headers.get("content-type", "").startswith(
"application/json"
)
else resp.text,
}
)
if resp.status_code == 200:
results["ok"] = True
results["active_url"] = health_url
return results
except Exception as exc:
logger.warning(
"LLM health check failed", extra={"url": health_url}, exc_info=exc
)
results["endpoints"].append({"url": health_url, "error": str(exc)})
results["ok"] = False
return results

# File 126/163: services\llm_service\Dockerfile
################################################################################

FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Устанавливаем зависимости для FastAPI и LLM-клиента
RUN pip install --no-cache-dir fastapi uvicorn[standard] httpx pydantic

COPY services/llm_service /app

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8002"]


# File 127/163: services\llm_service\main.py
################################################################################

# services/llm_service/main.py
"""
FastAPI приложение для LLM‑разбора пользовательских запросов на поиск парковки.
Включает абстрактный клиент LLMClient, OpenAI‑реализацию и rule‑based фолбэк.
"""
from __future__ import annotations
import json
import re
from datetime import datetime
from functools import lru_cache
from typing import Any, Dict, Protocol, runtime_checkable
import httpx
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, ConfigDict, Field, ValidationError
from pydantic_settings import BaseSettings, SettingsConfigDict
class Settings(BaseSettings):
"""Конфигурация сервиса, читаемая из переменных окружения."""
openai_api_key: str = ""
openai_base_url: str = "https:
openai_model: str = "gpt-3.5-turbo"
request_timeout: float = 30.0
cors_allow_origins: list[str] = []
model_config = SettingsConfigDict(
env_file=".env",
env_file_encoding="utf-8",
env_prefix="",
case_sensitive=False,
extra="ignore",
)
@runtime_checkable
class LLMClient(Protocol):
"""Простейший протокол для LLM-клиентов."""
async def parse_search_query(self, system_prompt: str, user_query: str) -> Dict[str, Any]:
"""Получить структурированные данные по текстовому запросу пользователя."""
class OpenAILLMClient:
"""LLM-клиент для работы с OpenAI Chat Completions API."""
def __init__(self, settings: Settings):
self.base_url = settings.openai_base_url.rstrip("/")
self.api_key = settings.openai_api_key
self.model = settings.openai_model
self.timeout = settings.request_timeout
async def parse_search_query(self, system_prompt: str, user_query: str) -> Dict[str, Any]:
if not self.api_key:
raise HTTPException(
status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
detail="OpenAI API key is not configured",
)
payload = {
"model": self.model,
"messages": [
{"role": "system", "content": system_prompt},
{"role": "user", "content": user_query},
],
"response_format": {"type": "json_object"},
"temperature": 0.2,
}
headers = {
"Authorization": f"Bearer {self.api_key}",
"Content-Type": "application/json",
}
url = f"{self.base_url}/chat/completions"
async with httpx.AsyncClient(timeout=self.timeout) as client:
try:
response = await client.post(url, json=payload, headers=headers)
response.raise_for_status()
except httpx.HTTPStatusError as exc:
raise HTTPException(
status_code=status.HTTP_502_BAD_GATEWAY,
detail=f"LLM HTTP error: {exc.response.status_code}",
) from exc
except httpx.RequestError as exc:
raise HTTPException(
status_code=status.HTTP_502_BAD_GATEWAY,
detail="LLM request error",
) from exc
try:
raw = response.json()
except ValueError as exc:
raise HTTPException(
status_code=status.HTTP_502_BAD_GATEWAY,
detail="LLM returned invalid JSON",
) from exc
try:
content = (
raw["choices"][0]["message"]["content"]
if raw.get("choices")
else None
)
except (KeyError, IndexError, TypeError) as exc:
raise HTTPException(
status_code=status.HTTP_502_BAD_GATEWAY,
detail="Unexpected response format from LLM",
) from exc
if not content:
raise HTTPException(
status_code=status.HTTP_502_BAD_GATEWAY,
detail="Empty response from LLM",
)
try:
return json.loads(content)
except json.JSONDecodeError as exc:
raise HTTPException(
status_code=status.HTTP_502_BAD_GATEWAY,
detail="LLM response is not valid JSON",
) from exc
def _simple_rule_parser(user_query: str) -> Dict[str, Any]:
"""Простой разбор текста без внешних LLM."""
lowered = (user_query or "").lower()
price_match = re.search(r"(\d{2,5})\s*(?:₽|р|руб)", lowered)
city = None
for candidate, title in [
("москва", "Москва"),
("москов", "Москва"),
("питер", "Санкт-Петербург"),
("спб", "Санкт-Петербург"),
]:
if candidate in lowered:
city = title
break
max_price = float(price_match.group(1)) if price_match else None
return {
"city": city,
"start_at": None,
"end_at": None,
"max_price_per_hour": max_price,
"near_metro": "метро" in lowered,
"has_ev_charging": any(key in lowered for key in ["ev", "электро", "заряд"]),
"covered": "крыт" in lowered or "подзем" in lowered,
}
class RuleBasedLLMClient:
"""Фолбэк без внешних зависимостей."""
async def parse_search_query(self, system_prompt: str, user_query: str) -> Dict[str, Any]:
return _simple_rule_parser(user_query)
class ResilientLLMClient:
"""Обёртка: пытаемся OpenAI, при ошибке — rule-based."""
def __init__(self, primary: LLMClient | None, fallback: LLMClient):
self.primary = primary
self.fallback = fallback
async def parse_search_query(self, system_prompt: str, user_query: str) -> Dict[str, Any]:
if self.primary:
try:
return await self.primary.parse_search_query(system_prompt, user_query)
except HTTPException:
# Прокидываем 5xx наверх, чтобы клиент увидел, но оставим фолбэк
pass
except Exception:
# Любая другая ошибка — пробуем фолбэк
pass
return await self.fallback.parse_search_query(system_prompt, user_query)
PARSER_SYSTEM_PROMPT = """
You are an assistant that extracts structured parking search intent for ParkShare.
Return a strict JSON object with the following fields:
- city: string with the city name in nominative case, or null if unknown.
- start_at: ISO 8601 datetime with timezone (offset or Z) when parking should start, or null.
- end_at: ISO 8601 datetime with timezone (offset or Z) when parking should end, or null.
- max_price_per_hour: number (float) with the hourly price ceiling, or null.
- near_metro: boolean, true if the user wants parking near metro/public transit, else false or null.
- has_ev_charging: boolean, true if the user requires EV charging, else false or null.
- covered: boolean, true if the user prefers indoor/covered parking, else false or null.
Rules:
- If the user did not provide a value, set it to null.
- Never invent unavailable dates or cities; prefer null.
- Output only the JSON object without explanations, markdown, or comments.
- Respect the language of the request, but city names should be in nominative form.
Example output: {"city": "Moscow", "start_at": "2024-02-10T08:00:00+03:00", "end_at": null, "max_price_per_hour": 250.0, "near_metro": true, "has_ev_charging": false, "covered": true}
"""
class SearchQueryRequest(BaseModel):
query: str = Field(
...,
min_length=1,
description="Текстовый запрос пользователя",
)
class SearchQueryResponse(BaseModel):
model_config = ConfigDict(extra="ignore")
city: str | None = Field(None, description="Город, указанный пользователем")
start_at: datetime | None = Field(
None, description="ISO 8601 время начала парковки (или null)"
)
end_at: datetime | None = Field(
None, description="ISO 8601 время завершения парковки (или null)"
)
max_price_per_hour: float | None = Field(
None, description="Максимальная цена в час, если указана"
)
near_metro: bool | None = Field(
None, description="True, если нужно рядом с метро/транспортом"
)
has_ev_charging: bool | None = Field(
None, description="True, если требуется зарядка для электромобиля"
)
covered: bool | None = Field(
None, description="True, если требуется крытая/подземная парковка"
)
@lru_cache
def get_settings() -> Settings:
return Settings()
def get_llm_client(settings: Settings = Depends(get_settings)) -> LLMClient:
fallback = RuleBasedLLMClient()
primary = OpenAILLMClient(settings) if settings.openai_api_key else None
if primary:
return ResilientLLMClient(primary, fallback)
return fallback
app = FastAPI(title="ParkShare LLM Service", version="0.2.0")
_settings = get_settings()
app.add_middleware(
CORSMiddleware,
allow_origins=_settings.cors_allow_origins or ["*"],
allow_credentials=True,
allow_methods=["*"],
allow_headers=["*"],
)
@app.get("/health", tags=["health"])
async def health() -> dict[str, Any]:
mode = "openai" if _settings.openai_api_key else "fallback"
return {"status": "ok", "mode": mode}
@app.get("/healthz", tags=["health"])
async def healthz() -> dict[str, Any]:
return await health()
async def _execute_parse(payload: SearchQueryRequest, client: LLMClient) -> SearchQueryResponse:
try:
data = await client.parse_search_query(PARSER_SYSTEM_PROMPT, payload.query)
return SearchQueryResponse.model_validate(data)
except ValidationError as exc:
raise HTTPException(
status_code=status.HTTP_502_BAD_GATEWAY,
detail=f"LLM returned invalid payload: {exc}",
) from exc
except HTTPException:
raise
except Exception as exc:
raise HTTPException(
status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
detail=f"Unexpected LLM error: {exc}",
) from exc
@app.post(
"/parse",
response_model=SearchQueryResponse,
tags=["llm"],
summary="Распарсить поисковый запрос пользователя",
)
async def parse_endpoint(
payload: SearchQueryRequest,
client: LLMClient = Depends(get_llm_client),
) -> SearchQueryResponse:
return await _execute_parse(payload, client)
@app.post(
"/api/v1/llm/parse-search-query",
response_model=SearchQueryResponse,
tags=["llm"],
summary="Распарсить поисковый запрос пользователя через LLM",
)
async def parse_search_query_endpoint(
payload: SearchQueryRequest,
client: LLMClient = Depends(get_llm_client),
) -> SearchQueryResponse:
return await _execute_parse(payload, client)
if __name__ == "__main__":
import uvicorn
uvicorn.run(app, host="0.0.0.0", port=8002)

# File 128/163: services\llm_service\requirements.txt
################################################################################

fastapi==0.115.0
uvicorn[standard]==0.32.1
httpx==0.27.2
pydantic==2.12.4
pydantic-settings==2.8.0
python-dotenv==1.2.1


# File 129/163: static\manifest.webmanifest
################################################################################

{
  "name": "ParkShare — умная парковка",
  "short_name": "ParkShare",
  "description": "Поиск, бронирование и оплата парковок рядом с вами. Работает как приложение, даже офлайн.",
  "start_url": "/?pwa=true",
  "scope": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "background_color": "#020617",
  "theme_color": "#0f172a",
  "icons": [
    {
      "src": "/static/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/static/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/static/icons/icon-maskable-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/static/icons/icon-maskable-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "shortcuts": [
    {
      "name": "Найти парковку рядом",
      "short_name": "Найти рядом",
      "url": "/#search",
      "icons": [
        {
          "src": "/static/icons/shortcut-search.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Мои бронирования",
      "short_name": "Брони",
      "url": "/dashboard/#bookings"
    }
  ],
  "categories": ["navigation", "productivity", "travel"],
  "lang": "ru-RU"
}


# File 130/163: static\service-worker.js
################################################################################

const CACHE_VERSION = 'v5';
const STATIC_CACHE = `static-${CACHE_VERSION}`;
const HTML_CACHE = `html-${CACHE_VERSION}`;
const API_CACHE = `api-${CACHE_VERSION}`;
const OFFLINE_URL = '/offline/';
const STATIC_ASSETS = [
'/',
OFFLINE_URL,
'/static/css/app.css',
'/static/js/app.js',
'/static/js/map.js',
'/static/icons/icon-192.png',
'/static/icons/icon-512.png',
'/manifest.webmanifest'
];
self.addEventListener('install', (event) => {
event.waitUntil(
caches.open(STATIC_CACHE).then((cache) => cache.addAll(STATIC_ASSETS)).catch(() => null)
);
self.skipWaiting();
});
self.addEventListener('activate', (event) => {
event.waitUntil(
caches.keys().then((keys) =>
Promise.all(
keys
.filter((key) => ![STATIC_CACHE, HTML_CACHE, API_CACHE].includes(key))
.map((key) => caches.delete(key))
)
)
);
self.clients.claim();
});
const isGet = (req) => req.method === 'GET';
const isApi = (req) => new URL(req.url).pathname.startsWith('/api/');
const isHtml = (req) => req.headers.get('accept')?.includes('text/html');
const sameOrigin = (req) => self.location.origin === new URL(req.url).origin;
self.addEventListener('fetch', (event) => {
const { request } = event;
if (!isGet(request)) return;
if (isApi(request)) {
event.respondWith(staleWhileRevalidate(request, API_CACHE));
return;
}
if (sameOrigin(request) && isHtml(request)) {
event.respondWith(networkFirst(request, HTML_CACHE, OFFLINE_URL));
return;
}
event.respondWith(cacheFirst(request, STATIC_CACHE));
});
async function cacheFirst(request, cacheName) {
const cache = await caches.open(cacheName);
const cached = await cache.match(request);
if (cached) return cached;
try {
const response = await fetch(request);
if (response && response.status === 200) {
cache.put(request, response.clone());
}
return response;
} catch (err) {
if (isHtml(request)) {
const fallback = await caches.match(OFFLINE_URL);
if (fallback) return fallback;
}
throw err;
}
}
async function networkFirst(request, cacheName, fallbackUrl) {
const cache = await caches.open(cacheName);
try {
const response = await fetch(request);
if (response && response.status === 200) {
cache.put(request, response.clone());
}
return response;
} catch (err) {
const cached = await cache.match(request);
if (cached) return cached;
if (fallbackUrl) {
const fallback = await caches.match(fallbackUrl);
if (fallback) return fallback;
}
throw err;
}
}
async function staleWhileRevalidate(request, cacheName) {
const cache = await caches.open(cacheName);
const cached = await cache.match(request);
const network = fetch(request)
.then((response) => {
if (response && response.status === 200) {
cache.put(request, response.clone());
}
return response;
})
.catch(() => cached);
return cached || network;
}

# File 131/163: static\css\app.css
################################################################################

:root {
--ps-color-bg:
--ps-color-bg-elevated:
--ps-color-surface:
--ps-color-border: rgba(255, 255, 255, 0.06);
--ps-color-primary:
--ps-color-primary-soft: rgba(13, 110, 253, 0.16);
--ps-color-primary-strong:
--ps-color-accent:
--ps-color-text:
--ps-color-text-muted:
--ps-color-danger:
--ps-color-warning:
--ps-color-success:
--ps-color-neutral:
--ps-radius-sm: 0.5rem;
--ps-radius-md: 0.75rem;
--ps-radius-lg: 1rem;
--ps-shadow-soft: 0 18px 45px rgba(0, 0, 0, 0.45);
--ps-shadow-card: 0 10px 30px rgba(15, 23, 42, 0.9);
--ps-font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
"Segoe UI", sans-serif;
--ps-transition-fast: 0.15s ease-out;
--ps-transition-normal: 0.25s ease-out;
--ps-header-height: 60px;
--ps-bottom-nav-height: 70px;
}
@media (min-width: 768px) {
:root {
--ps-header-height: 64px;
}
}
*,
*::before,
*::after {
box-sizing: border-box;
}
html,
body {
margin: 0;
padding: 0;
}
body.ps-body {
min-height: 100vh;
font-family: var(--ps-font-family);
background: radial-gradient(circle at top left,
color: var(--ps-color-text);
-webkit-font-smoothing: antialiased;
}
@media (max-width: 767px) {
body.ps-body {
padding-bottom: calc(var(--ps-bottom-nav-height) + env(safe-area-inset-bottom));
}
.ps-header {
height: var(--ps-header-height);
}
}
img {
max-width: 100%;
display: block;
}
.ps-header {
position: sticky;
top: 0;
z-index: 40;
backdrop-filter: blur(12px);
background: linear-gradient(to bottom, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.7));
border-bottom: 1px solid rgba(148, 163, 184, 0.18);
}
.ps-navbar {
max-width: 1120px;
margin: 0 auto;
display: flex;
align-items: center;
padding: 0.35rem 1rem;
height: var(--ps-header-height);
}
.ps-navbar-left {
flex: 1 1 auto;
display: flex;
align-items: center;
}
.ps-logo {
display: inline-flex;
align-items: baseline;
gap: 0.24rem;
text-decoration: none;
}
.ps-logo-main {
font-weight: 700;
letter-spacing: 0.03em;
text-transform: uppercase;
font-size: 1.05rem;
color:
}
.ps-logo-accent {
font-weight: 700;
font-size: 0.9rem;
color: var(--ps-color-primary);
padding: 0.08rem 0.45rem;
border-radius: 999px;
background: linear-gradient(90deg, rgba(59, 130, 246, 0.16), rgba(59, 130, 246, 0.04));
border: 1px solid rgba(59, 130, 246, 0.4);
}
.ps-navbar-menu {
display: none;
flex-direction: column;
gap: 0.25rem;
position: absolute;
inset-inline: 0.75rem;
top: calc(var(--ps-header-height) + 0.35rem);
padding: 0.5rem;
border-radius: var(--ps-radius-md);
background: rgba(15, 23, 42, 0.97);
box-shadow: var(--ps-shadow-soft);
border: 1px solid rgba(148, 163, 184, 0.35);
}
.ps-navbar-menu.is-open {
display: flex;
}
.ps-nav-link {
display: inline-flex;
align-items: center;
justify-content: flex-start;
padding: 0.5rem 0.75rem;
border-radius: 999px;
font-size: 0.85rem;
text-decoration: none;
color: var(--ps-color-text-muted);
transition: background-color var(--ps-transition-fast), color var(--ps-transition-fast), transform var(--ps-transition-fast);
}
.ps-nav-link:hover {
background: rgba(15, 23, 42, 0.85);
color:
transform: translateY(-1px);
}
.ps-nav-link--primary {
background: linear-gradient(135deg,
color:
}
.ps-nav-link--primary:hover {
filter: brightness(1.08);
}
.ps-nav-link--danger {
color:
}
.ps-nav-link--danger:hover {
background: rgba(248, 113, 113, 0.08);
}
.ps-navbar-toggle {
border: none;
background: transparent;
cursor: pointer;
width: 40px;
height: 40px;
border-radius: 999px;
display: inline-flex;
align-items: center;
justify-content: center;
margin-left: auto;
padding: 0;
position: relative;
}
.ps-navbar-toggle span {
position: absolute;
display: block;
width: 22px;
height: 2px;
border-radius: 999px;
background:
left: 50%;
transition: transform var(--ps-transition-normal), opacity var(--ps-transition-fast);
}
.ps-navbar-toggle span + span {
margin-top: 0;
}
.ps-navbar-toggle span:nth-child(1) {
transform: translate(-50%, -9px);
}
.ps-navbar-toggle span:nth-child(2) {
transform: translate(-50%, -1px);
}
.ps-navbar-toggle span:nth-child(3) {
transform: translate(-50%, 7px);
}
.ps-navbar-toggle.is-open span:nth-child(1) {
transform: translate(-50%, -1px) rotate(45deg);
}
.ps-navbar-toggle.is-open span:nth-child(2) {
opacity: 0;
transform: translate(-50%, -1px);
}
.ps-navbar-toggle.is-open span:nth-child(3) {
transform: translate(-50%, -1px) rotate(-45deg);
}
@media (min-width: 768px) {
.ps-navbar {
padding-inline: 1.25rem;
}
.ps-navbar-menu {
position: static;
display: flex !important;
flex-direction: row;
gap: 0.35rem;
padding: 0;
border-radius: 999px;
background: transparent;
box-shadow: none;
border: none;
}
.ps-navbar-toggle {
display: none;
}
.ps-nav-link {
font-size: 0.85rem;
padding-inline: 0.9rem;
}
}
.ps-main {
max-width: 1120px;
margin: 1.25rem auto 2.5rem;
padding-inline: 1rem;
}
@media (min-width: 768px) {
.ps-main {
margin-top: 1.8rem;
}
}
@media (max-width: 767px) {
.ps-main {
margin-bottom: 5.5rem;
}
}
.ps-footer {
border-top: 1px solid rgba(148, 163, 184, 0.18);
background: rgba(15, 23, 42, 0.96);
}
.ps-footer-inner {
max-width: 1120px;
margin: 0 auto;
padding: 0.75rem 1rem 1rem;
display: flex;
flex-direction: column;
gap: 0.25rem;
font-size: 0.8rem;
color: var(--ps-color-text-muted);
}
@media (min-width: 640px) {
.ps-footer-inner {
flex-direction: row;
justify-content: space-between;
align-items: center;
}
}
.ps-section {
margin-bottom: 2.5rem;
}
.ps-section--flush-top {
margin-top: 0.5rem;
}
.ps-section--center {
text-align: center;
margin-top: 2.5rem;
}
.ps-section--narrow {
max-width: 640px;
margin-inline: auto;
}
.ps-section-header {
margin-bottom: 1.4rem;
}
.ps-section-title {
margin: 0 0 0.35rem;
font-size: 1.4rem;
font-weight: 700;
}
.ps-section-title span {
color: var(--ps-color-primary);
}
.ps-section-title-sm {
margin: 0.75rem 0 0.25rem;
font-size: 1rem;
font-weight: 600;
}
.ps-section-subtitle {
margin: 0;
font-size: 0.9rem;
color: var(--ps-color-text-muted);
}
.ps-section-subheader {
margin-top: 1.4rem;
margin-bottom: 0.5rem;
}
.ps-section-header--stack {
display: flex;
justify-content: space-between;
gap: 12px;
align-items: flex-start;
}
.ps-section-actions {
display: flex;
gap: 8px;
flex-wrap: wrap;
}
@media (max-width: 767px) {
.ps-section-header--stack {
flex-direction: column;
align-items: flex-start;
}
.ps-section-actions {
width: 100%;
}
}
.ps-grid {
display: grid;
gap: 1rem;
}
.ps-grid--gap-md {
gap: 0.75rem;
}
.ps-grid--gap-xl {
gap: 1.5rem;
}
.ps-grid--2col {
grid-template-columns: repeat(2, minmax(0, 1fr));
}
.ps-grid--mobile-stack {
grid-template-columns: 1fr;
}
@media (min-width: 992px) {
.ps-grid--2col@lg {
grid-template-columns: 1.1fr 1.2fr;
align-items: flex-start;
}
}
@media (min-width: 992px) {
.ps-grid--3col@lg {
grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.6fr);
}
}
@media (min-width: 1200px) {
.ps-grid--3col@xl {
grid-template-columns: minmax(0, 1.1fr) minmax(0, 1.9fr);
}
}
@media (max-width: 767px) {
.ps-grid--mobile-stack {
gap: 1.25rem;
}
}
.ps-grid-span-1 {
grid-column: span 1 / span 1;
}
.ps-grid-span-2 {
grid-column: span 1 / span 1;
}
@media (min-width: 992px) {
.ps-grid-span-2 {
grid-column: span 1 / span 1;
}
}
.ps-hero {
margin-bottom: 2rem;
}
.ps-hero-inner {
display: grid;
gap: 1.75rem;
}
@media (min-width: 768px) {
.ps-hero-inner {
grid-template-columns: minmax(0, 1.5fr) minmax(0, 1fr);
align-items: center;
}
}
.ps-hero-title {
margin: 0 0 0.5rem;
font-size: 1.9rem;
line-height: 1.2;
}
.ps-hero-title span {
color: var(--ps-color-primary);
}
@media (min-width: 640px) {
.ps-hero-title {
font-size: 2.15rem;
}
}
.ps-hero-subtitle {
margin: 0 0 1rem;
font-size: 0.95rem;
color: var(--ps-color-text-muted);
}
.ps-hero-actions {
display: flex;
flex-wrap: wrap;
gap: 0.6rem;
margin-bottom: 0.75rem;
}
.ps-hero-meta {
font-size: 0.8rem;
color: var(--ps-color-text-muted);
}
.ps-hero-visual {
display: flex;
justify-content: center;
}
.ps-hero-card {
padding: 0.9rem 1rem;
border-radius: var(--ps-radius-lg);
background: radial-gradient(circle at top left, rgba(37, 99, 235, 0.25), rgba(15, 23, 42, 0.95));
border: 1px solid rgba(148, 163, 184, 0.26);
box-shadow: var(--ps-shadow-card);
min-width: 260px;
}
.ps-hero-card-line {
display: flex;
align-items: center;
gap: 0.4rem;
font-size: 0.85rem;
color:
}
.ps-hero-card-line + .ps-hero-card-line {
margin-top: 0.4rem;
}
.ps-dot {
width: 8px;
height: 8px;
border-radius: 999px;
}
.ps-dot--green {
background: var(--ps-color-success);
}
.ps-dot--blue {
background: var(--ps-color-primary);
}
.ps-dot--yellow {
background: var(--ps-color-warning);
}
.ps-card {
border-radius: var(--ps-radius-md);
background: radial-gradient(circle at top, rgba(15, 23, 42, 0.98),
border: 1px solid rgba(148, 163, 184, 0.22);
padding: 0.9rem 0.95rem;
box-shadow: 0 10px 35px rgba(15, 23, 42, 0.86);
}
.ps-card--elevated {
box-shadow: var(--ps-shadow-card);
}
.ps-card-header {
display: flex;
justify-content: space-between;
align-items: center;
gap: 0.5rem;
margin-bottom: 0.6rem;
}
.ps-card-title {
font-size: 1rem;
font-weight: 600;
}
.ps-card-body {
font-size: 0.88rem;
}
.ps-card-line {
margin-bottom: 0.25rem;
}
.ps-card-line--muted {
color: var(--ps-color-text-muted);
font-size: 0.8rem;
}
.ps-card--spot {
margin-bottom: 0.5rem;
}
.ps-spots-panel {
position: relative;
}
.ps-spots-list {
display: grid;
gap: 0.65rem;
}
@media (max-width: 767px) {
.ps-spots-panel {
background: rgba(15, 23, 42, 0.85);
border: 1px solid rgba(148, 163, 184, 0.25);
border-radius: 18px 18px 0 0;
padding: 12px 14px;
box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.45);
}
.ps-spots-panel.is-sheet-open {
position: fixed;
left: 0;
right: 0;
bottom: 0;
max-height: 70vh;
overflow-y: auto;
z-index: 40;
}
}
.ps-list {
list-style: none;
padding: 0;
margin: 0;
}
.ps-list--compact .ps-list-item {
padding-block: 0.45rem;
}
.ps-list-item {
display: flex;
align-items: center;
justify-content: space-between;
gap: 0.5rem;
padding-block: 0.5rem;
border-bottom: 1px dashed rgba(148, 163, 184, 0.28);
}
.ps-list-item:last-child {
border-bottom: none;
}
.ps-list-main {
min-width: 0;
}
.ps-list-title {
font-size: 0.9rem;
font-weight: 500;
}
.ps-list-subtitle {
font-size: 0.78rem;
color: var(--ps-color-text-muted);
}
.ps-list-empty {
font-size: 0.85rem;
color: var(--ps-color-text-muted);
padding-block: 0.4rem;
}
.ps-form {
display: flex;
flex-direction: column;
gap: 0.6rem;
}
.ps-form-row {
display: flex;
flex-direction: column;
gap: 0.2rem;
}
.ps-form-label {
font-size: 0.82rem;
color: var(--ps-color-text-muted);
}
.ps-input {
border-radius: var(--ps-radius-sm);
border: 1px solid rgba(148, 163, 184, 0.4);
background: rgba(15, 23, 42, 0.95);
color: var(--ps-color-text);
padding: 0.45rem 0.55rem;
font-size: 0.9rem;
outline: none;
transition: border-color var(--ps-transition-fast), box-shadow var(--ps-transition-fast), background-color var(--ps-transition-fast), transform var(--ps-transition-fast);
}
.ps-input:focus {
border-color: var(--ps-color-primary);
box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
transform: translateY(-0.5px);
}
.ps-field-error {
font-size: 0.75rem;
color:
}
.ps-field-help {
font-size: 0.75rem;
color: var(--ps-color-text-muted);
}
.ps-form-actions {
display: flex;
flex-direction: column;
gap: 0.5rem;
margin-top: 0.4rem;
}
@media (min-width: 640px) {
.ps-form-actions {
flex-direction: row;
justify-content: flex-start;
}
}
.ps-btn {
border-radius: 999px;
border: none;
padding: 0.45rem 0.95rem;
font-size: 0.88rem;
font-weight: 500;
cursor: pointer;
display: inline-flex;
align-items: center;
justify-content: center;
gap: 0.35rem;
background: linear-gradient(135deg,
color:
text-decoration: none;
transition: transform var(--ps-transition-fast), box-shadow var(--ps-transition-fast), filter var(--ps-transition-fast), background var(--ps-transition-fast);
}
.ps-btn:hover {
transform: translateY(-1px);
filter: brightness(1.06);
box-shadow: 0 14px 32px rgba(37, 99, 235, 0.6);
}
.ps-btn:active {
transform: translateY(1px);
box-shadow: 0 8px 20px rgba(15, 23, 42, 0.8);
}
.ps-btn-secondary {
background: rgba(15, 23, 42, 0.96);
color:
border: 1px solid rgba(148, 163, 184, 0.5);
box-shadow: none;
}
.ps-btn-secondary:hover {
background: rgba(15, 23, 42, 1);
border-color: rgba(148, 163, 184, 0.8);
}
.ps-btn-ghost {
background: transparent;
color:
border: 1px solid rgba(148, 163, 184, 0.35);
}
.ps-btn-ghost:hover {
background: rgba(15, 23, 42, 0.8);
}
.ps-btn-lg {
padding-block: 0.55rem;
padding-inline: 1.1rem;
}
.ps-btn-full {
width: 100%;
}
.ps-badge {
display: inline-flex;
align-items: center;
justify-content: center;
padding: 0.15rem 0.55rem;
border-radius: 999px;
font-size: 0.72rem;
font-weight: 500;
border: 1px solid transparent;
}
.ps-badge--success {
background: rgba(34, 197, 94, 0.1);
border-color: rgba(34, 197, 94, 0.65);
color:
}
.ps-badge--neutral {
background: rgba(148, 163, 184, 0.12);
border-color: rgba(148, 163, 184, 0.6);
color:
}
.ps-badge--status-pending {
background: rgba(234, 179, 8, 0.1);
border-color: rgba(234, 179, 8, 0.7);
color:
}
.ps-badge--status-confirmed,
.ps-badge--status-active {
background: rgba(34, 197, 94, 0.1);
border-color: rgba(34, 197, 94, 0.7);
color:
}
.ps-badge--status-completed {
background: rgba(59, 130, 246, 0.1);
border-color: rgba(59, 130, 246, 0.7);
color:
}
.ps-badge--status-cancelled,
.ps-badge--status-expired,
.ps-badge--status-inactive {
background: rgba(248, 113, 113, 0.08);
border-color: rgba(248, 113, 113, 0.7);
color:
}
.ps-table-wrapper {
overflow-x: auto;
margin-top: 0.3rem;
}
.ps-table {
width: 100%;
border-collapse: collapse;
font-size: 0.85rem;
}
.ps-table thead {
background: rgba(15, 23, 42, 0.95);
}
.ps-table th,
.ps-table td {
padding: 0.45rem 0.5rem;
border-bottom: 1px solid rgba(30, 64, 175, 0.45);
}
.ps-table th {
text-align: left;
font-weight: 500;
font-size: 0.78rem;
color: var(--ps-color-text-muted);
}
.ps-table tbody tr:nth-child(even) {
background: rgba(15, 23, 42, 0.75);
}
.ps-table tbody tr:hover {
background: rgba(30, 64, 175, 0.45);
}
@media (max-width: 640px) {
.ps-table thead {
display: none;
}
.ps-table tr {
display: grid;
padding-block: 0.4rem;
border-bottom: 1px solid rgba(30, 64, 175, 0.45);
}
.ps-table td {
border: none;
padding: 0.2rem 0.3rem;
}
.ps-table td::before {
content: attr(data-label);
display: inline-block;
width: 46%;
max-width: 120px;
font-size: 0.74rem;
text-transform: uppercase;
letter-spacing: 0.04em;
color: var(--ps-color-text-muted);
}
.ps-table td {
font-size: 0.8rem;
}
}
.ps-map {
border-radius: var(--ps-radius-md);
border: 1px solid rgba(148, 163, 184, 0.25);
overflow: hidden;
height: min(65vh, 560px);
margin-bottom: 0.5rem;
box-shadow: var(--ps-shadow-card);
position: relative;
z-index: 2;
background:
transition: filter 0.2s ease, transform 0.2s ease;
}
@media (max-width: 767px) {
.ps-map {
height: calc(100vh - var(--ps-header-height) - var(--ps-bottom-nav-height) - env(safe-area-inset-bottom) - 16px);
}
}
.ps-map.ps-map--dark {
background:
}
.ps-map-wrapper {
position: relative;
overflow: visible;
}
.ps-map-floating-actions {
position: absolute;
top: 12px;
right: 12px;
display: flex;
flex-direction: column;
gap: 8px;
pointer-events: auto;
z-index: 1300;
transition: opacity var(--ps-transition-normal);
backdrop-filter: blur(8px);
padding: 6px;
border-radius: 16px;
background: rgba(255, 255, 255, 0.75);
}
.ps-map-floating-actions.is-dimmed {
opacity: 0.35;
}
.ps-map-action {
width: 44px;
height: 44px;
border-radius: 12px;
border: 1px solid rgba(15, 23, 42, 0.2);
background: rgba(250, 250, 255, 0.98);
color:
cursor: pointer;
pointer-events: auto;
box-shadow: var(--ps-shadow-card);
transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, opacity 0.2s ease;
}
.ps-map-action:hover {
transform: translateY(-1px);
background: rgba(255, 255, 255, 0.95);
}
.ps-map-action:active {
transform: scale(0.96);
}
.ps-map-action--toggled {
box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.4);
}
.ps-map-action--spinning { animation: ps-spin-once 0.5s ease-out; }
.ps-map-action--pulse { animation: ps-pulse 1.3s ease-out infinite; }
.ps-map-action.is-animating { animation: ps-rotate-pop 0.45s ease; }
.ps-map-action.is-busy { opacity: 0.7; pointer-events: none; }
@keyframes ps-spin-once {
to { transform: rotate(360deg); }
}
@keyframes ps-pulse {
0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
70% { box-shadow: 0 0 0 12px rgba(34, 197, 94, 0); }
100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
}
@keyframes ps-rotate-pop {
0% { transform: rotate(0deg) scale(0.96); }
60% { transform: rotate(-12deg) scale(1.08); }
100% { transform: rotate(0deg) scale(1); }
}
.ps-map.ps-map--dark ~ .ps-map-floating-actions .ps-map-action,
body.theme-dark .ps-map-floating-actions .ps-map-action,
body:not(.ps-day-mode) .ps-map-floating-actions .ps-map-action {
background: rgba(17, 24, 39, 0.92);
color:
border-color: rgba(255, 255, 255, 0.12);
}
.ps-map-popup,
.ymaps-2-1-79-balloon__layout,
.ymaps-2-1-79-balloon__content {
background-color:
color:
border-radius: 16px;
padding: 0;
box-shadow: 0 20px 40px rgba(15, 23, 42, 0.28);
border: 1px solid rgba(148, 163, 184, 0.35);
}
.ymaps-2-1-79-balloon__layout {
overflow: hidden;
}
.ps-map.ps-map--dark .ps-map-popup,
.ps-map.ps-map--dark .ymaps-2-1-79-balloon__layout,
.ps-map.ps-map--dark .ymaps-2-1-79-balloon__content,
body.theme-dark .ps-map-popup,
body.theme-dark .ymaps-2-1-79-balloon__layout,
body.theme-dark .ymaps-2-1-79-balloon__content,
body:not(.ps-day-mode) .ps-map-popup,
body:not(.ps-day-mode) .ymaps-2-1-79-balloon__layout,
body:not(.ps-day-mode) .ymaps-2-1-79-balloon__content {
background-color:
color:
box-shadow: 0 20px 40px rgba(15, 23, 42, 0.6);
border-color: rgba(148, 163, 184, 0.25);
}
.ps-map-popup {
width: min(380px, 82vw);
padding: 16px 18px 14px;
box-sizing: border-box;
max-height: 55vh;
overflow: hidden;
}
.ps-map-popup-head { margin-bottom: 4px; }
.ps-map-popup-title { font-weight: 700; font-size: 1rem; margin-bottom: 2px; color:
.ps-map-popup-meta { font-size: 0.82rem; color: var(--ps-color-text-muted); margin-bottom: 6px; }
.ps-map-popup-price { font-size: 0.95rem; margin-bottom: 10px; color:
.ps-map-popup-meter {
margin: 10px 0 12px;
height: 10px;
border-radius: 999px;
background: rgba(15, 23, 42, 0.08);
overflow: hidden;
}
.ps-map-popup-meter span {
display: block;
height: 100%;
border-radius: inherit;
background: linear-gradient(90deg,
}
.ps-map-popup-meter-label { font-size: 0.78rem; color: var(--ps-color-text-muted); margin-top: 4px; }
.ps-map.ps-map--dark .ps-map-popup-title,
body.theme-dark .ps-map-popup-title,
body:not(.ps-day-mode) .ps-map-popup-title {
color:
}
.ps-map.ps-map--dark .ps-map-popup-price,
body.theme-dark .ps-map-popup-price,
body:not(.ps-day-mode) .ps-map-popup-price {
color:
}
.ps-map.ps-map--dark .ps-map-popup-meter,
body.theme-dark .ps-map-popup-meter,
body:not(.ps-day-mode) .ps-map-popup-meter {
background: rgba(255, 255, 255, 0.08);
}
.ps-map-popup--list {
max-height: 420px;
overflow-y: auto;
padding: 12px 14px 10px;
}
.ps-map-popup--list .ps-map-popup {
margin-bottom: 10px;
border: 1px solid rgba(148, 163, 184, 0.22);
}
.ps-map-popup--list .ps-map-popup:last-child {
margin-bottom: 0;
}
.ps-map-grid {
display: grid;
grid-template-columns: 1.15fr 0.85fr;
gap: 18px;
}
.ps-map-topbar {
position: absolute;
left: 12px;
right: 12px;
top: 12px;
display: flex;
gap: 10px;
align-items: center;
background: rgba(255, 255, 255, 0.9);
padding: 10px 12px;
border-radius: 14px;
box-shadow: var(--ps-shadow-card);
z-index: 1250;
}
.ps-map.ps-map--dark ~ .ps-map-topbar,
body.theme-dark .ps-map-topbar,
body:not(.ps-day-mode) .ps-map-topbar {
background: rgba(15, 23, 42, 0.9);
}
.ps-map-chips {
position: absolute;
left: 12px;
right: 12px;
top: 72px;
display: flex;
gap: 8px;
overflow-x: auto;
padding: 4px 2px;
z-index: 1200;
}
.ps-bottom-sheet {
background: rgba(255, 255, 255, 0.96);
border-radius: 16px;
border: 1px solid rgba(148, 163, 184, 0.3);
box-shadow: var(--ps-shadow-card);
height: min(70vh, 640px);
display: flex;
flex-direction: column;
position: relative;
overflow: hidden;
}
.ps-bottom-sheet__handle {
width: 54px;
height: 5px;
border-radius: 999px;
background: rgba(148, 163, 184, 0.35);
margin: 8px auto;
}
.ps-bottom-sheet__header {
display: flex;
align-items: center;
justify-content: space-between;
padding: 4px 16px 8px;
}
.ps-bottom-sheet__actions { display: flex; gap: 8px; }
.ps-bottom-sheet__body {
padding: 0 12px 12px;
overflow-y: auto;
}
@media (max-width: 1023px) {
.ps-map-grid { grid-template-columns: 1fr; }
.ps-bottom-sheet { height: auto; min-height: 320px; }
.ps-map-topbar { position: fixed; left: 12px; right: 12px; top: calc(var(--ps-header-height) + 10px); }
.ps-map-chips { top: calc(var(--ps-header-height) + 64px); }
}
@media (max-width: 640px) {
.ps-map { height: calc(100vh - var(--ps-header-height) - var(--ps-bottom-nav-height) - env(safe-area-inset-bottom) - 10px); }
.ps-map-topbar { flex-direction: column; align-items: stretch; gap: 8px; }
.ps-map-grid { gap: 12px; }
}
@media (max-width: 640px) {
.ymaps-2-1-79-balloon__layout,
.ymaps-2-1-79-balloon__content {
max-width: 90vw;
}
.ps-map-popup {
padding: 12px 14px 10px;
max-width: 90vw;
font-size: 13px;
}
.ps-map-popup-title {
font-size: 14px;
}
.ps-map-popup-price {
font-size: 13px;
}
}
.ymaps-2-1-79-balloon__tail::after,
.ymaps-2-1-79-balloon__tail::before {
background: inherit;
}
.ps-map-popup-card .leaflet-popup-content {
margin: 12px 14px;
}
.ps-map-popup-card .ps-map-popup-title {
color: inherit;
}
.ps-map-popup-card .ps-map-popup-price {
color: inherit;
}
.ps-map-popup-actions .ps-btn {
box-shadow: none;
}
.ps-map-popup-actions .ps-btn.ps-btn-ghost {
color: inherit;
border: 1px solid rgba(148, 163, 184, 0.35);
}
.ps-map-marker {
width: 52px;
height: 52px;
border-radius: 50%;
background:
position: relative;
box-shadow: 0 8px 20px rgba(14, 165, 233, 0.35);
transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.ps-map-marker__body {
width: 100%;
height: 100%;
border-radius: inherit;
display: grid;
place-items: center;
color:
font-weight: 700;
font-size: 13px;
letter-spacing: 0.01em;
box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.12);
}
.ps-map-marker__halo {
position: absolute;
inset: -6px;
border-radius: inherit;
background: rgba(59, 130, 246, 0.12);
z-index: -1;
transition: opacity 0.2s ease;
}
.ps-map-marker:hover,
.ps-map-marker--active {
transform: translateY(-6px) scale(1.06);
box-shadow: 0 14px 38px rgba(15, 23, 42, 0.35), 0 0 0 3px rgba(59, 130, 246, 0.12);
}
.ps-map-marker:hover .ps-map-marker__halo,
.ps-map-marker--active .ps-map-marker__halo {
opacity: 0.9;
}
.ps-map-marker--hot .ps-map-marker__halo {
background: rgba(34, 197, 94, 0.3);
animation: ps-pulse 1.4s ease-out infinite;
}
.ps-map-marker__value {
text-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}
.ps-map-cluster {
width: 56px;
height: 56px;
border-radius: 999px;
background: linear-gradient(135deg,
color:
display: grid;
place-items: center;
font-weight: 700;
font-size: 15px;
box-shadow: 0 12px 26px rgba(59, 130, 246, 0.35);
}
.ps-map-cluster--warn {
background: linear-gradient(135deg,
box-shadow: 0 12px 26px rgba(249, 115, 22, 0.35);
}
.ps-map-cluster--danger {
background: linear-gradient(135deg,
box-shadow: 0 12px 26px rgba(239, 68, 68, 0.35);
}
.ps-map-filters {
margin-top: 0.5rem;
}
.ps-map-filters-card {
background: linear-gradient(120deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.7));
border: 1px solid rgba(148, 163, 184, 0.35);
border-radius: var(--ps-radius-lg);
padding: 12px;
display: grid;
gap: 12px;
box-shadow: var(--ps-shadow-card);
}
.ps-map-filters-row {
display: grid;
grid-template-columns: 1fr auto;
gap: 12px;
align-items: center;
}
.ps-map-filters-actions {
display: flex;
justify-content: flex-end;
}
.ps-map-filters-row--chips {
grid-template-columns: 1fr;
gap: 8px;
}
.ps-chip-scroll {
display: flex;
gap: 8px;
overflow-x: auto;
padding-bottom: 4px;
scrollbar-width: thin;
}
.ps-chip-scroll .ps-chip {
white-space: nowrap;
}
.ps-map-filters-row--slider {
grid-template-columns: 1fr;
gap: 6px;
}
.ps-filter-slider {
margin: 2px 0;
}
.ps-filter-price {
font-size: 0.9rem;
color: var(--ps-color-text-muted);
}
.ps-input-icon {
position: relative;
display: flex;
align-items: center;
}
.ps-input-icon .ps-input {
padding-left: 2.25rem;
}
.ps-input-icon-symbol {
position: absolute;
left: 12px;
pointer-events: none;
opacity: 0.8;
}
.ps-geocode-suggestions {
display: grid;
gap: 6px;
}
.ps-geocode-suggestions button {
text-align: left;
background: rgba(30, 41, 59, 0.8);
border: 1px solid rgba(148, 163, 184, 0.3);
color:
padding: 8px 10px;
border-radius: var(--ps-radius-md);
}
.ps-map-popup-badges {
display: flex;
flex-wrap: wrap;
gap: 4px;
}
.ps-map-popup-title {
font-weight: 600;
font-size: 15px;
color:
margin-bottom: 4px;
}
.ps-map-popup-price {
font-size: 14px;
color:
margin-bottom: 8px;
}
.ps-map-popup-meter {
margin-top: 8px;
background: rgba(15, 23, 42, 0.08);
border-radius: 999px;
overflow: hidden;
height: 6px;
}
.ps-map-popup-meter span {
display: block;
height: 100%;
border-radius: 999px;
background: linear-gradient(to right,
}
.ps-map-popup-actions {
display: flex;
gap: 6px;
margin-top: 6px;
}
.ps-meter {
display: inline-block;
width: 90px;
height: 8px;
background: rgba(148, 163, 184, 0.35);
border-radius: 999px;
overflow: hidden;
}
.ps-meter span {
display: block;
height: 100%;
background: linear-gradient(90deg,
}
.ps-map-loading {
position: absolute;
inset: 0;
display: none;
align-items: center;
justify-content: center;
background: rgba(15, 23, 42, 0.5);
color:
font-weight: 600;
}
.ps-route-hint {
margin-top: 8px;
color: var(--ps-color-text-muted);
font-size: 0.9rem;
}
.ps-payment-list {
display: grid;
gap: 10px;
}
.ps-payment-card {
display: grid;
grid-template-columns: 1fr auto;
gap: 8px;
align-items: center;
padding: 10px 12px;
border-radius: var(--ps-radius-md);
background: linear-gradient(120deg, rgba(34, 197, 94, 0.08), rgba(14, 165, 233, 0.06));
border: 1px solid rgba(148, 163, 184, 0.25);
}
.ps-payment-meta {
color: var(--ps-color-text-muted);
font-size: 0.9rem;
}
.ps-payment-actions {
display: flex;
gap: 6px;
}
.ps-payment-brand {
font-weight: 700;
display: inline-flex;
align-items: center;
gap: 6px;
}
.ps-progress-block {
background: rgba(148, 163, 184, 0.08);
border: 1px solid rgba(148, 163, 184, 0.2);
border-radius: var(--ps-radius-md);
padding: 8px 10px;
margin-bottom: 10px;
}
.ps-progress-header {
display: flex;
align-items: center;
justify-content: space-between;
gap: 8px;
flex-wrap: wrap;
margin-bottom: 6px;
}
.ps-progress-label {
color: var(--ps-color-text-muted);
font-size: 0.9rem;
}
.ps-progress {
width: 100%;
height: 8px;
background: rgba(148, 163, 184, 0.2);
border-radius: 999px;
overflow: hidden;
}
.ps-progress-bar {
height: 100%;
background: linear-gradient(90deg,
border-radius: 999px;
}
.ps-chip {
display: inline-flex;
align-items: center;
justify-content: center;
gap: 6px;
background: rgba(148, 163, 184, 0.15);
color:
padding: 8px 12px;
border-radius: 999px;
border: 1px solid rgba(148, 163, 184, 0.25);
cursor: pointer;
transition: all var(--ps-transition-fast);
font-weight: 600;
font-size: 0.9rem;
}
.ps-chip:hover {
border-color: rgba(34, 197, 94, 0.5);
box-shadow: 0 10px 25px rgba(34, 197, 94, 0.14);
}
.ps-chip input {
accent-color:
}
.ps-chip.is-active {
background: rgba(34, 197, 94, 0.12);
border-color: rgba(34, 197, 94, 0.6);
color:
}
@media (min-width: 768px) {
.ps-map {
height: 420px;
}
.ps-map-filters-card {
padding: 14px 16px;
}
}
@media (max-width: 767px) {
.ps-map-filters-row {
grid-template-columns: 1fr;
}
.ps-map {
height: calc(100vh - var(--ps-header-height) - var(--ps-bottom-nav-height) - 150px);
border-radius: var(--ps-radius-lg);
}
.ps-map-filters-actions {
width: 100%;
}
}
.ps-modal {
position: fixed;
inset: 0;
background: rgba(0, 0, 0, 0.7);
display: grid;
place-items: center;
z-index: 50;
}
.ps-modal-dialog {
background:
border: 1px solid rgba(148, 163, 184, 0.4);
border-radius: var(--ps-radius-xl);
padding: 18px;
min-width: 320px;
max-width: 420px;
position: relative;
}
.ps-modal-close {
position: absolute;
top: 8px;
right: 10px;
background: none;
border: none;
color:
font-size: 1.2rem;
cursor: pointer;
}
.ps-tabs {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 6px;
margin-bottom: 10px;
}
.ps-tabs button {
background: rgba(148, 163, 184, 0.15);
border: 1px solid rgba(148, 163, 184, 0.2);
color:
padding: 8px 4px;
border-radius: var(--ps-radius-md);
}
.ps-tabs button.is-active {
border-color:
box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.3);
}
.ps-tab-panel {
display: none;
gap: 8px;
}
.ps-tab-panel.is-active {
display: grid;
}
.ps-chat {
position: fixed;
right: 24px;
bottom: 24px;
z-index: 65;
display: grid;
grid-template-columns: auto;
gap: 12px;
align-items: flex-end;
}
.ps-chat-fab {
display: inline-flex;
align-items: center;
gap: 10px;
padding: 12px 16px;
border-radius: 999px;
border: 1px solid rgba(255, 255, 255, 0.12);
background: linear-gradient(145deg, rgba(34, 197, 94, 0.95), rgba(14, 165, 233, 0.95));
color:
font-weight: 700;
box-shadow: 0 18px 35px rgba(0, 0, 0, 0.6);
cursor: pointer;
transition: transform var(--ps-transition-fast), box-shadow var(--ps-transition-fast);
position: relative;
z-index: 3;
}
.ps-chat-fab:hover {
transform: translateY(-1px);
box-shadow: 0 20px 40px rgba(0, 0, 0, 0.55);
}
.ps-chat-fab-text {
display: inline;
}
.ps-chat-panel {
position: fixed;
right: 24px;
bottom: 24px;
width: 400px;
max-width: calc(100vw - 32px);
max-height: 78vh;
background: rgba(10, 14, 26, 0.95);
border-radius: 18px;
border: 1px solid rgba(148, 163, 184, 0.25);
display: grid;
grid-template-rows: auto 1fr auto;
box-shadow: 0 22px 48px rgba(0, 0, 0, 0.7);
overflow: hidden;
transform: translateY(12px) scale(0.99);
opacity: 0;
pointer-events: none;
transition: transform var(--ps-transition-normal), opacity var(--ps-transition-normal);
z-index: 2;
}
.ps-chat.is-sheet .ps-chat-panel {
left: 12px;
right: 12px;
width: auto;
bottom: calc(var(--ps-bottom-nav-height) + 10px);
max-height: calc(100vh - var(--ps-header-height) - var(--ps-bottom-nav-height) - 18px);
border-radius: 20px;
box-shadow: 0 32px 80px rgba(0, 0, 0, 0.65);
}
.ps-chat-overlay {
position: fixed;
inset: 0;
background: rgba(3, 6, 17, 0.3);
backdrop-filter: blur(2px);
opacity: 0;
pointer-events: none;
transition: opacity var(--ps-transition-fast);
z-index: 1;
}
.ps-chat.is-sheet .ps-chat-overlay {
background: linear-gradient(to top, rgba(3, 6, 17, 0.55), rgba(3, 6, 17, 0.1));
}
.ps-chat.is-open .ps-chat-panel {
transform: translateY(0) scale(1);
opacity: 1;
pointer-events: auto;
}
.ps-chat.is-open .ps-chat-overlay {
opacity: 1;
pointer-events: auto;
}
.ps-chat-header {
padding: 14px 16px 12px;
border-bottom: 1px solid rgba(148, 163, 184, 0.2);
display: grid;
grid-template-columns: 1fr auto;
gap: 12px;
align-items: center;
}
.ps-chat-header-text {
display: grid;
gap: 4px;
}
.ps-chat-title {
font-size: 1rem;
font-weight: 700;
}
.ps-chat-hint {
font-size: 0.85rem;
color: var(--ps-color-text-muted);
}
.ps-chat-meta {
display: inline-flex;
gap: 10px;
align-items: center;
}
.ps-chat-close {
border: 1px solid rgba(255, 255, 255, 0.14);
background: rgba(255, 255, 255, 0.06);
color:
border-radius: 10px;
padding: 6px 10px;
cursor: pointer;
}
.ps-chat-status-dot {
font-size: 0.85rem;
color:
padding: 6px 10px;
border-radius: 999px;
background: rgba(52, 211, 153, 0.12);
border: 1px solid rgba(52, 211, 153, 0.4);
}
.ps-chat-body {
overflow-y: auto;
padding: 14px 16px;
display: grid;
gap: 12px;
background: radial-gradient(circle at top right, rgba(34, 197, 94, 0.04), transparent 40%);
}
.ps-chat-bubble {
padding: 12px 13px;
border-radius: 18px;
border: 1px solid rgba(148, 163, 184, 0.22);
background: rgba(148, 163, 184, 0.08);
display: grid;
gap: 6px;
box-shadow: var(--ps-shadow-soft);
}
.ps-chat-bubble--user {
background: rgba(34, 197, 94, 0.14);
border-color: rgba(34, 197, 94, 0.35);
justify-self: end;
}
.ps-chat-text {
line-height: 1.45;
font-size: 0.98rem;
color:
}
.ps-chat-meta {
font-size: 0.82rem;
color: var(--ps-color-text-muted);
}
.ps-chat-spots {
display: grid;
gap: 8px;
}
.ps-chat-spot-card {
padding: 10px 12px;
background: linear-gradient(135deg, rgba(26, 34, 52, 0.94), rgba(16, 24, 40, 0.92));
border: 1px solid rgba(148, 163, 184, 0.25);
border-radius: var(--ps-radius-md);
display: grid;
gap: 6px;
box-shadow: 0 10px 24px rgba(0, 0, 0, 0.25);
}
.ps-chat-spot-title {
font-weight: 700;
}
.ps-chat-spot-meta {
font-size: 0.9rem;
color: var(--ps-color-text-muted);
}
.ps-chat-spot-actions {
display: flex;
justify-content: flex-start;
}
.ps-chat-feedback {
display: flex;
align-items: center;
gap: 8px;
font-size: 0.9rem;
}
.ps-chat-feedback-actions button {
background: rgba(148, 163, 184, 0.1);
border: 1px solid rgba(148, 163, 184, 0.3);
color: var(--ps-color-text);
border-radius: 8px;
padding: 4px 8px;
cursor: pointer;
transition: background var(--ps-transition-fast), transform var(--ps-transition-fast);
}
.ps-chat-feedback-actions button:hover {
background: rgba(255, 255, 255, 0.08);
transform: translateY(-1px);
}
.ps-chat-feedback-actions button.is-active {
border-color: var(--ps-color-primary);
box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.2);
}
.ps-chat-input {
padding: 12px 14px;
display: grid;
grid-template-columns: 1fr auto;
gap: 10px;
border-top: 1px solid rgba(148, 163, 184, 0.2);
background: rgba(15, 23, 42, 0.92);
}
.ps-chat-input .ps-btn {
align-self: end;
}
.ps-chat-input textarea {
min-height: 56px;
resize: none;
}
.ps-chat-status {
padding: 6px 16px;
font-size: 0.85rem;
color: var(--ps-color-text-muted);
}
@media (max-width: 1023px) {
.ps-chat {
right: 16px;
bottom: calc(var(--ps-bottom-nav-height) + 18px);
}
.ps-chat-fab {
padding: 12px;
min-height: 48px;
border-radius: 999px;
box-shadow: 0 14px 32px rgba(0, 0, 0, 0.55);
}
.ps-chat-fab-text {
display: none;
}
.ps-chat-panel {
right: 12px;
left: 12px;
bottom: calc(var(--ps-bottom-nav-height) + 10px);
width: auto;
max-width: 100%;
max-height: calc(100vh - var(--ps-header-height) - var(--ps-bottom-nav-height) - 12px);
border-radius: 18px 18px 0 0;
transform: translateY(120%);
}
.ps-chat.is-open .ps-chat-panel {
transform: translateY(0);
}
.ps-chat-overlay {
display: block;
}
}
.ps-bottom-nav {
position: fixed;
left: 0;
right: 0;
bottom: 0;
height: var(--ps-bottom-nav-height);
background: linear-gradient(180deg, rgba(10, 14, 26, 0.94), rgba(5, 8, 22, 0.98));
border-top: 1px solid rgba(148, 163, 184, 0.15);
display: none;
grid-template-columns: repeat(4, 1fr);
box-shadow: 0 -10px 28px rgba(0, 0, 0, 0.45);
z-index: 1300;
padding-bottom: env(safe-area-inset-bottom);
}
.ps-bottom-nav-item {
display: inline-flex;
flex-direction: column;
align-items: center;
justify-content: center;
gap: 4px;
color: var(--ps-color-text-muted);
background: transparent;
border: none;
font-size: 0.82rem;
cursor: pointer;
text-decoration: none;
position: relative;
transition: color var(--ps-transition-fast), transform var(--ps-transition-fast);
}
.ps-bottom-nav-icon {
font-size: 1.1rem;
}
.ps-bottom-nav-item::before {
content: "";
position: absolute;
top: 0;
left: 18%;
right: 18%;
height: 3px;
border-radius: 999px;
background: transparent;
transition: background var(--ps-transition-fast);
}
.ps-bottom-nav-item.is-active,
.ps-bottom-nav-item:focus-visible,
.ps-bottom-nav-item:hover {
color: var(--ps-color-text);
}
.ps-bottom-nav-item.is-active::before {
background: linear-gradient(90deg,
}
@media (max-width: 1023px) {
.ps-bottom-nav {
display: grid;
}
}
.ps-user-level {
display: inline-flex;
align-items: center;
gap: 4px;
padding: 4px 8px;
border-radius: 999px;
background: rgba(34, 197, 94, 0.12);
color:
margin-left: 8px;
font-size: 0.9rem;
}
.ps-card--skeleton {
position: relative;
overflow: hidden;
}
.ps-skeleton-line {
height: 0.55rem;
border-radius: 999px;
background: linear-gradient(
90deg,
rgba(31, 41, 55, 0.9),
rgba(55, 65, 81, 0.85),
rgba(31, 41, 55, 0.9)
);
background-size: 200% 100%;
animation: ps-shimmer 1.2s linear infinite;
margin-bottom: 0.3rem;
}
.ps-skeleton-line--lg {
width: 75%;
}
.ps-skeleton-line--short {
width: 40%;
}
@keyframes ps-shimmer {
0% {
background-position: 200% 0;
}
100% {
background-position: -200% 0;
}
}
.ps-empty {
font-size: 0.85rem;
color: var(--ps-color-text-muted);
padding: 0.4rem 0;
}
.ps-hint {
font-size: 0.82rem;
color: var(--ps-color-text-muted);
}
.ps-back-to-top {
position: fixed;
right: 1rem;
bottom: 1.1rem;
width: 38px;
height: 38px;
border-radius: 999px;
border: 1px solid rgba(148, 163, 184, 0.6);
background: radial-gradient(circle at top, rgba(30, 64, 175, 0.7), rgba(15, 23, 42, 0.98));
color:
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
opacity: 0;
pointer-events: none;
transform: translateY(8px);
transition: opacity var(--ps-transition-normal), transform var(--ps-transition-normal), box-shadow var(--ps-transition-fast);
box-shadow: 0 10px 30px rgba(15, 23, 42, 0.9);
z-index: 50;
}
.ps-back-to-top.is-visible {
opacity: 1;
pointer-events: auto;
transform: translateY(0);
}
.ps-back-to-top:hover {
box-shadow: 0 18px 40px rgba(15, 23, 42, 0.95);
}
.ps-toast-container {
position: fixed;
inset-inline: 0;
bottom: 0.85rem;
display: flex;
flex-direction: column;
gap: 0.4rem;
padding-inline: 0.75rem;
z-index: 60;
}
@media (min-width: 640px) {
.ps-toast-container {
align-items: center;
}
}
.ps-toast {
max-width: 360px;
width: 100%;
border-radius: var(--ps-radius-md);
padding: 0.6rem 0.75rem;
display: flex;
align-items: center;
justify-content: space-between;
gap: 0.5rem;
font-size: 0.82rem;
border: 1px solid rgba(148, 163, 184, 0.56);
background: rgba(15, 23, 42, 0.98);
box-shadow: var(--ps-shadow-card);
transform: translateY(8px);
opacity: 0;
animation: ps-toast-in 0.22s ease-out forwards;
}
.ps-toast-message {
flex: 1;
}
.ps-toast-close {
border: none;
background: transparent;
color: var(--ps-color-text-muted);
cursor: pointer;
padding: 0.1rem;
font-size: 1rem;
}
.ps-toast--success {
border-color: rgba(34, 197, 94, 0.7);
}
.ps-toast--error {
border-color: rgba(248, 113, 113, 0.8);
}
@keyframes ps-toast-in {
from {
opacity: 0;
transform: translateY(8px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
.ps-install-banner {
position: fixed;
inset-inline: 0.5rem;
bottom: 4rem;
z-index: 55;
display: flex;
justify-content: center;
opacity: 0;
transform: translateY(12px);
transition: opacity var(--ps-transition-normal), transform var(--ps-transition-normal);
}
.ps-install-banner-inner {
max-width: 420px;
width: 100%;
border-radius: var(--ps-radius-lg);
padding: 0.6rem 0.75rem;
background: radial-gradient(circle at top left, rgba(37, 99, 235, 0.3), rgba(15, 23, 42, 0.98));
border: 1px solid rgba(148, 163, 184, 0.65);
box-shadow: var(--ps-shadow-card);
display: flex;
flex-direction: column;
gap: 0.5rem;
font-size: 0.82rem;
}
.ps-install-banner.is-visible {
opacity: 1;
transform: translateY(0);
}
.ps-install-banner-actions {
display: flex;
flex-wrap: wrap;
gap: 0.4rem;
}
.ps-auth {
min-height: calc(100vh - var(--ps-header-height) - 80px);
display: flex;
align-items: center;
justify-content: center;
padding: 1.5rem;
}
.ps-auth-card {
max-width: 420px;
width: 100%;
background: rgba(12, 16, 28, 0.92);
border: 1px solid rgba(148, 163, 184, 0.25);
border-radius: 16px;
padding: 1.25rem;
box-shadow: var(--ps-shadow-card);
}
.ps-auth-title {
margin: 0 0 0.4rem;
font-size: 1.4rem;
}
.ps-auth-subtitle {
margin: 0 0 1rem;
font-size: 0.9rem;
color: var(--ps-color-text-muted);
}
.ps-auth-tabs {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 6px;
margin-bottom: 12px;
}
.ps-auth-tabs button {
padding: 0.45rem 0.35rem;
border-radius: 10px;
border: 1px solid rgba(148, 163, 184, 0.2);
background: rgba(255, 255, 255, 0.02);
color: var(--ps-color-text);
cursor: pointer;
font-weight: 600;
}
.ps-auth-tabs button.is-active {
border-color: var(--ps-color-primary);
background: rgba(13, 110, 253, 0.12);
box-shadow: 0 4px 16px rgba(13, 110, 253, 0.25);
}
.ps-auth-panels {
position: relative;
}
.ps-auth-panel {
display: none;
}
.ps-auth-panel.is-active {
display: block;
}
.ps-auth-placeholder {
padding: 1rem;
border: 1px dashed rgba(148, 163, 184, 0.4);
border-radius: 12px;
color: var(--ps-color-text-muted);
display: grid;
gap: 0.6rem;
text-align: center;
}
.ps-auth-footer {
margin-top: 0.75rem;
font-size: 0.8rem;
color: var(--ps-color-text-muted);
}
.ps-auth-footer a {
color: var(--ps-color-primary);
text-decoration: none;
}
.ps-auth-footer a:hover {
text-decoration: underline;
}
.ps-auth-alt {
display: grid;
gap: 8px;
margin-top: 12px;
}
.ps-alert {
border-radius: var(--ps-radius-sm);
padding: 0.4rem 0.55rem;
font-size: 0.8rem;
margin-bottom: 0.45rem;
}
.ps-alert--danger {
background: rgba(248, 113, 113, 0.12);
border: 1px solid rgba(248, 113, 113, 0.7);
color:
}
.ps-offline-icon {
font-size: 2.5rem;
margin-bottom: 0.75rem;
}
.ps-offline-actions {
margin-top: 1rem;
display: flex;
justify-content: center;
gap: 0.5rem;
flex-wrap: wrap;
}
.ps-animate-fade-up {
opacity: 0;
transform: translateY(8px);
animation: ps-fade-up 0.45s ease-out forwards;
}
.ps-animate-delay-1 {
animation-delay: 0.12s;
}
.ps-animate-stagger {
animation-delay: 0.04s;
}
.ps-animate-float {
animation: ps-float 6s ease-in-out infinite;
}
@keyframes ps-fade-up {
from {
opacity: 0;
transform: translateY(8px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
@keyframes ps-float {
0% {
transform: translateY(0);
}
50% {
transform: translateY(-6px);
}
100% {
transform: translateY(0);
}
}
.ps-form-row input,
.ps-form-row select,
.ps-form-row textarea {
border-radius: 8px;
padding: 0.75rem 1rem;
}

# File 132/163: static\css\cinematic-ui.css
################################################################################

:root {
--cinematic-glow: radial-gradient(circle at center,
rgba(100, 200, 255, 0.4) 0%,
transparent 70%);
--hologram-effect: linear-gradient(45deg,
transparent 30%,
rgba(255, 255, 255, 0.1) 50%,
transparent 70%);
--quantum-shadow: 0 0 40px rgba(100, 200, 255, 0.3),
0 0 80px rgba(100, 200, 255, 0.2),
0 0 120px rgba(100, 200, 255, 0.1);
--hologram-glow: rgba(0, 255, 255, 0.8);
}
@property --hologram-glow {
syntax: '<color>';
inherits: false;
initial-value: rgba(0, 255, 255, 0.8);
}
.cinematic-surface {
position: relative;
overflow: hidden;
background: linear-gradient(135deg, rgba(12, 19, 39, 0.9), rgba(6, 11, 25, 0.9));
border: 1px solid rgba(255, 255, 255, 0.04);
box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55), var(--quantum-shadow);
}
.cinematic-surface::before {
content: "";
position: absolute;
inset: -1px;
background: var(--cinematic-glow);
filter: blur(38px);
opacity: 0.55;
pointer-events: none;
}
.cinematic-surface::after {
content: "";
position: absolute;
inset: 0;
background: var(--hologram-effect);
opacity: 0.35;
mix-blend-mode: screen;
pointer-events: none;
}
.cinematic-button,
.quantum-toggle {
background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.35), rgba(14, 165, 233, 0.12));
box-shadow: 0 10px 30px rgba(14, 165, 233, 0.35), 0 20px 60px rgba(6, 182, 212, 0.25);
border: 1px solid rgba(255, 255, 255, 0.08);
color:
padding: 0.5rem 0.9rem;
border-radius: 999px;
display: inline-flex;
align-items: center;
gap: 0.4rem;
cursor: pointer;
position: relative;
overflow: hidden;
}
.cinematic-button::after,
.quantum-toggle::after {
content: "";
position: absolute;
inset: 0;
background: linear-gradient(120deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0));
opacity: 0;
transition: opacity 0.35s ease;
}
.cinematic-button:hover::after,
.quantum-toggle:hover::after {
opacity: 1;
}
.cinematic-marker {
animation: hologram-float 3s ease-in-out infinite;
filter: drop-shadow(0 0 20px var(--hologram-glow));
}
.quantum-pulse {
position: absolute;
inset: 0;
pointer-events: none;
border-radius: inherit;
background: radial-gradient(circle at 50% 45%, rgba(56, 189, 248, 0.15), transparent 60%);
animation: quantum-breathe 6s ease-in-out infinite;
}
.ai-forecast {
display: grid;
grid-template-columns: repeat(2, minmax(0, 1fr));
gap: 0.5rem;
margin-top: 0.35rem;
}
.ai-forecast-metric {
padding: 0.55rem 0.65rem;
border-radius: 0.75rem;
border: 1px solid rgba(59, 130, 246, 0.2);
background: rgba(15, 23, 42, 0.8);
box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
}
.ai-forecast-label {
font-size: 0.7rem;
color:
display: block;
margin-bottom: 0.15rem;
}
.ai-forecast-value {
font-weight: 700;
font-size: 0.95rem;
letter-spacing: 0.01em;
}
.ai-reasoning {
margin-top: 0.5rem;
padding: 0.55rem 0.6rem;
border-radius: 0.75rem;
border: 1px dashed rgba(255, 255, 255, 0.16);
color:
background: rgba(79, 70, 229, 0.08);
}
@keyframes hologram-float {
0% { transform: translateY(0); }
50% { transform: translateY(-4px); }
100% { transform: translateY(0); }
}
@keyframes quantum-breathe {
0% { opacity: 0.2; }
50% { opacity: 0.55; }
100% { opacity: 0.2; }
}
[data-quantum-theme="dark"] body,
body[data-quantum-theme="dark"] {
background: radial-gradient(circle at top left,
}
[data-quantum-theme="light"] body,
body[data-quantum-theme="light"] {
background: radial-gradient(circle at top left,
color:
}
.ai-crest {
display: inline-flex;
align-items: center;
gap: 0.35rem;
padding: 0.35rem 0.8rem;
border-radius: 999px;
border: 1px solid rgba(255, 255, 255, 0.14);
background: linear-gradient(135deg, rgba(59, 130, 246, 0.18), rgba(16, 185, 129, 0.16));
box-shadow: 0 18px 45px rgba(15, 23, 42, 0.5);
}

# File 133/163: static\js\app.js
################################################################################

(function () {
"use strict";
window.ParkShare = window.ParkShare || {};
function qs(selector, scope) {
return (scope || document).querySelector(selector);
}
function qsa(selector, scope) {
return Array.prototype.slice.call((scope || document).querySelectorAll(selector));
}
function isMobileWidth() {
return window.matchMedia("(max-width: 767px)").matches;
}
if ("serviceWorker" in navigator) {
window.addEventListener("load", function () {
navigator.serviceWorker
.register("/service-worker.js")
.then(function (reg) {
console.log("[SW] registered", reg.scope);
})
.catch(function (err) {
console.warn("[SW] registration failed", err);
});
});
}
function initMenu() {
const toggle = qs("[data-menu-toggle]");
const menu = qs("[data-menu]");
if (!toggle || !menu) return;
function syncAria(isOpen) {
toggle.setAttribute("aria-expanded", String(isOpen));
toggle.setAttribute("aria-label", isOpen ? "Закрыть меню" : "Открыть меню");
}
toggle.addEventListener("click", function () {
const isOpen = toggle.classList.toggle("is-open");
menu.classList.toggle("is-open", isOpen);
document.body.classList.toggle("ps-menu-open", isOpen);
syncAria(isOpen);
});
syncAria(toggle.classList.contains("is-open"));
qsa(".ps-nav-link", menu).forEach(function (link) {
link.addEventListener("click", function () {
toggle.classList.remove("is-open");
menu.classList.remove("is-open");
document.body.classList.remove("ps-menu-open");
syncAria(false);
});
});
}
function initSmoothScroll() {
qsa("[data-scroll-to]").forEach(function (el) {
el.addEventListener("click", function (e) {
const href = el.getAttribute("href");
if (!href || !href.startsWith("
const target = qs(href);
if (!target) return;
e.preventDefault();
window.scrollTo({
top: target.getBoundingClientRect().top + window.scrollY - 72,
behavior: "smooth"
});
});
});
}
function initBackToTop() {
const btn = qs("[data-back-to-top]");
if (!btn) return;
function onScroll() {
if (window.scrollY > 300) {
btn.classList.add("is-visible");
} else {
btn.classList.remove("is-visible");
}
}
window.addEventListener("scroll", onScroll, {passive: true});
onScroll();
btn.addEventListener("click", function () {
window.scrollTo({top: 0, behavior: "smooth"});
});
}
function showToast(message, type) {
type = type || "info";
const container = qs(".ps-toast-container");
if (!container) return;
const toast = document.createElement("div");
toast.className = "ps-toast ps-toast--" + type;
const msg = document.createElement("div");
msg.className = "ps-toast-message";
msg.textContent = message;
const close = document.createElement("button");
close.className = "ps-toast-close";
close.type = "button";
close.innerHTML = "×";
close.addEventListener("click", function () {
toast.remove();
});
toast.appendChild(msg);
toast.appendChild(close);
container.appendChild(toast);
setTimeout(function () {
toast.remove();
}, 4000);
}
let deferredPrompt = null;
const INSTALL_DISMISS_KEY = "pwaPromptDismissedUntil";
const INSTALL_DISMISS_DAYS = 30;
function isStandalone() {
return window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
}
function isMobileDevice() {
const ua = navigator.userAgent || "";
const isIOS = /iPhone|iPad|iPod/i.test(ua);
const isAndroid = /Android/i.test(ua);
const isCoarse = window.matchMedia && window.matchMedia("(pointer:coarse)").matches;
return isIOS || isAndroid || isCoarse;
}
function dismissedUntil() {
try {
const value = localStorage.getItem(INSTALL_DISMISS_KEY);
return value ? parseInt(value, 10) : 0;
} catch (_) {
return 0;
}
}
function markDismiss(days) {
try {
const until = Date.now() + days * 24 * 60 * 60 * 1000;
localStorage.setItem(INSTALL_DISMISS_KEY, String(until));
} catch (_) {}
}
function canShowBanner() {
if (!isMobileDevice() || isStandalone()) return false;
const until = dismissedUntil();
if (until && until > Date.now()) return false;
return true;
}
function initInstallBanner() {
const banner = qs("[data-install-banner]");
const btnAccept = qs("[data-install-accept]", banner);
const btnDismiss = qs("[data-install-dismiss]", banner);
const menuButton = qs("[data-nav-install-app]");
const fallbackUrl = (menuButton && menuButton.getAttribute("data-install-href")) || "/pwa-install/";
if (!banner || !btnAccept || !btnDismiss) return;
function hideBanner() {
banner.classList.remove("is-visible");
setTimeout(function () { banner.hidden = true; }, 200);
}
function showBanner() {
if (!canShowBanner()) return;
banner.hidden = false;
requestAnimationFrame(function () { banner.classList.add("is-visible"); });
}
function triggerInstall(source) {
if (deferredPrompt) {
deferredPrompt.prompt();
deferredPrompt.userChoice
.then(function (choiceResult) {
if (choiceResult.outcome === "accepted") {
showToast("Установка ParkShare RU запущена", "success");
markDismiss(365);
}
})
.finally(function () {
deferredPrompt = null;
hideBanner();
});
} else {
if (fallbackUrl) {
window.location.href = fallbackUrl;
} else {
showToast("Откройте меню браузера и выберите «Добавить на экран»", "info");
}
hideBanner();
}
}
if (menuButton) {
if (!isMobileDevice() || isStandalone()) {
menuButton.style.display = "none";
}
menuButton.addEventListener("click", function () { triggerInstall("menu"); });
}
window.addEventListener("beforeinstallprompt", function (e) {
e.preventDefault();
deferredPrompt = e;
if (canShowBanner()) {
showBanner();
}
});
btnDismiss.addEventListener("click", function () {
markDismiss(INSTALL_DISMISS_DAYS);
hideBanner();
deferredPrompt = null;
});
btnAccept.addEventListener("click", function () { triggerInstall("banner"); });
window.addEventListener("appinstalled", function () {
markDismiss(365);
hideBanner();
});
if (canShowBanner()) {
showBanner();
}
}
function initSkeletons() {
const cards = qsa(".ps-card--skeleton");
if (!cards.length) return;
window.setTimeout(function () {
cards.forEach(function (card) {
card.parentNode && card.parentNode.removeChild(card);
});
}, 350);
}
function initSpotsSheet() {
const panel = qs("[data-spots-panel]");
if (!panel) return;
const triggers = qsa("[data-open-spots]");
function setState(open) {
panel.classList.toggle("is-sheet-open", open);
if (open) {
panel.scrollIntoView({ behavior: "smooth" });
}
}
triggers.forEach(function (btn) {
btn.addEventListener("click", function () {
const next = !panel.classList.contains("is-sheet-open");
setState(next);
});
});
window.addEventListener("resize", function () {
if (!isMobileWidth()) {
panel.classList.remove("is-sheet-open");
}
});
}
function initAdaptiveProbe() {
const payload = {
width: window.innerWidth,
height: window.innerHeight,
pixelRatio: window.devicePixelRatio || 1,
platform: document.documentElement.getAttribute("data-platform") || "RU",
};
fetch("/api/ai/parkmate/config/", {
method: "POST",
credentials: "include",
headers: {
"Content-Type": "application/json",
},
body: JSON.stringify({
client: payload,
action: "adaptive-profile",
}),
keepalive: true,
}).catch(function () {
});
}
function initGeolocation() {
const buttons = qsa("[data-fill-location]");
if (!buttons.length) return;
function fill(lat, lng) {
const latInput = qs("
const lngInput = qs("
if (!latInput || !lngInput) return;
latInput.value = lat.toFixed(5);
lngInput.value = lng.toFixed(5);
showToast("Координаты определены, нажмите «Найти места»", "success");
}
buttons.forEach(function (btn) {
btn.addEventListener("click", function () {
if (!("geolocation" in navigator)) {
showToast("Геолокация недоступна в этом браузере", "error");
return;
}
navigator.geolocation.getCurrentPosition(
function (pos) {
fill(pos.coords.latitude, pos.coords.longitude);
},
function () {
showToast("Не удалось получить местоположение", "error");
},
{
enableHighAccuracy: false,
timeout: 8000,
maximumAge: 60000
}
);
});
});
}
const PAYMENT_METHODS_ENDPOINT = "/api/payments/methods/";
function getCSRFToken() {
const match = document.cookie.match(/csrftoken=([^;]+)/);
return match ? match[1] : "";
}
function detectBrand(num) {
if (!num) return "other";
if (/^4/.test(num)) return "visa";
if (/^5[1-5]/.test(num)) return "mc";
if (/^220[0-4]/.test(num)) return "mir";
if (/^62/.test(num)) return "up";
return "other";
}
function renderPaymentMethods(methods, container) {
if (!container) return;
if (!methods || !methods.length) {
container.innerHTML = "<div class='ps-empty'>Карты пока не добавлены.</div>";
return;
}
container.innerHTML = methods
.map(function (method) {
const brand = method.brand ? method.brand.toUpperCase() : "CARD";
const defaultBadge = method.is_default ? "<span class='ps-badge ps-badge--success'>По умолчанию</span>" : "";
return (
"<div class='ps-payment-card'>" +
"<div>" +
"<div class='ps-payment-brand'>" + brand + " · " + (method.mask || ("**** " + method.last4)) + " " + defaultBadge + "</div>" +
"<div class='ps-payment-meta'>Срок: " + method.exp_month + "/" + method.exp_year + (method.label ? " · " + method.label : "") + "</div>" +
"</div>" +
"<div class='ps-payment-actions'>" +
"<button class='ps-btn ps-btn-ghost ps-btn-sm' data-payment-default='" + method.id + "'>Сделать осн.</button>" +
"<button class='ps-btn ps-btn-ghost ps-btn-sm' data-payment-delete='" + method.id + "'>Удалить</button>" +
"</div>" +
"</div>"
);
})
.join("");
}
function initPaymentMethods() {
const container = qs("[data-payment-methods]");
const form = qs("[data-payment-method-form]");
if (!container && !form) return;
function loadMethods() {
fetch(PAYMENT_METHODS_ENDPOINT, { credentials: "include" })
.then(function (resp) { return resp.json(); })
.then(function (data) { renderPaymentMethods(data.results || data, container); })
.catch(function () { showToast("Не удалось загрузить способы оплаты", "error"); });
}
if (form) {
form.addEventListener("submit", function (evt) {
evt.preventDefault();
const fd = new FormData(form);
const cardNumber = (fd.get("card_number") || "").replace(/\D/g, "");
const exp = (fd.get("exp") || "").split("/");
const expMonth = parseInt(exp[0], 10) || 1;
const expYear = parseInt((exp[1] || "").replace(/[^0-9]/g, ""), 10) || 30;
const payload = {
label: fd.get("label") || fd.get("provider") || "Моя карта",
brand: detectBrand(cardNumber),
last4: cardNumber.slice(-4) || "0000",
exp_month: expMonth,
exp_year: expYear,
is_default: fd.get("is_default") === "on",
token_masked: "tok_" + (cardNumber.slice(-6) || "card") + Date.now(),
};
fetch(PAYMENT_METHODS_ENDPOINT, {
method: "POST",
credentials: "include",
headers: {
"Content-Type": "application/json",
"X-CSRFToken": getCSRFToken(),
},
body: JSON.stringify(payload),
})
.then(function (resp) { return resp.json(); })
.then(function () {
showToast("Карта сохранена", "success");
form.reset();
loadMethods();
})
.catch(function () { showToast("Не удалось сохранить карту", "error"); });
});
}
if (container) {
container.addEventListener("click", function (evt) {
const defBtn = evt.target.closest("[data-payment-default]");
const delBtn = evt.target.closest("[data-payment-delete]");
if (defBtn) {
const id = defBtn.getAttribute("data-payment-default");
fetch(PAYMENT_METHODS_ENDPOINT + id + "/", {
method: "PATCH",
credentials: "include",
headers: {
"Content-Type": "application/json",
"X-CSRFToken": getCSRFToken(),
},
body: JSON.stringify({ is_default: true }),
})
.then(function (resp) { return resp.json(); })
.then(function () { showToast("Карта выбрана по умолчанию", "success"); loadMethods(); })
.catch(function () { showToast("Не удалось обновить карту", "error"); });
}
if (delBtn) {
const id = delBtn.getAttribute("data-payment-delete");
fetch(PAYMENT_METHODS_ENDPOINT + id + "/", {
method: "DELETE",
credentials: "include",
headers: { "X-CSRFToken": getCSRFToken() },
})
.then(function (resp) { if (!resp.ok) throw new Error(); })
.then(function () { showToast("Карта удалена", "info"); loadMethods(); })
.catch(function () { showToast("Не удалось удалить карту", "error"); });
}
});
}
loadMethods();
}
var ChatWidget = (function () {
let root, toggle, panel, overlay, input, sendBtn, body, statusEl, closeBtn;
let isOpen = false;
let isLoading = false;
let messages = [];
function setStatus(text, visible) {
if (!statusEl) return;
statusEl.textContent = text || "";
statusEl.hidden = !visible;
}
function isSheetMode() {
return isMobileWidth();
}
function applyLayout() {
if (!root) return;
root.classList.toggle("is-sheet", isSheetMode());
}
function persistState(openState) {
try {
localStorage.setItem("psChatState", openState ? "open" : "closed");
} catch (e) {}
}
function syncState(nextOpen) {
isOpen = !!nextOpen;
if (!root) return;
root.classList.toggle("is-open", isOpen);
root.classList.toggle("is-sheet-open", isOpen && isSheetMode());
if (panel) {
panel.setAttribute("aria-hidden", String(!isOpen));
}
if (toggle) {
toggle.setAttribute("aria-expanded", String(isOpen));
}
document.body.classList.toggle("ps-chat-open", isOpen && !isSheetMode());
if (window.ParkShare && typeof window.ParkShare.setBottomNavActive === "function") {
window.ParkShare.setBottomNavActive(isOpen ? "chat" : null);
}
}
function openPanel() {
syncState(true);
applyLayout();
if (input) {
input.focus({ preventScroll: isSheetMode() });
}
persistState(true);
}
function closePanel() {
syncState(false);
persistState(false);
}
function togglePanel() {
if (isOpen) {
closePanel();
} else {
openPanel();
}
}
function sendFeedback(messageId, rating, container) {
fetch("/api/ai/chat/feedback/", {
method: "POST",
credentials: "include",
headers: {"Content-Type": "application/json"},
body: JSON.stringify({message_id: messageId, rating: rating}),
}).catch(function () {
console.debug("Feedback failed");
});
if (!container) return;
qsa("button", container).forEach(function (btn) {
btn.classList.toggle("is-active", btn.getAttribute("data-rating") == String(rating));
});
}
function renderSuggestions(suggestions, messageId) {
if (!suggestions || !suggestions.length) return null;
const list = document.createElement("div");
list.className = "ps-chat-spots";
suggestions.forEach(function (spot) {
const card = document.createElement("div");
card.className = "ps-chat-spot-card";
const badges = [];
if (spot.tags && spot.tags.length) {
badges.push(spot.tags.join(" · "));
}
if (spot.allow_dynamic_pricing) badges.push("AI-тариф");
if (spot.ev || spot.has_ev_charging) badges.push("EV");
if (spot.is_covered) badges.push("Крытая");
if (spot.is_24_7) badges.push("24/7");
const metaParts = [
spot.price ? spot.price + " ₽/час" : null,
spot.distance_m ? "~" + Math.round(spot.distance_m) + " м" : null,
spot.occupancy_now != null ? "Свободно: " + Math.round((1 - spot.occupancy_now) * 100) + "%" : null,
].filter(Boolean);
const title = spot.title || spot.name || "Парковка";
card.innerHTML =
"<div class='ps-chat-spot-title'>" + title + "</div>" +
"<div class='ps-chat-spot-meta'>" + metaParts.join(" · ") + (badges.length ? " · " + badges.join(" · ") : "") + "</div>" +
"<div class='ps-chat-spot-actions'>" +
"<button type='button' class='ps-btn ps-btn-ghost ps-btn-sm' data-spot-map>Показать на карте</button>" +
"</div>";
const mapBtn = card.querySelector("[data-spot-map]");
mapBtn.addEventListener("click", function () {
const event = new CustomEvent("ps:focus-spot", {detail: {spotId: spot.spot_id || spot.id}});
window.dispatchEvent(event);
if (isSheetMode()) closePanel();
});
list.appendChild(card);
});
if (messageId) {
const feedback = document.createElement("div");
feedback.className = "ps-chat-feedback";
feedback.innerHTML =
"<span>Подсказка помогла?</span>" +
"<div class='ps-chat-feedback-actions'>" +
"<button type='button' data-rating='1' aria-label='Полезно'>👍</button>" +
"<button type='button' data-rating='-1' aria-label='Не полезно'>👎</button>" +
"</div>";
feedback.querySelectorAll("button").forEach(function (btn) {
btn.addEventListener("click", function () {
sendFeedback(messageId, parseInt(btn.getAttribute("data-rating"), 10), feedback);
});
});
list.appendChild(feedback);
}
return list;
}
function appendBubble(message) {
if (!body) return;
const item = document.createElement("div");
item.className = "ps-chat-bubble ps-chat-bubble--" + (message.role === "assistant" ? "bot" : "user");
const text = document.createElement("div");
text.className = "ps-chat-text";
text.textContent = message.text;
item.appendChild(text);
if (message.reason) {
const meta = document.createElement("div");
meta.className = "ps-chat-meta";
meta.textContent = "Почему так: " + message.reason;
item.appendChild(meta);
}
const suggestions = renderSuggestions(message.suggestions, message.id);
if (suggestions) item.appendChild(suggestions);
body.appendChild(item);
body.scrollTop = body.scrollHeight;
}
function sendMessage() {
const text = (input.value || "").trim();
if (!text || isLoading) return;
const userMsg = {role: "user", text: text};
messages.push(userMsg);
appendBubble(userMsg);
input.value = "";
isLoading = true;
setStatus("Ассистент печатает…", true);
sendBtn.disabled = true;
const history = messages.slice(-6).map(function (msg) {
return {role: msg.role === "assistant" ? "assistant" : "user", text: msg.text};
});
fetch("/api/ai/chat/parking/", {
method: "POST",
credentials: "include",
headers: {"Content-Type": "application/json"},
body: JSON.stringify({message: text, history: history}),
})
.then(function (resp) { return resp.json(); })
.then(function (data) {
const botMsg = {
role: "assistant",
text: data.reply || data.answer || "Готов помочь с поиском парковки.",
suggestions: data.suggestions || data.spots || [],
reason: data.reason,
id: data.message_id,
};
messages.push(botMsg);
appendBubble(botMsg);
})
.catch(function () {
const fallback = {role: "assistant", text: "Не удалось обратиться к ассистенту."};
messages.push(fallback);
appendBubble(fallback);
})
.finally(function () {
isLoading = false;
sendBtn.disabled = false;
setStatus("", false);
});
}
function init() {
root = qs("[data-chat]");
if (!root) return;
toggle = qs("[data-chat-toggle]", root);
panel = qs("[data-chat-panel]", root);
overlay = qs("[data-chat-overlay]", root);
input = qs("[data-chat-input]", root);
sendBtn = qs("[data-chat-send]", root);
body = qs("[data-chat-body]", root);
statusEl = qs("[data-chat-status]", root);
closeBtn = qs("[data-chat-close]", root);
const openLinks = qsa("[data-chat-open-link]");
applyLayout();
const savedState = (function () {
try { return localStorage.getItem("psChatState"); } catch (e) { return null; }
})();
syncState(savedState === "open");
const welcome = {
role: "assistant",
text: "Привет! Напишите адрес, метро или время — подскажу свободные места и тарифы.",
};
messages.push(welcome);
appendBubble(welcome);
if (toggle) toggle.addEventListener("click", togglePanel);
if (closeBtn) closeBtn.addEventListener("click", closePanel);
if (overlay) overlay.addEventListener("click", closePanel);
openLinks.forEach(function (link) {
link.addEventListener("click", function (e) {
e.preventDefault();
openPanel();
if (isSheetMode() && panel) {
panel.scrollTo({ top: panel.scrollHeight });
}
});
});
if (sendBtn) sendBtn.addEventListener("click", sendMessage);
if (input) {
input.addEventListener("keydown", function (e) {
if (e.key === "Enter" && !e.shiftKey) {
e.preventDefault();
sendMessage();
}
});
}
document.addEventListener("keydown", function (e) {
if (e.key === "Escape" && !isSheetMode() && isOpen) {
closePanel();
}
});
window.addEventListener("resize", function () {
applyLayout();
if (!isSheetMode() && isOpen) {
document.body.classList.add("ps-chat-open");
}
});
}
return {
init: init,
open: openPanel,
close: closePanel,
toggle: togglePanel,
};
})();
window.ParkShare = window.ParkShare || {};
window.ParkShare.ChatWidget = ChatWidget;
function initBottomNav() {
const nav = qs("[data-bottom-nav]");
if (!nav) return;
const items = qsa("[data-nav]", nav);
const defaultKey = (function () {
const path = window.location.pathname;
if (path.indexOf("/accounts") === 0) return "profile";
if (path.indexOf("/parking/user") === 0) return "bookings";
return "map";
})();
function setActive(key) {
const target = key || defaultKey;
items.forEach(function (item) {
const current = item.getAttribute("data-nav");
item.classList.toggle("is-active", current === target);
});
}
items.forEach(function (item) {
item.addEventListener("click", function () {
const key = item.getAttribute("data-nav");
if (key === "chat") {
setActive("chat");
if (window.ParkShare && window.ParkShare.ChatWidget) {
window.ParkShare.ChatWidget.open();
}
return;
}
if (key) setActive(key);
});
});
setActive(defaultKey);
window.ParkShare = window.ParkShare || {};
window.ParkShare.setBottomNavActive = setActive;
}
document.addEventListener("DOMContentLoaded", function () {
initMenu();
initSmoothScroll();
initBackToTop();
initInstallBanner();
initSkeletons();
initSpotsSheet();
initAdaptiveProbe();
initGeolocation();
initPaymentMethods();
ChatWidget.init();
initBottomNav();
});
window.ParkShare = window.ParkShare || {};
window.ParkShare.showToast = showToast;
})();

# File 134/163: static\js\map.js
################################################################################

(function () {
"use strict";
function qs(sel, ctx) { return (ctx || document).querySelector(sel); }
function qsa(sel, ctx) { return Array.prototype.slice.call((ctx || document).querySelectorAll(sel)); }
var MAP_CONFIG = window.PARKSHARE_MAP_PROVIDER || {};
var priceRange = [0, 1500];
var MAP_THEME_KEY = "ps-map-theme";
var storedTheme = null;
try { storedTheme = localStorage.getItem(MAP_THEME_KEY); } catch (_) {}
var prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
var isNight = (storedTheme || (prefersDark ? "dark" : "light")) === "dark";
var lastFeatures = [];
var userLocation = null;
function distanceKm(a, b) {
if (!a || !b) return 0;
var rad = Math.PI / 180;
var lat1 = a[0] * rad, lat2 = b[0] * rad, lon1 = a[1] * rad, lon2 = b[1] * rad;
var dlat = lat2 - lat1, dlon = lon2 - lon1;
var h = Math.sin(dlat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) ** 2;
return 6371 * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
}
function applyMapTheme(theme, provider, container) {
var mode = theme === "dark" ? "dark" : "light";
var mapEl = container || qs("
if (mapEl) {
mapEl.classList.toggle("ps-map--dark", mode === "dark");
mapEl.classList.toggle("ps-map--light", mode === "light");
}
document.body.classList.toggle("theme-dark", mode === "dark");
document.body.classList.toggle("ps-day-mode", mode === "light");
var btn = qs("[data-map-theme]");
if (btn) {
var isDark = mode === "dark";
btn.textContent = isDark ? "☀️" : "🌙";
btn.setAttribute("aria-pressed", String(isDark));
btn.classList.toggle("is-active", isDark);
btn.classList.add("is-animating");
btn.addEventListener("animationend", function handler() {
btn.classList.remove("is-animating");
btn.removeEventListener("animationend", handler);
});
}
try { localStorage.setItem(MAP_THEME_KEY, mode); } catch (_) {}
isNight = mode === "dark";
if (provider && provider.toggleTheme) provider.toggleTheme(isNight ? "night" : "day");
}
function BaseMapProvider(options) { this.options = options || {}; }
BaseMapProvider.prototype.init = function () {};
BaseMapProvider.prototype.setFeatures = function () {};
BaseMapProvider.prototype.setLoading = function () {};
BaseMapProvider.prototype.drawRouteTo = function () {};
BaseMapProvider.prototype.focusOn = function () {};
BaseMapProvider.prototype.onInteraction = function () {};
BaseMapProvider.prototype.toggleTheme = function () {};
BaseMapProvider.prototype.showUserLocation = function () {};
BaseMapProvider.prototype.setView = function () {};
function LeafletMapProvider(options) {
BaseMapProvider.call(this, options);
this._map = null;
this._markersLayer = null;
this._tileLayers = {};
this._currentTile = "day";
this._activeRoute = null;
this._highlight = null;
}
LeafletMapProvider.prototype = Object.create(BaseMapProvider.prototype);
LeafletMapProvider.prototype.init = function (container, center, zoom) {
if (typeof L === "undefined") return;
this._map = L.map(container, { center: center, zoom: zoom, scrollWheelZoom: false });
this._tileLayers.day = this._createBaseLayer("light");
this._tileLayers.night = this._createBaseLayer("dark");
this._tileLayers.day.addTo(this._map);
this._markersLayer = L.markerClusterGroup({ chunkedLoading: true, spiderfyOnMaxZoom: true }).addTo(this._map);
};
LeafletMapProvider.prototype._createBaseLayer = function (mode) {
var url = mode === "dark"
? "https:
: "https:
return L.tileLayer(url, { maxZoom: 20 });
};
LeafletMapProvider.prototype.setFeatures = function (fc) {
if (!this._map || !this._markersLayer) return;
var layer = this._markersLayer;
layer.clearLayers();
var bounds = [];
(fc.features || []).forEach(function (feature) {
var coords = feature.geometry && feature.geometry.coordinates;
if (!coords) return;
var lng = coords[0], lat = coords[1];
var p = feature.properties || {};
var stress = p.stress_index || 0;
var color = stress >= 0.8 ? "
var marker = L.circleMarker([lat, lng], { radius: 12, weight: 2, color: color, fillColor: color, fillOpacity: 0.92 });
marker.bindPopup(buildPopupHtml(p, color), { className: "ps-map-popup-card" });
marker.addTo(layer);
bounds.push([lat, lng]);
});
lastFeatures = fc.features || [];
if (bounds.length) this._map.fitBounds(bounds, { padding: [72, 72] });
};
LeafletMapProvider.prototype.toggleTheme = function (mode) {
if (!this._map) return;
var next = mode === "night" ? "night" : mode === "day" ? "day" : (this._currentTile === "day" ? "night" : "day");
this._map.removeLayer(this._tileLayers[this._currentTile]);
this._tileLayers[next].addTo(this._map);
this._currentTile = next;
};
LeafletMapProvider.prototype.setLoading = function (isLoading) {
var el = qs("[data-map-loading]");
if (el) el.style.display = isLoading ? "flex" : "none";
};
LeafletMapProvider.prototype.drawRouteTo = function (target, fromCoords, onHint) {
if (!this._map || !target) return;
if (this._activeRoute) this._activeRoute.remove();
var origin = fromCoords ? L.latLng(fromCoords.lat, fromCoords.lng) : this._map.getCenter();
var dest = target.lat != null ? L.latLng(target.lat, target.lng) : L.latLng(target[0], target[1]);
this._activeRoute = L.polyline([origin, dest], { color: "
var km = distanceKm([origin.lat, origin.lng], [dest.lat, dest.lng]);
if (onHint) onHint(km);
this._map.fitBounds(this._activeRoute.getBounds(), { padding: [56, 56] });
};
LeafletMapProvider.prototype.focusOn = function (lat, lng) {
if (!this._map) return;
if (this._highlight) this._highlight.remove();
this._highlight = L.circleMarker([lat, lng], { color: "
this._map.setView([lat, lng], 15);
};
LeafletMapProvider.prototype.onInteraction = function (start, end) {
if (!this._map) return;
if (start) this._map.on("movestart zoomstart dragstart", start);
if (end) this._map.on("moveend zoomend dragend", end);
};
LeafletMapProvider.prototype.showUserLocation = function (lat, lng) {
if (!this._map) return;
var radius = L.circle([lat, lng], { radius: 450, color: "
radius.bringToBack();
};
LeafletMapProvider.prototype.setView = function (lat, lng, zoom) {
if (!this._map) return;
this._map.setView([lat, lng], zoom || this._map.getZoom());
};
function YandexMapProvider(options) {
BaseMapProvider.call(this, options);
this._map = null;
this._clusterer = null;
this._activeRoute = null;
this._highlight = null;
this._ready = false;
this._theme = options.theme || "day";
this._mapTypesReady = false;
this._heatLayer = null;
}
YandexMapProvider.prototype = Object.create(BaseMapProvider.prototype);
YandexMapProvider.prototype._ensureMapTypes = function () {
if (this._mapTypesReady || typeof ymaps === "undefined") return;
var lightLayer = function () {
return new ymaps.Layer("https:
};
var darkLayer = function () {
return new ymaps.Layer("https:
};
ymaps.mapType.storage.add("ps
ymaps.mapType.storage.add("ps
this._mapTypesReady = true;
};
YandexMapProvider.prototype._ensureLayouts = function () {
if (this._markerLayout && this._clusterIconLayout && this._clusterBalloonLayout) return;
var markerTpl = [
"<div class='ps-map-marker {{properties.markerActive}} {{properties.markerHot ? \"ps-map-marker--hot\" : ''}}'>",
"  <div class='ps-map-marker__halo'></div>",
"  <div class='ps-map-marker__body' style='background: {{properties.markerColor}}'>",
"    <span class='ps-map-marker__value'>{{properties.markerLabel}}</span>",
"  </div>",
"</div>"
].join("");
this._markerLayout = ymaps.templateLayoutFactory.createClass(markerTpl, {
getShape: function () { return new ymaps.shape.Circle(new ymaps.geometry.pixel.Point([28, 28]), 26); },
});
var clusterTpl = "<div class='ps-map-cluster'><div class='ps-map-cluster__count'>{{properties.geoObjects.length}}</div></div>";
this._clusterIconLayout = ymaps.templateLayoutFactory.createClass(clusterTpl, {
build: function () {
this.constructor.superclass.build.call(this);
var node = this.getParentElement() && this.getParentElement().firstChild;
if (!node) return;
var geoObjects = (this.getData().properties.get("geoObjects") || []).map(function (g) { return g.properties.getAll(); });
var avg = geoObjects.reduce(function (acc, p) { return acc + (p.stress_index || 0); }, 0) / (geoObjects.length || 1);
node.classList.add(avg >= 0.75 ? "ps-map-cluster--danger" : avg >= 0.45 ? "ps-map-cluster--warn" : "ps-map-cluster--ok");
}
});
this._clusterBalloonLayout = ymaps.templateLayoutFactory.createClass("<div class='ps-map-popup ps-map-popup--list'></div>", {
build: function () {
this.constructor.superclass.build.call(this);
var container = this.getParentElement() && this.getParentElement().querySelector(".ps-map-popup--list");
if (!container) return;
var items = this.getData().properties.get("geoObjects") || [];
container.innerHTML = items.map(function (g) { return g.properties.get("balloonContent") || ""; }).join("");
}
});
};
YandexMapProvider.prototype.init = function (container, center, zoom) {
var self = this;
if (typeof ymaps === "undefined") return;
this._container = container;
ymaps.ready(function () {
self._ensureMapTypes();
self._map = new ymaps.Map(container, { center: center, zoom: zoom, type: isNight ? "ps
self._map.behaviors.disable("scrollZoom");
self._ensureLayouts();
self._clusterer = new ymaps.Clusterer({
clusterIconLayout: self._clusterIconLayout,
clusterIconOffset: [-28, -28],
clusterIconShape: { type: "Circle", coordinates: [28, 28], radius: 28 },
clusterNumbers: [50],
groupByCoordinates: false,
clusterDisableClickZoom: true,
clusterBalloonContentLayout: self._clusterBalloonLayout,
clusterBalloonPanelMaxMapArea: 0,
});
self._map.geoObjects.add(self._clusterer);
self._ready = true;
if (self._pending) { self.setFeatures(self._pending); self._pending = null; }
});
};
YandexMapProvider.prototype._renderHeat = function (features) {
if (!this._map) return;
if (this._heatLayer) { this._map.geoObjects.remove(this._heatLayer); }
var collection = new ymaps.GeoObjectCollection({}, { opacity: 0.35, fillOpacity: 0.18, strokeWidth: 0 });
features.slice(0, 40).forEach(function (f) {
var coords = f.geometry && f.geometry.coordinates; if (!coords) return;
var stress = f.properties && (f.properties.stress_index || 0);
if (!stress) return;
var radius = 250 + stress * 1200;
var color = stress > 0.75 ? "rgba(239,68,68,0.4)" : stress > 0.5 ? "rgba(245,158,11,0.4)" : "rgba(14,165,233,0.35)";
collection.add(new ymaps.Circle([[coords[1], coords[0]], radius], {}, { fillColor: color }));
});
this._heatLayer = collection;
this._map.geoObjects.add(collection);
};
YandexMapProvider.prototype.setFeatures = function (fc) {
if (typeof ymaps === "undefined") return;
if (!this._map || !this._ready) { this._pending = fc; return; }
this._ensureLayouts();
this._clusterer.removeAll();
var bounds = [];
var features = fc.features || [];
var prices = features.map(function (f) { return f.properties && f.properties.hourly_price; }).filter(function (v) { return typeof v === "number"; });
var avgPrice = prices.length ? prices.reduce(function (a, b) { return a + b; }, 0) / prices.length : null;
var self = this;
features.forEach(function (feature) {
var coords = feature.geometry && feature.geometry.coordinates; if (!coords) return;
var lng = coords[0], lat = coords[1];
var p = feature.properties || {};
var stress = p.stress_index || 0;
var allowAi = !!p.allow_dynamic_pricing;
var color = allowAi ? "
if (stress > 0.7) color = "
var isHot = avgPrice && p.hourly_price && p.hourly_price < avgPrice * 0.75;
var label = p.free_places != null ? p.free_places + " св." : (p.hourly_price ? p.hourly_price + " ₽" : "?" );
var popupHtml = buildPopupHtml(p, color);
var placemark = new ymaps.Placemark([lat, lng], {
hintContent: (p.lot_name || "") + (p.name ? " — " + p.name : ""),
balloonContent: popupHtml,
markerColor: color,
markerLabel: label,
markerHot: isHot,
stress_index: stress,
}, {
iconLayout: self._markerLayout,
iconOffset: [-26, -26],
hideIconOnBalloonOpen: false,
balloonPanelMaxMapArea: 0,
});
placemark.events.add("balloonopen", function () { self._setActive(placemark); self._map.panTo([lat, lng], { flying: true, duration: 400 }); });
placemark.events.add("balloonclose", function () { self._setActive(null); });
self._clusterer.add(placemark);
bounds.push([lat, lng]);
});
if (bounds.length) this._map.setBounds(bounds, { checkZoomRange: true, zoomMargin: 48 });
this._renderHeat(features);
};
YandexMapProvider.prototype._setActive = function (placemark) {
if (this._activePlacemark && this._activePlacemark !== placemark) {
this._activePlacemark.properties.set("markerActive", "");
this._activePlacemark.options.unset("zIndex");
}
this._activePlacemark = placemark;
if (placemark) { placemark.properties.set("markerActive", "ps-map-marker--active"); placemark.options.set("zIndex", 2200); }
};
YandexMapProvider.prototype.toggleTheme = function (mode) {
this._theme = mode || this._theme;
if (!this._map || !this._ready) return;
this._ensureMapTypes();
this._map.setType(this._theme === "night" ? "ps
};
YandexMapProvider.prototype.setLoading = LeafletMapProvider.prototype.setLoading;
YandexMapProvider.prototype.drawRouteTo = function (target, fromCoords, onHint) {
if (!this._map || !target) return;
if (this._activeRoute) this._map.geoObjects.remove(this._activeRoute);
var origin = fromCoords ? [fromCoords.lat, fromCoords.lng] : this._map.getCenter();
var dest = target.lat != null ? [target.lat, target.lng] : target;
this._activeRoute = new ymaps.Polyline([origin, dest], {}, { strokeColor: "
this._map.geoObjects.add(this._activeRoute);
var km = distanceKm(origin, dest);
if (onHint) onHint(km);
this._map.setBounds(this._activeRoute.geometry.getBounds(), { checkZoomRange: true, zoomMargin: 48 });
};
YandexMapProvider.prototype.focusOn = function (lat, lng) {
if (!this._map || !this._ready) return;
if (this._highlight) this._map.geoObjects.remove(this._highlight);
this._highlight = new ymaps.Circle([[lat, lng], 120], {}, { strokeColor: "
this._map.geoObjects.add(this._highlight);
this._map.setCenter([lat, lng], 15, { duration: 300 });
};
YandexMapProvider.prototype.onInteraction = function (start, end) {
var self = this;
if (!this._map || !this._ready) {
if (typeof ymaps !== "undefined") ymaps.ready(function () { self.onInteraction(start, end); });
return;
}
["actionbegin", "wheel", "mousedown", "touchstart"].forEach(function (ev) { if (start) self._map.events.add(ev, start); });
if (end) self._map.events.add("actionend", end);
};
YandexMapProvider.prototype.showUserLocation = function (lat, lng) {
if (!this._map || !this._ready) return;
if (this._userMarker) this._map.geoObjects.remove(this._userMarker);
if (this._userRadius) this._map.geoObjects.remove(this._userRadius);
this._userRadius = new ymaps.Circle([[lat, lng], 500], {}, { fillColor: "rgba(34,197,94,0.15)", strokeColor: "
this._userMarker = new ymaps.Placemark([lat, lng], {}, { preset: "islands
this._map.geoObjects.add(this._userRadius); this._map.geoObjects.add(this._userMarker);
};
YandexMapProvider.prototype.setView = function (lat, lng, zoom) {
if (!this._map || !this._ready) return;
this._map.setCenter([lat, lng], zoom || this._map.getZoom(), { duration: 300 });
};
function buildPopupHtml(props, color) {
var badges = [];
if (props.allow_dynamic_pricing) badges.push("<span class='ps-badge ps-badge--success'>AI‑тариф</span>");
if (props.has_ev_charging) badges.push("<span class='ps-badge'>EV</span>");
if (props.is_covered) badges.push("<span class='ps-badge'>Крытая</span>");
if (props.is_24_7) badges.push("<span class='ps-badge'>24/7</span>");
var occupancy = Math.min(100, Math.round((props.occupancy_7d || 0) * 100));
var stressTone = occupancy > 80 ? "danger" : occupancy > 60 ? "warn" : "ok";
return [
"<div class='ps-map-popup ps-map-popup--" + stressTone + "'>",
"  <header class='ps-map-popup-head'>",
"    <div class='ps-map-popup-title'>" + (props.city || "") + (props.lot_name ? ", " + props.lot_name : "") + (props.name ? " — " + props.name : "") + "</div>",
"    <div class='ps-map-popup-meta'>" + (props.address || "Адрес уточняется") + "</div>",
"  </header>",
"  <div class='ps-map-popup-price'>от <strong>" + (props.hourly_price || "?") + " ₽/час</strong></div>",
"  <div class='ps-map-popup-badges'>" + badges.join(" ") + "</div>",
"  <div class='ps-map-popup-meter'><span style='width:" + occupancy + "%; background:" + color + "'></span><div class='ps-map-popup-meter-label'>загруженность " + occupancy + "%</div></div>",
"  <div class='ps-map-popup-actions'>",
"    <button class='ps-btn ps-btn-primary ps-btn-sm' data-spot-id='" + (props.spot_id || props.id || "") + "'>Забронировать</button>",
"    <button class='ps-btn ps-btn-ghost ps-btn-sm' data-focus-spot='" + (props.spot_id || props.id || "") + "'>Маршрут</button>",
"  </div>",
"</div>"
].join("");
}
function createProvider() {
var id = (MAP_CONFIG.key || MAP_CONFIG.id || "yandex").toLowerCase();
var fallback = (MAP_CONFIG.fallback || "leaflet").toLowerCase();
var center = MAP_CONFIG.default_center || [55.75, 37.61];
var zoom = MAP_CONFIG.default_zoom || 12;
var container = qs("
if (!container) return { provider: null, center: center, zoom: zoom };
var hasYandex = typeof ymaps !== "undefined";
var hasLeaflet = typeof L !== "undefined";
var provider = null;
var opts = Object.assign({}, MAP_CONFIG, { theme: isNight ? "night" : "day" });
if (id === "yandex" && hasYandex) provider = new YandexMapProvider(opts);
else if (id === "leaflet" && hasLeaflet) provider = new LeafletMapProvider(opts);
else if (fallback === "yandex" && hasYandex) provider = new YandexMapProvider(opts);
else if (hasLeaflet) provider = new LeafletMapProvider(opts);
if (!provider) return { provider: null, center: center, zoom: zoom };
provider.init(container, center, zoom);
return { provider: provider, center: center, zoom: zoom };
}
function readFilters() {
var form = qs("[data-map-filters]");
if (!form) return {};
var fd = new FormData(form);
return {
only_free: fd.get("only_free") === "on",
ev: fd.get("ev") === "on",
covered: fd.get("covered") === "on",
is_24_7: fd.get("is_24_7") === "on",
ai_recommended: fd.get("ai_recommended") === "on",
min_price: priceRange[0],
max_price: priceRange[1]
};
}
function buildQuery(params) {
var q = [];
Object.keys(params).forEach(function (k) {
var v = params[k];
if (v === "" || v === null || typeof v === "undefined") return;
if (typeof v === "boolean") v = v ? "true" : "false";
q.push(encodeURIComponent(k) + "=" + encodeURIComponent(v));
});
return q.length ? "?" + q.join("&") : "";
}
function fetchFeatures(provider) {
if (!provider) return;
provider.setLoading(true);
var url = "/api/parking/map/" + buildQuery(readFilters());
return fetch(url, { headers: { "Accept": "application/json" } })
.then(function (resp) { if (!resp.ok) throw new Error("Map API error"); return resp.json(); })
.then(function (data) {
provider.setFeatures(data);
lastFeatures = data.features || [];
updateSpotsList(data); updateStats(data);
})
.catch(function () {})
.finally(function () { provider.setLoading(false); });
}
function updateStats(fc) {
var features = fc.features || [];
var prices = features.map(function (f) { return f.properties && f.properties.hourly_price; }).filter(function (p) { return typeof p === "number"; });
var avgEl = qs("[data-avg-price]"); var countEl = qs("[data-spots-count]");
if (countEl) countEl.textContent = String(features.length);
if (!avgEl) return; if (!prices.length) { avgEl.textContent = "—"; return; }
var sum = prices.reduce(function (acc, p) { return acc + p; }, 0);
avgEl.textContent = (Math.round((sum / prices.length) / 10) * 10) + " ₽/час";
}
function updateSpotsList(fc) {
var container = qs("[data-spots-list]"); if (!container) return;
var features = fc.features || [];
if (!features.length) { container.innerHTML = "<div class='ps-empty'><p>Подходящих мест пока нет. Попробуйте изменить фильтры.</p></div>"; return; }
container.innerHTML = features.map(function (f) {
var p = f.properties || {}, tags = [];
if (p.has_ev_charging) tags.push("⚡ EV"); if (p.is_covered) tags.push("🛡 крытая"); if (p.is_24_7) tags.push("⏰ 24/7");
var badge = p.allow_dynamic_pricing ? "<span class='ps-badge ps-badge--success'>AI‑тариф</span>" : "";
return [
"<article class='ps-card ps-card--spot ps-animate-fade-up ps-animate-stagger' data-spot-card='" + (p.spot_id || f.id || "") + "'>",
"  <div class='ps-card-header'><div class='ps-card-title'>" + (p.city || "") + (p.lot_name ? ", " + p.lot_name : "") + (p.name ? " — " + p.name : "") + "</div>" + badge + "</div>",
"  <div class='ps-card-body'>",
"    <div class='ps-card-line'>от " + (p.hourly_price || "?") + " ₽/час" + (tags.length ? " · " + tags.join(" · ") : "") + "</div>",
"    <div class='ps-card-line ps-card-line--muted'>" + (p.address || "Адрес будет уточнён") + "</div>",
"  </div>",
"</article>"
].join("");
}).join("");
}
function initPriceSlider(onChange) {
var slider = qs("[data-price-slider]"); var priceLabel = qs("[data-price-display]");
if (!slider || typeof noUiSlider === "undefined") return;
function render(values) { if (priceLabel) priceLabel.textContent = "Цена: от " + values[0] + " ₽ до " + values[1] + " ₽"; }
noUiSlider.create(slider, { start: priceRange, connect: true, step: 50, range: { min: 0, max: 2000 } });
slider.noUiSlider.on("update", function (values) { priceRange = values.map(function (v) { return Math.round(parseFloat(v)); }); render(priceRange); if (onChange) onChange(); });
render(priceRange);
}
function updateRouteHint(km) {
var hint = qs("[data-route-hint]"); if (!hint) return;
if (!km) { hint.textContent = "Постройте мини-маршрут до выбранной точки."; return; }
var timeMin = Math.max(2, Math.round(km / 0.4));
hint.textContent = "~" + km.toFixed(1) + " км, " + timeMin + " мин пешком/авто.";
}
function drawRoute(provider, targetLatLng) {
if (!provider || !targetLatLng || !provider.drawRouteTo) return;
var from = userLocation ? { lat: userLocation.lat, lng: userLocation.lng } : null;
provider.drawRouteTo({ lat: targetLatLng.lat || targetLatLng[0], lng: targetLatLng.lng || targetLatLng[1] }, from, function (km) { updateRouteHint(km); });
}
function initFloatingActions(provider) {
var actions = qs(".ps-map-floating-actions"); if (!actions) return;
var timer = null;
function dim() { actions.classList.add("is-dimmed"); }
function undim() { actions.classList.remove("is-dimmed"); startTimer(); }
function startTimer() { clearTimeout(timer); timer = setTimeout(dim, 3000); }
startTimer();
qsa(".ps-map-action", actions).forEach(function (btn) {
["mouseenter", "touchstart", "click"].forEach(function (evt) { btn.addEventListener(evt, undim, { passive: true }); });
});
if (provider && provider.onInteraction) provider.onInteraction(undim, startTimer);
}
function initGeocode(provider) {
var input = qs("[data-geocode-input]"); var submit = qs("[data-geocode-submit]"); var suggestions = qs("[data-geocode-suggestions]"); var timer = null;
function search(query) {
if (!query) return;
fetch("/api/geocode/?q=" + encodeURIComponent(query))
.then(function (resp) { return resp.json(); })
.then(function (data) {
var list = data.results || [];
suggestions.innerHTML = list.map(function (item) { return "<button type='button' data-geocode-choice data-lat='" + item.lat + "' data-lng='" + item.lng + "'>" + item.title + "</button>"; }).join("");
})
.catch(function () {});
}
if (input) {
input.addEventListener("input", function () { clearTimeout(timer); var value = input.value.trim(); timer = setTimeout(function () { search(value); }, 350); });
input.addEventListener("keydown", function (evt) { if (evt.key === "Enter") { evt.preventDefault(); search(input.value.trim()); } });
}
if (submit) submit.addEventListener("click", function () { search(input.value); });
if (suggestions) {
suggestions.addEventListener("click", function (e) {
var btn = e.target.closest("[data-geocode-choice]"); if (!btn) return;
var lat = parseFloat(btn.getAttribute("data-lat")); var lng = parseFloat(btn.getAttribute("data-lng"));
suggestions.innerHTML = "";
if (provider && provider.setView) { provider.setView(lat, lng, 15); drawRoute(provider, { lat: lat, lng: lng }); }
});
}
}
document.addEventListener("DOMContentLoaded", function () {
var mapContainer = qs("
var result = createProvider(); var provider = result.provider; if (!provider) return;
initPriceSlider(function () { fetchFeatures(provider); });
initGeocode(provider);
fetchFeatures(provider);
initFloatingActions(provider);
applyMapTheme(isNight ? "dark" : "light", provider, mapContainer);
var themeBtn = qs("[data-map-theme]");
if (themeBtn) themeBtn.addEventListener("click", function () { var next = isNight ? "light" : "dark"; themeBtn.classList.add("is-animating"); applyMapTheme(next, provider, mapContainer); });
var filtersForm = qs("[data-map-filters]");
if (filtersForm) filtersForm.addEventListener("change", function () { fetchFeatures(provider); });
qsa("[data-chip-toggle]").forEach(function (chip) {
var input = qs("input", chip); if (!input) return; chip.classList.toggle("is-active", input.checked);
chip.addEventListener("click", function (e) { if (e.target.tagName === "INPUT") return; input.checked = !input.checked; chip.classList.toggle("is-active", input.checked); input.dispatchEvent(new Event("change", { bubbles: true })); fetchFeatures(provider); });
});
var resetBtn = qs("[data-reset-filters]");
if (resetBtn) {
resetBtn.addEventListener("click", function () {
resetBtn.classList.remove("ps-map-action--spinning"); void resetBtn.offsetWidth; resetBtn.classList.add("ps-map-action--spinning");
if (filtersForm) filtersForm.reset(); priceRange = [0, 1500];
var slider = qs("[data-price-slider]"); if (slider && slider.noUiSlider) slider.noUiSlider.set(priceRange);
qsa("[data-chip-toggle]").forEach(function (chip) { chip.classList.remove("is-active"); });
fetchFeatures(provider);
});
}
qsa("[data-fill-location]").forEach(function (btn) {
btn.addEventListener("click", function () {
if (!navigator.geolocation) return; btn.classList.add("ps-map-action--pulse");
navigator.geolocation.getCurrentPosition(function (pos) {
userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
if (provider.showUserLocation) provider.showUserLocation(userLocation.lat, userLocation.lng);
if (provider.setView) provider.setView(userLocation.lat, userLocation.lng, 14);
btn.classList.remove("ps-map-action--pulse");
}, function () { btn.classList.remove("ps-map-action--pulse"); }, { timeout: 8000 });
});
});
var mapPanel = qs("[data-map-panel]");
if (mapPanel) {
mapPanel.addEventListener("click", function (e) {
var focusBtn = e.target.closest("[data-focus-spot]");
var bookBtn = e.target.closest("[data-spot-id]");
if (focusBtn) {
var id = focusBtn.getAttribute("data-focus-spot");
var match = (lastFeatures || []).find(function (f) { var fid = String(f.id); var pid = f.properties && f.properties.spot_id ? String(f.properties.spot_id) : null; return id && (fid === id || pid === id); });
if (match && match.geometry) { var coords = match.geometry.coordinates; var latlng = { lat: coords[1], lng: coords[0] }; if (provider.focusOn) provider.focusOn(latlng.lat, latlng.lng); drawRoute(provider, latlng); }
}
if (bookBtn) {
var targetId = bookBtn.getAttribute("data-spot-id");
var card = qs("[data-spot-card='" + targetId + "']");
if (card) card.scrollIntoView({ behavior: "smooth", block: "start" });
}
});
}
qsa("[data-spots-list]").forEach(function (list) {
list.addEventListener("click", function (e) {
var card = e.target.closest("[data-spot-card]"); if (!card) return;
var id = card.getAttribute("data-spot-card");
var match = (lastFeatures || []).find(function (f) { var fid = String(f.id); var pid = f.properties && f.properties.spot_id ? String(f.properties.spot_id) : null; return id && (fid === id || pid === id); });
if (match && match.geometry) { var coords = match.geometry.coordinates; var latlng = { lat: coords[1], lng: coords[0] }; if (provider.focusOn) provider.focusOn(latlng.lat, latlng.lng); drawRoute(provider, latlng); }
});
});
});
})();

# File 135/163: static\js\parkmate-ai.ts
################################################################################

export interface ParkMateVoiceCommands {
booking: string;
navigation: string;
payment: string;
support: string;
}
export interface ParkMateComputerVision {
licensePlateRecognition: string;
parkingSpotDetection: string;
damageDetection: string;
occupancyAnalytics: string;
}
export interface ParkMatePredictions {
arrivalTime: string;
priceForecast: string;
availability: string;
}
export interface ParkMateAI {
voiceCommands: ParkMateVoiceCommands;
computerVision: ParkMateComputerVision;
predictions: ParkMatePredictions;
}
export const parkMateConfig: ParkMateAI = {
voiceCommands: {
booking: "Забронировать парковку рядом",
navigation: "Построить маршрут до парковки",
payment: "Оплатить текущую парковку",
support: "Связаться с поддержкой ParkShare",
},
computerVision: {
licensePlateRecognition: "/api/ai/cv/license-plate/",
parkingSpotDetection: "/api/ai/cv/parking-occupancy/",
damageDetection: "/api/ai/cv/vehicle-damage/",
occupancyAnalytics: "/api/ai/stress-index/",
},
predictions: {
arrivalTime: "/api/ai/departure-assistant/",
priceForecast: "/api/ai/parkmate/price-forecast/",
availability: "/api/ai/parkmate/availability/",
},
};
export interface PriceForecastRequestPayload {
spotId: string;
}
export interface PriceForecastResponse {
spot_id: string;
lot_id: string;
currency: string;
base_price: number;
recommended_price: number;
min_price: number;
max_price: number;
discount_percent: number;
is_discount: boolean;
reason: string;
}
export interface AvailabilityForecastRequestPayload {
spotId?: string;
occupancy_7d?: number;
stress_index?: number;
}
export interface AvailabilityForecastResponse {
spot_id: string | null;
occupancy_7d: number;
stress_index: number;
as_of: string;
availability: {
next_1h: number;
next_3h: number;
next_24h: number;
};
}
async function jsonFetch<T>(
url: string,
options: RequestInit = {}
): Promise<T> {
const resp = await fetch(url, {
credentials: "include",
...options,
headers: {
"Content-Type": "application/json",
...(options.headers || {}),
},
});
if (!resp.ok) {
const text = await resp.text();
throw new Error(`Request failed ${resp.status}: ${text}`);
}
return (await resp.json()) as T;
}
export async function getPriceForecast(
payload: PriceForecastRequestPayload
): Promise<PriceForecastResponse> {
return jsonFetch<PriceForecastResponse>(
parkMateConfig.predictions.priceForecast,
{
method: "POST",
body: JSON.stringify({ spot_id: payload.spotId }),
}
);
}
export async function getAvailabilityForecast(
payload: AvailabilityForecastRequestPayload
): Promise<AvailabilityForecastResponse> {
return jsonFetch<AvailabilityForecastResponse>(
parkMateConfig.predictions.availability,
{
method: "POST",
body: JSON.stringify({
spot_id: payload.spotId,
occupancy_7d: payload.occupancy_7d,
stress_index: payload.stress_index,
}),
}
);
}
export async function fetchPriceForecast(
payload: PriceForecastRequestPayload
): Promise<PriceForecastResponse> {
return jsonFetch<PriceForecastResponse>(
parkMateConfig.predictions.priceForecast,
{
method: "POST",
body: JSON.stringify({ spot_id: payload.spotId }),
}
);
}
export async function fetchAvailabilityForecast(
payload: AvailabilityForecastRequestPayload
): Promise<AvailabilityForecastResponse> {
return jsonFetch<AvailabilityForecastResponse>(
parkMateConfig.predictions.availability,
{
method: "POST",
body: JSON.stringify({
spot_id: payload.spotId,
occupancy_7d: payload.occupancy_7d,
stress_index: payload.stress_index,
}),
}
);
}

# File 136/163: static\js\quantum-theme-manager.js
################################################################################

class QuantumThemeManager {
constructor(options = {}) {
this.themes = options.themes || {
dark: {
map: "dark",
css: "dark",
effects: "hologram-dark",
emotion: "calm",
},
light: {
map: "standard",
css: "light",
effects: "hologram-light",
emotion: "energetic",
},
};
this.currentTheme = "dark";
this.root = options.root || document.documentElement;
}
async switchTheme(theme) {
const config = this.themes[theme];
if (!config) return;
this.currentTheme = theme;
const tasks = [
this.switchCSSTheme(config.css),
this.switchEmotionalMode(config.emotion),
this.switchCinematicEffects(config.effects),
];
await Promise.all(tasks);
this.triggerThemeTransitionAnimation();
}
switchCSSTheme(css) {
this.root.dataset.quantumTheme = css;
document.body.dataset.quantumTheme = css;
return Promise.resolve();
}
switchEmotionalMode(emotion) {
document.body.dataset.emotion = emotion;
return Promise.resolve();
}
switchCinematicEffects(effects) {
document.body.dataset.cinematic = effects;
return Promise.resolve();
}
triggerThemeTransitionAnimation() {
const flash = document.createElement("div");
flash.className = "quantum-pulse";
document.body.appendChild(flash);
setTimeout(() => flash.remove(), 800);
}
bindToggle(buttonId) {
const btn = document.getElementById(buttonId);
if (!btn) return;
btn.addEventListener("click", () => {
const next = this.currentTheme === "dark" ? "light" : "dark";
btn.dataset.theme = next;
const label = btn.querySelector(".quantum-toggle__label");
if (label) {
label.textContent = next === "dark" ? "Dark Matter" : "Photon";
}
this.switchTheme(next);
});
}
}
window.initQuantumThemeManager = function initQuantumThemeManager() {
const manager = new QuantumThemeManager();
manager.bindToggle("themeToggle");
manager.switchTheme("dark");
return manager;
};

# File 137/163: templates\base.html
################################################################################

{% load static %}
<!doctype html>
<html lang="ru" data-platform="{{ PLATFORM_MODE|default:'RU' }}">
<head>
<meta charset="utf-8">
<title>{% block title %}ParkShare — smart parking{% endblock %}</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- PWA -->
<meta name="theme-color" content="
<link rel="manifest" href="{% url 'manifest' %}">
<link rel="apple-touch-icon" sizes="192x192" href="{% static 'icons/icon-192.png' %}">
<link rel="apple-touch-icon" sizes="512x512" href="{% static 'icons/icon-512.png' %}">
<!-- Favicon (минимальный набор) -->
<link rel="icon" type="image/png" sizes="32x32" href="{% static 'icons/icon-72.png' %}">
<!-- Основные стили PWA -->
<link rel="stylesheet" href="{% static 'css/app.css' %}">
{% block extra_head %}{% endblock %}
</head>
<body class="ps-body">
<header class="ps-header">
<nav class="ps-navbar">
<div class="ps-navbar-left">
<a href="{% url 'landing' %}" class="ps-logo">
<span class="ps-logo-main">ParkShare</span>
<span class="ps-logo-accent">{{ REGION_PROFILE }}</span>
</a>
{% if user.is_authenticated %}
<span class="ps-user-level" title="Ваш уровень по бронированиям">
🎖️ {{ user.username }}
</span>
{% endif %}
</div>
<button class="ps-navbar-toggle" type="button" data-menu-toggle aria-label="Открыть меню">
<span></span>
<span></span>
<span></span>
</button>
<div class="ps-navbar-menu" data-menu>
<a href="{% url 'landing' %}" class="ps-nav-link">Главная</a>
<a href="{% url 'user_dashboard' %}" class="ps-nav-link">Личный кабинет</a>
{% if user.is_authenticated and user.is_owner %}
<a href="{% url 'owner_dashboard' %}" class="ps-nav-link">Кабинет владельца</a>
{% endif %}
<a href="{% url 'map_page' %}" class="ps-nav-link">Карта</a>
<button type="button" class="ps-nav-link ps-nav-link--ghost" data-chat-open-link>AI-помощник</button>
<button type="button" class="ps-nav-link" data-nav-install-app data-install-href="{% url 'pwa_install' %}">Установить приложение</button>
{% if user.is_authenticated %}
<a href="{% url 'accounts:profile' %}" class="ps-nav-link">Профиль</a>
<a href="{% url 'accounts:logout' %}" class="ps-nav-link ps-nav-link--danger">Выйти</a>
{% else %}
<a href="{% url 'accounts:login' %}" class="ps-nav-link">Войти</a>
<a href="{% url 'accounts:register' %}" class="ps-nav-link ps-nav-link--primary">Регистрация</a>
{% endif %}
</div>
</nav>
</header>
<main class="ps-main">
{% block content %}{% endblock %}
</main>
<footer class="ps-footer">
<div class="ps-footer-inner">
<span>© {% now "Y" %} ParkShare RU</span>
<span class="ps-footer-meta">PWA · Offline-first · AI pricing</span>
</div>
</footer>
<!-- Back to top -->
<button class="ps-back-to-top" type="button" data-back-to-top aria-label="Наверх">
↑
</button>
<!-- Toasts -->
<div class="ps-toast-container" aria-live="polite" aria-atomic="true"></div>
<!-- Chat assistant -->
<div class="ps-chat" data-chat>
<button class="ps-chat-fab" type="button" data-chat-toggle aria-expanded="false">
<span class="ps-chat-fab-icon">🤖</span>
<span class="ps-chat-fab-text">AI-помощник</span>
</button>
<div class="ps-chat-overlay" data-chat-overlay></div>
<div class="ps-chat-panel" data-chat-panel aria-hidden="true" role="dialog" aria-label="AI-помощник по парковке">
<div class="ps-chat-header">
<div class="ps-chat-header-text">
<div class="ps-chat-title">AI-помощник по парковке</div>
<div class="ps-chat-hint">Подскажет свободные места, тарифы и построит маршрут.</div>
</div>
<div class="ps-chat-meta">
<span class="ps-chat-status-dot">онлайн</span>
<button class="ps-chat-close" type="button" data-chat-close aria-label="Свернуть чат">×</button>
</div>
</div>
<div class="ps-chat-body" data-chat-body></div>
<div class="ps-chat-status" data-chat-status hidden>Ассистент печатает…</div>
<div class="ps-chat-input">
<textarea class="ps-input" rows="2" placeholder="Напишите: «Нужна парковка завтра с 9 до 11 у метро Курская, недорого»" data-chat-input></textarea>
<button class="ps-btn ps-btn-primary" type="button" data-chat-send>Отправить</button>
</div>
</div>
</div>
<!-- Bottom navigation for mobile -->
<nav class="ps-bottom-nav" data-bottom-nav>
<a href="{% url 'map_page' %}" class="ps-bottom-nav-item" data-nav="map">
<span class="ps-bottom-nav-icon" aria-hidden="true">🗺️</span>
<span class="ps-bottom-nav-label">Карта</span>
</a>
<a href="{% url 'user_dashboard' %}" class="ps-bottom-nav-item" data-nav="bookings">
<span class="ps-bottom-nav-icon" aria-hidden="true">🧾</span>
<span class="ps-bottom-nav-label">Мои брони</span>
</a>
<a href="{% url 'accounts:profile' %}" class="ps-bottom-nav-item" data-nav="profile">
<span class="ps-bottom-nav-icon" aria-hidden="true">👤</span>
<span class="ps-bottom-nav-label">Профиль</span>
</a>
<button type="button" class="ps-bottom-nav-item" data-nav="chat" data-chat-open-link>
<span class="ps-bottom-nav-icon" aria-hidden="true">🤖</span>
<span class="ps-bottom-nav-label">AI-чат</span>
</button>
</nav>
<!-- PWA install banner -->
<div class="ps-install-banner" data-install-banner hidden>
<div class="ps-install-banner-inner">
<div class="ps-install-banner-text">
Установите <strong>ParkShare RU</strong> как приложение
</div>
<div class="ps-install-banner-actions">
<button type="button" class="ps-btn ps-btn-secondary" data-install-dismiss>Позже</button>
<button type="button" class="ps-btn" data-install-accept>Установить</button>
</div>
</div>
</div>
<script src="{% static 'js/app.js' %}"></script>
{% block extra_scripts %}{% endblock %}
</body>
</html>

# File 138/163: templates\offline.html
################################################################################

{% extends "base.html" %}
{% block title %}Оффлайн — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-section ps-section--center">
<div class="ps-offline-icon">☁️</div>
<h1 class="ps-section-title">Нет подключения к сети</h1>
<p class="ps-section-subtitle">
Вы оффлайн. Некоторые данные могут быть устаревшими или недоступными,
но базовые страницы и ранее открытые ресурсы всё ещё работают.
</p>
<div class="ps-offline-actions">
<button type="button" class="ps-btn" onclick="location.reload()">
Повторить попытку
</button>
<a href="{% url 'landing' %}" class="ps-btn ps-btn-secondary">
На главную
</a>
</div>
</section>
{% endblock %}

# File 139/163: templates\accounts\login.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}Вход — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-auth">
<div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
<h1 class="ps-auth-title">Вход</h1>
<p class="ps-auth-subtitle">
Войдите, чтобы управлять своими бронированиями и машинами.
</p>
<div class="ps-auth-tabs" data-auth-switcher>
<button type="button" class="is-active" data-auth-target="password">Email/Пароль</button>
<button type="button" data-auth-target="google">Google</button>
<button type="button" data-auth-target="sms">SMS</button>
<button type="button" data-auth-target="esia">Госуслуги</button>
</div>
<div class="ps-auth-panels">
<div class="ps-auth-panel is-active" data-auth-panel="password">
<form method="post" class="ps-form">
{% csrf_token %}
{% if form.non_field_errors %}
<div class="ps-alert ps-alert--danger">
{{ form.non_field_errors }}
</div>
{% endif %}
{% for field in form.visible_fields %}
<div class="ps-form-row">
<label class="ps-form-label" for="{{ field.id_for_label }}">
{{ field.label }}
</label>
{{ field }}
{% if field.help_text %}
<div class="ps-field-help">{{ field.help_text }}</div>
{% endif %}
{% for error in field.errors %}
<div class="ps-field-error">{{ error }}</div>
{% endfor %}
</div>
{% endfor %}
<div class="ps-form-actions">
<button type="submit" class="ps-btn ps-btn-full">
Войти
</button>
</div>
</form>
</div>
<div class="ps-auth-panel" data-auth-panel="google">
<div class="ps-auth-placeholder">
<p>Вход через Google скоро появится.</p>
<button type="button" class="ps-btn ps-btn-secondary" disabled>Google</button>
</div>
</div>
<div class="ps-auth-panel" data-auth-panel="sms">
<div class="ps-auth-placeholder">
<p>Вход по SMS-коду в разработке.</p>
<button type="button" class="ps-btn ps-btn-secondary" disabled>Получить код</button>
</div>
</div>
<div class="ps-auth-panel" data-auth-panel="esia">
<div class="ps-auth-placeholder">
<p>Поддержка Госуслуг скоро будет доступна.</p>
<button type="button" class="ps-btn ps-btn-secondary" disabled>Перейти в Госуслуги</button>
</div>
</div>
</div>
<div class="ps-auth-footer">
Нет аккаунта?
<a href="{% url 'accounts:register' %}">Зарегистрироваться</a>
<br>
<a href="{% url 'accounts:password_reset' %}">Забыли пароль?</a>
</div>
</div>
</section>
{% endblock %}
{% block extra_scripts %}
<script>
(function () {
const root = document.querySelector('[data-auth-switcher]');
if (!root) return;
const buttons = Array.from(root.querySelectorAll('[data-auth-target]'));
const panels = Array.from(document.querySelectorAll('[data-auth-panel]'));
buttons.forEach(function (btn) {
btn.addEventListener('click', function () {
const target = btn.getAttribute('data-auth-target');
buttons.forEach(function (b) { b.classList.toggle('is-active', b === btn); });
panels.forEach(function (panel) {
panel.classList.toggle('is-active', panel.getAttribute('data-auth-panel') === target);
});
});
});
})();
</script>
{% endblock %}

# File 140/163: templates\accounts\password_change.html
################################################################################

{% extends "base.html" %}
{% block title %}Смена пароля — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-auth">
<div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
<h1 class="ps-auth-title">Смена пароля</h1>
<p class="ps-auth-subtitle">
Укажите текущий пароль и новый — мы проверим его надёжность.
</p>
<form method="post" class="ps-form">
{% csrf_token %}
{% if form.non_field_errors %}
<div class="ps-alert ps-alert--danger">
{{ form.non_field_errors }}
</div>
{% endif %}
{% for field in form.visible_fields %}
<div class="ps-form-row">
<label class="ps-form-label" for="{{ field.id_for_label }}">
{{ field.label }}
</label>
{{ field }}
{% if field.help_text %}
<div class="ps-field-help">{{ field.help_text }}</div>
{% endif %}
{% for error in field.errors %}
<div class="ps-field-error">{{ error }}</div>
{% endfor %}
</div>
{% endfor %}
<div class="ps-form-actions">
<button type="submit" class="ps-btn ps-btn-full">
Обновить пароль
</button>
</div>
</form>
</div>
</section>
{% endblock %}

# File 141/163: templates\accounts\password_change_done.html
################################################################################

{% extends "base.html" %}
{% block title %}Пароль обновлён — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
<h1 class="ps-section-title">Пароль успешно обновлён</h1>
<p class="ps-section-subtitle">
Ваш новый пароль сохранён. Используйте его для следующего входа.
</p>
<div class="ps-offline-actions">
<a href="{% url 'user_dashboard' %}" class="ps-btn">
В личный кабинет
</a>
</div>
</section>
{% endblock %}

# File 142/163: templates\accounts\password_reset.html
################################################################################

{% extends "base.html" %}
{% block title %}Сброс пароля — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-auth">
<div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
<h1 class="ps-auth-title">Сброс пароля</h1>
<p class="ps-auth-subtitle">
Укажите email, на который зарегистрирован аккаунт. Мы отправим ссылку
для задания нового пароля.
</p>
<form method="post" class="ps-form">
{% csrf_token %}
{% if form.non_field_errors %}
<div class="ps-alert ps-alert--danger">
{{ form.non_field_errors }}
</div>
{% endif %}
{% for field in form.visible_fields %}
<div class="ps-form-row">
<label class="ps-form-label" for="{{ field.id_for_label }}">
{{ field.label }}
</label>
{{ field }}
{% for error in field.errors %}
<div class="ps-field-error">{{ error }}</div>
{% endfor %}
</div>
{% endfor %}
<div class="ps-form-actions">
<button type="submit" class="ps-btn ps-btn-full">
Отправить ссылку
</button>
</div>
</form>
<div class="ps-auth-footer">
Вспомнили пароль?
<a href="{% url 'accounts:login' %}">Вернуться ко входу</a>
</div>
</div>
</section>
{% endblock %}

# File 143/163: templates\accounts\password_reset_complete.html
################################################################################

{% extends "base.html" %}
{% block title %}Пароль изменён — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
<h1 class="ps-section-title">Пароль успешно изменён</h1>
<p class="ps-section-subtitle">
Теперь вы можете войти в свой аккаунт, используя новый пароль.
</p>
<div class="ps-offline-actions">
<a href="{% url 'accounts:login' %}" class="ps-btn">
Перейти ко входу
</a>
</div>
</section>
{% endblock %}

# File 144/163: templates\accounts\password_reset_confirm.html
################################################################################

{% extends "base.html" %}
{% block title %}Новый пароль — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-auth">
<div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
{% if validlink %}
<h1 class="ps-auth-title">Задайте новый пароль</h1>
<p class="ps-auth-subtitle">
Введите новый пароль дважды, чтобы исключить опечатки.
</p>
<form method="post" class="ps-form">
{% csrf_token %}
{% if form.non_field_errors %}
<div class="ps-alert ps-alert--danger">
{{ form.non_field_errors }}
</div>
{% endif %}
{% for field in form.visible_fields %}
<div class="ps-form-row">
<label class="ps-form-label" for="{{ field.id_for_label }}">
{{ field.label }}
</label>
{{ field }}
{% if field.help_text %}
<div class="ps-field-help">{{ field.help_text }}</div>
{% endif %}
{% for error in field.errors %}
<div class="ps-field-error">{{ error }}</div>
{% endfor %}
</div>
{% endfor %}
<div class="ps-form-actions">
<button type="submit" class="ps-btn ps-btn-full">
Сохранить новый пароль
</button>
</div>
</form>
{% else %}
<h1 class="ps-auth-title">Ссылка недействительна</h1>
<p class="ps-auth-subtitle">
Ссылка для сброса пароля устарела или уже была использована.
Попробуйте запросить сброс ещё раз.
</p>
<div class="ps-offline-actions">
<a href="{% url 'accounts:password_reset' %}" class="ps-btn">
Запросить новую ссылку
</a>
</div>
{% endif %}
</div>
</section>
{% endblock %}

# File 145/163: templates\accounts\password_reset_done.html
################################################################################

{% extends "base.html" %}
{% block title %}Письмо отправлено — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
<h1 class="ps-section-title">Проверьте почту</h1>
<p class="ps-section-subtitle">
Если аккаунт с таким email существует, мы отправили на него письмо
с дальнейшими инструкциями.
</p>
<div class="ps-offline-actions">
<a href="{% url 'accounts:login' %}" class="ps-btn ps-btn-secondary">
Вернуться ко входу
</a>
</div>
</section>
{% endblock %}

# File 146/163: templates\accounts\password_reset_email.txt
################################################################################

Вы получили это письмо, потому что на сайте {{ site_name }} был запрошен сброс пароля
для пользователя, использующего этот email.

Чтобы задать новый пароль, перейдите по ссылке:

{{ protocol }}://{{ domain }}{% url 'accounts:password_reset_confirm' uidb64=uid token=token %}

Если вы не запрашивали сброс пароля, просто проигнорируйте это письмо.


# File 147/163: templates\accounts\password_reset_subject.txt
################################################################################

Сброс пароля на ParkShare RU


# File 148/163: templates\accounts\profile.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}Профиль — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-section ps-section--narrow">
<div class="ps-section-header">
<h1 class="ps-section-title">Профиль</h1>
<p class="ps-section-subtitle">
Обновите контактные данные, чтобы получать уведомления по бронированиям.
</p>
</div>
<div class="ps-card ps-card--elevated ps-animate-fade-up">
<form method="post" class="ps-form">
{% csrf_token %}
{% if form.non_field_errors %}
<div class="ps-alert ps-alert--danger">
{{ form.non_field_errors }}
</div>
{% endif %}
{% for field in form.visible_fields %}
<div class="ps-form-row">
<label class="ps-form-label" for="{{ field.id_for_label }}">
{{ field.label }}
</label>
{{ field }}
{% if field.help_text %}
<div class="ps-field-help">{{ field.help_text }}</div>
{% endif %}
{% for error in field.errors %}
<div class="ps-field-error">{{ error }}</div>
{% endfor %}
</div>
{% endfor %}
<div class="ps-form-actions">
<button type="submit" class="ps-btn ps-btn-full">
Сохранить изменения
</button>
<a href="{% url 'user_dashboard' %}" class="ps-btn ps-btn-secondary ps-btn-full">
Вернуться в кабинет
</a>
</div>
</form>
</div>
</section>
{% endblock %}

# File 149/163: templates\accounts\register.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}Регистрация — ParkShare RU{% endblock %}
{% block content %}
<section class="ps-auth">
<div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
<h1 class="ps-auth-title">Регистрация</h1>
<p class="ps-auth-subtitle">
Создайте аккаунт, чтобы бронировать парковки и управлять местами.
</p>
<form method="post" class="ps-form">
{% csrf_token %}
{% if form.non_field_errors %}
<div class="ps-alert ps-alert--danger">
{{ form.non_field_errors }}
</div>
{% endif %}
{% for field in form.visible_fields %}
<div class="ps-form-row">
<label class="ps-form-label" for="{{ field.id_for_label }}">
{{ field.label }}
</label>
{{ field }}
{% if field.help_text %}
<div class="ps-field-help">{{ field.help_text }}</div>
{% endif %}
{% for error in field.errors %}
<div class="ps-field-error">{{ error }}</div>
{% endfor %}
</div>
{% endfor %}
<div class="ps-form-actions">
<button type="submit" class="ps-btn ps-btn-full">
Зарегистрироваться
</button>
</div>
<div class="ps-auth-alt">
<button type="button" class="ps-btn ps-btn-ghost" title="Скоро">Регистрация по коду</button>
<button type="button" class="ps-btn ps-btn-ghost" title="Скоро">Госуслуги</button>
<button type="button" class="ps-btn ps-btn-ghost" title="Скоро">Google</button>
<!-- TODO: подключить быструю регистрацию через code/ESIA/OAuth -->
</div>
</form>
<div class="ps-auth-footer">
Уже есть аккаунт?
<a href="{% url 'accounts:login' %}">Войти</a>
</div>
</div>
</section>
{% endblock %}

# File 150/163: templates\parking\landing.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}ParkShare RU — найти парковку рядом{% endblock %}
{% block extra_head %}
<!-- Карта: Yandex API как основной провайдер, Leaflet — fallback -->
<link rel="stylesheet"
href="https:
integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
crossorigin=""/>
<link rel="stylesheet" href="https:
<link rel="stylesheet" href="https:
<script src="https:
defer></script>
{% endblock %}
{% block content %}
<section class="ps-hero ps-animate-fade-up">
<div class="ps-hero-inner">
<div class="ps-hero-text">
<h1 class="ps-hero-title">
Парковка <span>в один тап</span>
</h1>
<p class="ps-hero-subtitle">
Найдите свободное место во дворе, у офиса или рядом с домом.
Бронирование, оплата и навигация — прямо в вашем браузере.
</p>
<div class="ps-hero-actions">
<a href="
Найти парковку рядом
</a>
<button type="button" class="ps-btn ps-btn-ghost ps-btn-lg" data-fill-location>
Определить моё местоположение
</button>
</div>
<div class="ps-hero-meta">
Работает как приложение · Оффлайн-режим · Уведомления о бронях
</div>
</div>
<div class="ps-hero-visual">
<div class="ps-hero-card ps-animate-float">
<div class="ps-hero-card-line">
<span class="ps-dot ps-dot--green"></span>
Места рядом с вами найдены
</div>
<div class="ps-hero-card-line">
<span class="ps-dot ps-dot--blue"></span>
Средняя цена: <strong data-avg-price>180 ₽/час</strong>
</div>
<div class="ps-hero-card-line">
<span class="ps-dot ps-dot--yellow"></span>
Свободных мест:
<strong data-spots-count>{{ spots|length }}</strong>
</div>
</div>
</div>
</div>
</section>
<section id="search" class="ps-section ps-section--flush-top">
<div class="ps-section-header ps-section-header--stack">
<div>
<h2 class="ps-section-title">Найти парковку рядом</h2>
<p class="ps-section-subtitle">
Карта с динамическими ценами, фильтрами и AI‑рекомендациями.
</p>
</div>
<div class="ps-section-actions" data-mobile-toolbar>
<button type="button" class="ps-btn ps-btn-secondary ps-btn-sm" data-fill-location>Рядом со мной</button>
<button type="button" class="ps-btn ps-btn-ghost ps-btn-sm" data-open-spots>Список мест</button>
</div>
</div>
<div class="ps-grid ps-grid--2col@lg ps-grid--gap-xl ps-grid--mobile-stack">
<div class="ps-map-panel" data-map-panel>
<div class="ps-map-wrapper">
<div id="map" class="ps-map ps-map--light"></div>
<div class="ps-map-loading" data-map-loading>Обновляем карту…</div>
<div class="ps-map-floating-actions" aria-label="Действия карты">
<button class="ps-map-action" type="button" data-fill-location title="Моё местоположение">🎯</button>
<button class="ps-map-action" type="button" data-reset-filters title="Сбросить фильтры">↺</button>
<button class="ps-map-action" type="button" data-map-theme title="Светлая / тёмная карта" aria-pressed="false">🌙</button>
</div>
</div>
<div class="ps-map-filters" data-map-filters-container>
<form class="ps-map-filters-card" data-map-filters>
<div class="ps-map-filters-row">
<div class="ps-input-icon">
<span class="ps-input-icon-symbol">🔍</span>
<input type="text" class="ps-input" placeholder="Адрес, метро или место" data-geocode-input>
</div>
<div class="ps-map-filters-actions">
<button class="ps-btn ps-btn-primary" type="button" data-geocode-submit>Найти</button>
</div>
</div>
<div class="ps-geocode-suggestions" data-geocode-suggestions></div>
<div class="ps-map-filters-row ps-map-filters-row--chips" data-filter-chips>
<div class="ps-chip-scroll">
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="only_free" hidden>
<span>Только свободные</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="ai_recommended" hidden>
<span>AI-рекомендации</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="ev" hidden>
<span>С зарядкой EV</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="covered" hidden>
<span>Крытая</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="is_24_7" hidden>
<span>24/7</span>
</label>
</div>
</div>
<div class="ps-map-filters-row ps-map-filters-row--slider">
<div class="ps-filter-slider" data-price-slider></div>
<div class="ps-filter-price" data-price-display>Цена: от 0 ₽ до 1500 ₽</div>
</div>
</form>
</div>
<div class="ps-route-hint" data-route-hint>Постройте мини-маршрут до выбранной точки.</div>
</div>
<div class="ps-spots-panel" data-spots-panel>
<div class="ps-section-subheader">
<h3 class="ps-section-title-sm">Доступные места</h3>
</div>
<div class="ps-spots-list" data-spots-list>
<div class="ps-card ps-card--spot ps-card--skeleton">
<div class="ps-skeleton-line ps-skeleton-line--lg"></div>
<div class="ps-skeleton-line"></div>
<div class="ps-skeleton-line ps-skeleton-line--short"></div>
</div>
<div class="ps-card ps-card--spot ps-card--skeleton">
<div class="ps-skeleton-line ps-skeleton-line--lg"></div>
<div class="ps-skeleton-line"></div>
<div class="ps-skeleton-line ps-skeleton-line--short"></div>
</div>
</div>
<div class="ps-favorites-hint">
Сохраняйте парковки в избранное и синхронизируйте с «домом»/«офисом».
</div>
</div>
</div>
</section>
<section class="ps-section">
<div class="ps-section-header ps-section--center">
<h2 class="ps-section-title">
Почему <span>ParkShare RU</span>
</h2>
<p class="ps-section-subtitle">
Не просто карта парковок, а умный помощник, который экономит время и деньги.
</p>
</div>
<div class="ps-grid ps-grid--2col ps-grid--gap-xl">
<article class="ps-card ps-card--elevated ps-animate-fade-up">
<div class="ps-card-header">
<h3 class="ps-card-title">Дешевле, чем штраф за эвакуатор</h3>
</div>
<div class="ps-card-body">
<p class="ps-card-line">
Бронируйте место заранее и не рискуйте ставить машину “как-нибудь”.
</p>
<p class="ps-card-line ps-card-line--muted">
Алгоритмы подсказывают варианты с лучшим соотношением цена/расстояние.
</p>
</div>
</article>
<article class="ps-card ps-card--elevated ps-animate-fade-up ps-animate-delay-1">
<div class="ps-card-header">
<h3 class="ps-card-title">Без приложений и регистрации на старте</h3>
</div>
<div class="ps-card-body">
<p class="ps-card-line">
Всё работает прямо в браузере — как PWA-приложение.
</p>
<p class="ps-card-line ps-card-line--muted">
Добавьте на главный экран и открывайте в один тап, даже оффлайн.
</p>
</div>
</article>
</div>
</section>
<section class="ps-section">
<div class="ps-section-header">
<h2 class="ps-section-title">Как это работает</h2>
<p class="ps-section-subtitle">
Три шага от поиска до оплаченного места.
</p>
</div>
<div class="ps-grid ps-grid--2col ps-grid--gap-xl">
<div>
<article class="ps-card ps-card--elevated ps-animate-fade-up">
<div class="ps-card-body">
<div class="ps-card-line"><strong>1. Найдите точку на карте</strong></div>
<div class="ps-card-line ps-card-line--muted">
Укажите район или воспользуйтесь определением геопозиции — мы покажем свободные места поблизости.
</div>
<div class="ps-card-line"><strong>2. Забронируйте онлайн</strong></div>
<div class="ps-card-line ps-card-line--muted">
Выберите тариф, время и способ оплаты. Место резервируется под вас, сосед его уже не заберёт.
</div>
<div class="ps-card-line"><strong>3. Постройте маршрут</strong></div>
<div class="ps-card-line ps-card-line--muted">
Откройте навигатор в один клик и доезжайте без кругов вокруг дома.
</div>
</div>
</article>
</div>
<div>
<article class="ps-card ps-card--elevated ps-animate-fade-up ps-animate-delay-1">
<div class="ps-card-header">
<h3 class="ps-card-title">Есть своё место или парковка?</h3>
</div>
<div class="ps-card-body">
<p class="ps-card-line">
Превратите пустующие места во дворe или у офиса в пассивный доход.
</p>
<p class="ps-card-line ps-card-line--muted">
Добавьте объект, настройте цены и ограничения — бронирования и выплаты мы возьмём на себя.
</p>
<div class="ps-form-actions" style="margin-top:0.75rem;">
<a href="{% url 'owner_dashboard' %}" class="ps-btn ps-btn-lg">
Стать владельцем парковки
</a>
</div>
</div>
</article>
</div>
</div>
</section>
{% endblock %}
{% block extra_scripts %}
<script src="https:
integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
crossorigin=""></script>
<script src="https:
<script src="https:
<script>
window.PARKSHARE_MAP_PROVIDER = {
id: "{{ MAP_PROVIDER|default:'yandex' }}",
fallback: "{{ MAP_PROVIDER_FALLBACK|default:'leaflet' }}",
default_center: {{ MAP_DEFAULT_CENTER|safe }},
default_zoom: {{ MAP_DEFAULT_ZOOM|default:11 }},
};
</script>
{% load static %}
{% static 'js/map.js' as map_static %}
<script src="{{ map_static }}?v=43"></script>
{% endblock %}

# File 151/163: templates\parking\map_fullscreen.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}Живая карта — ParkShare{% endblock %}
{% block extra_head %}
<link rel="stylesheet"
href="https:
integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
crossorigin=""/>
<link rel="stylesheet" href="https:
<link rel="stylesheet" href="https:
<script src="https:
defer></script>
{% endblock %}
{% block content %}
<section class="ps-section ps-section--flush-top ps-map-hero">
<div class="ps-section-header ps-section-header--stack">
<div>
<h1 class="ps-section-title">Карта парковок</h1>
<p class="ps-section-subtitle">Полноэкранный режим с поиском, фильтрами и маршрутами.</p>
</div>
<div class="ps-section-actions">
<a href="{% url 'landing' %}" class="ps-btn ps-btn-ghost ps-btn-sm">На главную</a>
<button type="button" class="ps-btn ps-btn-primary ps-btn-sm" data-fill-location>Рядом со мной</button>
</div>
</div>
<div class="ps-map-grid">
<div class="ps-map-panel" data-map-panel>
<div class="ps-map-wrapper">
<div id="map" class="ps-map ps-map--light"></div>
<div class="ps-map-loading" data-map-loading>Обновляем карту…</div>
<div class="ps-map-floating-actions" aria-label="Действия карты">
<button class="ps-map-action" type="button" data-fill-location title="Моё местоположение">🎯</button>
<button class="ps-map-action" type="button" data-reset-filters title="Сбросить фильтры">↺</button>
<button class="ps-map-action" type="button" data-map-theme title="Светлая / тёмная карта" aria-pressed="false">🌙</button>
</div>
<div class="ps-map-topbar">
<div class="ps-input-icon">
<span class="ps-input-icon-symbol">🔍</span>
<input type="text" class="ps-input" placeholder="Адрес, метро или место" data-geocode-input>
</div>
<button class="ps-btn ps-btn-primary" type="button" data-geocode-submit>Найти</button>
</div>
<div class="ps-map-chips" data-filter-chips>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="only_free" hidden>
<span>Только свободные</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="ai_recommended" hidden>
<span>AI-рекомендации</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="ev" hidden>
<span>EV-зарядка</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="covered" hidden>
<span>Крытая</span>
</label>
<label class="ps-chip" data-chip-toggle>
<input type="checkbox" name="is_24_7" hidden>
<span>24/7</span>
</label>
</div>
<div class="ps-geocode-suggestions" data-geocode-suggestions></div>
</div>
<div class="ps-map-filters" data-map-filters-container>
<form class="ps-map-filters-card" data-map-filters>
<div class="ps-map-filters-row ps-map-filters-row--slider">
<div class="ps-filter-slider" data-price-slider></div>
<div class="ps-filter-price" data-price-display>Цена: от 0 ₽ до 1500 ₽</div>
</div>
</form>
</div>
<div class="ps-route-hint" data-route-hint>Постройте мини-маршрут до выбранной точки.</div>
</div>
<div class="ps-bottom-sheet" data-spots-panel>
<div class="ps-bottom-sheet__handle"></div>
<div class="ps-bottom-sheet__header">
<div>
<div class="ps-section-title-sm">Доступные места</div>
<div class="ps-text-muted">Свободных: <span data-spots-count>{{ spots|length }}</span>, ср. цена <span data-avg-price>—</span></div>
</div>
<div class="ps-bottom-sheet__actions">
<button type="button" class="ps-btn ps-btn-ghost ps-btn-sm" data-reset-filters>Сбросить</button>
</div>
</div>
<div class="ps-bottom-sheet__body">
<div class="ps-spots-list" data-spots-list>
{% for spot in spots %}
<article class="ps-card ps-card--spot" data-spot-card="{{ spot.id }}">
<div class="ps-card-header">
<div class="ps-card-title">{{ spot.lot.city }}, {{ spot.lot.name }} — {{ spot.name }}</div>
</div>
<div class="ps-card-body">
<div class="ps-card-line">от {{ spot.hourly_price }} ₽/час</div>
<div class="ps-card-line ps-card-line--muted">{{ spot.lot.address|default:"Адрес уточняется" }}</div>
</div>
</article>
{% empty %}
<div class="ps-empty">Места будут показаны после загрузки карты.</div>
{% endfor %}
</div>
</div>
</div>
</div>
</section>
{% endblock %}
{% block extra_scripts %}
<script src="https:
integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
crossorigin=""></script>
<script src="https:
<script src="https:
<script>
window.PARKSHARE_MAP_PROVIDER = {
id: "{{ MAP_PROVIDER|default:'yandex' }}",
fallback: "{{ MAP_PROVIDER_FALLBACK|default:'leaflet' }}",
default_center: {{ MAP_DEFAULT_CENTER|safe }},
default_zoom: {{ MAP_DEFAULT_ZOOM|default:11 }},
};
</script>
{% static 'js/map.js' as map_static %}
<script src="{{ map_static }}?v=50"></script>
{% endblock %}

# File 152/163: templates\parking\owner_dashboard.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}ParkShare RU — кабинет владельца{% endblock %}
{% block content %}
<section class="ps-section">
<div class="ps-section-header">
<h1 class="ps-section-title">Кабинет владельца парковок</h1>
<p class="ps-section-subtitle">
Управляйте своими объектами, местами и бронированиями в одном интерфейсе.
</p>
</div>
<div class="ps-grid ps-grid--3col@xl ps-grid--gap-xl">
<div class="ps-grid-span-1">
<article class="ps-card ps-card--elevated ps-animate-fade-up">
<div class="ps-card-header">
<h2 class="ps-card-title">Мои объекты парковки</h2>
</div>
<ul class="ps-list">
{% for lot in lots %}
<li class="ps-list-item">
<div class="ps-list-main">
<div class="ps-list-title">
{{ lot.city }}, {{ lot.name }}
</div>
<div class="ps-list-subtitle">
{{ lot.get_parking_type_display }} · мест: {{ lot.spots.count }}
</div>
</div>
<span class="ps-badge ps-badge--neutral">
{{ lot.created_at|date:"d.m.Y" }}
</span>
</li>
{% empty %}
<li class="ps-list-empty">
Пока нет ни одного объекта. Добавьте парковку через web-интерфейс владельца.
</li>
{% endfor %}
</ul>
</article>
<article class="ps-card ps-animate-fade-up ps-animate-delay-1">
<div class="ps-card-header">
<h2 class="ps-card-title">Места</h2>
</div>
<ul class="ps-list ps-list--compact">
{% for spot in spots %}
<li class="ps-list-item">
<div class="ps-list-main">
<div class="ps-list-title">
{{ spot.lot.city }}, {{ spot.lot.name }} — {{ spot.name }}
</div>
<div class="ps-list-subtitle">
Тип: {{ spot.get_vehicle_type_display }} · {{ spot.hourly_price }} ₽/ч
</div>
</div>
<span class="ps-badge ps-badge--status-{{ spot.status }}">
{{ spot.get_status_display }}
</span>
</li>
{% empty %}
<li class="ps-list-empty">
Мест пока нет.
</li>
{% endfor %}
</ul>
</article>
</div>
<div class="ps-grid-span-2">
<article class="ps-card ps-card--elevated ps-animate-fade-up">
<div class="ps-card-header">
<h2 class="ps-card-title">Бронирования по моим местам</h2>
</div>
<div class="ps-table-wrapper">
<table class="ps-table">
<thead>
<tr>
<th>Место</th>
<th>Пользователь</th>
<th>Период</th>
<th>Статус</th>
<th>Сумма</th>
</tr>
</thead>
<tbody>
{% for booking in bookings %}
<tr class="ps-animate-fade-up ps-animate-stagger">
<td data-label="Место">
{{ booking.spot.lot.city }},
{{ booking.spot.lot.name }} — {{ booking.spot.name }}
</td>
<td data-label="Пользователь">
{{ booking.user.username }}
</td>
<td data-label="Период">
{{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
</td>
<td data-label="Статус">
<span class="ps-badge ps-badge--status-{{ booking.status }}">
{{ booking.get_status_display }}
</span>
</td>
<td data-label="Сумма">
{{ booking.total_price }} ₽
</td>
</tr>
{% empty %}
<tr>
<td colspan="5" class="ps-empty">
По вашим местам ещё не было бронирований.
</td>
</tr>
{% endfor %}
</tbody>
</table>
</div>
</article>
</div>
</div>
</section>
{% endblock %}

# File 153/163: templates\parking\pwa_install.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}Установить ParkShare как приложение{% endblock %}
{% block content %}
<section class="ps-section ps-section--flush-top">
<div class="ps-section-header ps-section-header--stack">
<div>
<h1 class="ps-section-title">Установите ParkShare RU на главный экран</h1>
<p class="ps-section-subtitle">PWA работает оффлайн, даёт быстрый доступ к брони и чату.</p>
</div>
</div>
<div class="ps-grid ps-grid--2col@lg ps-grid--gap-lg ps-grid--mobile-stack">
<article class="ps-card ps-card--elevated">
<div class="ps-card-header">
<h3 class="ps-card-title">Android / Chrome</h3>
</div>
<div class="ps-card-body">
<ol class="ps-list-ordered">
<li>Нажмите <strong>⋮</strong> в правом верхнем углу браузера.</li>
<li>Выберите пункт <strong>«Установить приложение»</strong> или <strong>«Добавить на главный экран»</strong>.</li>
<li>Подтвердите установку — ярлык появится рядом с другими приложениями.</li>
</ol>
<p class="ps-card-line ps-card-line--muted">Если видите баннер установки — нажмите «Установить» прямо в нём.</p>
</div>
</article>
<article class="ps-card ps-card--elevated">
<div class="ps-card-header">
<h3 class="ps-card-title">iOS / Safari</h3>
</div>
<div class="ps-card-body">
<ol class="ps-list-ordered">
<li>Нажмите кнопку «Поделиться» (квадрат со стрелкой вверх).</li>
<li>Прокрутите список и выберите <strong>«На экран “Домой”»</strong>.</li>
<li>Нажмите «Добавить» — появится значок ParkShare.</li>
</ol>
<p class="ps-card-line ps-card-line--muted">После добавления приложение работает без адресной строки и занимает весь экран.</p>
</div>
</article>
</div>
</section>
{% endblock %}

# File 154/163: templates\parking\user_dashboard.html
################################################################################

{% extends "base.html" %}
{% load static %}
{% block title %}ParkShare RU — личный кабинет{% endblock %}
{% block content %}
<section class="ps-section">
<div class="ps-section-header">
<h1 class="ps-section-title">Личный кабинет водителя</h1>
<p class="ps-section-subtitle">
Здесь собраны ваши машины и все активные бронирования.
</p>
</div>
<div class="ps-grid ps-grid--3col@lg ps-grid--gap-xl">
<div class="ps-grid-span-1">
<article class="ps-card ps-card--elevated ps-animate-fade-up">
<div class="ps-card-header">
<h2 class="ps-card-title">Профиль</h2>
</div>
<div class="ps-card-body">
<p class="ps-card-line">
<span class="ps-label">Логин:</span> {{ user.username }}
</p>
<p class="ps-card-line">
<span class="ps-label">Роль:</span> {{ user.get_role_display }}
</p>
<div class="ps-progress-block">
<div class="ps-progress-header">
<span class="ps-badge">Уровень 1 · Новичок</span>
<span class="ps-progress-label">До следующего уровня: 3 бронирования</span>
</div>
<div class="ps-progress">
<div class="ps-progress-bar" style="width: 45%"></div>
</div>
</div>
<a href="{% url 'accounts:profile' %}" class="ps-btn ps-btn-full">
Настройки профиля
</a>
</div>
</article>
<article class="ps-card ps-animate-fade-up">
<div class="ps-card-header">
<h2 class="ps-card-title">Способы оплаты</h2>
</div>
<div class="ps-card-body ps-card-body--spacing-lg">
<div class="ps-payment-list" data-payment-methods>
<div class="ps-empty">Карты ещё не добавлены. Подключите карту, чтобы бронировать без ввода данных.</div>
</div>
<div class="ps-divider"></div>
<form class="ps-form ps-form-compact" method="post" action="
<div class="ps-form-row">
<label class="ps-form-label">Номер карты / токен</label>
<input class="ps-input" type="text" name="card_number" placeholder="**** **** **** 1234" autocomplete="off">
<div class="ps-field-help">Данные токенизируются у провайдера, мы храним только маску.</div>
</div>
<div class="ps-form-row ps-form-row--inline">
<input class="ps-input" type="text" name="exp" placeholder="MM/YY">
<input class="ps-input" type="text" name="label" placeholder="Личная / Работа">
</div>
<div class="ps-form-row ps-form-row--inline">
<select class="ps-input" name="provider">
<option value="sber">Сбербанк</option>
<option value="tinkoff">Тинькофф</option>
<option value="other">YooKassa / другое</option>
</select>
<label class="ps-checkbox ps-checkbox--inline">
<input type="checkbox" name="is_default">
<span>Сделать по умолчанию</span>
</label>
</div>
<div class="ps-form-actions">
<button class="ps-btn ps-btn-primary ps-btn-full" type="submit">Сохранить карту</button>
</div>
</form>
</div>
</article>
<article class="ps-card ps-animate-fade-up ps-animate-delay-1">
<div class="ps-card-header">
<h2 class="ps-card-title">Мои машины</h2>
</div>
<ul class="ps-list">
{% for vehicle in vehicles %}
<li class="ps-list-item">
<div class="ps-list-main">
<div class="ps-list-title">
{{ vehicle.label|default:"Без названия" }}
</div>
<div class="ps-list-subtitle">
{{ vehicle.get_vehicle_type_display }}
</div>
</div>
<span class="ps-badge ps-badge--neutral">
{{ vehicle.created_at|date:"d.m.Y" }}
</span>
</li>
{% empty %}
<li class="ps-list-empty">
Пока ни одной машины. Добавьте машину через мобильный интерфейс ParkShare RU.
</li>
{% endfor %}
</ul>
</article>
</div>
<div class="ps-grid-span-2">
<article class="ps-card ps-card--elevated ps-animate-fade-up">
<div class="ps-card-header">
<h2 class="ps-card-title">Мои бронирования</h2>
</div>
<div class="ps-table-wrapper">
<table class="ps-table">
<thead>
<tr>
<th>Место</th>
<th>Тип</th>
<th>Период</th>
<th>Статус</th>
<th>Сумма</th>
</tr>
</thead>
<tbody>
{% for booking in bookings %}
<tr class="ps-animate-fade-up ps-animate-stagger">
<td data-label="Место">
{{ booking.spot.lot.city }},
{{ booking.spot.lot.name }} — {{ booking.spot.name }}
</td>
<td data-label="Тип">
{{ booking.get_booking_type_display }}
</td>
<td data-label="Период">
{{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
</td>
<td data-label="Статус">
<span class="ps-badge ps-badge--status-{{ booking.status }}">
{{ booking.get_status_display }}
</span>
</td>
<td data-label="Сумма">
{{ booking.total_price }} ₽
{% if booking.status == 'confirmed' or booking.status == 'active' or booking.status == 'completed' %}
<span class="ps-badge ps-badge--success">+10 опыта</span>
{% endif %}
</td>
</tr>
{% empty %}
<tr>
<td colspan="5" class="ps-empty">
У вас пока нет бронирований.
</td>
</tr>
{% endfor %}
</tbody>
</table>
</div>
</article>
</div>
</div>
</section>
{% endblock %}

# File 155/163: vehicles\__init__.py
################################################################################



# File 156/163: vehicles\admin.py
################################################################################

# vehicles/admin.py
from django.contrib import admin
from .models import Vehicle
@admin.register(Vehicle)
class VehicleAdmin(admin.ModelAdmin):
list_display = ("label", "owner", "vehicle_type", "created_at")
list_filter = ("vehicle_type", "created_at")
search_fields = ("label", "owner__username")
readonly_fields = ("plate_hash", "created_at")
def has_view_or_change_permission(self, request, obj=None):
"""
В админку по умолчанию имеет доступ только персонал,
так что дополнительных ограничений не вводим.
"""
return super().has_view_or_change_permission(request, obj)

# File 157/163: vehicles\apps.py
################################################################################

# vehicles/apps.py
from django.apps import AppConfig
class VehiclesConfig(AppConfig):
default_auto_field = "django.db.models.BigAutoField"
name = "vehicles"
verbose_name = "Машины пользователей"

# File 158/163: vehicles\models.py
################################################################################

import uuid
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _
from core.models import TimeStampedModel
class Vehicle(TimeStampedModel):
"""
Машина пользователя.
Важно:
- реальный госномер нигде не хранится;
- в БД есть только хэш цифр номера и произвольная метка (label).
"""
class VehicleType(models.TextChoices):
CAR = "car", _("Легковой автомобиль")
MOTO = "moto", _("Мотоцикл")
COMMERCIAL = "commercial", _("Коммерческий транспорт")
id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
owner = models.ForeignKey(
settings.AUTH_USER_MODEL,
on_delete=models.CASCADE,
related_name="vehicles",
verbose_name=_("Владелец"),
)
label = models.CharField(
_("Название/описание"),
max_length=64,
blank=True,
help_text=_("Например: «Серая Toyota у дома»."),
)
vehicle_type = models.CharField(
_("Тип транспорта"),
max_length=16,
choices=VehicleType.choices,
default=VehicleType.CAR,
)
plate_hash = models.CharField(
_("Хэш номера"),
max_length=64,
db_index=True,
help_text=_("SHA‑256‑хэш цифр госномера с солью."),
)
class Meta:
verbose_name = _("Машина")
verbose_name_plural = _("Машины")
unique_together = (("owner", "plate_hash"),)
ordering = ("-created_at",)
def __str__(self) -> str:
if self.label:
return f"{self.label} ({self.owner.username})"
return f"Машина {self.pk}"

# File 159/163: vehicles\serializers.py
################################################################################

# vehicles/serializers.py
from django.utils.translation import gettext_lazy as _
from rest_framework import serializers
from core.utils import hash_plate_digits
from .models import Vehicle
class VehicleSerializer(serializers.ModelSerializer):
"""
Сериализатор для машин.
Вход:
- plate_number (write_only) — строка номера, хэшируется на сервере;
- label, vehicle_type.
Выход:
- id, label, vehicle_type, created_at.
"""
plate_number = serializers.CharField(
write_only=True,
label=_("Госномер"),
help_text=_(
"Фактический номер будет преобразован в хэш и не будет храниться в открытом виде."
),
)
class Meta:
model = Vehicle
fields = ("id", "label", "vehicle_type", "plate_number", "created_at")
read_only_fields = ("id", "created_at")
def validate_plate_number(self, value: str) -> str:
digits = "".join(ch for ch in value if ch.isdigit())
if not digits:
raise serializers.ValidationError(
_("Нужно указать хотя бы одну цифру номера.")
)
return value
def create(self, validated_data: dict) -> Vehicle:
request = self.context["request"]
user = request.user
plate_number = validated_data.pop("plate_number")
plate_hash = hash_plate_digits(plate_number)
if Vehicle.objects.filter(owner=user, plate_hash=plate_hash).exists():
raise serializers.ValidationError(
{
"plate_number": _(
"Машина с таким номером уже добавлена в ваш список."
)
}
)
vehicle = Vehicle.objects.create(
owner=user,
plate_hash=plate_hash,
**validated_data,
)
return vehicle
def update(self, instance: Vehicle, validated_data: dict) -> Vehicle:
# Номер менять нельзя (потребует создания нового объекта),
# поэтому игнорируем plate_number при обновлении.
validated_data.pop("plate_number", None)
return super().update(instance, validated_data)

# File 160/163: vehicles\urls.py
################################################################################

# vehicles/urls.py
from django.contrib.auth.decorators import login_required
from django.urls import path
from django.views.generic import TemplateView
app_name = "vehicles"
urlpatterns = [
# Простая HTML-страница «Мои машины» (можно использовать в будущем).
path(
"my/",
login_required(
TemplateView.as_view(template_name="vehicles/my_vehicles.html")
),
name="my_vehicles",
),
]

# File 161/163: vehicles\views.py
################################################################################

# vehicles/views.py
from rest_framework import permissions, viewsets
from core.permissions import IsOwnerObject
from .models import Vehicle
from .serializers import VehicleSerializer
class VehicleViewSet(viewsets.ModelViewSet):
"""
API для машин пользователя.
- /api/vehicles/              (GET)   — список машин текущего пользователя
- /api/vehicles/              (POST)  — создать машину (номер хэшируется)
- /api/vehicles/{id}/         (GET)   — детали (только владелец)
- /api/vehicles/{id}/         (PATCH/PUT/DELETE) — управление машиной (только владелец)
"""
serializer_class = VehicleSerializer
permission_classes = [permissions.IsAuthenticated, IsOwnerObject]
def get_queryset(self):
user = self.request.user
if not user.is_authenticated:
return Vehicle.objects.none()
return Vehicle.objects.filter(owner=user).order_by("-created_at")
def perform_create(self, serializer: VehicleSerializer) -> None:
# owner устанавливается в serializer.create()
serializer.save()

# File 162/163: vehicles\migrations\0001_initial.py
################################################################################

# Generated by Django 5.2.8 on 2025-11-21 21:34
import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models
class Migration(migrations.Migration):
initial = True
dependencies = [
migrations.swappable_dependency(settings.AUTH_USER_MODEL),
]
operations = [
migrations.CreateModel(
name='Vehicle',
fields=[
('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
('label', models.CharField(blank=True, help_text='Например: «Серая Toyota у дома».', max_length=64, verbose_name='Название/описание')),
('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
('plate_hash', models.CharField(db_index=True, help_text='SHA‑256‑хэш цифр госномера с солью.', max_length=64, verbose_name='Хэш номера')),
('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='vehicles', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
],
options={
'verbose_name': 'Машина',
'verbose_name_plural': 'Машины',
'ordering': ('-created_at',),
'unique_together': {('owner', 'plate_hash')},
},
),
]

# File 163/163: vehicles\migrations\__init__.py
################################################################################



