################################################################################
# FULL PROJECT DUMP (NO TRUNCATION)
# FORMAT FOR LLM:
#   1) PROJECT TREE — общая структура проекта.
#   2) FILES INDEX — плоский список файлов с путём и языком.
#   3) FILES CONTENT — для каждого файла:
#        ===== FILE START =====
#        FILE_INDEX: <N>
#        PATH: <relative/path>
#        LANG: <language>
#        ===== CONTENT START =====
#        <raw file content>
#        ===== CONTENT END =====
#        ===== FILE END =====
#   Файлы идут в том же порядке, что и в индексе.
################################################################################
# Root: C:\Users\Sultan\Downloads\parkshare_ru_part1
# Generated at: 2025-12-08 18:11:29
# Files listed: 308
# Max single file size: NONE
# Max total dump size: NONE
# Code compression enabled: False
################################################################################
PROJECT TREE:
--------------------------------------------------------------------------------
parkshare_ru_part1/
    .env
    .env.example
    .env.prod
    .gitattributes
    .gitignore
    .ruff.toml
    Dockerfile
    Makefile
    README.md
    api_server.py
    app.js
    celerybeat-schedule.bak
    celerybeat-schedule.dat
    celerybeat-schedule.dir
    chat_test.py
    chat_test_len.py
    count_spots.py
    database.py
    docker-compose.prod.yml
    docker-compose.yml
    dump_project.py
    entrypoint.sh
    index.html
    model_training.py
    mypy.ini
    print_base.py
    print_llm_env.py
    project_dump.txt
    requirements.txt
    run_dev.bat
    run_dev.py
    run_dev.sh
    accounts/
        __init__.py
        admin.py
        apps.py
        auth.py
        authentication.py
        forms.py
        models.py
        oauth.py
        serializers.py
        urls.py
        utils.py
        views.py
        migrations/
            0001_initial.py
            0002_user_email_hash_user_phone_hash_logincode.py
            0003_userlevel_userbadge_promoreward.py
            0004_socialaccount.py
            0005_logincode_attempts_status.py
            0006_user_mfa_fields.py
            0007_user_last_mfa_change.py
            0008_rename_accounts_so_provide_3a0cdb_idx_accounts_so_provide_98721f_idx_and_more.py
            __init__.py
        tests/
            __init__.py
            test_mfa.py
    ai/
        __init__.py
        admin.py
        apps.py
        features.py
        models.py
        orchestrator.py
        pricing.py
        serializers.py
        tasks.py
        tools.py
        views.py
        chat/
            __init__.py
            parking_assistant.py
        management/
            __init__.py
            commands/
                __init__.py
                train_chat_intents_from_logs.py
        migrations/
            0001_initial.py
            __init__.py
        tests/
            __init__.py
            test_assistant_sessions.py
    ai_models/
    ai_services/
        __init__.py
        ai_pricing_service/
            __init__.py
            main.py
        cv_service/
            __init__.py
            main.py
    backend/
        __init__.py
        manage.py
        backend/
            __init__.py
            health.py
            config/
                __init__.py
                asgi.py
                celery.py
                urls.py
                wsgi.py
            settings/
                __init__.py
                base.py
                local.py
                production.py
                regions.py
        rest_framework_simplejwt/
            __init__.py
            authentication.py
            tokens.py
            views.py
        tests/
            __init__.py
            test_access_control.py
            test_analytics.py
            test_assistant_tools.py
            test_auth_api.py
            test_auth_mfa.py
            test_billing_modes.py
            test_booking_model.py
            test_business_reports.py
            test_error_formats.py
            test_health.py
            test_input_limits.py
            test_maintenance_mode.py
            test_notification_scheduling.py
            test_notification_settings.py
            test_offline_onboarding.py
            test_payment_methods_view.py
            test_preferences_view.py
            test_promo_activate.py
            test_security_headers.py
            test_ui_theme_chat.py
    core/
        __init__.py
        admin.py
        api_keys.py
        apps.py
        context_processors.py
        db_router.py
        feature_flags.py
        integrations.py
        metrics.py
        middleware.py
        models.py
        observability.py
        pagination.py
        permissions.py
        sms.py
        utils.py
        management/
            __init__.py
            commands/
                __init__.py
                migrate_safe.py
        migrations/
            0001_initial.py
            0002_rename_core_audit_action_6abf09_idx_core_auditl_action_d9fb24_idx_and_more.py
            __init__.py
        tests/
            test_feature_flags.py
    docs/
        auth_mfa_and_social_login.md
        deploy.md
    drf_spectacular/
        __init__.py
        openapi.py
        views.py
    frontend/
        next-app/
            .env.local
            .eslintrc.json
            Dockerfile
            jest.config.js
            jest.setup.ts
            next-env.d.ts
            next.config.mjs
            package.json
            postcss.config.js
            tailwind.config.ts
            tsconfig.json
            app/
                globals.css
                layout.tsx
                (site)/
                    layout.tsx
                    page.tsx
                    auth/
                        page.tsx
                api/
                    chat/
                        route.ts
                embed/
                    page.tsx
            components/
                header.tsx
                providers.tsx
                theme-provider.tsx
                theme-toggle.tsx
                auth/
                    SocialLoginButtons.tsx
                chat/
                    chat-panel.tsx
                    compact-chat-panel.tsx
                    conversation-list.tsx
                    markdown-message.tsx
                    suggested-prompts.tsx
                    types.ts
                pwa/
                    register-service-worker.tsx
                widget/
                    chat-widget.tsx
            context/
                AuthContext.tsx
            hooks/
                useAuth.ts
            lib/
                aiProvider.ts
                apiClient.ts
                apiTypes.ts
                authClient.ts
                authStorage.ts
                bottomSheet.ts
                chatClient.ts
                llmClient.ts
            public/
                manifest.webmanifest
                offline.html
                service-worker.js
                icons/
            __tests__/
                bottom-sheet.test.ts
                chat-client.test.ts
                conversation-list.test.tsx
                social-login-buttons.test.tsx
        parkmate/
            parkmate.types.ts
    k8s/
        beat-deployment.yaml
        configmap.yaml
        hpa.yaml
        ingress.yaml
        secret-example.yaml
        web-deployment.yaml
        web-service.yaml
        worker-deployment.yaml
    nginx/
        nginx.conf
    parking/
        __init__.py
        admin.py
        apps.py
        models.py
        models_notification.py
        push.py
        serializers.py
        tasks.py
        urls.py
        views.py
        analytics/
            __init__.py
        management/
            commands/
                seed_demo_parking.py
                send_expiry_notifications.py
        migrations/
            0001_initial.py
            0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
            0003_booking_ai_fields.py
            0004_favoriteparkingspot_savedplace.py
            0005_pushsubscription.py
            0006_booking_billing_mode.py
            0007_notificationsettings.py
            0008_indexes.py
            0009_remove_booking_booking_time_idx_and_more.py
            __init__.py
        notifications/
            __init__.py
        tests/
            __init__.py
            test_mobile_api.py
            test_pwa_endpoints.py
    payments/
        __init__.py
        admin.py
        apps.py
        models.py
        providers.py
        serializers.py
        tasks.py
        views.py
        migrations/
            0001_initial.py
            0002_alter_payment_provider.py
            0003_paymentmethod.py
            __init__.py
        providers/
            __init__.py
            base.py
            registry.py
            stripe.py
            yookassa.py
    regions/
        global.yml
        ru.yml
    services/
        __init__.py
        llm.py
        llm_service/
            Dockerfile
            main.py
            requirements.txt
    static/
        manifest.webmanifest
        service-worker.js
        css/
            app.css
            cinematic-ui.css
        icons/
        js/
            app.js
            chat.js
            map.js
            parkmate-ai.ts
            quantum-theme-manager.js
            theme.js
        pwa/
            api-client.js
            app.js
            router.js
            spots-view.js
            state-store.js
            ui-kit.js
    templates/
        base.html
        offline.html
        accounts/
            login.html
            mfa_setup.html
            mfa_verify.html
            password_change.html
            password_change_done.html
            password_reset.html
            password_reset_complete.html
            password_reset_confirm.html
            password_reset_done.html
            password_reset_email.txt
            password_reset_subject.txt
            profile.html
            register.html
        admin/
            metrics.html
        ai/
            concierge.html
        parking/
            booking_confirm.html
            business_reports.html
            landing.html
            map_fullscreen.html
            owner_dashboard.html
            payment_methods.html
            profile_settings.html
            promo_activate.html
            pwa_install.html
            user_dashboard.html
    vehicles/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py


FILES INDEX:
--------------------------------------------------------------------------------
1. PATH=.env | LANG=text
2. PATH=.env.example | LANG=text
3. PATH=.env.prod | LANG=text
4. PATH=.gitattributes | LANG=text
5. PATH=.gitignore | LANG=text
6. PATH=.ruff.toml | LANG=toml
7. PATH=Dockerfile | LANG=text
8. PATH=Makefile | LANG=text
9. PATH=README.md | LANG=markdown
10. PATH=api_server.py | LANG=python
11. PATH=app.js | LANG=javascript
12. PATH=celerybeat-schedule.bak | LANG=text
13. PATH=celerybeat-schedule.dat | LANG=text
14. PATH=celerybeat-schedule.dir | LANG=text
15. PATH=chat_test.py | LANG=python
16. PATH=chat_test_len.py | LANG=python
17. PATH=count_spots.py | LANG=python
18. PATH=database.py | LANG=python
19. PATH=docker-compose.prod.yml | LANG=yaml
20. PATH=docker-compose.yml | LANG=yaml
21. PATH=dump_project.py | LANG=python
22. PATH=entrypoint.sh | LANG=bash
23. PATH=index.html | LANG=html
24. PATH=model_training.py | LANG=python
25. PATH=mypy.ini | LANG=ini
26. PATH=print_base.py | LANG=python
27. PATH=print_llm_env.py | LANG=python
28. PATH=project_dump.txt | LANG=text
29. PATH=requirements.txt | LANG=text
30. PATH=run_dev.bat | LANG=batch
31. PATH=run_dev.py | LANG=python
32. PATH=run_dev.sh | LANG=bash
33. PATH=accounts\__init__.py | LANG=python
34. PATH=accounts\admin.py | LANG=python
35. PATH=accounts\apps.py | LANG=python
36. PATH=accounts\auth.py | LANG=python
37. PATH=accounts\authentication.py | LANG=python
38. PATH=accounts\forms.py | LANG=python
39. PATH=accounts\models.py | LANG=python
40. PATH=accounts\oauth.py | LANG=python
41. PATH=accounts\serializers.py | LANG=python
42. PATH=accounts\urls.py | LANG=python
43. PATH=accounts\utils.py | LANG=python
44. PATH=accounts\views.py | LANG=python
45. PATH=accounts\migrations\0001_initial.py | LANG=python
46. PATH=accounts\migrations\0002_user_email_hash_user_phone_hash_logincode.py | LANG=python
47. PATH=accounts\migrations\0003_userlevel_userbadge_promoreward.py | LANG=python
48. PATH=accounts\migrations\0004_socialaccount.py | LANG=python
49. PATH=accounts\migrations\0005_logincode_attempts_status.py | LANG=python
50. PATH=accounts\migrations\0006_user_mfa_fields.py | LANG=python
51. PATH=accounts\migrations\0007_user_last_mfa_change.py | LANG=python
52. PATH=accounts\migrations\0008_rename_accounts_so_provide_3a0cdb_idx_accounts_so_provide_98721f_idx_and_more.py | LANG=python
53. PATH=accounts\migrations\__init__.py | LANG=python
54. PATH=accounts\tests\__init__.py | LANG=python
55. PATH=accounts\tests\test_mfa.py | LANG=python
56. PATH=ai\__init__.py | LANG=python
57. PATH=ai\admin.py | LANG=python
58. PATH=ai\apps.py | LANG=python
59. PATH=ai\features.py | LANG=python
60. PATH=ai\models.py | LANG=python
61. PATH=ai\orchestrator.py | LANG=python
62. PATH=ai\pricing.py | LANG=python
63. PATH=ai\serializers.py | LANG=python
64. PATH=ai\tasks.py | LANG=python
65. PATH=ai\tools.py | LANG=python
66. PATH=ai\views.py | LANG=python
67. PATH=ai\chat\__init__.py | LANG=python
68. PATH=ai\chat\parking_assistant.py | LANG=python
69. PATH=ai\management\__init__.py | LANG=python
70. PATH=ai\management\commands\__init__.py | LANG=python
71. PATH=ai\management\commands\train_chat_intents_from_logs.py | LANG=python
72. PATH=ai\migrations\0001_initial.py | LANG=python
73. PATH=ai\migrations\__init__.py | LANG=python
74. PATH=ai\tests\__init__.py | LANG=python
75. PATH=ai\tests\test_assistant_sessions.py | LANG=python
76. PATH=ai_services\__init__.py | LANG=python
77. PATH=ai_services\ai_pricing_service\__init__.py | LANG=python
78. PATH=ai_services\ai_pricing_service\main.py | LANG=python
79. PATH=ai_services\cv_service\__init__.py | LANG=python
80. PATH=ai_services\cv_service\main.py | LANG=python
81. PATH=backend\__init__.py | LANG=python
82. PATH=backend\manage.py | LANG=python
83. PATH=backend\backend\__init__.py | LANG=python
84. PATH=backend\backend\health.py | LANG=python
85. PATH=backend\backend\config\__init__.py | LANG=python
86. PATH=backend\backend\config\asgi.py | LANG=python
87. PATH=backend\backend\config\celery.py | LANG=python
88. PATH=backend\backend\config\urls.py | LANG=python
89. PATH=backend\backend\config\wsgi.py | LANG=python
90. PATH=backend\backend\settings\__init__.py | LANG=python
91. PATH=backend\backend\settings\base.py | LANG=python
92. PATH=backend\backend\settings\local.py | LANG=python
93. PATH=backend\backend\settings\production.py | LANG=python
94. PATH=backend\backend\settings\regions.py | LANG=python
95. PATH=backend\rest_framework_simplejwt\__init__.py | LANG=python
96. PATH=backend\rest_framework_simplejwt\authentication.py | LANG=python
97. PATH=backend\rest_framework_simplejwt\tokens.py | LANG=python
98. PATH=backend\rest_framework_simplejwt\views.py | LANG=python
99. PATH=backend\tests\__init__.py | LANG=python
100. PATH=backend\tests\test_access_control.py | LANG=python
101. PATH=backend\tests\test_analytics.py | LANG=python
102. PATH=backend\tests\test_assistant_tools.py | LANG=python
103. PATH=backend\tests\test_auth_api.py | LANG=python
104. PATH=backend\tests\test_auth_mfa.py | LANG=python
105. PATH=backend\tests\test_billing_modes.py | LANG=python
106. PATH=backend\tests\test_booking_model.py | LANG=python
107. PATH=backend\tests\test_business_reports.py | LANG=python
108. PATH=backend\tests\test_error_formats.py | LANG=python
109. PATH=backend\tests\test_health.py | LANG=python
110. PATH=backend\tests\test_input_limits.py | LANG=python
111. PATH=backend\tests\test_maintenance_mode.py | LANG=python
112. PATH=backend\tests\test_notification_scheduling.py | LANG=python
113. PATH=backend\tests\test_notification_settings.py | LANG=python
114. PATH=backend\tests\test_offline_onboarding.py | LANG=python
115. PATH=backend\tests\test_payment_methods_view.py | LANG=python
116. PATH=backend\tests\test_preferences_view.py | LANG=python
117. PATH=backend\tests\test_promo_activate.py | LANG=python
118. PATH=backend\tests\test_security_headers.py | LANG=python
119. PATH=backend\tests\test_ui_theme_chat.py | LANG=python
120. PATH=core\__init__.py | LANG=python
121. PATH=core\admin.py | LANG=python
122. PATH=core\api_keys.py | LANG=python
123. PATH=core\apps.py | LANG=python
124. PATH=core\context_processors.py | LANG=python
125. PATH=core\db_router.py | LANG=python
126. PATH=core\feature_flags.py | LANG=python
127. PATH=core\integrations.py | LANG=python
128. PATH=core\metrics.py | LANG=python
129. PATH=core\middleware.py | LANG=python
130. PATH=core\models.py | LANG=python
131. PATH=core\observability.py | LANG=python
132. PATH=core\pagination.py | LANG=python
133. PATH=core\permissions.py | LANG=python
134. PATH=core\sms.py | LANG=python
135. PATH=core\utils.py | LANG=python
136. PATH=core\management\__init__.py | LANG=python
137. PATH=core\management\commands\__init__.py | LANG=python
138. PATH=core\management\commands\migrate_safe.py | LANG=python
139. PATH=core\migrations\0001_initial.py | LANG=python
140. PATH=core\migrations\0002_rename_core_audit_action_6abf09_idx_core_auditl_action_d9fb24_idx_and_more.py | LANG=python
141. PATH=core\migrations\__init__.py | LANG=python
142. PATH=core\tests\test_feature_flags.py | LANG=python
143. PATH=docs\auth_mfa_and_social_login.md | LANG=markdown
144. PATH=docs\deploy.md | LANG=markdown
145. PATH=drf_spectacular\__init__.py | LANG=python
146. PATH=drf_spectacular\openapi.py | LANG=python
147. PATH=drf_spectacular\views.py | LANG=python
148. PATH=frontend\next-app\.env.local | LANG=text
149. PATH=frontend\next-app\.eslintrc.json | LANG=json
150. PATH=frontend\next-app\Dockerfile | LANG=text
151. PATH=frontend\next-app\jest.config.js | LANG=javascript
152. PATH=frontend\next-app\jest.setup.ts | LANG=typescript
153. PATH=frontend\next-app\next-env.d.ts | LANG=typescript
154. PATH=frontend\next-app\next.config.mjs | LANG=text
155. PATH=frontend\next-app\package.json | LANG=json
156. PATH=frontend\next-app\postcss.config.js | LANG=javascript
157. PATH=frontend\next-app\tailwind.config.ts | LANG=typescript
158. PATH=frontend\next-app\tsconfig.json | LANG=json
159. PATH=frontend\next-app\app\globals.css | LANG=css
160. PATH=frontend\next-app\app\layout.tsx | LANG=tsx
161. PATH=frontend\next-app\app\(site)\layout.tsx | LANG=tsx
162. PATH=frontend\next-app\app\(site)\page.tsx | LANG=tsx
163. PATH=frontend\next-app\app\(site)\auth\page.tsx | LANG=tsx
164. PATH=frontend\next-app\app\api\chat\route.ts | LANG=typescript
165. PATH=frontend\next-app\app\embed\page.tsx | LANG=tsx
166. PATH=frontend\next-app\components\header.tsx | LANG=tsx
167. PATH=frontend\next-app\components\providers.tsx | LANG=tsx
168. PATH=frontend\next-app\components\theme-provider.tsx | LANG=tsx
169. PATH=frontend\next-app\components\theme-toggle.tsx | LANG=tsx
170. PATH=frontend\next-app\components\auth\SocialLoginButtons.tsx | LANG=tsx
171. PATH=frontend\next-app\components\chat\chat-panel.tsx | LANG=tsx
172. PATH=frontend\next-app\components\chat\compact-chat-panel.tsx | LANG=tsx
173. PATH=frontend\next-app\components\chat\conversation-list.tsx | LANG=tsx
174. PATH=frontend\next-app\components\chat\markdown-message.tsx | LANG=tsx
175. PATH=frontend\next-app\components\chat\suggested-prompts.tsx | LANG=tsx
176. PATH=frontend\next-app\components\chat\types.ts | LANG=typescript
177. PATH=frontend\next-app\components\pwa\register-service-worker.tsx | LANG=tsx
178. PATH=frontend\next-app\components\widget\chat-widget.tsx | LANG=tsx
179. PATH=frontend\next-app\context\AuthContext.tsx | LANG=tsx
180. PATH=frontend\next-app\hooks\useAuth.ts | LANG=typescript
181. PATH=frontend\next-app\lib\aiProvider.ts | LANG=typescript
182. PATH=frontend\next-app\lib\apiClient.ts | LANG=typescript
183. PATH=frontend\next-app\lib\apiTypes.ts | LANG=typescript
184. PATH=frontend\next-app\lib\authClient.ts | LANG=typescript
185. PATH=frontend\next-app\lib\authStorage.ts | LANG=typescript
186. PATH=frontend\next-app\lib\bottomSheet.ts | LANG=typescript
187. PATH=frontend\next-app\lib\chatClient.ts | LANG=typescript
188. PATH=frontend\next-app\lib\llmClient.ts | LANG=typescript
189. PATH=frontend\next-app\public\manifest.webmanifest | LANG=text
190. PATH=frontend\next-app\public\offline.html | LANG=html
191. PATH=frontend\next-app\public\service-worker.js | LANG=javascript
192. PATH=frontend\next-app\__tests__\bottom-sheet.test.ts | LANG=typescript
193. PATH=frontend\next-app\__tests__\chat-client.test.ts | LANG=typescript
194. PATH=frontend\next-app\__tests__\conversation-list.test.tsx | LANG=tsx
195. PATH=frontend\next-app\__tests__\social-login-buttons.test.tsx | LANG=tsx
196. PATH=frontend\parkmate\parkmate.types.ts | LANG=typescript
197. PATH=k8s\beat-deployment.yaml | LANG=yaml
198. PATH=k8s\configmap.yaml | LANG=yaml
199. PATH=k8s\hpa.yaml | LANG=yaml
200. PATH=k8s\ingress.yaml | LANG=yaml
201. PATH=k8s\secret-example.yaml | LANG=yaml
202. PATH=k8s\web-deployment.yaml | LANG=yaml
203. PATH=k8s\web-service.yaml | LANG=yaml
204. PATH=k8s\worker-deployment.yaml | LANG=yaml
205. PATH=nginx\nginx.conf | LANG=text
206. PATH=parking\__init__.py | LANG=python
207. PATH=parking\admin.py | LANG=python
208. PATH=parking\apps.py | LANG=python
209. PATH=parking\models.py | LANG=python
210. PATH=parking\models_notification.py | LANG=python
211. PATH=parking\push.py | LANG=python
212. PATH=parking\serializers.py | LANG=python
213. PATH=parking\tasks.py | LANG=python
214. PATH=parking\urls.py | LANG=python
215. PATH=parking\views.py | LANG=python
216. PATH=parking\analytics\__init__.py | LANG=python
217. PATH=parking\management\commands\seed_demo_parking.py | LANG=python
218. PATH=parking\management\commands\send_expiry_notifications.py | LANG=python
219. PATH=parking\migrations\0001_initial.py | LANG=python
220. PATH=parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py | LANG=python
221. PATH=parking\migrations\0003_booking_ai_fields.py | LANG=python
222. PATH=parking\migrations\0004_favoriteparkingspot_savedplace.py | LANG=python
223. PATH=parking\migrations\0005_pushsubscription.py | LANG=python
224. PATH=parking\migrations\0006_booking_billing_mode.py | LANG=python
225. PATH=parking\migrations\0007_notificationsettings.py | LANG=python
226. PATH=parking\migrations\0008_indexes.py | LANG=python
227. PATH=parking\migrations\0009_remove_booking_booking_time_idx_and_more.py | LANG=python
228. PATH=parking\migrations\__init__.py | LANG=python
229. PATH=parking\notifications\__init__.py | LANG=python
230. PATH=parking\tests\__init__.py | LANG=python
231. PATH=parking\tests\test_mobile_api.py | LANG=python
232. PATH=parking\tests\test_pwa_endpoints.py | LANG=python
233. PATH=payments\__init__.py | LANG=python
234. PATH=payments\admin.py | LANG=python
235. PATH=payments\apps.py | LANG=python
236. PATH=payments\models.py | LANG=python
237. PATH=payments\providers.py | LANG=python
238. PATH=payments\serializers.py | LANG=python
239. PATH=payments\tasks.py | LANG=python
240. PATH=payments\views.py | LANG=python
241. PATH=payments\migrations\0001_initial.py | LANG=python
242. PATH=payments\migrations\0002_alter_payment_provider.py | LANG=python
243. PATH=payments\migrations\0003_paymentmethod.py | LANG=python
244. PATH=payments\migrations\__init__.py | LANG=python
245. PATH=payments\providers\__init__.py | LANG=python
246. PATH=payments\providers\base.py | LANG=python
247. PATH=payments\providers\registry.py | LANG=python
248. PATH=payments\providers\stripe.py | LANG=python
249. PATH=payments\providers\yookassa.py | LANG=python
250. PATH=regions\global.yml | LANG=yaml
251. PATH=regions\ru.yml | LANG=yaml
252. PATH=services\__init__.py | LANG=python
253. PATH=services\llm.py | LANG=python
254. PATH=services\llm_service\Dockerfile | LANG=text
255. PATH=services\llm_service\main.py | LANG=python
256. PATH=services\llm_service\requirements.txt | LANG=text
257. PATH=static\manifest.webmanifest | LANG=text
258. PATH=static\service-worker.js | LANG=javascript
259. PATH=static\css\app.css | LANG=css
260. PATH=static\css\cinematic-ui.css | LANG=css
261. PATH=static\js\app.js | LANG=javascript
262. PATH=static\js\chat.js | LANG=javascript
263. PATH=static\js\map.js | LANG=javascript
264. PATH=static\js\parkmate-ai.ts | LANG=typescript
265. PATH=static\js\quantum-theme-manager.js | LANG=javascript
266. PATH=static\js\theme.js | LANG=javascript
267. PATH=static\pwa\api-client.js | LANG=javascript
268. PATH=static\pwa\app.js | LANG=javascript
269. PATH=static\pwa\router.js | LANG=javascript
270. PATH=static\pwa\spots-view.js | LANG=javascript
271. PATH=static\pwa\state-store.js | LANG=javascript
272. PATH=static\pwa\ui-kit.js | LANG=javascript
273. PATH=templates\base.html | LANG=html
274. PATH=templates\offline.html | LANG=html
275. PATH=templates\accounts\login.html | LANG=html
276. PATH=templates\accounts\mfa_setup.html | LANG=html
277. PATH=templates\accounts\mfa_verify.html | LANG=html
278. PATH=templates\accounts\password_change.html | LANG=html
279. PATH=templates\accounts\password_change_done.html | LANG=html
280. PATH=templates\accounts\password_reset.html | LANG=html
281. PATH=templates\accounts\password_reset_complete.html | LANG=html
282. PATH=templates\accounts\password_reset_confirm.html | LANG=html
283. PATH=templates\accounts\password_reset_done.html | LANG=html
284. PATH=templates\accounts\password_reset_email.txt | LANG=text
285. PATH=templates\accounts\password_reset_subject.txt | LANG=text
286. PATH=templates\accounts\profile.html | LANG=html
287. PATH=templates\accounts\register.html | LANG=html
288. PATH=templates\admin\metrics.html | LANG=html
289. PATH=templates\ai\concierge.html | LANG=html
290. PATH=templates\parking\booking_confirm.html | LANG=html
291. PATH=templates\parking\business_reports.html | LANG=html
292. PATH=templates\parking\landing.html | LANG=html
293. PATH=templates\parking\map_fullscreen.html | LANG=html
294. PATH=templates\parking\owner_dashboard.html | LANG=html
295. PATH=templates\parking\payment_methods.html | LANG=html
296. PATH=templates\parking\profile_settings.html | LANG=html
297. PATH=templates\parking\promo_activate.html | LANG=html
298. PATH=templates\parking\pwa_install.html | LANG=html
299. PATH=templates\parking\user_dashboard.html | LANG=html
300. PATH=vehicles\__init__.py | LANG=python
301. PATH=vehicles\admin.py | LANG=python
302. PATH=vehicles\apps.py | LANG=python
303. PATH=vehicles\models.py | LANG=python
304. PATH=vehicles\serializers.py | LANG=python
305. PATH=vehicles\urls.py | LANG=python
306. PATH=vehicles\views.py | LANG=python
307. PATH=vehicles\migrations\0001_initial.py | LANG=python
308. PATH=vehicles\migrations\__init__.py | LANG=python


================================================================================
FILES CONTENT:
================================================================================

===== FILE START =====
FILE_INDEX: 1
PATH: .env
LANG: text
===== CONTENT START =====
DEBUG=1
SECRET_KEY=change_this_to_a_random_long_string
# or use your existing DJANGO_SECRET_KEY if you have one
ALLOWED_HOSTS=127.0.0.1,localhost
DATABASE_NAME=db.sqlite3

YOOKASSA_SHOP_ID=
YOOKASSA_SECRET_KEY=

EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend


# Карты / регион
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc

# Старый токен Mapbox
MAPBOX_TOKEN=your_actual_token_here

# OPENAI_API_KEY=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

# LLM / AI
LLM_SERVICE_URL=http://127.0.0.1:8002

# OpenAI GPT-3.5
LLM_OPENAI_API_KEY=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

# Основная модель
LLM_DEFAULT_MODEL=gpt-3.5-turbo

# Список fallback-моделей ДОЛЖЕН быть JSON-списком или строкой с запятыми
LLM_FALLBACK_MODELS=["gpt-3.5-turbo"]

#LLM_GROQ_API_KEY=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

# Настройки LLM
LLM_CACHE_ENABLED=true
LLM_CACHE_TTL_SECONDS=30
LLM_REQUESTS_PER_MINUTE=60

# Django Settings
DJANGO_SETTINGS_MODULE=backend.backend.settings.local

# Redis & Celery
REDIS_URL=redis://localhost:6379/0
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0

# Database
DATABASE_URL=sqlite:///db.sqlite3
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 2
PATH: .env.example
LANG: text
===== CONTENT START =====
SECRET_KEY=changeme
DEBUG=True
DATABASE_URL=sqlite:///db.sqlite3
ALLOWED_HOSTS=127.0.0.1,localhost

# Map
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc

# AI / LLM
LLM_PROVIDER=openai
LLM_API_URL=https://api.example.com
LLM_API_KEY=your-llm-key

# Push / WebPush
PUSH_PUBLIC_KEY=
PUSH_PRIVATE_KEY=

# Auth / OTP
AUTH_OTP_CODE_TTL_SECONDS=600
AUTH_OTP_WINDOW_SECONDS=600
AUTH_OTP_MAX_PER_WINDOW=5
AUTH_OTP_MAX_ATTEMPTS=5
SMS_PROVIDER=console
SMS_DEFAULT_FROM=ParkShare
ENABLE_METRICS=True

# Social OAuth
VK_OAUTH_CLIENT_ID=
VK_OAUTH_CLIENT_SECRET=
YANDEX_OAUTH_CLIENT_ID=
YANDEX_OAUTH_CLIENT_SECRET=
GOOGLE_OAUTH_CLIENT_ID=
GOOGLE_OAUTH_CLIENT_SECRET=
SOCIAL_OAUTH_TEST_MODE=True

# Payments
PAYMENT_PROVIDER=yookassa
PAYMENT_API_KEY=
PAYMENT_SHOP_ID=

# Misc
ENABLE_NIGHT_RESTRICTION_NOTICES=False

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 3
PATH: .env.prod
LANG: text
===== CONTENT START =====
# -----------------------------
# DJANGO SETTINGS (PROD)
# -----------------------------
DEBUG=0
SECRET_KEY=django-insecure-поставь_сюда_очень_длинную_строку_символов
ALLOWED_HOSTS=your-domain.ru,your-domain.com,127.0.0.1

DJANGO_SETTINGS_MODULE=backend.settings.production

# -----------------------------
# DATABASE (PostgreSQL / PostGIS)
# -----------------------------
DATABASE_NAME=parkshare
DATABASE_USER=parkshare
DATABASE_PASSWORD=сильный_пароль_к_бд
DATABASE_HOST=db
DATABASE_PORT=5432

# -----------------------------
# YOOKASSA PAYMENTS (боевые реквизиты)
# -----------------------------
YOOKASSA_SHOP_ID=твой_shop_id
YOOKASSA_SECRET_KEY=твой_secret_key

# -----------------------------
# EMAIL SETTINGS
# -----------------------------
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.yandex.ru
EMAIL_PORT=465
EMAIL_USE_SSL=1
EMAIL_HOST_USER=no-reply@your-domain.ru
EMAIL_HOST_PASSWORD=пароль_от_почты

# -----------------------------
# MAP / REGION
# -----------------------------
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc
MAPBOX_TOKEN=your_actual_token_here

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 4
PATH: .gitattributes
LANG: text
===== CONTENT START =====
# Auto detect text files and perform LF normalization
* text=auto

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 5
PATH: .gitignore
LANG: text
===== CONTENT START =====
db.sqlite3
__pycache__/
*.pyc
.env
staticfiles/
frontend/next-app/node_modules/
.next/
node_modules/

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 6
PATH: .ruff.toml
LANG: toml
===== CONTENT START =====
line-length = 120
target-version = "py311"
extend-select = ["B", "E", "F", "W"]
ignore = ["E501"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 7
PATH: Dockerfile
LANG: text
===== CONTENT START =====
# Production-ready Dockerfile
FROM python:3.12-slim AS builder
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    gdal-bin \
    libgdal-dev \
    binutils \
    libproj-dev \
    libgeos-dev \
    libspatialindex-dev \
    gettext \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt
COPY . /app/

RUN python backend/manage.py collectstatic --noinput --settings=backend.backend.settings.production || true

FROM python:3.12-slim AS runtime
ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1
WORKDIR /app

COPY --from=builder /usr/local/lib/python3.12 /usr/local/lib/python3.12
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app /app

EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD curl -f http://localhost:8000/health/ || exit 1
CMD ["gunicorn", "backend.config.wsgi:application", "--bind", "0.0.0.0:8000"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 8
PATH: Makefile
LANG: text
===== CONTENT START =====
PYTHON=python
MANAGE=backend/manage.py

lint:
\truff check .

typecheck:
\tmypy ai parking

test:
\t$(PYTHON) $(MANAGE) test

migrate_safe:
\t$(PYTHON) $(MANAGE) migrate_safe --apply

.PHONY: lint typecheck test migrate_safe

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 9
PATH: README.md
LANG: markdown
===== CONTENT START =====
# ParkShare RU — Django + PWA

Единственная продакшн-UI поверхность — Django-шаблоны (карта, ассистент, бронирования, PWA).

## Архитектура (коротко)
- Backend: Django + DRF (parking/search/booking/payments/metrics/notifications).
- Карта: Yandex/Leaflet абстракция, без Google Maps.
- Ассистент: /api/chat/ (streaming) + ai/tools.py (search/booking/favorite/prefs), preference-aware.
- Биллинг: booking_confirm с billing_mode (pay_as_you_go 15м слоты, prepaid_block 2/4/24h), бизнес-флаг и отчёты.
- Платежи/промо/награды: PaymentMethod, PromoReward, UserLevel/Badge.
- PWA: сервис-воркер, offline shell, onboarding, push, NotificationSettings + send_expiry_notifications.
- Метрики/A-B: UiEvent/Booking/ChatSession, staff dashboard (metrics) с 7/30-дневным срезом и вариантами A/B.

## Запуск (локально)
```bash
pip install -r requirements.txt
python manage.py migrate
python manage.py runserver
```

### Настройки
- Используйте `DJANGO_SETTINGS_MODULE` (`backend.backend.settings.local`/`production`) для выбора профиля.
- Общие параметры лежат в `backend/backend/settings/base.py`; dev/prod наследуют.

## Уведомления
- Включение флагов: профиль → уведомления.
- Отправка напоминаний: `python manage.py send_expiry_notifications --minutes 30`

## Тесты
```bash
python manage.py test
```

## Линт/типизация
```bash
ruff check .
mypy ai parking
```

## Полезные команды
- `make test` — все тесты
- `make lint` — ruff
- `make typecheck` — mypy на основных пакетах
- `python manage.py send_expiry_notifications --minutes 30` — напоминания о завершении брони
- health/ready: `/healthz`, `/readyz`

## Конфигурация (env)
- MAP_PROVIDER / YANDEX_MAP_API_KEY
- LLM_PROVIDER / LLM_API_URL / LLM_API_KEY (для ассистента)
- PUSH_PUBLIC_KEY / PUSH_PRIVATE_KEY (если используете WebPush)
- Billing/Payments: провайдеры/ключи (YooKassa и др.) из `.env`
- Флаги: MAINTENANCE_MODE, ENABLE_EXPERIMENTAL_ASSISTANT, ENABLE_AB_VARIANTS
- Auth: OTP (AUTH_OTP_*), SMS_PROVIDER/SMS_DEFAULT_FROM, OAuth (VK/Yandex/Google client id/secret), ENABLE_METRICS для `/metrics`

## Основные ссылки
- Карта: `/`
- Полная карта: `/map/`
- Ассистент: `/assistant/`
- Бронирование: `/booking/confirm/`
- Платежи: `/payments/methods/`
- Предпочтения/уведомления: `/profile/settings/`
- Промокоды: `/promos/activate/`
- Бизнес-отчёты: `/business/reports/`
- Метрики (staff): `/admin/metrics-lite/`

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 10
PATH: api_server.py
LANG: python
===== CONTENT START =====
# api_server.py
from __future__ import annotations

import datetime as dt
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

import joblib
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from database import get_connection

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"

# --- Загрузка моделей ---

occ_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "occupancy_model.pkl")
OCC_PIPE = occ_bundle["pipeline"]
OCC_FEATURE_COLS = occ_bundle["feature_cols"]

NLP_PIPE = joblib.load(MODELS_DIR / "nlp_intent.pkl")

rec_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "recommender.pkl")
USER_ITEM: pd.DataFrame = rec_bundle["user_item"]
ITEM_SIM: pd.DataFrame = rec_bundle["item_sim"]
LOT_FEATURES: pd.DataFrame = rec_bundle["lot_features"]

# --- FastAPI ---

app = FastAPI(title="ParkShare Local AI", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # при желании ограничить доменом PWA
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ---------- Схемы ----------


class Lot(BaseModel):
    id: int
    name: str
    latitude: float
    longitude: float
    near_metro: bool
    price_level: int
    has_covered: bool
    has_ev_charging: bool
    predicted_occupancy: float


class SearchResult(BaseModel):
    query: str
    intent: str
    time_of_day: Optional[str]
    near_metro: Optional[bool]
    max_price_level: Optional[int]
    has_ev_charging: Optional[bool]
    has_covered: Optional[bool]
    lots: List[Lot]


class OccupancyPredictionResponse(BaseModel):
    lot_id: int
    ts: dt.datetime
    predicted_occupancy: float


class Recommendation(BaseModel):
    lot: Lot
    score: float


class RecommendationsResponse(BaseModel):
    user_id: Optional[int]
    variant: str  # 'A' или 'B' для A/B теста
    recommendations: List[Recommendation]


# ---------- Утилиты ----------


def parse_dt_iso(value: Optional[str]) -> dt.datetime:
    if not value:
        return dt.datetime.now()
    try:
        return dt.datetime.fromisoformat(value)
    except Exception as exc:
        raise HTTPException(status_code=400, detail=f"Неверный формат datetime: {value}") from exc


def nlp_extract_entities(text: str) -> Dict[str, Any]:
    s = text.lower()

    time_of_day = None
    if "утр" in s:
        time_of_day = "morning"
    elif "днем" in s or "днём" in s:
        time_of_day = "day"
    elif "вечер" in s:
        time_of_day = "evening"
    elif "ноч" in s:
        time_of_day = "night"

    near_metro = "метро" in s

    max_price_level: Optional[int] = None
    if "дешев" in s or "недорог" in s:
        max_price_level = 1
    elif "средн" in s:
        max_price_level = 2
    elif "дорог" in s:
        max_price_level = 3

    has_ev = "электро" in s or "зарядк" in s or "ev" in s
    has_covered = "крыт" in s or "подзем" in s or "паркинг" in s

    return {
        "time_of_day": time_of_day,
        "near_metro": near_metro if near_metro else None,
        "max_price_level": max_price_level,
        "has_ev_charging": has_ev if has_ev else None,
        "has_covered": has_covered if has_covered else None,
    }


def build_occ_feature_df(lot_row: Dict[str, Any], ts: dt.datetime) -> pd.DataFrame:
    return pd.DataFrame(
        [
            {
                "hour": ts.hour,
                "dow": ts.weekday(),
                "temperature": 15.0,  # без реальной погоды
                "is_rain": 0,
                "is_event": 0,
                "near_metro": lot_row["near_metro"],
                "price_level": lot_row["price_level"],
                "has_covered": lot_row["has_covered"],
                "has_ev_charging": lot_row["has_ev_charging"],
                "lot_id_str": str(lot_row["id"]),
            }
        ]
    )[OCC_FEATURE_COLS]


def predict_occupancy_for_lot(lot_row: Dict[str, Any], ts: dt.datetime) -> float:
    df = build_occ_feature_df(lot_row, ts)
    pred = float(OCC_PIPE.predict(df)[0])
    return max(0.0, min(pred, 1.0))


def fetch_lots(filters: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
    conn = get_connection()
    cur = conn.cursor()

    base_query = """
        SELECT
            id, name, latitude, longitude,
            near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE 1=1
    """
    params: List[Any] = []

    if filters:
        if filters.get("near_metro") is not None:
            base_query += " AND near_metro = ?"
            params.append(1 if filters["near_metro"] else 0)
        if filters.get("max_price_level") is not None:
            base_query += " AND price_level <= ?"
            params.append(int(filters["max_price_level"]))
        if filters.get("has_ev_charging") is not None:
            base_query += " AND has_ev_charging = ?"
            params.append(1 if filters["has_ev_charging"] else 0)
        if filters.get("has_covered") is not None:
            base_query += " AND has_covered = ?"
            params.append(1 if filters["has_covered"] else 0)

    base_query += " ORDER BY price_level ASC, near_metro DESC"

    cur.execute(base_query, params)
    rows = [dict(r) for r in cur.fetchall()]
    conn.close()
    return rows


# ---------- Эндпоинты ----------


@app.get("/health")
def health() -> Dict[str, Any]:
    return {"status": "ok"}


@app.get("/api/lots", response_model=List[Lot])
def api_list_lots(
    ts: Optional[str] = Query(default=None, description="ISO datetime, по умолчанию — сейчас"),
) -> List[Lot]:
    dt_value = parse_dt_iso(ts)
    lots = fetch_lots()

    result: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        result.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )
    return result


@app.get("/api/occupancy/predict", response_model=OccupancyPredictionResponse)
def api_predict_occupancy(
    lot_id: int = Query(...),
    ts: Optional[str] = Query(default=None),
) -> OccupancyPredictionResponse:
    dt_value = parse_dt_iso(ts)
    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id = ?
        """,
        (lot_id,),
    )
    row = cur.fetchone()
    conn.close()
    if row is None:
        raise HTTPException(status_code=404, detail="Парковка не найдена")
    d = dict(row)
    occ = predict_occupancy_for_lot(d, dt_value)
    return OccupancyPredictionResponse(
        lot_id=lot_id,
        ts=dt_value,
        predicted_occupancy=occ,
    )


@app.get("/api/search", response_model=SearchResult)
def api_search(
    query: str = Query(..., min_length=1),
    ts: Optional[str] = Query(default=None),
    limit: int = Query(default=15, ge=1, le=100),
) -> SearchResult:
    dt_value = parse_dt_iso(ts)

    intent = NLP_PIPE.predict([query])[0]
    entities = nlp_extract_entities(query)

    filters: Dict[str, Any] = {}
    if entities["near_metro"]:
        filters["near_metro"] = True
    if entities["max_price_level"] is not None:
        filters["max_price_level"] = entities["max_price_level"]
    if entities["has_ev_charging"] is not None:
        filters["has_ev_charging"] = entities["has_ev_charging"]
    if entities["has_covered"] is not None:
        filters["has_covered"] = entities["has_covered"]

    if intent == "near_metro":
        filters["near_metro"] = True
    if intent == "cheap" and "max_price_level" not in filters:
        filters["max_price_level"] = 1

    lots = fetch_lots(filters)
    lots = lots[:limit]

    lot_models: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        lot_models.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )

    return SearchResult(
        query=query,
        intent=intent,
        time_of_day=entities["time_of_day"],
        near_metro=filters.get("near_metro"),
        max_price_level=filters.get("max_price_level"),
        has_ev_charging=filters.get("has_ev_charging"),
        has_covered=filters.get("has_covered"),
        lots=lot_models,
    )


def _recommend_item_based(user_id: int, top_n: int = 10) -> List[int]:
    if user_id not in USER_ITEM.index:
        return []

    user_ratings = USER_ITEM.loc[user_id]
    rated_items = user_ratings[user_ratings > 0].index.tolist()
    if not rated_items:
        return []

    scores = pd.Series(0.0, index=USER_ITEM.columns)

    for item_id in rated_items:
        sim_vec = ITEM_SIM.loc[item_id]
        scores += sim_vec * float(user_ratings[item_id])

    scores = scores.drop(rated_items)
    scores = scores.sort_values(ascending=False)
    return scores.head(top_n).index.tolist()


def _recommend_content_based(top_n: int = 10) -> List[int]:
    df = LOT_FEATURES.copy()
    df["score"] = 0.0

    df["score"] += (1 - (df["price_level"] - 1) / 2)  # дешёвые выше
    df["score"] += df["near_metro"] * 0.5
    df["score"] += df["has_ev_charging"] * 0.3
    df["score"] += df["has_covered"] * 0.2

    df = df.sort_values("score", ascending=False)
    return df.head(top_n).index.tolist()


@app.get("/api/recommendations", response_model=RecommendationsResponse)
def api_recommendations(
    user_id: Optional[int] = Query(default=None),
    variant: Optional[str] = Query(
        default=None,
        description="A или B — для A/B тестирования (A=collab, B=content)",
    ),
    limit: int = Query(default=10, ge=1, le=50),
    ts: Optional[str] = Query(default=None),
) -> RecommendationsResponse:
    dt_value = parse_dt_iso(ts)

    chosen_variant = variant or ("A" if user_id else "B")

    if chosen_variant == "A" and user_id is not None:
        item_ids = _recommend_item_based(user_id, top_n=limit)
        if not item_ids:
            chosen_variant = "B"
    if chosen_variant == "B" or user_id is None:
        item_ids = _recommend_content_based(top_n=limit)

    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        f"""
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id IN ({",".join(["?"] * len(item_ids))})
        """,
        item_ids,
    )
    rows = {r["id"]: dict(r) for r in cur.fetchall()}
    conn.close()

    recs: List[Recommendation] = []
    for lot_id in item_ids:
        row = rows.get(lot_id)
        if not row:
            continue
        occ = predict_occupancy_for_lot(row, dt_value)
        lot = Lot(
            id=row["id"],
            name=row["name"],
            latitude=row["latitude"],
            longitude=row["longitude"],
            near_metro=bool(row["near_metro"]),
            price_level=row["price_level"],
            has_covered=bool(row["has_covered"]),
            has_ev_charging=bool(row["has_ev_charging"]),
            predicted_occupancy=occ,
        )
        # простая метрика: обратная занятость + бонус за метро и цену
        score = (1.0 - occ) + (1 - (row["price_level"] - 1) / 2) + (0.3 if row["near_metro"] else 0.0)
        recs.append(Recommendation(lot=lot, score=float(score)))

    return RecommendationsResponse(
        user_id=user_id,
        variant=chosen_variant,
        recommendations=recs,
    )


if __name__ == "__main__":
    import os
    import uvicorn

    host = os.environ.get("AI_API_HOST", "0.0.0.0")
    try:
        port = int(os.environ.get("AI_API_PORT", "8001"))
    except (TypeError, ValueError):
        port = 8001

    uvicorn.run("api_server:app", host=host, port=port, reload=True)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 11
PATH: app.js
LANG: javascript
===== CONTENT START =====
// app.js

// Базовый URL FastAPI-сервера
// Если сервер крутится на другом порту/домене — поправь здесь.
const API_BASE = "http://localhost:8001";

let map;
let markersLayer;
let lotsCache = [];
let lotsById = new Map();

function pickBestLot(lots) {
  if (!lots || lots.length === 0) return null;
  const ranked = [...lots].sort((a, b) => {
    const occA = a.predicted_occupancy ?? 1;
    const occB = b.predicted_occupancy ?? 1;
    return occA - occB;
  });
  return ranked[0];
}

function updateAIOracleCard(lots) {
  const nameEl = document.getElementById("aiOracleName");
  const etaEl = document.getElementById("aiOracleETA");
  const confEl = document.getElementById("aiOracleConfidence");
  const metaEl = document.getElementById("aiOracleMeta");
  const reasoningEl = document.getElementById("aiOracleReason");

  if (!nameEl || !etaEl || !confEl || !metaEl || !reasoningEl) return;

  if (!lots || lots.length === 0) {
    nameEl.textContent = "—";
    etaEl.textContent = "—";
    confEl.textContent = "—";
    metaEl.textContent = "—";
    reasoningEl.textContent = "AI готовит инсайт…";
    return;
  }

  const bestLot = pickBestLot(lots);
  if (!bestLot) return;

  const occ = bestLot.predicted_occupancy ?? 0;
  const occPercent = Math.round(occ * 100);
  const eta = Math.max(2, Math.min(15, Math.round((1 - occ) * 12)));
  const confidence = Math.max(68, Math.min(99, 96 - Math.round(occPercent / 2)));
  const ev = bestLot.has_ev_charging ? "EV" : "обычная";
  const covered = bestLot.has_covered ? "крытая" : "открытая";

  nameEl.textContent = bestLot.name;
  etaEl.textContent = `${eta} мин`;
  confEl.textContent = `${confidence}%`;
  metaEl.textContent = `${ev} · ${covered}`;
  reasoningEl.textContent =
    "Учитывая вашу историю: быстрый выезд, EV и близость к метро — этот слот даст наивысший WOW-эффект.";
}

// ----------------- ИНИЦИАЛИЗАЦИЯ КАРТЫ -----------------

function occupancyColor(value) {
  if (value <= 0.4) return "#22c55e"; // green
  if (value <= 0.7) return "#eab308"; // yellow
  return "#ef4444"; // red
}

function initMap() {
  map = L.map("map", {
    zoomControl: true,
    attributionControl: false,
  }).setView([55.7558, 37.6173], 12);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
  }).addTo(map);

  markersLayer = L.layerGroup().addTo(map);
}

// ----------------- API HELPERS -----------------

async function apiGet(path, params = {}) {
  const url = new URL(API_BASE + path);
  Object.entries(params).forEach(([k, v]) => {
    if (v !== undefined && v !== null) {
      url.searchParams.set(k, v);
    }
  });

  const res = await fetch(url.toString());
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`API error ${res.status}: ${text}`);
  }
  return res.json();
}

// ----------------- ОТРИСОВКА ЛОТОВ -----------------

function renderLotsOnMap(lots) {
  markersLayer.clearLayers();

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const color = occupancyColor(occ);

    const marker = L.circleMarker([lot.latitude, lot.longitude], {
      radius: 8,
      fillColor: color,
      fillOpacity: 0.9,
      color: "#020617",
      weight: 1,
    });

    const occPercent = Math.round(occ * 100);

    const html = `
      <div style="font-size: 12px;">
        <strong>${lot.name}</strong><br />
        Загрузка: <strong>${occPercent}%</strong><br />
        Метро: ${lot.near_metro ? "рядом" : "нет"}<br />
        Уровень цены: ${lot.price_level}<br />
        Крытая: ${lot.has_covered ? "да" : "нет"}<br />
        Зарядка EV: ${lot.has_ev_charging ? "есть" : "нет"}
      </div>
    `;

    marker.bindPopup(html);
    marker.addTo(markersLayer);
  });

  if (lots.length > 0) {
    const bounds = L.latLngBounds(
      lots.map((lot) => [lot.latitude, lot.longitude])
    );
    map.fitBounds(bounds.pad(0.2));
  }
}

function renderLotsList(containerId, lots, clickHandler) {
  const container = document.getElementById(containerId);
  container.innerHTML = "";

  if (!lots || lots.length === 0) {
    container.innerHTML =
      '<div style="font-size: 0.75rem; color: #6b7280;">Нет данных.</div>';
    return;
  }

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const occPercent = Math.round(occ * 100);

    const div = document.createElement("div");
    div.className = "lot-item";
    div.innerHTML = `
      <div class="lot-main">
        <div class="lot-name">${lot.name}</div>
        <div class="lot-meta">
          <span>Цена: L${lot.price_level}</span>
          <span>Метро: ${lot.near_metro ? "рядом" : "нет"}</span>
          <span>EV: ${lot.has_ev_charging ? "есть" : "нет"}</span>
          <span>Крытая: ${lot.has_covered ? "да" : "нет"}</span>
        </div>
      </div>
      <div class="lot-occ">${occPercent}%</div>
    `;

    div.addEventListener("click", () => clickHandler(lot));
    container.appendChild(div);
  });
}

// ----------------- ЛОГИКА UI -----------------

async function loadAllLots() {
  const status = document.getElementById("statusText");
  try {
    const lots = await apiGet("/api/lots");
    lotsCache = lots;
    lotsById.clear();
    lots.forEach((lot) => lotsById.set(lot.id, lot));

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = "AI-сервер подключён";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка подключения к AI-серверу";
  }
}

async function handleSearch() {
  const input = document.getElementById("searchInput");
  const status = document.getElementById("searchStatus");
  const text = input.value.trim();
  if (!text) return;

  status.textContent = "Обрабатываю запрос (локальный NLP)…";

  try {
    const data = await apiGet("/api/search", { query: text });
    const lots = data.lots || [];

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    const parts = [];
    parts.push(`Интент: ${data.intent}`);
    if (data.near_metro !== null) {
      parts.push(`рядом с метро: ${data.near_metro ? "да" : "нет"}`);
    }
    if (data.max_price_level !== null) {
      parts.push(`макс. уровень цены: L${data.max_price_level}`);
    }
    if (data.has_ev_charging !== null) {
      parts.push(`EV: ${data.has_ev_charging ? "нужна" : "не нужна"}`);
    }
    if (data.has_covered !== null) {
      parts.push(`крытая: ${data.has_covered ? "нужна" : "не нужна"}`);
    }
    if (data.time_of_day) {
      parts.push(`время суток: ${data.time_of_day}`);
    }
    status.textContent = parts.join(" · ") || "Фильтры не распознаны.";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка обработки запроса";
  }
}

async function initUsersSelect() {
  const select = document.getElementById("userSelect");
  // Пользователи не отдаются API, но user_id есть в тренировочных данных.
  // Для демо предположим, что есть пользователи с id 1..20.
  for (let i = 1; i <= 20; i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `Пользователь #${i}`;
    select.appendChild(opt);
  }
}

async function handleRecommendations(variant) {
  const select = document.getElementById("userSelect");
  const status = document.getElementById("recStatus");
  const listContainerId = "recList";

  const userId = parseInt(select.value, 10) || undefined;

  status.textContent =
    variant === "A"
      ? "Рассчитываю рекомендации (collaborative)…"
      : "Рассчитываю рекомендации (content-based)…";

  try {
    const params = { limit: 10, variant };
    if (variant === "A" && userId) {
      params.user_id = userId;
    }
    const data = await apiGet("/api/recommendations", params);
    const recs = data.recommendations || [];

    const lots = recs.map((r) => r.lot);
    renderLotsOnMap(lots);
    renderLotsList(listContainerId, lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = `Вариант ${data.variant}, получено ${recs.length} рекомендаций.`;
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка получения рекомендаций";
  }
}

// ----------------- СТАРТ -----------------

window.addEventListener("DOMContentLoaded", async () => {
  initMap();
  await initUsersSelect();
  await loadAllLots();

  document
    .getElementById("searchBtn")
    .addEventListener("click", () => handleSearch());

  document
    .getElementById("searchInput")
    .addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        handleSearch();
      }
    });

  document.getElementById("recBtn").addEventListener("click", () => {
    handleRecommendations("A");
  });

  document
    .getElementById("recContentBtn")
    .addEventListener("click", () => {
      handleRecommendations("B");
    });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 12
PATH: celerybeat-schedule.bak
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 13
PATH: celerybeat-schedule.dat
LANG: text
===== CONTENT START =====
�}�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ��	       �5.5.3�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��       �
Europe/Moscow�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ��.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��L      }�(�expire_unpaid_bookings��celery.beat��
ScheduleEntry���(�expire_unpaid_bookings��$parking.tasks.expire_unpaid_bookings��datetime��datetime���C
�-�E��builtins��getattr����zoneinfo��ZoneInfo����	_unpickle���R��
Europe/Moscow�K��R���R�K�celery.schedules��schedule���h�	timedelta���K MXK ��R��N��R�)}�}�t�R��update_ai_models�h(�update_ai_models��ai.tasks.update_models�h	C
�-	3Ӕh��R�KhhK MK ��R��N��R�)}�}�t�R��check_stale_payments�h(�check_stale_payments��#payments.tasks.check_stale_payments�h	C
�-	;��h��R�KhhK M�K ��R��N��R�)}�}�t�R�u.
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 14
PATH: celerybeat-schedule.dir
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 15
PATH: chat_test.py
LANG: python
===== CONTENT START =====
import os,sys
sys.path.insert(0,r'c:\Users\Sultan\Downloads\parkshare_ru_part1') 
os.environ.setdefault('DJANGO_SETTINGS_MODULE','backend.backend.settings.local') 
import django;django.setup() 
from ai.chat.parking_assistant import generate_chat_reply 
reply=generate_chat_reply('Kurskaya parking 9-11 300 rub ev', [], None) 
print(repr(reply)) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 16
PATH: chat_test_len.py
LANG: python
===== CONTENT START =====
import os,sys,json
sys.path.insert(0,r'c:\Users\Sultan\Downloads\parkshare_ru_part1') 
os.environ.setdefault('DJANGO_SETTINGS_MODULE','backend.backend.settings.local') 
import django;django.setup() 
from ai.chat.parking_assistant import generate_chat_reply 
r=generate_chat_reply('Kurskaya parking 9-11 300 rub ev', [], None) 
print(len(r.get('suggestions',[])), r.get('reply')) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 17
PATH: count_spots.py
LANG: python
===== CONTENT START =====
import os,sys 
sys.path.insert(0,r'c:\Users\Sultan\Downloads\parkshare_ru_part1') 
os.environ.setdefault('DJANGO_SETTINGS_MODULE','backend.backend.settings.local') 
import django;django.setup() 
from parking.models import ParkingSpot 
print(ParkingSpot.objects.count()) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 18
PATH: database.py
LANG: python
===== CONTENT START =====
# database.py
from __future__ import annotations

import random
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import List

DB_PATH = Path(__file__).parent / "ai_data.db"


def get_connection() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db() -> None:
    conn = get_connection()
    cur = conn.cursor()

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS parking_lot (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            latitude REAL NOT NULL,
            longitude REAL NOT NULL,
            near_metro INTEGER NOT NULL,
            price_level INTEGER NOT NULL,
            has_covered INTEGER NOT NULL,
            has_ev_charging INTEGER NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS occupancy_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            lot_id INTEGER NOT NULL,
            ts TEXT NOT NULL,
            occupancy REAL NOT NULL,
            temperature REAL NOT NULL,
            is_rain INTEGER NOT NULL,
            is_event INTEGER NOT NULL,
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS app_user (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS user_rating (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            lot_id INTEGER NOT NULL,
            rating REAL NOT NULL,
            FOREIGN KEY (user_id) REFERENCES app_user(id),
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    conn.commit()
    conn.close()


@dataclass
class LotSpec:
    name: str
    base_lat: float
    base_lon: float
    near_metro: int
    price_level: int
    has_covered: int
    has_ev_charging: int


def generate_synthetic_data(
    num_lots: int = 30,
    num_users: int = 50,
    days_back: int = 30,
) -> None:
    """
    Генерация синтетических:
    - парковок
    - истории занятости
    - пользователей
    - оценок пользователей
    """
    random.seed(42)

    conn = get_connection()
    cur = conn.cursor()

    # Чистим старые данные
    cur.execute("DELETE FROM user_rating;")
    cur.execute("DELETE FROM app_user;")
    cur.execute("DELETE FROM occupancy_history;")
    cur.execute("DELETE FROM parking_lot;")
    conn.commit()

    # Базовые точки вокруг Москвы
    center_lat, center_lon = 55.7558, 37.6173

    lots: List[int] = []
    for i in range(num_lots):
        near_metro = 1 if random.random() < 0.5 else 0
        price_level = random.choice([1, 2, 3])  # 1 — дешево, 3 — дорого
        has_covered = 1 if random.random() < 0.4 else 0
        has_ev = 1 if random.random() < 0.3 else 0

        # Немного раскидываем точки вокруг центра
        lat = center_lat + random.uniform(-0.05, 0.05)
        lon = center_lon + random.uniform(-0.1, 0.1)

        cur.execute(
            """
            INSERT INTO parking_lot (
                name, latitude, longitude, near_metro,
                price_level, has_covered, has_ev_charging
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """,
            (
                f"Лот #{i+1}",
                lat,
                lon,
                near_metro,
                price_level,
                has_covered,
                has_ev,
            ),
        )
        lots.append(cur.lastrowid)

    # История занятости — каждые 2 часа за days_back дней
    now = datetime.now()
    start_ts = now - timedelta(days=days_back)

    weather_states = ["sunny", "cloudy", "rainy"]

    for lot_id in lots:
        ts = start_ts
        while ts < now:
            dow = ts.weekday()
            hour = ts.hour

            is_event = 1 if (dow in (4, 5) and hour >= 18 and random.random() < 0.3) else 0
            weather = random.choice(weather_states)
            is_rain = 1 if weather == "rainy" else 0
            temperature = random.uniform(-10, 30)

            # Базовая занятость зависит от часа и дня недели
            base_occ = 0.2
            if 8 <= hour <= 11:
                base_occ = 0.6
            elif 17 <= hour <= 20:
                base_occ = 0.7
            elif 0 <= hour <= 5:
                base_occ = 0.1

            if dow >= 5:
                base_occ += 0.1

            if is_event:
                base_occ += 0.2
            if is_rain:
                base_occ += 0.1

            base_occ = max(0.0, min(base_occ + random.uniform(-0.1, 0.1), 1.0))

            cur.execute(
                """
                INSERT INTO occupancy_history (
                    lot_id, ts, occupancy, temperature, is_rain, is_event
                ) VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    lot_id,
                    ts.isoformat(),
                    base_occ,
                    temperature,
                    is_rain,
                    is_event,
                ),
            )

            ts += timedelta(hours=2)

    # Пользователи
    users = []
    for i in range(num_users):
        cur.execute(
            "INSERT INTO app_user (name) VALUES (?);",
            (f"user_{i+1}",),
        )
        users.append(cur.lastrowid)

    # Оценки пользователей парковок
    for user_id in users:
        # Каждый пользователь оценит 5–15 парковок
        k = random.randint(5, min(15, len(lots)))
        rated_lots = random.sample(lots, k)
        for lot_id in rated_lots:
            # Рейтинг зависит от price_level и случайности
            base_rating = 4.5 - 0.5 * (random.randint(1, 3) - 1)
            rating = max(1.0, min(5.0, base_rating + random.uniform(-1.0, 1.0)))
            cur.execute(
                """
                INSERT INTO user_rating (user_id, lot_id, rating)
                VALUES (?, ?, ?)
                """,
                (user_id, lot_id, rating),
            )

    conn.commit()
    conn.close()
    print("Синтетические данные сгенерированы в", DB_PATH)


if __name__ == "__main__":
    init_db()
    generate_synthetic_data()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 19
PATH: docker-compose.prod.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: gunicorn backend.config.wsgi:application --bind 0.0.0.0:8000
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config worker -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config beat -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    restart: always
    environment:
      NEXTAUTH_URL: ${NEXTAUTH_URL:-http://localhost:3000}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:-change_me_frontend}
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID:-dummy}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET:-dummy}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-dummy}
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:1.27-alpine
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 20
PATH: docker-compose.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    container_name: parkshare_db
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: parkshare
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    container_name: parkshare_redis
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_web
    restart: always
    env_file:
      - .env  # можно потом заменить на .env.prod
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_worker
    restart: always
    env_file:
      - .env
    command: celery -A backend.config worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_beat
    restart: always
    env_file:
      - .env
    command: celery -A backend.config beat -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  ai_pricing_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_ai_pricing
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.ai_pricing_service.main:app --host 0.0.0.0 --port 8100
    depends_on:
      - redis
    networks:
      - parkshare_net

  llm_service:
    build:
      context: .
      dockerfile: services/llm_service/Dockerfile
    container_name: parkshare_llm_service
    restart: always
    env_file:
      - .env
    ports:
      - "8002:8002"
    networks:
      - parkshare_net

  cv_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_cv_service
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.cv_service.main:app --host 0.0.0.0 --port 8200
    depends_on:
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    container_name: parkshare_frontend
    restart: always
    environment:
      NEXTAUTH_URL: http://localhost:3000
      NEXTAUTH_SECRET: dev_secret
      GOOGLE_CLIENT_ID: dummy
      GOOGLE_CLIENT_SECRET: dummy
      OPENAI_API_KEY: dummy
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:alpine
    container_name: parkshare_nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 21
PATH: dump_project.py
LANG: python
===== CONTENT START =====
import os
from datetime import datetime

# Какие папки игнорировать (расширенный список)
EXCLUDED_DIRS = {
    ".git", ".venv", "venv", "__pycache__", "node_modules",
    "dist", "build", "staticfiles", "media", ".idea", ".vscode",
    "static/icons",      # иконки не нужны в дампе
    "logs", "cache", "temp",  # временные файлы и логи
}

# Какие расширения файлов пропускать (расширенный список)
IGNORED_EXTENSIONS = {
    ".pyc", ".pyo", ".pyd", ".sqlite3", ".sqlite", ".db",
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp",
    ".pdf", ".zip", ".rar", ".7z", ".tar", ".gz",
    ".exe", ".dll", ".so", ".pkl", ".h5", ".model", ".pt",
    ".mp4", ".mp3", ".wav", ".avi", ".mov",
    ".log", ".tmp", ".cache",
}

# Файлы, которые нужно полностью игнорировать
EXCLUDED_FILES = {
    "CODEX_LOG1.txt", "CODEX__LOGS.txt",
    "package-lock.json", "yarn.lock",
}

# Никакого лимита на размер файла и дампа
MAX_FILE_SIZE = None  # не используется
MAX_TOTAL_DUMP_SIZE = None  # не используется

# Сжатие кода выключено, содержимое пишется как есть
COMPRESS_CODE = False


def is_binary_file(filename: str) -> bool:
    _, ext = os.path.splitext(filename.lower())
    return ext in IGNORED_EXTENSIONS


def should_exclude_file(filename: str) -> bool:
    return filename in EXCLUDED_FILES


def compress_content(content: str, filepath: str) -> str:
    # Оставлено для совместимости, по факту возвращает исходный контент
    if not COMPRESS_CODE:
        return content
    return content


def detect_language(filepath: str) -> str:
    """
    Определение "языка" для ИИ по расширению файла,
    чтобы он лучше понимал, что за содержимое перед ним.
    """
    _, ext = os.path.splitext(filepath.lower())
    mapping = {
        ".py": "python",
        ".js": "javascript",
        ".ts": "typescript",
        ".tsx": "tsx",
        ".jsx": "jsx",
        ".html": "html",
        ".htm": "html",
        ".css": "css",
        ".scss": "scss",
        ".sass": "sass",
        ".json": "json",
        ".yml": "yaml",
        ".yaml": "yaml",
        ".md": "markdown",
        ".sh": "bash",
        ".bat": "batch",
        ".ps1": "powershell",
        ".toml": "toml",
        ".ini": "ini",
        ".cfg": "ini",
        ".txt": "text",
        ".sql": "sql",
        ".csv": "csv",
        ".xml": "xml",
    }
    return mapping.get(ext, "text")


def build_tree_and_collect_files(root: str):
    """
    Обходит проект, строит дерево директорий и собирает список файлов.
    Фильтр только по директориям/расширениям/именам.
    """
    tree_lines = []
    file_paths = []

    root = os.path.abspath(root)
    root_name = os.path.basename(root.rstrip(os.sep))

    tree_lines.append(f"{root_name}/")

    for current_root, dirs, files in os.walk(root):
        # Фильтр директорий
        dirs[:] = [
            d for d in dirs
            if d not in EXCLUDED_DIRS and not d.startswith(".")
        ]

        rel_root = os.path.relpath(current_root, root)
        if rel_root == ".":
            depth = 0
        else:
            depth = rel_root.count(os.sep) + 1

        indent = "    " * depth

        if rel_root != ".":
            tree_lines.append(f"{indent}{os.path.basename(current_root)}/")

        for name in sorted(files):
            if is_binary_file(name) or should_exclude_file(name):
                continue

            file_rel_path = os.path.join(rel_root, name) if rel_root != "." else name
            file_abs_path = os.path.join(current_root, name)

            tree_lines.append(f"{indent}    {name}")
            file_paths.append((file_rel_path, file_abs_path))

    return tree_lines, file_paths


def dump_project(root: str, output_filename: str = "project_dump.txt"):
    tree_lines, file_paths = build_tree_and_collect_files(root)

    root = os.path.abspath(root)

    # Индекс файлов для ИИ, чтобы он мог быстро увидеть структуру и прыгать по пути
    files_index_lines = []
    for idx, (rel_path, abs_path) in enumerate(file_paths, 1):
        lang = detect_language(abs_path)
        files_index_lines.append(
            f"{idx}. PATH={rel_path} | LANG={lang}"
        )

    header = [
        "#" * 80,
        "# FULL PROJECT DUMP (NO TRUNCATION)",
        "# FORMAT FOR LLM:",
        "#   1) PROJECT TREE — общая структура проекта.",
        "#   2) FILES INDEX — плоский список файлов с путём и языком.",
        "#   3) FILES CONTENT — для каждого файла:",
        "#        ===== FILE START =====",
        "#        FILE_INDEX: <N>",
        "#        PATH: <relative/path>",
        "#        LANG: <language>",
        "#        ===== CONTENT START =====",
        "#        <raw file content>",
        "#        ===== CONTENT END =====",
        "#        ===== FILE END =====",
        "#   Файлы идут в том же порядке, что и в индексе.",
        "#" * 80,
        f"# Root: {root}",
        f"# Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Files listed: {len(file_paths)}",
        f"# Max single file size: NONE",
        f"# Max total dump size: NONE",
        f"# Code compression enabled: {COMPRESS_CODE}",
        "#" * 80,
        "",
    ]

    with open(output_filename, "w", encoding="utf-8", errors="replace") as f:
        # Шапка
        f.write("\n".join(header))

        # Дерево проекта
        f.write("PROJECT TREE:\n")
        f.write("-" * 80 + "\n")
        for line in tree_lines:
            f.write(line + "\n")

        # Индекс файлов
        f.write("\n\n")
        f.write("FILES INDEX:\n")
        f.write("-" * 80 + "\n")
        for line in files_index_lines:
            f.write(line + "\n")

        # Разделитель
        f.write("\n\n")
        f.write("=" * 80 + "\n")
        f.write("FILES CONTENT:\n")
        f.write("=" * 80 + "\n\n")

        total_files = len(file_paths)

        for i, (rel_path, abs_path) in enumerate(file_paths, 1):
            lang = detect_language(abs_path)

            # Явные маркеры для ИИ
            f.write("===== FILE START =====\n")
            f.write(f"FILE_INDEX: {i}\n")
            f.write(f"PATH: {rel_path}\n")
            f.write(f"LANG: {lang}\n")
            f.write("===== CONTENT START =====\n")

            try:
                with open(abs_path, "r", encoding="utf-8", errors="replace") as src:
                    content = src.read()

                content = compress_content(content, abs_path)
                f.write(content)

            except Exception as e:
                f.write(f"<< ERROR READING FILE: {e} >>\n")

            f.write("\n===== CONTENT END =====\n")
            f.write("===== FILE END =====\n\n")

            if i % 10 == 0:
                print(f"Processed {i}/{total_files} files...")

    file_size_bytes = os.path.getsize(output_filename)
    file_size_kb = file_size_bytes / 1024
    file_size_mb = file_size_bytes / (1024 * 1024)

    print(f"Готово! Файл с дампом проекта: {output_filename}")
    print(f"Размер дампа: {file_size_kb:.0f}KB (~{file_size_mb:.2f}MB)")
    print(f"Файлов в обходе (включено в дамп): {len(file_paths)}")


if __name__ == "__main__":
    project_root = os.path.dirname(os.path.abspath(__file__))
    dump_project(project_root)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 22
PATH: entrypoint.sh
LANG: bash
===== CONTENT START =====
#!/bin/sh
set -e

# Если DJANGO_SETTINGS_MODULE не задан, по умолчанию считаем, что это прод.
: "${DJANGO_SETTINGS_MODULE:=backend.backend.settings.production}"
export DJANGO_SETTINGS_MODULE

echo "Using DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE}"

# Миграции
python backend/manage.py migrate --noinput

# Сбор статики
python backend/manage.py collectstatic --noinput

# Запуск gunicorn
exec gunicorn backend.config.wsgi:application \
    --bind 0.0.0.0:8000 \
    --workers "${GUNICORN_WORKERS:-3}" \
    --timeout "${GUNICORN_TIMEOUT:-60}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 23
PATH: index.html
LANG: html
===== CONTENT START =====
<!-- index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ParkShare AI Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <link rel="stylesheet" href="./static/css/cinematic-ui.css" />

  <style>
    :root {
      --primary: #0d6efd;
      --bg: #050816;
      --bg-card: #111827;
      --text: #e5e7eb;
      --accent: #22c55e;
      --danger: #ef4444;
      --warning: #f59e0b;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827, #020617 40%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      z-index: 1000;
      position: sticky;
      top: 0;
    }

    header h1 {
      font-size: 1.1rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .header-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.3fr);
      min-height: 0;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .sidebar {
      border-left: 1px solid rgba(148, 163, 184, 0.2);
      background: radial-gradient(circle at top, #020617, #020617 40%);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 280px;
      max-width: 480px;
    }

    .card {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 0.75rem 0.8rem;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.6);
    }

    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .input-row {
      display: flex;
      gap: 0.4rem;
      margin-top: 0.3rem;
    }

    input[type="text"],
    select {
      flex: 1;
      padding: 0.4rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      font-size: 0.85rem;
      outline: none;
    }

    input::placeholder {
      color: rgba(148, 163, 184, 0.9);
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 0.45rem 0.9rem;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      background: linear-gradient(135deg, #0ea5e9, #22c55e);
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      white-space: nowrap;
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: rgba(209, 213, 219, 0.95);
    }

    .pill {
      font-size: 0.72rem;
      border-radius: 999px;
      padding: 0.16rem 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      color: rgba(209, 213, 219, 0.95);
    }

    .pill-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
    }

    .pill-dot.green {
      background: var(--accent);
    }
    .pill-dot.yellow {
      background: var(--warning);
    }
    .pill-dot.red {
      background: var(--danger);
    }

    .lots-list {
      max-height: 220px;
      overflow-y: auto;
      margin-top: 0.4rem;
      padding-right: 0.2rem;
    }

    .lot-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.4rem 0.2rem;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      cursor: pointer;
    }

    .lot-item:last-child {
      border-bottom: none;
    }

    .lot-main {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      font-size: 0.75rem;
    }

    .lot-name {
      font-weight: 500;
      font-size: 0.8rem;
    }

    .lot-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      font-size: 0.7rem;
      color: rgba(156, 163, 175, 0.95);
    }

    .lot-occ {
      font-size: 0.8rem;
      font-weight: 500;
      min-width: 80px;
      text-align: right;
    }

    .status {
      font-size: 0.7rem;
      color: rgba(148, 163, 184, 0.9);
      margin-top: 0.3rem;
    }

    .ai-oracle-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.18rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(59, 130, 246, 0.45);
      background: linear-gradient(120deg, rgba(37, 99, 235, 0.35), rgba(14, 165, 233, 0.15));
      color: #e5edff;
      font-size: 0.75rem;
      letter-spacing: 0.02em;
      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.25);
    }

    .ai-orchestrator-card {
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.92), rgba(17, 24, 39, 0.94));
    }

    .ai-orchestrator-card .card-title {
      align-items: center;
    }

    .ai-orchestrator-card .card-title span {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .quantum-toggle {
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: #e2e8f0;
      font-weight: 600;
      letter-spacing: 0.01em;
      min-width: 150px;
      justify-content: space-between;
    }

    .quantum-toggle__dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.7);
      background: radial-gradient(circle at 35% 35%, #38bdf8, #0ea5e9);
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.45);
    }

    .quantum-toggle__label {
      flex: 1;
      text-align: right;
      font-size: 0.8rem;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
      .sidebar {
        max-width: 100%;
        border-left: none;
        border-top: 1px solid rgba(148, 163, 184, 0.2);
      }
    }
  </style>
</head>
<body>
  <header class="cinematic-surface">
    <h1>
      <span>ParkShare AI Map</span>
      <span class="badge">local ML</span>
    </h1>
    <div class="header-meta">
      <div class="ai-crest">
        <span>🧠</span>
        <span class="quantum-toggle__label">AI Orchestrator</span>
      </div>
      <button id="themeToggle" class="quantum-toggle cinematic-button" data-theme="dark">
        <span class="quantum-toggle__dot"></span>
        <span class="quantum-toggle__label">Dark Matter</span>
      </button>
      <div class="pill">
        <span class="pill-dot green"></span>
        <span id="statusText">Подключение к AI-серверу…</span>
      </div>
    </div>
  </header>

  <main>
    <div id="map"></div>
    <aside class="sidebar">
      <section class="card cinematic-surface ai-orchestrator-card">
        <div class="card-title">
          <span>AI-Оркестратор</span>
          <span class="ai-oracle-chip">Quantum boost</span>
        </div>
        <div class="ai-forecast">
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Лучшая ставка</span>
            <span class="ai-forecast-value" id="aiOracleName">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Освободится через</span>
            <span class="ai-forecast-value" id="aiOracleETA">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Уверенность AI</span>
            <span class="ai-forecast-value" id="aiOracleConfidence">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">EV/крытая</span>
            <span class="ai-forecast-value" id="aiOracleMeta">—</span>
          </div>
        </div>
        <div class="ai-reasoning" id="aiOracleReason">AI готовит инсайт…</div>
      </section>
      <section class="card">
        <div class="card-title">
          <span>Поиск парковок (NLP)</span>
        </div>
        <div class="input-row">
          <input
            type="text"
            id="searchInput"
            placeholder='Например: "рядом с метро", "дешевые утром"'
          />
          <button id="searchBtn">Искать</button>
        </div>
        <div class="status" id="searchStatus">Запрос еще не выполнен.</div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Рекомендации (коллаб. фильтрация)</span>
          <select id="userSelect"></select>
        </div>
        <div class="input-row">
          <button id="recBtn">Получить рекомендации</button>
          <button id="recContentBtn" class="secondary">Вариант B (content)</button>
        </div>
        <div class="status" id="recStatus">Нет рекомендаций.</div>
        <div class="lots-list" id="recList"></div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Все парковки</span>
        </div>
        <div class="lots-list" id="lotsList"></div>
      </section>
    </aside>
  </main>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="./static/js/quantum-theme-manager.js"></script>
  <script src="app.js"></script>
  <script>
    // Запускаем квантовый менеджер темы, чтобы анимации и эмоции были синхронизированы.
    window.psThemeManager = window.initQuantumThemeManager();
  </script>
</body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 24
PATH: model_training.py
LANG: python
===== CONTENT START =====
# model_training.py
from __future__ import annotations

import joblib
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Dict, Any

from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.svm import LinearSVC

from database import DB_PATH, get_connection, init_db, generate_synthetic_data

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"
# Создаём папку для моделей заранее, чтобы не упасть на сохранении
MODELS_DIR.mkdir(parents=True, exist_ok=True)


# ---------- 1. Модель предсказания загруженности парковок ----------


def load_occupancy_dataframe() -> pd.DataFrame:
    conn = get_connection()
    try:
        query = """
            SELECT
                oh.lot_id,
                oh.ts,
                oh.occupancy,
                oh.temperature,
                oh.is_rain,
                oh.is_event,
                pl.near_metro,
                pl.price_level,
                pl.has_covered,
                pl.has_ev_charging
            FROM occupancy_history oh
            JOIN parking_lot pl ON pl.id = oh.lot_id
        """
        df = pd.read_sql_query(query, conn)
    finally:
        conn.close()

    if df.empty:
        return df

    df["ts"] = pd.to_datetime(df["ts"], errors="coerce")
    df = df.dropna(subset=["ts"])
    df["hour"] = df["ts"].dt.hour
    df["dow"] = df["ts"].dt.weekday
    df["lot_id_str"] = df["lot_id"].astype(str)

    return df


def train_occupancy_model() -> None:
    df = load_occupancy_dataframe()
    if df.empty:
        raise RuntimeError("Нет данных для обучения occupancy-модели")

    feature_cols = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
        "lot_id_str",
    ]

    X = df[feature_cols].copy()
    y = df["occupancy"].astype(float)

    numeric_features = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
    ]
    categorical_features = ["lot_id_str"]

    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), numeric_features),
            ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_features),
        ]
    )

    model = RandomForestRegressor(
        n_estimators=80,
        random_state=42,
        n_jobs=-1,
    )

    pipe = Pipeline(
        steps=[
            ("preprocess", preprocessor),
            ("model", model),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "occupancy_model.pkl"
    joblib.dump(
        {
            "pipeline": pipe,
            "feature_cols": feature_cols,
        },
        model_path,
    )
    print("occupancy_model.pkl сохранён в", model_path)


# ---------- 2. NLP: интенты и парсинг пользовательских запросов ----------


def build_nlp_training_data() -> pd.DataFrame:
    data = [
        ("рядом с метро", "near_metro"),
        ("парковка около метро", "near_metro"),
        ("парковка возле метро", "near_metro"),
        ("где припарковаться у метро курская", "near_metro"),
        ("найди парковку у метро", "near_metro"),
        ("самая дешевая парковка", "cheap"),
        ("дешевые парковки утром", "cheap"),
        ("недорогая парковка рядом", "cheap"),
        ("дешево припарковаться", "cheap"),
        ("недорогие места для машины", "cheap"),
        ("парковка с зарядкой для электромобиля", "ev"),
        ("нужна зарядка для электрокара", "ev"),
        ("парковка с ev charging", "ev"),
        ("крытая парковка", "covered"),
        ("подземная парковка", "covered"),
        ("парковка в паркинге", "covered"),
        ("парковка ночью", "time_night"),
        ("парковка утром", "time_morning"),
        ("парковка вечером", "time_evening"),
        ("парковка днем", "time_day"),
        ("найди парковку", "general"),
        ("показать все парковки", "general"),
        ("где можно припарковаться", "general"),
        ("парковка в центре", "general"),
        ("парковка возле офиса", "general"),
    ]
    return pd.DataFrame(data, columns=["text", "intent"])


def train_nlp_model() -> None:
    df = build_nlp_training_data()
    X = df["text"].values
    y = df["intent"].values

    pipe = Pipeline(
        steps=[
            (
                "vec",
                CountVectorizer(
                    ngram_range=(1, 2),
                    analyzer="word",
                ),
            ),
            ("clf", LinearSVC()),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "nlp_intent.pkl"
    joblib.dump(pipe, model_path)
    print("nlp_intent.pkl сохранён в", model_path)


# ---------- 3. Рекомендательная система (collab + content) ----------


def train_recommender() -> None:
    """
    Простейшая item-based collaborative filtering + content-based фолбэк.
    """
    conn = get_connection()

    ratings = pd.read_sql_query("SELECT * FROM user_rating;", conn)
    lots = pd.read_sql_query("SELECT * FROM parking_lot;", conn)

    if ratings.empty or lots.empty:
        raise RuntimeError("Нет данных для обучения рекомендера")

    # user-item матрица
    user_item = (
        ratings.pivot(index="user_id", columns="lot_id", values="rating")
        .fillna(0.0)
        .astype(float)
    )

    # Нормируем по пользователям
    user_norms = np.linalg.norm(user_item.values, axis=1, keepdims=True)
    user_norms[user_norms == 0] = 1.0
    user_item_norm = user_item.values / user_norms

    # item-item similarity (cosine)
    sim_matrix = cosine_similarity(user_item_norm.T)
    item_ids = user_item.columns.tolist()
    item_sim = pd.DataFrame(sim_matrix, index=item_ids, columns=item_ids)

    # Content-features
    lot_features = lots.set_index("id")[
        ["near_metro", "price_level", "has_covered", "has_ev_charging", "latitude", "longitude"]
    ].copy()

    model_path = MODELS_DIR / "recommender.pkl"
    joblib.dump(
        {
            "user_item": user_item,
            "item_sim": item_sim,
            "lot_features": lot_features,
        },
        model_path,
    )
    print("recommender.pkl сохранён в", model_path)
    conn.close()


def _dataset_is_empty() -> bool:
    conn = get_connection()
    try:
        cur = conn.cursor()
        counts = {}
        for table in ["parking_lot", "occupancy_history", "user_rating"]:
            try:
                cur.execute(f"SELECT COUNT(*) FROM {table};")
                counts[table] = cur.fetchone()[0]
            except Exception:
                counts[table] = 0
        return any(value == 0 for value in counts.values())
    finally:
        conn.close()


def _safe_call(name: str, fn) -> None:
    try:
        fn()
    except Exception as exc:
        # Логируем и выбрасываем дальше, чтобы CI увидел сбой
        print(f"[!] Ошибка во время '{name}': {exc}")
        raise


def main() -> None:
    # На случай чистой установки
    init_db()

    try:
        if _dataset_is_empty():
            print("База пуста — генерируем синтетические данные...")
            generate_synthetic_data()
        else:
            print("Используем существующие данные в БД", DB_PATH)
    except Exception as exc:
        print(f"[!] Не удалось подготовить данные: {exc}")
        raise

    print("=== Обучение occupancy-модели ===")
    _safe_call("occupancy", train_occupancy_model)

    print("=== Обучение NLP-модели ===")
    _safe_call("nlp", train_nlp_model)

    print("=== Обучение рекомендательной системы ===")
    _safe_call("recommender", train_recommender)

    print("Готово: все модели обучены и сохранены в", MODELS_DIR)


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 25
PATH: mypy.ini
LANG: ini
===== CONTENT START =====
[mypy]
python_version = 3.11
strict = False
ignore_missing_imports = True
exclude = (frontend|node_modules|venv|.venv|.git|migrations)

[mypy-ai.*]
warn_unused_configs = True

[mypy-parking.*]
warn_unused_configs = True

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 26
PATH: print_base.py
LANG: python
===== CONTENT START =====
from backend.backend.settings import base 
print(base.BASE_DIR) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 27
PATH: print_llm_env.py
LANG: python
===== CONTENT START =====
from backend.backend.settings import base 
import os 
print(os.getenv('LLM_OPENAI_API_KEY')) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 28
PATH: project_dump.txt
LANG: text
===== CONTENT START =====
################################################################################
# FULL PROJECT DUMP (NO TRUNCATION)
# FORMAT FOR LLM:
#   1) PROJECT TREE — общая структура проекта.
#   2) FILES INDEX — плоский список файлов с путём и языком.
#   3) FILES CONTENT — для каждого файла:
#        ===== FILE START =====
#        FILE_INDEX: <N>
#        PATH: <relative/path>
#        LANG: <language>
#        ===== CONTENT START =====
#        <raw file content>
#        ===== CONTENT END =====
#        ===== FILE END =====
#   Файлы идут в том же порядке, что и в индексе.
################################################################################
# Root: C:\Users\Sultan\Downloads\parkshare_ru_part1
# Generated at: 2025-12-08 18:11:29
# Files listed: 308
# Max single file size: NONE
# Max total dump size: NONE
# Code compression enabled: False
################################################################################
PROJECT TREE:
--------------------------------------------------------------------------------
parkshare_ru_part1/
    .env
    .env.example
    .env.prod
    .gitattributes
    .gitignore
    .ruff.toml
    Dockerfile
    Makefile
    README.md
    api_server.py
    app.js
    celerybeat-schedule.bak
    celerybeat-schedule.dat
    celerybeat-schedule.dir
    chat_test.py
    chat_test_len.py
    count_spots.py
    database.py
    docker-compose.prod.yml
    docker-compose.yml
    dump_project.py
    entrypoint.sh
    index.html
    model_training.py
    mypy.ini
    print_base.py
    print_llm_env.py
    project_dump.txt
    requirements.txt
    run_dev.bat
    run_dev.py
    run_dev.sh
    accounts/
        __init__.py
        admin.py
        apps.py
        auth.py
        authentication.py
        forms.py
        models.py
        oauth.py
        serializers.py
        urls.py
        utils.py
        views.py
        migrations/
            0001_initial.py
            0002_user_email_hash_user_phone_hash_logincode.py
            0003_userlevel_userbadge_promoreward.py
            0004_socialaccount.py
            0005_logincode_attempts_status.py
            0006_user_mfa_fields.py
            0007_user_last_mfa_change.py
            0008_rename_accounts_so_provide_3a0cdb_idx_accounts_so_provide_98721f_idx_and_more.py
            __init__.py
        tests/
            __init__.py
            test_mfa.py
    ai/
        __init__.py
        admin.py
        apps.py
        features.py
        models.py
        orchestrator.py
        pricing.py
        serializers.py
        tasks.py
        tools.py
        views.py
        chat/
            __init__.py
            parking_assistant.py
        management/
            __init__.py
            commands/
                __init__.py
                train_chat_intents_from_logs.py
        migrations/
            0001_initial.py
            __init__.py
        tests/
            __init__.py
            test_assistant_sessions.py
    ai_models/
    ai_services/
        __init__.py
        ai_pricing_service/
            __init__.py
            main.py
        cv_service/
            __init__.py
            main.py
    backend/
        __init__.py
        manage.py
        backend/
            __init__.py
            health.py
            config/
                __init__.py
                asgi.py
                celery.py
                urls.py
                wsgi.py
            settings/
                __init__.py
                base.py
                local.py
                production.py
                regions.py
        rest_framework_simplejwt/
            __init__.py
            authentication.py
            tokens.py
            views.py
        tests/
            __init__.py
            test_access_control.py
            test_analytics.py
            test_assistant_tools.py
            test_auth_api.py
            test_auth_mfa.py
            test_billing_modes.py
            test_booking_model.py
            test_business_reports.py
            test_error_formats.py
            test_health.py
            test_input_limits.py
            test_maintenance_mode.py
            test_notification_scheduling.py
            test_notification_settings.py
            test_offline_onboarding.py
            test_payment_methods_view.py
            test_preferences_view.py
            test_promo_activate.py
            test_security_headers.py
            test_ui_theme_chat.py
    core/
        __init__.py
        admin.py
        api_keys.py
        apps.py
        context_processors.py
        db_router.py
        feature_flags.py
        integrations.py
        metrics.py
        middleware.py
        models.py
        observability.py
        pagination.py
        permissions.py
        sms.py
        utils.py
        management/
            __init__.py
            commands/
                __init__.py
                migrate_safe.py
        migrations/
            0001_initial.py
            0002_rename_core_audit_action_6abf09_idx_core_auditl_action_d9fb24_idx_and_more.py
            __init__.py
        tests/
            test_feature_flags.py
    docs/
        auth_mfa_and_social_login.md
        deploy.md
    drf_spectacular/
        __init__.py
        openapi.py
        views.py
    frontend/
        next-app/
            .env.local
            .eslintrc.json
            Dockerfile
            jest.config.js
            jest.setup.ts
            next-env.d.ts
            next.config.mjs
            package.json
            postcss.config.js
            tailwind.config.ts
            tsconfig.json
            app/
                globals.css
                layout.tsx
                (site)/
                    layout.tsx
                    page.tsx
                    auth/
                        page.tsx
                api/
                    chat/
                        route.ts
                embed/
                    page.tsx
            components/
                header.tsx
                providers.tsx
                theme-provider.tsx
                theme-toggle.tsx
                auth/
                    SocialLoginButtons.tsx
                chat/
                    chat-panel.tsx
                    compact-chat-panel.tsx
                    conversation-list.tsx
                    markdown-message.tsx
                    suggested-prompts.tsx
                    types.ts
                pwa/
                    register-service-worker.tsx
                widget/
                    chat-widget.tsx
            context/
                AuthContext.tsx
            hooks/
                useAuth.ts
            lib/
                aiProvider.ts
                apiClient.ts
                apiTypes.ts
                authClient.ts
                authStorage.ts
                bottomSheet.ts
                chatClient.ts
                llmClient.ts
            public/
                manifest.webmanifest
                offline.html
                service-worker.js
                icons/
            __tests__/
                bottom-sheet.test.ts
                chat-client.test.ts
                conversation-list.test.tsx
                social-login-buttons.test.tsx
        parkmate/
            parkmate.types.ts
    k8s/
        beat-deployment.yaml
        configmap.yaml
        hpa.yaml
        ingress.yaml
        secret-example.yaml
        web-deployment.yaml
        web-service.yaml
        worker-deployment.yaml
    nginx/
        nginx.conf
    parking/
        __init__.py
        admin.py
        apps.py
        models.py
        models_notification.py
        push.py
        serializers.py
        tasks.py
        urls.py
        views.py
        analytics/
            __init__.py
        management/
            commands/
                seed_demo_parking.py
                send_expiry_notifications.py
        migrations/
            0001_initial.py
            0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
            0003_booking_ai_fields.py
            0004_favoriteparkingspot_savedplace.py
            0005_pushsubscription.py
            0006_booking_billing_mode.py
            0007_notificationsettings.py
            0008_indexes.py
            0009_remove_booking_booking_time_idx_and_more.py
            __init__.py
        notifications/
            __init__.py
        tests/
            __init__.py
            test_mobile_api.py
            test_pwa_endpoints.py
    payments/
        __init__.py
        admin.py
        apps.py
        models.py
        providers.py
        serializers.py
        tasks.py
        views.py
        migrations/
            0001_initial.py
            0002_alter_payment_provider.py
            0003_paymentmethod.py
            __init__.py
        providers/
            __init__.py
            base.py
            registry.py
            stripe.py
            yookassa.py
    regions/
        global.yml
        ru.yml
    services/
        __init__.py
        llm.py
        llm_service/
            Dockerfile
            main.py
            requirements.txt
    static/
        manifest.webmanifest
        service-worker.js
        css/
            app.css
            cinematic-ui.css
        icons/
        js/
            app.js
            chat.js
            map.js
            parkmate-ai.ts
            quantum-theme-manager.js
            theme.js
        pwa/
            api-client.js
            app.js
            router.js
            spots-view.js
            state-store.js
            ui-kit.js
    templates/
        base.html
        offline.html
        accounts/
            login.html
            mfa_setup.html
            mfa_verify.html
            password_change.html
            password_change_done.html
            password_reset.html
            password_reset_complete.html
            password_reset_confirm.html
            password_reset_done.html
            password_reset_email.txt
            password_reset_subject.txt
            profile.html
            register.html
        admin/
            metrics.html
        ai/
            concierge.html
        parking/
            booking_confirm.html
            business_reports.html
            landing.html
            map_fullscreen.html
            owner_dashboard.html
            payment_methods.html
            profile_settings.html
            promo_activate.html
            pwa_install.html
            user_dashboard.html
    vehicles/
        __init__.py
        admin.py
        apps.py
        models.py
        serializers.py
        urls.py
        views.py
        migrations/
            0001_initial.py
            __init__.py


FILES INDEX:
--------------------------------------------------------------------------------
1. PATH=.env | LANG=text
2. PATH=.env.example | LANG=text
3. PATH=.env.prod | LANG=text
4. PATH=.gitattributes | LANG=text
5. PATH=.gitignore | LANG=text
6. PATH=.ruff.toml | LANG=toml
7. PATH=Dockerfile | LANG=text
8. PATH=Makefile | LANG=text
9. PATH=README.md | LANG=markdown
10. PATH=api_server.py | LANG=python
11. PATH=app.js | LANG=javascript
12. PATH=celerybeat-schedule.bak | LANG=text
13. PATH=celerybeat-schedule.dat | LANG=text
14. PATH=celerybeat-schedule.dir | LANG=text
15. PATH=chat_test.py | LANG=python
16. PATH=chat_test_len.py | LANG=python
17. PATH=count_spots.py | LANG=python
18. PATH=database.py | LANG=python
19. PATH=docker-compose.prod.yml | LANG=yaml
20. PATH=docker-compose.yml | LANG=yaml
21. PATH=dump_project.py | LANG=python
22. PATH=entrypoint.sh | LANG=bash
23. PATH=index.html | LANG=html
24. PATH=model_training.py | LANG=python
25. PATH=mypy.ini | LANG=ini
26. PATH=print_base.py | LANG=python
27. PATH=print_llm_env.py | LANG=python
28. PATH=project_dump.txt | LANG=text
29. PATH=requirements.txt | LANG=text
30. PATH=run_dev.bat | LANG=batch
31. PATH=run_dev.py | LANG=python
32. PATH=run_dev.sh | LANG=bash
33. PATH=accounts\__init__.py | LANG=python
34. PATH=accounts\admin.py | LANG=python
35. PATH=accounts\apps.py | LANG=python
36. PATH=accounts\auth.py | LANG=python
37. PATH=accounts\authentication.py | LANG=python
38. PATH=accounts\forms.py | LANG=python
39. PATH=accounts\models.py | LANG=python
40. PATH=accounts\oauth.py | LANG=python
41. PATH=accounts\serializers.py | LANG=python
42. PATH=accounts\urls.py | LANG=python
43. PATH=accounts\utils.py | LANG=python
44. PATH=accounts\views.py | LANG=python
45. PATH=accounts\migrations\0001_initial.py | LANG=python
46. PATH=accounts\migrations\0002_user_email_hash_user_phone_hash_logincode.py | LANG=python
47. PATH=accounts\migrations\0003_userlevel_userbadge_promoreward.py | LANG=python
48. PATH=accounts\migrations\0004_socialaccount.py | LANG=python
49. PATH=accounts\migrations\0005_logincode_attempts_status.py | LANG=python
50. PATH=accounts\migrations\0006_user_mfa_fields.py | LANG=python
51. PATH=accounts\migrations\0007_user_last_mfa_change.py | LANG=python
52. PATH=accounts\migrations\0008_rename_accounts_so_provide_3a0cdb_idx_accounts_so_provide_98721f_idx_and_more.py | LANG=python
53. PATH=accounts\migrations\__init__.py | LANG=python
54. PATH=accounts\tests\__init__.py | LANG=python
55. PATH=accounts\tests\test_mfa.py | LANG=python
56. PATH=ai\__init__.py | LANG=python
57. PATH=ai\admin.py | LANG=python
58. PATH=ai\apps.py | LANG=python
59. PATH=ai\features.py | LANG=python
60. PATH=ai\models.py | LANG=python
61. PATH=ai\orchestrator.py | LANG=python
62. PATH=ai\pricing.py | LANG=python
63. PATH=ai\serializers.py | LANG=python
64. PATH=ai\tasks.py | LANG=python
65. PATH=ai\tools.py | LANG=python
66. PATH=ai\views.py | LANG=python
67. PATH=ai\chat\__init__.py | LANG=python
68. PATH=ai\chat\parking_assistant.py | LANG=python
69. PATH=ai\management\__init__.py | LANG=python
70. PATH=ai\management\commands\__init__.py | LANG=python
71. PATH=ai\management\commands\train_chat_intents_from_logs.py | LANG=python
72. PATH=ai\migrations\0001_initial.py | LANG=python
73. PATH=ai\migrations\__init__.py | LANG=python
74. PATH=ai\tests\__init__.py | LANG=python
75. PATH=ai\tests\test_assistant_sessions.py | LANG=python
76. PATH=ai_services\__init__.py | LANG=python
77. PATH=ai_services\ai_pricing_service\__init__.py | LANG=python
78. PATH=ai_services\ai_pricing_service\main.py | LANG=python
79. PATH=ai_services\cv_service\__init__.py | LANG=python
80. PATH=ai_services\cv_service\main.py | LANG=python
81. PATH=backend\__init__.py | LANG=python
82. PATH=backend\manage.py | LANG=python
83. PATH=backend\backend\__init__.py | LANG=python
84. PATH=backend\backend\health.py | LANG=python
85. PATH=backend\backend\config\__init__.py | LANG=python
86. PATH=backend\backend\config\asgi.py | LANG=python
87. PATH=backend\backend\config\celery.py | LANG=python
88. PATH=backend\backend\config\urls.py | LANG=python
89. PATH=backend\backend\config\wsgi.py | LANG=python
90. PATH=backend\backend\settings\__init__.py | LANG=python
91. PATH=backend\backend\settings\base.py | LANG=python
92. PATH=backend\backend\settings\local.py | LANG=python
93. PATH=backend\backend\settings\production.py | LANG=python
94. PATH=backend\backend\settings\regions.py | LANG=python
95. PATH=backend\rest_framework_simplejwt\__init__.py | LANG=python
96. PATH=backend\rest_framework_simplejwt\authentication.py | LANG=python
97. PATH=backend\rest_framework_simplejwt\tokens.py | LANG=python
98. PATH=backend\rest_framework_simplejwt\views.py | LANG=python
99. PATH=backend\tests\__init__.py | LANG=python
100. PATH=backend\tests\test_access_control.py | LANG=python
101. PATH=backend\tests\test_analytics.py | LANG=python
102. PATH=backend\tests\test_assistant_tools.py | LANG=python
103. PATH=backend\tests\test_auth_api.py | LANG=python
104. PATH=backend\tests\test_auth_mfa.py | LANG=python
105. PATH=backend\tests\test_billing_modes.py | LANG=python
106. PATH=backend\tests\test_booking_model.py | LANG=python
107. PATH=backend\tests\test_business_reports.py | LANG=python
108. PATH=backend\tests\test_error_formats.py | LANG=python
109. PATH=backend\tests\test_health.py | LANG=python
110. PATH=backend\tests\test_input_limits.py | LANG=python
111. PATH=backend\tests\test_maintenance_mode.py | LANG=python
112. PATH=backend\tests\test_notification_scheduling.py | LANG=python
113. PATH=backend\tests\test_notification_settings.py | LANG=python
114. PATH=backend\tests\test_offline_onboarding.py | LANG=python
115. PATH=backend\tests\test_payment_methods_view.py | LANG=python
116. PATH=backend\tests\test_preferences_view.py | LANG=python
117. PATH=backend\tests\test_promo_activate.py | LANG=python
118. PATH=backend\tests\test_security_headers.py | LANG=python
119. PATH=backend\tests\test_ui_theme_chat.py | LANG=python
120. PATH=core\__init__.py | LANG=python
121. PATH=core\admin.py | LANG=python
122. PATH=core\api_keys.py | LANG=python
123. PATH=core\apps.py | LANG=python
124. PATH=core\context_processors.py | LANG=python
125. PATH=core\db_router.py | LANG=python
126. PATH=core\feature_flags.py | LANG=python
127. PATH=core\integrations.py | LANG=python
128. PATH=core\metrics.py | LANG=python
129. PATH=core\middleware.py | LANG=python
130. PATH=core\models.py | LANG=python
131. PATH=core\observability.py | LANG=python
132. PATH=core\pagination.py | LANG=python
133. PATH=core\permissions.py | LANG=python
134. PATH=core\sms.py | LANG=python
135. PATH=core\utils.py | LANG=python
136. PATH=core\management\__init__.py | LANG=python
137. PATH=core\management\commands\__init__.py | LANG=python
138. PATH=core\management\commands\migrate_safe.py | LANG=python
139. PATH=core\migrations\0001_initial.py | LANG=python
140. PATH=core\migrations\0002_rename_core_audit_action_6abf09_idx_core_auditl_action_d9fb24_idx_and_more.py | LANG=python
141. PATH=core\migrations\__init__.py | LANG=python
142. PATH=core\tests\test_feature_flags.py | LANG=python
143. PATH=docs\auth_mfa_and_social_login.md | LANG=markdown
144. PATH=docs\deploy.md | LANG=markdown
145. PATH=drf_spectacular\__init__.py | LANG=python
146. PATH=drf_spectacular\openapi.py | LANG=python
147. PATH=drf_spectacular\views.py | LANG=python
148. PATH=frontend\next-app\.env.local | LANG=text
149. PATH=frontend\next-app\.eslintrc.json | LANG=json
150. PATH=frontend\next-app\Dockerfile | LANG=text
151. PATH=frontend\next-app\jest.config.js | LANG=javascript
152. PATH=frontend\next-app\jest.setup.ts | LANG=typescript
153. PATH=frontend\next-app\next-env.d.ts | LANG=typescript
154. PATH=frontend\next-app\next.config.mjs | LANG=text
155. PATH=frontend\next-app\package.json | LANG=json
156. PATH=frontend\next-app\postcss.config.js | LANG=javascript
157. PATH=frontend\next-app\tailwind.config.ts | LANG=typescript
158. PATH=frontend\next-app\tsconfig.json | LANG=json
159. PATH=frontend\next-app\app\globals.css | LANG=css
160. PATH=frontend\next-app\app\layout.tsx | LANG=tsx
161. PATH=frontend\next-app\app\(site)\layout.tsx | LANG=tsx
162. PATH=frontend\next-app\app\(site)\page.tsx | LANG=tsx
163. PATH=frontend\next-app\app\(site)\auth\page.tsx | LANG=tsx
164. PATH=frontend\next-app\app\api\chat\route.ts | LANG=typescript
165. PATH=frontend\next-app\app\embed\page.tsx | LANG=tsx
166. PATH=frontend\next-app\components\header.tsx | LANG=tsx
167. PATH=frontend\next-app\components\providers.tsx | LANG=tsx
168. PATH=frontend\next-app\components\theme-provider.tsx | LANG=tsx
169. PATH=frontend\next-app\components\theme-toggle.tsx | LANG=tsx
170. PATH=frontend\next-app\components\auth\SocialLoginButtons.tsx | LANG=tsx
171. PATH=frontend\next-app\components\chat\chat-panel.tsx | LANG=tsx
172. PATH=frontend\next-app\components\chat\compact-chat-panel.tsx | LANG=tsx
173. PATH=frontend\next-app\components\chat\conversation-list.tsx | LANG=tsx
174. PATH=frontend\next-app\components\chat\markdown-message.tsx | LANG=tsx
175. PATH=frontend\next-app\components\chat\suggested-prompts.tsx | LANG=tsx
176. PATH=frontend\next-app\components\chat\types.ts | LANG=typescript
177. PATH=frontend\next-app\components\pwa\register-service-worker.tsx | LANG=tsx
178. PATH=frontend\next-app\components\widget\chat-widget.tsx | LANG=tsx
179. PATH=frontend\next-app\context\AuthContext.tsx | LANG=tsx
180. PATH=frontend\next-app\hooks\useAuth.ts | LANG=typescript
181. PATH=frontend\next-app\lib\aiProvider.ts | LANG=typescript
182. PATH=frontend\next-app\lib\apiClient.ts | LANG=typescript
183. PATH=frontend\next-app\lib\apiTypes.ts | LANG=typescript
184. PATH=frontend\next-app\lib\authClient.ts | LANG=typescript
185. PATH=frontend\next-app\lib\authStorage.ts | LANG=typescript
186. PATH=frontend\next-app\lib\bottomSheet.ts | LANG=typescript
187. PATH=frontend\next-app\lib\chatClient.ts | LANG=typescript
188. PATH=frontend\next-app\lib\llmClient.ts | LANG=typescript
189. PATH=frontend\next-app\public\manifest.webmanifest | LANG=text
190. PATH=frontend\next-app\public\offline.html | LANG=html
191. PATH=frontend\next-app\public\service-worker.js | LANG=javascript
192. PATH=frontend\next-app\__tests__\bottom-sheet.test.ts | LANG=typescript
193. PATH=frontend\next-app\__tests__\chat-client.test.ts | LANG=typescript
194. PATH=frontend\next-app\__tests__\conversation-list.test.tsx | LANG=tsx
195. PATH=frontend\next-app\__tests__\social-login-buttons.test.tsx | LANG=tsx
196. PATH=frontend\parkmate\parkmate.types.ts | LANG=typescript
197. PATH=k8s\beat-deployment.yaml | LANG=yaml
198. PATH=k8s\configmap.yaml | LANG=yaml
199. PATH=k8s\hpa.yaml | LANG=yaml
200. PATH=k8s\ingress.yaml | LANG=yaml
201. PATH=k8s\secret-example.yaml | LANG=yaml
202. PATH=k8s\web-deployment.yaml | LANG=yaml
203. PATH=k8s\web-service.yaml | LANG=yaml
204. PATH=k8s\worker-deployment.yaml | LANG=yaml
205. PATH=nginx\nginx.conf | LANG=text
206. PATH=parking\__init__.py | LANG=python
207. PATH=parking\admin.py | LANG=python
208. PATH=parking\apps.py | LANG=python
209. PATH=parking\models.py | LANG=python
210. PATH=parking\models_notification.py | LANG=python
211. PATH=parking\push.py | LANG=python
212. PATH=parking\serializers.py | LANG=python
213. PATH=parking\tasks.py | LANG=python
214. PATH=parking\urls.py | LANG=python
215. PATH=parking\views.py | LANG=python
216. PATH=parking\analytics\__init__.py | LANG=python
217. PATH=parking\management\commands\seed_demo_parking.py | LANG=python
218. PATH=parking\management\commands\send_expiry_notifications.py | LANG=python
219. PATH=parking\migrations\0001_initial.py | LANG=python
220. PATH=parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py | LANG=python
221. PATH=parking\migrations\0003_booking_ai_fields.py | LANG=python
222. PATH=parking\migrations\0004_favoriteparkingspot_savedplace.py | LANG=python
223. PATH=parking\migrations\0005_pushsubscription.py | LANG=python
224. PATH=parking\migrations\0006_booking_billing_mode.py | LANG=python
225. PATH=parking\migrations\0007_notificationsettings.py | LANG=python
226. PATH=parking\migrations\0008_indexes.py | LANG=python
227. PATH=parking\migrations\0009_remove_booking_booking_time_idx_and_more.py | LANG=python
228. PATH=parking\migrations\__init__.py | LANG=python
229. PATH=parking\notifications\__init__.py | LANG=python
230. PATH=parking\tests\__init__.py | LANG=python
231. PATH=parking\tests\test_mobile_api.py | LANG=python
232. PATH=parking\tests\test_pwa_endpoints.py | LANG=python
233. PATH=payments\__init__.py | LANG=python
234. PATH=payments\admin.py | LANG=python
235. PATH=payments\apps.py | LANG=python
236. PATH=payments\models.py | LANG=python
237. PATH=payments\providers.py | LANG=python
238. PATH=payments\serializers.py | LANG=python
239. PATH=payments\tasks.py | LANG=python
240. PATH=payments\views.py | LANG=python
241. PATH=payments\migrations\0001_initial.py | LANG=python
242. PATH=payments\migrations\0002_alter_payment_provider.py | LANG=python
243. PATH=payments\migrations\0003_paymentmethod.py | LANG=python
244. PATH=payments\migrations\__init__.py | LANG=python
245. PATH=payments\providers\__init__.py | LANG=python
246. PATH=payments\providers\base.py | LANG=python
247. PATH=payments\providers\registry.py | LANG=python
248. PATH=payments\providers\stripe.py | LANG=python
249. PATH=payments\providers\yookassa.py | LANG=python
250. PATH=regions\global.yml | LANG=yaml
251. PATH=regions\ru.yml | LANG=yaml
252. PATH=services\__init__.py | LANG=python
253. PATH=services\llm.py | LANG=python
254. PATH=services\llm_service\Dockerfile | LANG=text
255. PATH=services\llm_service\main.py | LANG=python
256. PATH=services\llm_service\requirements.txt | LANG=text
257. PATH=static\manifest.webmanifest | LANG=text
258. PATH=static\service-worker.js | LANG=javascript
259. PATH=static\css\app.css | LANG=css
260. PATH=static\css\cinematic-ui.css | LANG=css
261. PATH=static\js\app.js | LANG=javascript
262. PATH=static\js\chat.js | LANG=javascript
263. PATH=static\js\map.js | LANG=javascript
264. PATH=static\js\parkmate-ai.ts | LANG=typescript
265. PATH=static\js\quantum-theme-manager.js | LANG=javascript
266. PATH=static\js\theme.js | LANG=javascript
267. PATH=static\pwa\api-client.js | LANG=javascript
268. PATH=static\pwa\app.js | LANG=javascript
269. PATH=static\pwa\router.js | LANG=javascript
270. PATH=static\pwa\spots-view.js | LANG=javascript
271. PATH=static\pwa\state-store.js | LANG=javascript
272. PATH=static\pwa\ui-kit.js | LANG=javascript
273. PATH=templates\base.html | LANG=html
274. PATH=templates\offline.html | LANG=html
275. PATH=templates\accounts\login.html | LANG=html
276. PATH=templates\accounts\mfa_setup.html | LANG=html
277. PATH=templates\accounts\mfa_verify.html | LANG=html
278. PATH=templates\accounts\password_change.html | LANG=html
279. PATH=templates\accounts\password_change_done.html | LANG=html
280. PATH=templates\accounts\password_reset.html | LANG=html
281. PATH=templates\accounts\password_reset_complete.html | LANG=html
282. PATH=templates\accounts\password_reset_confirm.html | LANG=html
283. PATH=templates\accounts\password_reset_done.html | LANG=html
284. PATH=templates\accounts\password_reset_email.txt | LANG=text
285. PATH=templates\accounts\password_reset_subject.txt | LANG=text
286. PATH=templates\accounts\profile.html | LANG=html
287. PATH=templates\accounts\register.html | LANG=html
288. PATH=templates\admin\metrics.html | LANG=html
289. PATH=templates\ai\concierge.html | LANG=html
290. PATH=templates\parking\booking_confirm.html | LANG=html
291. PATH=templates\parking\business_reports.html | LANG=html
292. PATH=templates\parking\landing.html | LANG=html
293. PATH=templates\parking\map_fullscreen.html | LANG=html
294. PATH=templates\parking\owner_dashboard.html | LANG=html
295. PATH=templates\parking\payment_methods.html | LANG=html
296. PATH=templates\parking\profile_settings.html | LANG=html
297. PATH=templates\parking\promo_activate.html | LANG=html
298. PATH=templates\parking\pwa_install.html | LANG=html
299. PATH=templates\parking\user_dashboard.html | LANG=html
300. PATH=vehicles\__init__.py | LANG=python
301. PATH=vehicles\admin.py | LANG=python
302. PATH=vehicles\apps.py | LANG=python
303. PATH=vehicles\models.py | LANG=python
304. PATH=vehicles\serializers.py | LANG=python
305. PATH=vehicles\urls.py | LANG=python
306. PATH=vehicles\views.py | LANG=python
307. PATH=vehicles\migrations\0001_initial.py | LANG=python
308. PATH=vehicles\migrations\__init__.py | LANG=python


================================================================================
FILES CONTENT:
================================================================================

===== FILE START =====
FILE_INDEX: 1
PATH: .env
LANG: text
===== CONTENT START =====
DEBUG=1
SECRET_KEY=change_this_to_a_random_long_string
# or use your existing DJANGO_SECRET_KEY if you have one
ALLOWED_HOSTS=127.0.0.1,localhost
DATABASE_NAME=db.sqlite3

YOOKASSA_SHOP_ID=
YOOKASSA_SECRET_KEY=

EMAIL_BACKEND=django.core.mail.backends.console.EmailBackend


# Карты / регион
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc

# Старый токен Mapbox
MAPBOX_TOKEN=your_actual_token_here

# OPENAI_API_KEY=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

# LLM / AI
LLM_SERVICE_URL=http://127.0.0.1:8002

# OpenAI GPT-3.5
LLM_OPENAI_API_KEY=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

# Основная модель
LLM_DEFAULT_MODEL=gpt-3.5-turbo

# Список fallback-моделей ДОЛЖЕН быть JSON-списком или строкой с запятыми
LLM_FALLBACK_MODELS=["gpt-3.5-turbo"]

#LLM_GROQ_API_KEY=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

# Настройки LLM
LLM_CACHE_ENABLED=true
LLM_CACHE_TTL_SECONDS=30
LLM_REQUESTS_PER_MINUTE=60

# Django Settings
DJANGO_SETTINGS_MODULE=backend.backend.settings.local

# Redis & Celery
REDIS_URL=redis://localhost:6379/0
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/0

# Database
DATABASE_URL=sqlite:///db.sqlite3
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 2
PATH: .env.example
LANG: text
===== CONTENT START =====
SECRET_KEY=changeme
DEBUG=True
DATABASE_URL=sqlite:///db.sqlite3
ALLOWED_HOSTS=127.0.0.1,localhost

# Map
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc

# AI / LLM
LLM_PROVIDER=openai
LLM_API_URL=https://api.example.com
LLM_API_KEY=your-llm-key

# Push / WebPush
PUSH_PUBLIC_KEY=
PUSH_PRIVATE_KEY=

# Auth / OTP
AUTH_OTP_CODE_TTL_SECONDS=600
AUTH_OTP_WINDOW_SECONDS=600
AUTH_OTP_MAX_PER_WINDOW=5
AUTH_OTP_MAX_ATTEMPTS=5
SMS_PROVIDER=console
SMS_DEFAULT_FROM=ParkShare
ENABLE_METRICS=True

# Social OAuth
VK_OAUTH_CLIENT_ID=
VK_OAUTH_CLIENT_SECRET=
YANDEX_OAUTH_CLIENT_ID=
YANDEX_OAUTH_CLIENT_SECRET=
GOOGLE_OAUTH_CLIENT_ID=
GOOGLE_OAUTH_CLIENT_SECRET=
SOCIAL_OAUTH_TEST_MODE=True

# Payments
PAYMENT_PROVIDER=yookassa
PAYMENT_API_KEY=
PAYMENT_SHOP_ID=

# Misc
ENABLE_NIGHT_RESTRICTION_NOTICES=False

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 3
PATH: .env.prod
LANG: text
===== CONTENT START =====
# -----------------------------
# DJANGO SETTINGS (PROD)
# -----------------------------
DEBUG=0
SECRET_KEY=django-insecure-поставь_сюда_очень_длинную_строку_символов
ALLOWED_HOSTS=your-domain.ru,your-domain.com,127.0.0.1

DJANGO_SETTINGS_MODULE=backend.settings.production

# -----------------------------
# DATABASE (PostgreSQL / PostGIS)
# -----------------------------
DATABASE_NAME=parkshare
DATABASE_USER=parkshare
DATABASE_PASSWORD=сильный_пароль_к_бд
DATABASE_HOST=db
DATABASE_PORT=5432

# -----------------------------
# YOOKASSA PAYMENTS (боевые реквизиты)
# -----------------------------
YOOKASSA_SHOP_ID=твой_shop_id
YOOKASSA_SECRET_KEY=твой_secret_key

# -----------------------------
# EMAIL SETTINGS
# -----------------------------
EMAIL_BACKEND=django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST=smtp.yandex.ru
EMAIL_PORT=465
EMAIL_USE_SSL=1
EMAIL_HOST_USER=no-reply@your-domain.ru
EMAIL_HOST_PASSWORD=пароль_от_почты

# -----------------------------
# MAP / REGION
# -----------------------------
REGION_PROFILE=RU
MAP_PROVIDER=yandex
YANDEX_MAP_API_KEY=8fee7d21-b90a-43cd-8536-7acf9fc3c1cc
MAPBOX_TOKEN=your_actual_token_here

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 4
PATH: .gitattributes
LANG: text
===== CONTENT START =====
# Auto detect text files and perform LF normalization
* text=auto

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 5
PATH: .gitignore
LANG: text
===== CONTENT START =====
db.sqlite3
__pycache__/
*.pyc
.env
staticfiles/
frontend/next-app/node_modules/
.next/
node_modules/

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 6
PATH: .ruff.toml
LANG: toml
===== CONTENT START =====
line-length = 120
target-version = "py311"
extend-select = ["B", "E", "F", "W"]
ignore = ["E501"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 7
PATH: Dockerfile
LANG: text
===== CONTENT START =====
# Production-ready Dockerfile
FROM python:3.12-slim AS builder
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1

RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    gdal-bin \
    libgdal-dev \
    binutils \
    libproj-dev \
    libgeos-dev \
    libspatialindex-dev \
    gettext \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt /app/
RUN pip install --upgrade pip && pip install -r requirements.txt
COPY . /app/

RUN python backend/manage.py collectstatic --noinput --settings=backend.backend.settings.production || true

FROM python:3.12-slim AS runtime
ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1
WORKDIR /app

COPY --from=builder /usr/local/lib/python3.12 /usr/local/lib/python3.12
COPY --from=builder /usr/local/bin /usr/local/bin
COPY --from=builder /app /app

EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD curl -f http://localhost:8000/health/ || exit 1
CMD ["gunicorn", "backend.config.wsgi:application", "--bind", "0.0.0.0:8000"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 8
PATH: Makefile
LANG: text
===== CONTENT START =====
PYTHON=python
MANAGE=backend/manage.py

lint:
\truff check .

typecheck:
\tmypy ai parking

test:
\t$(PYTHON) $(MANAGE) test

migrate_safe:
\t$(PYTHON) $(MANAGE) migrate_safe --apply

.PHONY: lint typecheck test migrate_safe

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 9
PATH: README.md
LANG: markdown
===== CONTENT START =====
# ParkShare RU — Django + PWA

Единственная продакшн-UI поверхность — Django-шаблоны (карта, ассистент, бронирования, PWA).

## Архитектура (коротко)
- Backend: Django + DRF (parking/search/booking/payments/metrics/notifications).
- Карта: Yandex/Leaflet абстракция, без Google Maps.
- Ассистент: /api/chat/ (streaming) + ai/tools.py (search/booking/favorite/prefs), preference-aware.
- Биллинг: booking_confirm с billing_mode (pay_as_you_go 15м слоты, prepaid_block 2/4/24h), бизнес-флаг и отчёты.
- Платежи/промо/награды: PaymentMethod, PromoReward, UserLevel/Badge.
- PWA: сервис-воркер, offline shell, onboarding, push, NotificationSettings + send_expiry_notifications.
- Метрики/A-B: UiEvent/Booking/ChatSession, staff dashboard (metrics) с 7/30-дневным срезом и вариантами A/B.

## Запуск (локально)
```bash
pip install -r requirements.txt
python manage.py migrate
python manage.py runserver
```

### Настройки
- Используйте `DJANGO_SETTINGS_MODULE` (`backend.backend.settings.local`/`production`) для выбора профиля.
- Общие параметры лежат в `backend/backend/settings/base.py`; dev/prod наследуют.

## Уведомления
- Включение флагов: профиль → уведомления.
- Отправка напоминаний: `python manage.py send_expiry_notifications --minutes 30`

## Тесты
```bash
python manage.py test
```

## Линт/типизация
```bash
ruff check .
mypy ai parking
```

## Полезные команды
- `make test` — все тесты
- `make lint` — ruff
- `make typecheck` — mypy на основных пакетах
- `python manage.py send_expiry_notifications --minutes 30` — напоминания о завершении брони
- health/ready: `/healthz`, `/readyz`

## Конфигурация (env)
- MAP_PROVIDER / YANDEX_MAP_API_KEY
- LLM_PROVIDER / LLM_API_URL / LLM_API_KEY (для ассистента)
- PUSH_PUBLIC_KEY / PUSH_PRIVATE_KEY (если используете WebPush)
- Billing/Payments: провайдеры/ключи (YooKassa и др.) из `.env`
- Флаги: MAINTENANCE_MODE, ENABLE_EXPERIMENTAL_ASSISTANT, ENABLE_AB_VARIANTS
- Auth: OTP (AUTH_OTP_*), SMS_PROVIDER/SMS_DEFAULT_FROM, OAuth (VK/Yandex/Google client id/secret), ENABLE_METRICS для `/metrics`

## Основные ссылки
- Карта: `/`
- Полная карта: `/map/`
- Ассистент: `/assistant/`
- Бронирование: `/booking/confirm/`
- Платежи: `/payments/methods/`
- Предпочтения/уведомления: `/profile/settings/`
- Промокоды: `/promos/activate/`
- Бизнес-отчёты: `/business/reports/`
- Метрики (staff): `/admin/metrics-lite/`

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 10
PATH: api_server.py
LANG: python
===== CONTENT START =====
# api_server.py
from __future__ import annotations

import datetime as dt
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

import joblib
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

from database import get_connection

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"

# --- Загрузка моделей ---

occ_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "occupancy_model.pkl")
OCC_PIPE = occ_bundle["pipeline"]
OCC_FEATURE_COLS = occ_bundle["feature_cols"]

NLP_PIPE = joblib.load(MODELS_DIR / "nlp_intent.pkl")

rec_bundle: Dict[str, Any] = joblib.load(MODELS_DIR / "recommender.pkl")
USER_ITEM: pd.DataFrame = rec_bundle["user_item"]
ITEM_SIM: pd.DataFrame = rec_bundle["item_sim"]
LOT_FEATURES: pd.DataFrame = rec_bundle["lot_features"]

# --- FastAPI ---

app = FastAPI(title="ParkShare Local AI", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # при желании ограничить доменом PWA
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ---------- Схемы ----------


class Lot(BaseModel):
    id: int
    name: str
    latitude: float
    longitude: float
    near_metro: bool
    price_level: int
    has_covered: bool
    has_ev_charging: bool
    predicted_occupancy: float


class SearchResult(BaseModel):
    query: str
    intent: str
    time_of_day: Optional[str]
    near_metro: Optional[bool]
    max_price_level: Optional[int]
    has_ev_charging: Optional[bool]
    has_covered: Optional[bool]
    lots: List[Lot]


class OccupancyPredictionResponse(BaseModel):
    lot_id: int
    ts: dt.datetime
    predicted_occupancy: float


class Recommendation(BaseModel):
    lot: Lot
    score: float


class RecommendationsResponse(BaseModel):
    user_id: Optional[int]
    variant: str  # 'A' или 'B' для A/B теста
    recommendations: List[Recommendation]


# ---------- Утилиты ----------


def parse_dt_iso(value: Optional[str]) -> dt.datetime:
    if not value:
        return dt.datetime.now()
    try:
        return dt.datetime.fromisoformat(value)
    except Exception as exc:
        raise HTTPException(status_code=400, detail=f"Неверный формат datetime: {value}") from exc


def nlp_extract_entities(text: str) -> Dict[str, Any]:
    s = text.lower()

    time_of_day = None
    if "утр" in s:
        time_of_day = "morning"
    elif "днем" in s or "днём" in s:
        time_of_day = "day"
    elif "вечер" in s:
        time_of_day = "evening"
    elif "ноч" in s:
        time_of_day = "night"

    near_metro = "метро" in s

    max_price_level: Optional[int] = None
    if "дешев" in s or "недорог" in s:
        max_price_level = 1
    elif "средн" in s:
        max_price_level = 2
    elif "дорог" in s:
        max_price_level = 3

    has_ev = "электро" in s or "зарядк" in s or "ev" in s
    has_covered = "крыт" in s or "подзем" in s or "паркинг" in s

    return {
        "time_of_day": time_of_day,
        "near_metro": near_metro if near_metro else None,
        "max_price_level": max_price_level,
        "has_ev_charging": has_ev if has_ev else None,
        "has_covered": has_covered if has_covered else None,
    }


def build_occ_feature_df(lot_row: Dict[str, Any], ts: dt.datetime) -> pd.DataFrame:
    return pd.DataFrame(
        [
            {
                "hour": ts.hour,
                "dow": ts.weekday(),
                "temperature": 15.0,  # без реальной погоды
                "is_rain": 0,
                "is_event": 0,
                "near_metro": lot_row["near_metro"],
                "price_level": lot_row["price_level"],
                "has_covered": lot_row["has_covered"],
                "has_ev_charging": lot_row["has_ev_charging"],
                "lot_id_str": str(lot_row["id"]),
            }
        ]
    )[OCC_FEATURE_COLS]


def predict_occupancy_for_lot(lot_row: Dict[str, Any], ts: dt.datetime) -> float:
    df = build_occ_feature_df(lot_row, ts)
    pred = float(OCC_PIPE.predict(df)[0])
    return max(0.0, min(pred, 1.0))


def fetch_lots(filters: Dict[str, Any] | None = None) -> List[Dict[str, Any]]:
    conn = get_connection()
    cur = conn.cursor()

    base_query = """
        SELECT
            id, name, latitude, longitude,
            near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE 1=1
    """
    params: List[Any] = []

    if filters:
        if filters.get("near_metro") is not None:
            base_query += " AND near_metro = ?"
            params.append(1 if filters["near_metro"] else 0)
        if filters.get("max_price_level") is not None:
            base_query += " AND price_level <= ?"
            params.append(int(filters["max_price_level"]))
        if filters.get("has_ev_charging") is not None:
            base_query += " AND has_ev_charging = ?"
            params.append(1 if filters["has_ev_charging"] else 0)
        if filters.get("has_covered") is not None:
            base_query += " AND has_covered = ?"
            params.append(1 if filters["has_covered"] else 0)

    base_query += " ORDER BY price_level ASC, near_metro DESC"

    cur.execute(base_query, params)
    rows = [dict(r) for r in cur.fetchall()]
    conn.close()
    return rows


# ---------- Эндпоинты ----------


@app.get("/health")
def health() -> Dict[str, Any]:
    return {"status": "ok"}


@app.get("/api/lots", response_model=List[Lot])
def api_list_lots(
    ts: Optional[str] = Query(default=None, description="ISO datetime, по умолчанию — сейчас"),
) -> List[Lot]:
    dt_value = parse_dt_iso(ts)
    lots = fetch_lots()

    result: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        result.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )
    return result


@app.get("/api/occupancy/predict", response_model=OccupancyPredictionResponse)
def api_predict_occupancy(
    lot_id: int = Query(...),
    ts: Optional[str] = Query(default=None),
) -> OccupancyPredictionResponse:
    dt_value = parse_dt_iso(ts)
    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id = ?
        """,
        (lot_id,),
    )
    row = cur.fetchone()
    conn.close()
    if row is None:
        raise HTTPException(status_code=404, detail="Парковка не найдена")
    d = dict(row)
    occ = predict_occupancy_for_lot(d, dt_value)
    return OccupancyPredictionResponse(
        lot_id=lot_id,
        ts=dt_value,
        predicted_occupancy=occ,
    )


@app.get("/api/search", response_model=SearchResult)
def api_search(
    query: str = Query(..., min_length=1),
    ts: Optional[str] = Query(default=None),
    limit: int = Query(default=15, ge=1, le=100),
) -> SearchResult:
    dt_value = parse_dt_iso(ts)

    intent = NLP_PIPE.predict([query])[0]
    entities = nlp_extract_entities(query)

    filters: Dict[str, Any] = {}
    if entities["near_metro"]:
        filters["near_metro"] = True
    if entities["max_price_level"] is not None:
        filters["max_price_level"] = entities["max_price_level"]
    if entities["has_ev_charging"] is not None:
        filters["has_ev_charging"] = entities["has_ev_charging"]
    if entities["has_covered"] is not None:
        filters["has_covered"] = entities["has_covered"]

    if intent == "near_metro":
        filters["near_metro"] = True
    if intent == "cheap" and "max_price_level" not in filters:
        filters["max_price_level"] = 1

    lots = fetch_lots(filters)
    lots = lots[:limit]

    lot_models: List[Lot] = []
    for row in lots:
        occ = predict_occupancy_for_lot(row, dt_value)
        lot_models.append(
            Lot(
                id=row["id"],
                name=row["name"],
                latitude=row["latitude"],
                longitude=row["longitude"],
                near_metro=bool(row["near_metro"]),
                price_level=row["price_level"],
                has_covered=bool(row["has_covered"]),
                has_ev_charging=bool(row["has_ev_charging"]),
                predicted_occupancy=occ,
            )
        )

    return SearchResult(
        query=query,
        intent=intent,
        time_of_day=entities["time_of_day"],
        near_metro=filters.get("near_metro"),
        max_price_level=filters.get("max_price_level"),
        has_ev_charging=filters.get("has_ev_charging"),
        has_covered=filters.get("has_covered"),
        lots=lot_models,
    )


def _recommend_item_based(user_id: int, top_n: int = 10) -> List[int]:
    if user_id not in USER_ITEM.index:
        return []

    user_ratings = USER_ITEM.loc[user_id]
    rated_items = user_ratings[user_ratings > 0].index.tolist()
    if not rated_items:
        return []

    scores = pd.Series(0.0, index=USER_ITEM.columns)

    for item_id in rated_items:
        sim_vec = ITEM_SIM.loc[item_id]
        scores += sim_vec * float(user_ratings[item_id])

    scores = scores.drop(rated_items)
    scores = scores.sort_values(ascending=False)
    return scores.head(top_n).index.tolist()


def _recommend_content_based(top_n: int = 10) -> List[int]:
    df = LOT_FEATURES.copy()
    df["score"] = 0.0

    df["score"] += (1 - (df["price_level"] - 1) / 2)  # дешёвые выше
    df["score"] += df["near_metro"] * 0.5
    df["score"] += df["has_ev_charging"] * 0.3
    df["score"] += df["has_covered"] * 0.2

    df = df.sort_values("score", ascending=False)
    return df.head(top_n).index.tolist()


@app.get("/api/recommendations", response_model=RecommendationsResponse)
def api_recommendations(
    user_id: Optional[int] = Query(default=None),
    variant: Optional[str] = Query(
        default=None,
        description="A или B — для A/B тестирования (A=collab, B=content)",
    ),
    limit: int = Query(default=10, ge=1, le=50),
    ts: Optional[str] = Query(default=None),
) -> RecommendationsResponse:
    dt_value = parse_dt_iso(ts)

    chosen_variant = variant or ("A" if user_id else "B")

    if chosen_variant == "A" and user_id is not None:
        item_ids = _recommend_item_based(user_id, top_n=limit)
        if not item_ids:
            chosen_variant = "B"
    if chosen_variant == "B" or user_id is None:
        item_ids = _recommend_content_based(top_n=limit)

    conn = get_connection()
    cur = conn.cursor()
    cur.execute(
        f"""
        SELECT id, name, latitude, longitude,
               near_metro, price_level, has_covered, has_ev_charging
        FROM parking_lot
        WHERE id IN ({",".join(["?"] * len(item_ids))})
        """,
        item_ids,
    )
    rows = {r["id"]: dict(r) for r in cur.fetchall()}
    conn.close()

    recs: List[Recommendation] = []
    for lot_id in item_ids:
        row = rows.get(lot_id)
        if not row:
            continue
        occ = predict_occupancy_for_lot(row, dt_value)
        lot = Lot(
            id=row["id"],
            name=row["name"],
            latitude=row["latitude"],
            longitude=row["longitude"],
            near_metro=bool(row["near_metro"]),
            price_level=row["price_level"],
            has_covered=bool(row["has_covered"]),
            has_ev_charging=bool(row["has_ev_charging"]),
            predicted_occupancy=occ,
        )
        # простая метрика: обратная занятость + бонус за метро и цену
        score = (1.0 - occ) + (1 - (row["price_level"] - 1) / 2) + (0.3 if row["near_metro"] else 0.0)
        recs.append(Recommendation(lot=lot, score=float(score)))

    return RecommendationsResponse(
        user_id=user_id,
        variant=chosen_variant,
        recommendations=recs,
    )


if __name__ == "__main__":
    import os
    import uvicorn

    host = os.environ.get("AI_API_HOST", "0.0.0.0")
    try:
        port = int(os.environ.get("AI_API_PORT", "8001"))
    except (TypeError, ValueError):
        port = 8001

    uvicorn.run("api_server:app", host=host, port=port, reload=True)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 11
PATH: app.js
LANG: javascript
===== CONTENT START =====
// app.js

// Базовый URL FastAPI-сервера
// Если сервер крутится на другом порту/домене — поправь здесь.
const API_BASE = "http://localhost:8001";

let map;
let markersLayer;
let lotsCache = [];
let lotsById = new Map();

function pickBestLot(lots) {
  if (!lots || lots.length === 0) return null;
  const ranked = [...lots].sort((a, b) => {
    const occA = a.predicted_occupancy ?? 1;
    const occB = b.predicted_occupancy ?? 1;
    return occA - occB;
  });
  return ranked[0];
}

function updateAIOracleCard(lots) {
  const nameEl = document.getElementById("aiOracleName");
  const etaEl = document.getElementById("aiOracleETA");
  const confEl = document.getElementById("aiOracleConfidence");
  const metaEl = document.getElementById("aiOracleMeta");
  const reasoningEl = document.getElementById("aiOracleReason");

  if (!nameEl || !etaEl || !confEl || !metaEl || !reasoningEl) return;

  if (!lots || lots.length === 0) {
    nameEl.textContent = "—";
    etaEl.textContent = "—";
    confEl.textContent = "—";
    metaEl.textContent = "—";
    reasoningEl.textContent = "AI готовит инсайт…";
    return;
  }

  const bestLot = pickBestLot(lots);
  if (!bestLot) return;

  const occ = bestLot.predicted_occupancy ?? 0;
  const occPercent = Math.round(occ * 100);
  const eta = Math.max(2, Math.min(15, Math.round((1 - occ) * 12)));
  const confidence = Math.max(68, Math.min(99, 96 - Math.round(occPercent / 2)));
  const ev = bestLot.has_ev_charging ? "EV" : "обычная";
  const covered = bestLot.has_covered ? "крытая" : "открытая";

  nameEl.textContent = bestLot.name;
  etaEl.textContent = `${eta} мин`;
  confEl.textContent = `${confidence}%`;
  metaEl.textContent = `${ev} · ${covered}`;
  reasoningEl.textContent =
    "Учитывая вашу историю: быстрый выезд, EV и близость к метро — этот слот даст наивысший WOW-эффект.";
}

// ----------------- ИНИЦИАЛИЗАЦИЯ КАРТЫ -----------------

function occupancyColor(value) {
  if (value <= 0.4) return "#22c55e"; // green
  if (value <= 0.7) return "#eab308"; // yellow
  return "#ef4444"; // red
}

function initMap() {
  map = L.map("map", {
    zoomControl: true,
    attributionControl: false,
  }).setView([55.7558, 37.6173], 12);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
  }).addTo(map);

  markersLayer = L.layerGroup().addTo(map);
}

// ----------------- API HELPERS -----------------

async function apiGet(path, params = {}) {
  const url = new URL(API_BASE + path);
  Object.entries(params).forEach(([k, v]) => {
    if (v !== undefined && v !== null) {
      url.searchParams.set(k, v);
    }
  });

  const res = await fetch(url.toString());
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`API error ${res.status}: ${text}`);
  }
  return res.json();
}

// ----------------- ОТРИСОВКА ЛОТОВ -----------------

function renderLotsOnMap(lots) {
  markersLayer.clearLayers();

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const color = occupancyColor(occ);

    const marker = L.circleMarker([lot.latitude, lot.longitude], {
      radius: 8,
      fillColor: color,
      fillOpacity: 0.9,
      color: "#020617",
      weight: 1,
    });

    const occPercent = Math.round(occ * 100);

    const html = `
      <div style="font-size: 12px;">
        <strong>${lot.name}</strong><br />
        Загрузка: <strong>${occPercent}%</strong><br />
        Метро: ${lot.near_metro ? "рядом" : "нет"}<br />
        Уровень цены: ${lot.price_level}<br />
        Крытая: ${lot.has_covered ? "да" : "нет"}<br />
        Зарядка EV: ${lot.has_ev_charging ? "есть" : "нет"}
      </div>
    `;

    marker.bindPopup(html);
    marker.addTo(markersLayer);
  });

  if (lots.length > 0) {
    const bounds = L.latLngBounds(
      lots.map((lot) => [lot.latitude, lot.longitude])
    );
    map.fitBounds(bounds.pad(0.2));
  }
}

function renderLotsList(containerId, lots, clickHandler) {
  const container = document.getElementById(containerId);
  container.innerHTML = "";

  if (!lots || lots.length === 0) {
    container.innerHTML =
      '<div style="font-size: 0.75rem; color: #6b7280;">Нет данных.</div>';
    return;
  }

  lots.forEach((lot) => {
    const occ = lot.predicted_occupancy ?? 0;
    const occPercent = Math.round(occ * 100);

    const div = document.createElement("div");
    div.className = "lot-item";
    div.innerHTML = `
      <div class="lot-main">
        <div class="lot-name">${lot.name}</div>
        <div class="lot-meta">
          <span>Цена: L${lot.price_level}</span>
          <span>Метро: ${lot.near_metro ? "рядом" : "нет"}</span>
          <span>EV: ${lot.has_ev_charging ? "есть" : "нет"}</span>
          <span>Крытая: ${lot.has_covered ? "да" : "нет"}</span>
        </div>
      </div>
      <div class="lot-occ">${occPercent}%</div>
    `;

    div.addEventListener("click", () => clickHandler(lot));
    container.appendChild(div);
  });
}

// ----------------- ЛОГИКА UI -----------------

async function loadAllLots() {
  const status = document.getElementById("statusText");
  try {
    const lots = await apiGet("/api/lots");
    lotsCache = lots;
    lotsById.clear();
    lots.forEach((lot) => lotsById.set(lot.id, lot));

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = "AI-сервер подключён";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка подключения к AI-серверу";
  }
}

async function handleSearch() {
  const input = document.getElementById("searchInput");
  const status = document.getElementById("searchStatus");
  const text = input.value.trim();
  if (!text) return;

  status.textContent = "Обрабатываю запрос (локальный NLP)…";

  try {
    const data = await apiGet("/api/search", { query: text });
    const lots = data.lots || [];

    renderLotsOnMap(lots);
    renderLotsList("lotsList", lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    const parts = [];
    parts.push(`Интент: ${data.intent}`);
    if (data.near_metro !== null) {
      parts.push(`рядом с метро: ${data.near_metro ? "да" : "нет"}`);
    }
    if (data.max_price_level !== null) {
      parts.push(`макс. уровень цены: L${data.max_price_level}`);
    }
    if (data.has_ev_charging !== null) {
      parts.push(`EV: ${data.has_ev_charging ? "нужна" : "не нужна"}`);
    }
    if (data.has_covered !== null) {
      parts.push(`крытая: ${data.has_covered ? "нужна" : "не нужна"}`);
    }
    if (data.time_of_day) {
      parts.push(`время суток: ${data.time_of_day}`);
    }
    status.textContent = parts.join(" · ") || "Фильтры не распознаны.";
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка обработки запроса";
  }
}

async function initUsersSelect() {
  const select = document.getElementById("userSelect");
  // Пользователи не отдаются API, но user_id есть в тренировочных данных.
  // Для демо предположим, что есть пользователи с id 1..20.
  for (let i = 1; i <= 20; i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `Пользователь #${i}`;
    select.appendChild(opt);
  }
}

async function handleRecommendations(variant) {
  const select = document.getElementById("userSelect");
  const status = document.getElementById("recStatus");
  const listContainerId = "recList";

  const userId = parseInt(select.value, 10) || undefined;

  status.textContent =
    variant === "A"
      ? "Рассчитываю рекомендации (collaborative)…"
      : "Рассчитываю рекомендации (content-based)…";

  try {
    const params = { limit: 10, variant };
    if (variant === "A" && userId) {
      params.user_id = userId;
    }
    const data = await apiGet("/api/recommendations", params);
    const recs = data.recommendations || [];

    const lots = recs.map((r) => r.lot);
    renderLotsOnMap(lots);
    renderLotsList(listContainerId, lots, (lot) => {
      map.setView([lot.latitude, lot.longitude], 16);
    });

    updateAIOracleCard(lots);

    status.textContent = `Вариант ${data.variant}, получено ${recs.length} рекомендаций.`;
  } catch (err) {
    console.error(err);
    status.textContent = "Ошибка получения рекомендаций";
  }
}

// ----------------- СТАРТ -----------------

window.addEventListener("DOMContentLoaded", async () => {
  initMap();
  await initUsersSelect();
  await loadAllLots();

  document
    .getElementById("searchBtn")
    .addEventListener("click", () => handleSearch());

  document
    .getElementById("searchInput")
    .addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        handleSearch();
      }
    });

  document.getElementById("recBtn").addEventListener("click", () => {
    handleRecommendations("A");
  });

  document
    .getElementById("recContentBtn")
    .addEventListener("click", () => {
      handleRecommendations("B");
    });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 12
PATH: celerybeat-schedule.bak
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 13
PATH: celerybeat-schedule.dat
LANG: text
===== CONTENT START =====
�}�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ��	       �5.5.3�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��       �
Europe/Moscow�.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ��.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ��L      }�(�expire_unpaid_bookings��celery.beat��
ScheduleEntry���(�expire_unpaid_bookings��$parking.tasks.expire_unpaid_bookings��datetime��datetime���C
�-�E��builtins��getattr����zoneinfo��ZoneInfo����	_unpickle���R��
Europe/Moscow�K��R���R�K�celery.schedules��schedule���h�	timedelta���K MXK ��R��N��R�)}�}�t�R��update_ai_models�h(�update_ai_models��ai.tasks.update_models�h	C
�-	3Ӕh��R�KhhK MK ��R��N��R�)}�}�t�R��check_stale_payments�h(�check_stale_payments��#payments.tasks.check_stale_payments�h	C
�-	;��h��R�KhhK M�K ��R��N��R�)}�}�t�R�u.
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 14
PATH: celerybeat-schedule.dir
LANG: text
===== CONTENT START =====
'entries', (2048, 599)
'__version__', (512, 20)
'tz', (1024, 28)
'utc_enabled', (1536, 4)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 15
PATH: chat_test.py
LANG: python
===== CONTENT START =====
import os,sys
sys.path.insert(0,r'c:\Users\Sultan\Downloads\parkshare_ru_part1') 
os.environ.setdefault('DJANGO_SETTINGS_MODULE','backend.backend.settings.local') 
import django;django.setup() 
from ai.chat.parking_assistant import generate_chat_reply 
reply=generate_chat_reply('Kurskaya parking 9-11 300 rub ev', [], None) 
print(repr(reply)) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 16
PATH: chat_test_len.py
LANG: python
===== CONTENT START =====
import os,sys,json
sys.path.insert(0,r'c:\Users\Sultan\Downloads\parkshare_ru_part1') 
os.environ.setdefault('DJANGO_SETTINGS_MODULE','backend.backend.settings.local') 
import django;django.setup() 
from ai.chat.parking_assistant import generate_chat_reply 
r=generate_chat_reply('Kurskaya parking 9-11 300 rub ev', [], None) 
print(len(r.get('suggestions',[])), r.get('reply')) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 17
PATH: count_spots.py
LANG: python
===== CONTENT START =====
import os,sys 
sys.path.insert(0,r'c:\Users\Sultan\Downloads\parkshare_ru_part1') 
os.environ.setdefault('DJANGO_SETTINGS_MODULE','backend.backend.settings.local') 
import django;django.setup() 
from parking.models import ParkingSpot 
print(ParkingSpot.objects.count()) 

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 18
PATH: database.py
LANG: python
===== CONTENT START =====
# database.py
from __future__ import annotations

import random
import sqlite3
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import List

DB_PATH = Path(__file__).parent / "ai_data.db"


def get_connection() -> sqlite3.Connection:
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db() -> None:
    conn = get_connection()
    cur = conn.cursor()

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS parking_lot (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            latitude REAL NOT NULL,
            longitude REAL NOT NULL,
            near_metro INTEGER NOT NULL,
            price_level INTEGER NOT NULL,
            has_covered INTEGER NOT NULL,
            has_ev_charging INTEGER NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS occupancy_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            lot_id INTEGER NOT NULL,
            ts TEXT NOT NULL,
            occupancy REAL NOT NULL,
            temperature REAL NOT NULL,
            is_rain INTEGER NOT NULL,
            is_event INTEGER NOT NULL,
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS app_user (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL
        );
        """
    )

    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS user_rating (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            lot_id INTEGER NOT NULL,
            rating REAL NOT NULL,
            FOREIGN KEY (user_id) REFERENCES app_user(id),
            FOREIGN KEY (lot_id) REFERENCES parking_lot(id)
        );
        """
    )

    conn.commit()
    conn.close()


@dataclass
class LotSpec:
    name: str
    base_lat: float
    base_lon: float
    near_metro: int
    price_level: int
    has_covered: int
    has_ev_charging: int


def generate_synthetic_data(
    num_lots: int = 30,
    num_users: int = 50,
    days_back: int = 30,
) -> None:
    """
    Генерация синтетических:
    - парковок
    - истории занятости
    - пользователей
    - оценок пользователей
    """
    random.seed(42)

    conn = get_connection()
    cur = conn.cursor()

    # Чистим старые данные
    cur.execute("DELETE FROM user_rating;")
    cur.execute("DELETE FROM app_user;")
    cur.execute("DELETE FROM occupancy_history;")
    cur.execute("DELETE FROM parking_lot;")
    conn.commit()

    # Базовые точки вокруг Москвы
    center_lat, center_lon = 55.7558, 37.6173

    lots: List[int] = []
    for i in range(num_lots):
        near_metro = 1 if random.random() < 0.5 else 0
        price_level = random.choice([1, 2, 3])  # 1 — дешево, 3 — дорого
        has_covered = 1 if random.random() < 0.4 else 0
        has_ev = 1 if random.random() < 0.3 else 0

        # Немного раскидываем точки вокруг центра
        lat = center_lat + random.uniform(-0.05, 0.05)
        lon = center_lon + random.uniform(-0.1, 0.1)

        cur.execute(
            """
            INSERT INTO parking_lot (
                name, latitude, longitude, near_metro,
                price_level, has_covered, has_ev_charging
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """,
            (
                f"Лот #{i+1}",
                lat,
                lon,
                near_metro,
                price_level,
                has_covered,
                has_ev,
            ),
        )
        lots.append(cur.lastrowid)

    # История занятости — каждые 2 часа за days_back дней
    now = datetime.now()
    start_ts = now - timedelta(days=days_back)

    weather_states = ["sunny", "cloudy", "rainy"]

    for lot_id in lots:
        ts = start_ts
        while ts < now:
            dow = ts.weekday()
            hour = ts.hour

            is_event = 1 if (dow in (4, 5) and hour >= 18 and random.random() < 0.3) else 0
            weather = random.choice(weather_states)
            is_rain = 1 if weather == "rainy" else 0
            temperature = random.uniform(-10, 30)

            # Базовая занятость зависит от часа и дня недели
            base_occ = 0.2
            if 8 <= hour <= 11:
                base_occ = 0.6
            elif 17 <= hour <= 20:
                base_occ = 0.7
            elif 0 <= hour <= 5:
                base_occ = 0.1

            if dow >= 5:
                base_occ += 0.1

            if is_event:
                base_occ += 0.2
            if is_rain:
                base_occ += 0.1

            base_occ = max(0.0, min(base_occ + random.uniform(-0.1, 0.1), 1.0))

            cur.execute(
                """
                INSERT INTO occupancy_history (
                    lot_id, ts, occupancy, temperature, is_rain, is_event
                ) VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    lot_id,
                    ts.isoformat(),
                    base_occ,
                    temperature,
                    is_rain,
                    is_event,
                ),
            )

            ts += timedelta(hours=2)

    # Пользователи
    users = []
    for i in range(num_users):
        cur.execute(
            "INSERT INTO app_user (name) VALUES (?);",
            (f"user_{i+1}",),
        )
        users.append(cur.lastrowid)

    # Оценки пользователей парковок
    for user_id in users:
        # Каждый пользователь оценит 5–15 парковок
        k = random.randint(5, min(15, len(lots)))
        rated_lots = random.sample(lots, k)
        for lot_id in rated_lots:
            # Рейтинг зависит от price_level и случайности
            base_rating = 4.5 - 0.5 * (random.randint(1, 3) - 1)
            rating = max(1.0, min(5.0, base_rating + random.uniform(-1.0, 1.0)))
            cur.execute(
                """
                INSERT INTO user_rating (user_id, lot_id, rating)
                VALUES (?, ?, ?)
                """,
                (user_id, lot_id, rating),
            )

    conn.commit()
    conn.close()
    print("Синтетические данные сгенерированы в", DB_PATH)


if __name__ == "__main__":
    init_db()
    generate_synthetic_data()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 19
PATH: docker-compose.prod.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: gunicorn backend.config.wsgi:application --bind 0.0.0.0:8000
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config worker -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    env_file:
      - .env.prod
    command: celery -A backend.config beat -l info
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    restart: always
    environment:
      NEXTAUTH_URL: ${NEXTAUTH_URL:-http://localhost:3000}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:-change_me_frontend}
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID:-dummy}
      GOOGLE_CLIENT_SECRET: ${GOOGLE_CLIENT_SECRET:-dummy}
      OPENAI_API_KEY: ${OPENAI_API_KEY:-dummy}
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:1.27-alpine
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 20
PATH: docker-compose.yml
LANG: yaml
===== CONTENT START =====
version: "3.9"

services:
  db:
    image: postgis/postgis:16-3.4
    container_name: parkshare_db
    restart: always
    environment:
      POSTGRES_DB: parkshare
      POSTGRES_USER: parkshare
      POSTGRES_PASSWORD: parkshare
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - parkshare_net

  redis:
    image: redis:7-alpine
    container_name: parkshare_redis
    restart: always
    networks:
      - parkshare_net

  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_web
    restart: always
    env_file:
      - .env  # можно потом заменить на .env.prod
    command: /app/entrypoint.sh
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  worker:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_worker
    restart: always
    env_file:
      - .env
    command: celery -A backend.config worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  beat:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_beat
    restart: always
    env_file:
      - .env
    command: celery -A backend.config beat -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    networks:
      - parkshare_net

  ai_pricing_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_ai_pricing
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.ai_pricing_service.main:app --host 0.0.0.0 --port 8100
    depends_on:
      - redis
    networks:
      - parkshare_net

  llm_service:
    build:
      context: .
      dockerfile: services/llm_service/Dockerfile
    container_name: parkshare_llm_service
    restart: always
    env_file:
      - .env
    ports:
      - "8002:8002"
    networks:
      - parkshare_net

  cv_service:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: parkshare_cv_service
    restart: always
    env_file:
      - .env
    command: uvicorn ai_services.cv_service.main:app --host 0.0.0.0 --port 8200
    depends_on:
      - redis
    networks:
      - parkshare_net

  frontend:
    build:
      context: ./frontend/next-app
      dockerfile: Dockerfile
    container_name: parkshare_frontend
    restart: always
    environment:
      NEXTAUTH_URL: http://localhost:3000
      NEXTAUTH_SECRET: dev_secret
      GOOGLE_CLIENT_ID: dummy
      GOOGLE_CLIENT_SECRET: dummy
      OPENAI_API_KEY: dummy
    ports:
      - "3000:3000"
    networks:
      - parkshare_net

  nginx:
    image: nginx:alpine
    container_name: parkshare_nginx
    restart: always
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - static_volume:/static
      - media_volume:/media
    depends_on:
      - web
    networks:
      - parkshare_net

volumes:
  postgres_data:
  static_volume:
  media_volume:

networks:
  parkshare_net:
    driver: bridge

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 21
PATH: dump_project.py
LANG: python
===== CONTENT START =====
import os
from datetime import datetime

# Какие папки игнорировать (расширенный список)
EXCLUDED_DIRS = {
    ".git", ".venv", "venv", "__pycache__", "node_modules",
    "dist", "build", "staticfiles", "media", ".idea", ".vscode",
    "static/icons",      # иконки не нужны в дампе
    "logs", "cache", "temp",  # временные файлы и логи
}

# Какие расширения файлов пропускать (расширенный список)
IGNORED_EXTENSIONS = {
    ".pyc", ".pyo", ".pyd", ".sqlite3", ".sqlite", ".db",
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".webp",
    ".pdf", ".zip", ".rar", ".7z", ".tar", ".gz",
    ".exe", ".dll", ".so", ".pkl", ".h5", ".model", ".pt",
    ".mp4", ".mp3", ".wav", ".avi", ".mov",
    ".log", ".tmp", ".cache",
}

# Файлы, которые нужно полностью игнорировать
EXCLUDED_FILES = {
    "CODEX_LOG1.txt", "CODEX__LOGS.txt",
    "package-lock.json", "yarn.lock",
}

# Никакого лимита на размер файла и дампа
MAX_FILE_SIZE = None  # не используется
MAX_TOTAL_DUMP_SIZE = None  # не используется

# Сжатие кода выключено, содержимое пишется как есть
COMPRESS_CODE = False


def is_binary_file(filename: str) -> bool:
    _, ext = os.path.splitext(filename.lower())
    return ext in IGNORED_EXTENSIONS


def should_exclude_file(filename: str) -> bool:
    return filename in EXCLUDED_FILES


def compress_content(content: str, filepath: str) -> str:
    # Оставлено для совместимости, по факту возвращает исходный контент
    if not COMPRESS_CODE:
        return content
    return content


def detect_language(filepath: str) -> str:
    """
    Определение "языка" для ИИ по расширению файла,
    чтобы он лучше понимал, что за содержимое перед ним.
    """
    _, ext = os.path.splitext(filepath.lower())
    mapping = {
        ".py": "python",
        ".js": "javascript",
        ".ts": "typescript",
        ".tsx": "tsx",
        ".jsx": "jsx",
        ".html": "html",
        ".htm": "html",
        ".css": "css",
        ".scss": "scss",
        ".sass": "sass",
        ".json": "json",
        ".yml": "yaml",
        ".yaml": "yaml",
        ".md": "markdown",
        ".sh": "bash",
        ".bat": "batch",
        ".ps1": "powershell",
        ".toml": "toml",
        ".ini": "ini",
        ".cfg": "ini",
        ".txt": "text",
        ".sql": "sql",
        ".csv": "csv",
        ".xml": "xml",
    }
    return mapping.get(ext, "text")


def build_tree_and_collect_files(root: str):
    """
    Обходит проект, строит дерево директорий и собирает список файлов.
    Фильтр только по директориям/расширениям/именам.
    """
    tree_lines = []
    file_paths = []

    root = os.path.abspath(root)
    root_name = os.path.basename(root.rstrip(os.sep))

    tree_lines.append(f"{root_name}/")

    for current_root, dirs, files in os.walk(root):
        # Фильтр директорий
        dirs[:] = [
            d for d in dirs
            if d not in EXCLUDED_DIRS and not d.startswith(".")
        ]

        rel_root = os.path.relpath(current_root, root)
        if rel_root == ".":
            depth = 0
        else:
            depth = rel_root.count(os.sep) + 1

        indent = "    " * depth

        if rel_root != ".":
            tree_lines.append(f"{indent}{os.path.basename(current_root)}/")

        for name in sorted(files):
            if is_binary_file(name) or should_exclude_file(name):
                continue

            file_rel_path = os.path.join(rel_root, name) if rel_root != "." else name
            file_abs_path = os.path.join(current_root, name)

            tree_lines.append(f"{indent}    {name}")
            file_paths.append((file_rel_path, file_abs_path))

    return tree_lines, file_paths


def dump_project(root: str, output_filename: str = "project_dump.txt"):
    tree_lines, file_paths = build_tree_and_collect_files(root)

    root = os.path.abspath(root)

    # Индекс файлов для ИИ, чтобы он мог быстро увидеть структуру и прыгать по пути
    files_index_lines = []
    for idx, (rel_path, abs_path) in enumerate(file_paths, 1):
        lang = detect_language(abs_path)
        files_index_lines.append(
            f"{idx}. PATH={rel_path} | LANG={lang}"
        )

    header = [
        "#" * 80,
        "# FULL PROJECT DUMP (NO TRUNCATION)",
        "# FORMAT FOR LLM:",
        "#   1) PROJECT TREE — общая структура проекта.",
        "#   2) FILES INDEX — плоский список файлов с путём и языком.",
        "#   3) FILES CONTENT — для каждого файла:",
        "#        ===== FILE START =====",
        "#        FILE_INDEX: <N>",
        "#        PATH: <relative/path>",
        "#        LANG: <language>",
        "#        ===== CONTENT START =====",
        "#        <raw file content>",
        "#        ===== CONTENT END =====",
        "#        ===== FILE END =====",
        "#   Файлы идут в том же порядке, что и в индексе.",
        "#" * 80,
        f"# Root: {root}",
        f"# Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"# Files listed: {len(file_paths)}",
        f"# Max single file size: NONE",
        f"# Max total dump size: NONE",
        f"# Code compression enabled: {COMPRESS_CODE}",
        "#" * 80,
        "",
    ]

    with open(output_filename, "w", encoding="utf-8", errors="replace") as f:
        # Шапка
        f.write("\n".join(header))

        # Дерево проекта
        f.write("PROJECT TREE:\n")
        f.write("-" * 80 + "\n")
        for line in tree_lines:
            f.write(line + "\n")

        # Индекс файлов
        f.write("\n\n")
        f.write("FILES INDEX:\n")
        f.write("-" * 80 + "\n")
        for line in files_index_lines:
            f.write(line + "\n")

        # Разделитель
        f.write("\n\n")
        f.write("=" * 80 + "\n")
        f.write("FILES CONTENT:\n")
        f.write("=" * 80 + "\n\n")

        total_files = len(file_paths)

        for i, (rel_path, abs_path) in enumerate(file_paths, 1):
            lang = detect_language(abs_path)

            # Явные маркеры для ИИ
            f.write("===== FILE START =====\n")
            f.write(f"FILE_INDEX: {i}\n")
            f.write(f"PATH: {rel_path}\n")
            f.write(f"LANG: {lang}\n")
            f.write("===== CONTENT START =====\n")

            try:
                with open(abs_path, "r", encoding="utf-8", errors="replace") as src:
                    content = src.read()

                content = compress_content(content, abs_path)
                f.write(content)

            except Exception as e:
                f.write(f"<< ERROR READING FILE: {e} >>\n")

            f.write("\n===== CONTENT END =====\n")
            f.write("===== FILE END =====\n\n")

            if i % 10 == 0:
                print(f"Processed {i}/{total_files} files...")

    file_size_bytes = os.path.getsize(output_filename)
    file_size_kb = file_size_bytes / 1024
    file_size_mb = file_size_bytes / (1024 * 1024)

    print(f"Готово! Файл с дампом проекта: {output_filename}")
    print(f"Размер дампа: {file_size_kb:.0f}KB (~{file_size_mb:.2f}MB)")
    print(f"Файлов в обходе (включено в дамп): {len(file_paths)}")


if __name__ == "__main__":
    project_root = os.path.dirname(os.path.abspath(__file__))
    dump_project(project_root)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 22
PATH: entrypoint.sh
LANG: bash
===== CONTENT START =====
#!/bin/sh
set -e

# Если DJANGO_SETTINGS_MODULE не задан, по умолчанию считаем, что это прод.
: "${DJANGO_SETTINGS_MODULE:=backend.backend.settings.production}"
export DJANGO_SETTINGS_MODULE

echo "Using DJANGO_SETTINGS_MODULE=${DJANGO_SETTINGS_MODULE}"

# Миграции
python backend/manage.py migrate --noinput

# Сбор статики
python backend/manage.py collectstatic --noinput

# Запуск gunicorn
exec gunicorn backend.config.wsgi:application \
    --bind 0.0.0.0:8000 \
    --workers "${GUNICORN_WORKERS:-3}" \
    --timeout "${GUNICORN_TIMEOUT:-60}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 23
PATH: index.html
LANG: html
===== CONTENT START =====
<!-- index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ParkShare AI Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <link rel="stylesheet" href="./static/css/cinematic-ui.css" />

  <style>
    :root {
      --primary: #0d6efd;
      --bg: #050816;
      --bg-card: #111827;
      --text: #e5e7eb;
      --accent: #22c55e;
      --danger: #ef4444;
      --warning: #f59e0b;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #111827, #020617 40%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      z-index: 1000;
      position: sticky;
      top: 0;
    }

    header h1 {
      font-size: 1.1rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .badge {
      font-size: 0.7rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .header-meta {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.3fr);
      min-height: 0;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .sidebar {
      border-left: 1px solid rgba(148, 163, 184, 0.2);
      background: radial-gradient(circle at top, #020617, #020617 40%);
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      min-width: 280px;
      max-width: 480px;
    }

    .card {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 0.75rem 0.8rem;
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.6);
    }

    .card-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .input-row {
      display: flex;
      gap: 0.4rem;
      margin-top: 0.3rem;
    }

    input[type="text"],
    select {
      flex: 1;
      padding: 0.4rem 0.5rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      font-size: 0.85rem;
      outline: none;
    }

    input::placeholder {
      color: rgba(148, 163, 184, 0.9);
    }

    button {
      border-radius: 999px;
      border: none;
      padding: 0.45rem 0.9rem;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      background: linear-gradient(135deg, #0ea5e9, #22c55e);
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      white-space: nowrap;
    }

    button.secondary {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: rgba(209, 213, 219, 0.95);
    }

    .pill {
      font-size: 0.72rem;
      border-radius: 999px;
      padding: 0.16rem 0.5rem;
      border: 1px solid rgba(148, 163, 184, 0.4);
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      color: rgba(209, 213, 219, 0.95);
    }

    .pill-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
    }

    .pill-dot.green {
      background: var(--accent);
    }
    .pill-dot.yellow {
      background: var(--warning);
    }
    .pill-dot.red {
      background: var(--danger);
    }

    .lots-list {
      max-height: 220px;
      overflow-y: auto;
      margin-top: 0.4rem;
      padding-right: 0.2rem;
    }

    .lot-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.4rem 0.2rem;
      border-bottom: 1px solid rgba(31, 41, 55, 0.9);
      cursor: pointer;
    }

    .lot-item:last-child {
      border-bottom: none;
    }

    .lot-main {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      font-size: 0.75rem;
    }

    .lot-name {
      font-weight: 500;
      font-size: 0.8rem;
    }

    .lot-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.3rem;
      font-size: 0.7rem;
      color: rgba(156, 163, 175, 0.95);
    }

    .lot-occ {
      font-size: 0.8rem;
      font-weight: 500;
      min-width: 80px;
      text-align: right;
    }

    .status {
      font-size: 0.7rem;
      color: rgba(148, 163, 184, 0.9);
      margin-top: 0.3rem;
    }

    .ai-oracle-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.18rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(59, 130, 246, 0.45);
      background: linear-gradient(120deg, rgba(37, 99, 235, 0.35), rgba(14, 165, 233, 0.15));
      color: #e5edff;
      font-size: 0.75rem;
      letter-spacing: 0.02em;
      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.25);
    }

    .ai-orchestrator-card {
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.92), rgba(17, 24, 39, 0.94));
    }

    .ai-orchestrator-card .card-title {
      align-items: center;
    }

    .ai-orchestrator-card .card-title span {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
    }

    .quantum-toggle {
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: #e2e8f0;
      font-weight: 600;
      letter-spacing: 0.01em;
      min-width: 150px;
      justify-content: space-between;
    }

    .quantum-toggle__dot {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.7);
      background: radial-gradient(circle at 35% 35%, #38bdf8, #0ea5e9);
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.45);
    }

    .quantum-toggle__label {
      flex: 1;
      text-align: right;
      font-size: 0.8rem;
    }

    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
      .sidebar {
        max-width: 100%;
        border-left: none;
        border-top: 1px solid rgba(148, 163, 184, 0.2);
      }
    }
  </style>
</head>
<body>
  <header class="cinematic-surface">
    <h1>
      <span>ParkShare AI Map</span>
      <span class="badge">local ML</span>
    </h1>
    <div class="header-meta">
      <div class="ai-crest">
        <span>🧠</span>
        <span class="quantum-toggle__label">AI Orchestrator</span>
      </div>
      <button id="themeToggle" class="quantum-toggle cinematic-button" data-theme="dark">
        <span class="quantum-toggle__dot"></span>
        <span class="quantum-toggle__label">Dark Matter</span>
      </button>
      <div class="pill">
        <span class="pill-dot green"></span>
        <span id="statusText">Подключение к AI-серверу…</span>
      </div>
    </div>
  </header>

  <main>
    <div id="map"></div>
    <aside class="sidebar">
      <section class="card cinematic-surface ai-orchestrator-card">
        <div class="card-title">
          <span>AI-Оркестратор</span>
          <span class="ai-oracle-chip">Quantum boost</span>
        </div>
        <div class="ai-forecast">
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Лучшая ставка</span>
            <span class="ai-forecast-value" id="aiOracleName">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Освободится через</span>
            <span class="ai-forecast-value" id="aiOracleETA">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">Уверенность AI</span>
            <span class="ai-forecast-value" id="aiOracleConfidence">—</span>
          </div>
          <div class="ai-forecast-metric">
            <span class="ai-forecast-label">EV/крытая</span>
            <span class="ai-forecast-value" id="aiOracleMeta">—</span>
          </div>
        </div>
        <div class="ai-reasoning" id="aiOracleReason">AI готовит инсайт…</div>
      </section>
      <section class="card">
        <div class="card-title">
          <span>Поиск парковок (NLP)</span>
        </div>
        <div class="input-row">
          <input
            type="text"
            id="searchInput"
            placeholder='Например: "рядом с метро", "дешевые утром"'
          />
          <button id="searchBtn">Искать</button>
        </div>
        <div class="status" id="searchStatus">Запрос еще не выполнен.</div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Рекомендации (коллаб. фильтрация)</span>
          <select id="userSelect"></select>
        </div>
        <div class="input-row">
          <button id="recBtn">Получить рекомендации</button>
          <button id="recContentBtn" class="secondary">Вариант B (content)</button>
        </div>
        <div class="status" id="recStatus">Нет рекомендаций.</div>
        <div class="lots-list" id="recList"></div>
      </section>

      <section class="card">
        <div class="card-title">
          <span>Все парковки</span>
        </div>
        <div class="lots-list" id="lotsList"></div>
      </section>
    </aside>
  </main>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <script src="./static/js/quantum-theme-manager.js"></script>
  <script src="app.js"></script>
  <script>
    // Запускаем квантовый менеджер темы, чтобы анимации и эмоции были синхронизированы.
    window.psThemeManager = window.initQuantumThemeManager();
  </script>
</body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 24
PATH: model_training.py
LANG: python
===== CONTENT START =====
# model_training.py
from __future__ import annotations

import joblib
import numpy as np
import pandas as pd
from pathlib import Path
from typing import Dict, Any

from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.svm import LinearSVC

from database import DB_PATH, get_connection, init_db, generate_synthetic_data

BASE_DIR = Path(__file__).parent
MODELS_DIR = BASE_DIR / "ai_models"
# Создаём папку для моделей заранее, чтобы не упасть на сохранении
MODELS_DIR.mkdir(parents=True, exist_ok=True)


# ---------- 1. Модель предсказания загруженности парковок ----------


def load_occupancy_dataframe() -> pd.DataFrame:
    conn = get_connection()
    try:
        query = """
            SELECT
                oh.lot_id,
                oh.ts,
                oh.occupancy,
                oh.temperature,
                oh.is_rain,
                oh.is_event,
                pl.near_metro,
                pl.price_level,
                pl.has_covered,
                pl.has_ev_charging
            FROM occupancy_history oh
            JOIN parking_lot pl ON pl.id = oh.lot_id
        """
        df = pd.read_sql_query(query, conn)
    finally:
        conn.close()

    if df.empty:
        return df

    df["ts"] = pd.to_datetime(df["ts"], errors="coerce")
    df = df.dropna(subset=["ts"])
    df["hour"] = df["ts"].dt.hour
    df["dow"] = df["ts"].dt.weekday
    df["lot_id_str"] = df["lot_id"].astype(str)

    return df


def train_occupancy_model() -> None:
    df = load_occupancy_dataframe()
    if df.empty:
        raise RuntimeError("Нет данных для обучения occupancy-модели")

    feature_cols = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
        "lot_id_str",
    ]

    X = df[feature_cols].copy()
    y = df["occupancy"].astype(float)

    numeric_features = [
        "hour",
        "dow",
        "temperature",
        "is_rain",
        "is_event",
        "near_metro",
        "price_level",
        "has_covered",
        "has_ev_charging",
    ]
    categorical_features = ["lot_id_str"]

    preprocessor = ColumnTransformer(
        transformers=[
            ("num", StandardScaler(), numeric_features),
            ("cat", OneHotEncoder(handle_unknown="ignore"), categorical_features),
        ]
    )

    model = RandomForestRegressor(
        n_estimators=80,
        random_state=42,
        n_jobs=-1,
    )

    pipe = Pipeline(
        steps=[
            ("preprocess", preprocessor),
            ("model", model),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "occupancy_model.pkl"
    joblib.dump(
        {
            "pipeline": pipe,
            "feature_cols": feature_cols,
        },
        model_path,
    )
    print("occupancy_model.pkl сохранён в", model_path)


# ---------- 2. NLP: интенты и парсинг пользовательских запросов ----------


def build_nlp_training_data() -> pd.DataFrame:
    data = [
        ("рядом с метро", "near_metro"),
        ("парковка около метро", "near_metro"),
        ("парковка возле метро", "near_metro"),
        ("где припарковаться у метро курская", "near_metro"),
        ("найди парковку у метро", "near_metro"),
        ("самая дешевая парковка", "cheap"),
        ("дешевые парковки утром", "cheap"),
        ("недорогая парковка рядом", "cheap"),
        ("дешево припарковаться", "cheap"),
        ("недорогие места для машины", "cheap"),
        ("парковка с зарядкой для электромобиля", "ev"),
        ("нужна зарядка для электрокара", "ev"),
        ("парковка с ev charging", "ev"),
        ("крытая парковка", "covered"),
        ("подземная парковка", "covered"),
        ("парковка в паркинге", "covered"),
        ("парковка ночью", "time_night"),
        ("парковка утром", "time_morning"),
        ("парковка вечером", "time_evening"),
        ("парковка днем", "time_day"),
        ("найди парковку", "general"),
        ("показать все парковки", "general"),
        ("где можно припарковаться", "general"),
        ("парковка в центре", "general"),
        ("парковка возле офиса", "general"),
    ]
    return pd.DataFrame(data, columns=["text", "intent"])


def train_nlp_model() -> None:
    df = build_nlp_training_data()
    X = df["text"].values
    y = df["intent"].values

    pipe = Pipeline(
        steps=[
            (
                "vec",
                CountVectorizer(
                    ngram_range=(1, 2),
                    analyzer="word",
                ),
            ),
            ("clf", LinearSVC()),
        ]
    )

    pipe.fit(X, y)

    model_path = MODELS_DIR / "nlp_intent.pkl"
    joblib.dump(pipe, model_path)
    print("nlp_intent.pkl сохранён в", model_path)


# ---------- 3. Рекомендательная система (collab + content) ----------


def train_recommender() -> None:
    """
    Простейшая item-based collaborative filtering + content-based фолбэк.
    """
    conn = get_connection()

    ratings = pd.read_sql_query("SELECT * FROM user_rating;", conn)
    lots = pd.read_sql_query("SELECT * FROM parking_lot;", conn)

    if ratings.empty or lots.empty:
        raise RuntimeError("Нет данных для обучения рекомендера")

    # user-item матрица
    user_item = (
        ratings.pivot(index="user_id", columns="lot_id", values="rating")
        .fillna(0.0)
        .astype(float)
    )

    # Нормируем по пользователям
    user_norms = np.linalg.norm(user_item.values, axis=1, keepdims=True)
    user_norms[user_norms == 0] = 1.0
    user_item_norm = user_item.values / user_norms

    # item-item similarity (cosine)
    sim_matrix = cosine_similarity(user_item_norm.T)
    item_ids = user_item.columns.tolist()
    item_sim = pd.DataFrame(sim_matrix, index=item_ids, columns=item_ids)

    # Content-features
    lot_features = lots.set_index("id")[
        ["near_metro", "price_level", "has_covered", "has_ev_charging", "latitude", "longitude"]
    ].copy()

    model_path = MODELS_DIR / "recommender.pkl"
    joblib.dump(
        {
            "user_item": user_item,
            "item_sim": item_sim,
            "lot_features": lot_features,
        },
        model_path,
    )
    print("recommender.pkl сохранён в", model_path)
    conn.close()


def _dataset_is_empty() -> bool:
    conn = get_connection()
    try:
        cur = conn.cursor()
        counts = {}
        for table in ["parking_lot", "occupancy_history", "user_rating"]:
            try:
                cur.execute(f"SELECT COUNT(*) FROM {table};")
                counts[table] = cur.fetchone()[0]
            except Exception:
                counts[table] = 0
        return any(value == 0 for value in counts.values())
    finally:
        conn.close()


def _safe_call(name: str, fn) -> None:
    try:
        fn()
    except Exception as exc:
        # Логируем и выбрасываем дальше, чтобы CI увидел сбой
        print(f"[!] Ошибка во время '{name}': {exc}")
        raise


def main() -> None:
    # На случай чистой установки
    init_db()

    try:
        if _dataset_is_empty():
            print("База пуста — генерируем синтетические данные...")
            generate_synthetic_data()
        else:
            print("Используем существующие данные в БД", DB_PATH)
    except Exception as exc:
        print(f"[!] Не удалось подготовить данные: {exc}")
        raise

    print("=== Обучение occupancy-модели ===")
    _safe_call("occupancy", train_occupancy_model)

    print("=== Обучение NLP-модели ===")
    _safe_call("nlp", train_nlp_model)

    print("=== Обучение рекомендательной системы ===")
    _safe_call("recommender", train_recommender)

    print("Готово: все модели обучены и сохранены в", MODELS_DIR)


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 29
PATH: requirements.txt
LANG: text
===== CONTENT START =====
Django==5.2.8
djangorestframework==3.16.1
django-environ==0.12.0
django-cors-headers==4.9.0
django-cryptography-django5==2.2
psycopg[binary]==3.2.12
celery==5.5.3
redis==7.0.1
Pillow==11.1.0
numpy==2.3.0
pandas==2.2.3
scikit-learn==1.7.2
gunicorn==23.0.0
yookassa
drf-spectacular==0.27.2
django-ratelimit==4.1.0
djangorestframework-simplejwt==5.3.1
httpx==0.27.2
asgiref==3.8.1
prometheus-client==0.21.0
pyotp==2.9.0

# LLM Gateway
litellm==1.51.0
cachetools==5.5.0
aiolimiter==1.1.0

# AI‑микросервисы (ParkMate AI)
fastapi
uvicorn[standard]==0.32.1
colorama==0.4.6

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 30
PATH: run_dev.bat
LANG: batch
===== CONTENT START =====
@echo off
echo 🎯 ParkShare Development Launcher (Windows)

REM Активируем виртуальное окружение если есть
if exist venv (
    echo 🔧 Активация виртуального окружения...
    call venv\Scripts\activate
)

REM Запускаем основной скрипт
python run_dev.py
pause
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 31
PATH: run_dev.py
LANG: python
===== CONTENT START =====
#!/usr/bin/env python3
"""
Единый скрипт для запуска всей системы ParkShare Development
Запускает: Django, LLM сервис, AI API сервер, Celery worker
"""
import os
import sys
import time
import subprocess
import signal
import threading
from pathlib import Path
from typing import Optional, Tuple

try:
    from colorama import Fore, Style, init as colorama_init
except ImportError:  # pragma: no cover - dev helper
    Fore = Style = None

    def colorama_init():
        return None


colorama_init()

# Добавляем корень проекта в Python path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))


def _color(msg: str, color: Optional[str]) -> str:
    if not color or not Fore:
        return msg
    return f"{color}{msg}{Style.RESET_ALL if Style else ''}"


def run_command(command, cwd=None, shell=False, env=None):
    """Запускает команду и возвращает процесс"""
    if env is None:
        env = os.environ.copy()

    print(_color(f"🚀 Запуск: {command}", Fore.CYAN if Fore else None))
    process = subprocess.Popen(
        command,
        cwd=cwd or project_root,
        shell=shell,
        env=env,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        universal_newlines=True,
        bufsize=1
    )
    return process


def log_output(process, name):
    """Логирует вывод процесса"""

    def log_thread():
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(_color(f"[{name}] {output.strip()}", Fore.WHITE if Fore else None))
        process.poll()

    thread = threading.Thread(target=log_thread)
    thread.daemon = True
    thread.start()
    return thread


def setup_environment():
    """Настраивает окружение для разработки"""
    env = os.environ.copy()
    env['PYTHONPATH'] = str(project_root)
    env['DJANGO_SETTINGS_MODULE'] = env.get('DJANGO_SETTINGS_MODULE', 'backend.backend.settings.local')
    env['DEBUG'] = env.get('DEBUG', '1')
    return env


def wait_for_service(port, timeout=30):
    """Ожидает пока сервис на порту станет доступен"""
    import socket
    import time

    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                result = sock.connect_ex(('localhost', port))
                if result == 0:
                    print(f"✅ Сервис на порту {port} готов")
                    return True
        except:
            pass
        time.sleep(1)

    print(f"❌ Таймаут ожидания порта {port}")
    return False


def start_django(port: int):
    """Запускает Django development server"""
    print("\n" + "=" * 50)
    print("🔄 Запуск Django сервера...")
    print("=" * 50)

    # Применяем миграции
    print("📦 Применяем миграции...")
    migrate_process = run_command([
        sys.executable, "backend/manage.py", "migrate"
    ])
    migrate_process.wait()

    # Собираем статику
    print("📦 Собираем статику...")
    collectstatic_process = run_command([
        sys.executable, "backend/manage.py", "collectstatic", "--noinput"
    ])
    collectstatic_process.wait()

    # Запускаем сервер
    return run_command([
        sys.executable, "backend/manage.py", "runserver", str(port)
    ])


def start_llm_service(host: str, port: int):
    """Запускает LLM микросервис"""
    print("\n" + "=" * 50)
    print("🧠 Запуск LLM сервиса...")
    print("=" * 50)

    return run_command([
        sys.executable, "-m", "uvicorn",
        "services.llm_service.main:app",
        "--host", host,
        "--port", str(port),
        "--reload"
    ])


def start_ai_api(host: str, port: int):
    """Запускает AI API сервер"""
    print("\n" + "=" * 50)
    print("🤖 Запуск AI API сервера...")
    print("=" * 50)

    env = setup_environment()
    env['AI_API_HOST'] = host
    env['AI_API_PORT'] = str(port)
    return run_command([
        sys.executable, "-m", "uvicorn", "api_server:app", "--host", host, "--port", str(port)
    ], env=env)


def start_celery_worker(env: Optional[dict] = None):
    """Запускает Celery worker."""
    print("\n" + "=" * 50)
    print("🔧 Запуск Celery worker...")
    print("=" * 50)

    # На Windows prefork вызывает PermissionError (WinError 5) из-за семафоров.
    # Переходим на однопроцессный режим solo, который официально поддерживается на Windows.
    is_windows = os.name == "nt"
    command = [
        sys.executable, "-m", "celery",
        "-A", "backend.backend.config.celery",
        "worker",
        "--loglevel=info",
    ]

    if is_windows:
        command.extend(["--pool", "solo", "--concurrency", "1"])
    else:
        command.extend(["--concurrency", "2"])

    return run_command(command, env=env)


def start_celery_beat(env: Optional[dict] = None):
    """Запускает Celery beat"""
    print("\n" + "=" * 50)
    print("⏰ Запуск Celery beat...")
    print("=" * 50)

    return run_command([
        sys.executable, "-m", "celery",
        "-A", "backend.backend.config.celery",
        "beat",
        "--loglevel=info"
    ], env=env)


def pick_port(preferred: int, env_name: str) -> int:
    """Возвращает доступный порт, если предпочтительный занят."""
    import socket

    try:
        override = int(os.environ.get(env_name, preferred))
    except (TypeError, ValueError):
        override = preferred

    def is_free(port_value: int) -> bool:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            return sock.connect_ex(("127.0.0.1", port_value)) != 0

    if is_free(override):
        return override

    print(f"⚠️ Порт {override} занят. Подбираем свободный...")
    for candidate in range(override + 1, override + 20):
        if is_free(candidate):
            print(f"➡️  Используем альтернативный порт {candidate} для {env_name}")
            return candidate

    raise RuntimeError(f"Не удалось найти свободный порт рядом с {override}")


def check_dependencies():
    """Проверяет наличие всех зависимостей"""
    print("🔍 Проверка зависимостей...")

    try:
        import django  # noqa: F401
        import fastapi  # noqa: F401
        import uvicorn  # noqa: F401
        import celery  # noqa: F401
        import redis  # noqa: F401
    except ImportError as e:
        print(f"❌ Отсутствует зависимость: {e}")
        print("Установите зависимости: pip install -r requirements.txt")
        return False

    # Проверяем доступность Redis для Celery/кэшей
    import socket

    redis_url = os.environ.get("REDIS_URL", "redis://localhost:6379/0")
    try:
        host_port = redis_url.split("//", 1)[-1].split("/", 1)[0]
        host, port = host_port.split(":")
        with socket.create_connection((host, int(port)), timeout=2):
            print("✅ Redis доступен")
    except Exception as exc:
        print(f"⚠️  Redis недоступен ({redis_url}): {exc}. Продолжаем запуск без гарантии Celery")
    return True


def monitor_process(name: str, starter, max_restarts: int = 2) -> Tuple[subprocess.Popen, int]:
    """Стартует процесс и возвращает пару (process, оставшиеся рестарты)."""

    process = starter()
    return process, max_restarts


def main():
    """Основная функция запуска"""
    print("🎯 ParkShare Development Launcher")
    print("Запуск всех компонентов системы...")

    # Проверяем зависимости
    if not check_dependencies():
        sys.exit(1)

    # Настраиваем окружение
    env = setup_environment()

    django_port = pick_port(8000, "DJANGO_PORT")
    ai_api_port = pick_port(8001, "AI_API_PORT")
    llm_port = pick_port(8002, "LLM_PORT")

    env["DJANGO_PORT"] = str(django_port)
    env["AI_API_PORT"] = str(ai_api_port)
    env["LLM_SERVICE_PORT"] = str(llm_port)
    env["LLM_PORT"] = str(llm_port)

    os.environ.update(env)

    processes: list[tuple[str, subprocess.Popen, int]] = []

    try:
        # Запускаем сервисы
        services = [
            ("LLM Service", lambda: start_llm_service("0.0.0.0", llm_port), llm_port),
            ("AI API", lambda: start_ai_api("0.0.0.0", ai_api_port), ai_api_port),
            ("Celery Worker", lambda: start_celery_worker(env), None),
            ("Celery Beat", lambda: start_celery_beat(env), None),
            ("Django", lambda: start_django(django_port), django_port),
        ]

        threads = []
        for name, starter, port in services:
            process, restarts = monitor_process(name, starter)
            processes.append((name, process, restarts))
            thread = log_output(process, name)
            threads.append(thread)

            if port:
                # Даем время сервису начать запуск
                time.sleep(2)
                if not wait_for_service(port, timeout=10):
                    print(f"⚠️  Сервис {name} медленно запускается...")

        print("\n" + "🎉 Все сервисы запущены!")
        print("📊 Статус сервисов:")
        print(f"   • Django: http://localhost:{django_port}")
        print(f"   • LLM Service: http://localhost:{llm_port}")
        print(f"   • AI API: http://localhost:{ai_api_port}")
        print("   • Celery Worker: ✅")
        print("   • Celery Beat: ✅")
        print("\n🛑 Для остановки нажмите Ctrl+C")

        # Ожидаем завершения
        while True:
            time.sleep(1)
            # Проверяем, что все процессы еще работают
            for idx, (name, process, restarts) in enumerate(list(processes)):
                if process.poll() is not None:
                    print(_color(f"❌ Процесс {name} завершился с кодом {process.returncode}", Fore.RED if Fore else None))
                    if restarts > 0:
                        print(_color(f"🔁 Перезапуск {name} (осталось {restarts})", Fore.YELLOW if Fore else None))
                        new_process, _ = monitor_process(name, services[idx][1])
                        processes[idx] = (name, new_process, restarts - 1)
                        log_output(new_process, name)
                    else:
                        print(_color(f"🛑 Достигнут лимит рестартов для {name}", Fore.RED if Fore else None))

    except KeyboardInterrupt:
        print("\n🛑 Остановка сервисов...")

        # Останавливаем процессы
        for name, process, _ in processes:
            if process.poll() is None:
                print(f"⏹️  Останавливаем {name}...")
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    print(f"❌ Принудительная остановка {name}...")
                    process.kill()

        print("👋 Все сервисы остановлены")


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 32
PATH: run_dev.sh
LANG: bash
===== CONTENT START =====
#!/bin/bash
# Скрипт запуска для Unix систем

echo "🎯 ParkShare Development Launcher (Unix)"

# Активируем виртуальное окружение если есть
if [ -d "venv" ]; then
    echo "🔧 Активация виртуального окружения..."
    source venv/bin/activate
fi

# Запускаем основной скрипт
python run_dev.py
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 33
PATH: accounts\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 34
PATH: accounts\admin.py
LANG: python
===== CONTENT START =====
# accounts/admin.py

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as DjangoUserAdmin

from .models import LoginCode, PromoReward, SocialAccount, User, UserBadge, UserLevel


@admin.register(User)
class UserAdmin(DjangoUserAdmin):
    """
    Кастомная админка для пользователя с UUID-ID и ролями.
    """

    fieldsets = DjangoUserAdmin.fieldsets + (
        (
            "Дополнительно",
            {
                "fields": (
                    "role",
                    "email_encrypted",
                    "phone_encrypted",
                    "owner_request_pending",
                    "mfa_enabled",
                    "mfa_method",
                    "mfa_secret",
                    "last_password_change",
                )
            },
        ),
    )

    list_display = (
        "username",
        "role",
        "mfa_enabled",
        "mfa_method",
        "is_active",
        "is_staff",
        "is_superuser",
        "date_joined",
    )
    list_filter = ("role", "mfa_enabled", "is_active", "is_staff", "is_superuser")
    search_fields = ("username",)


@admin.register(SocialAccount)
class SocialAccountAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "provider", "external_id", "email", "last_login_at")
    list_filter = ("provider",)
    search_fields = ("external_id", "email", "user__email", "user__username")
    autocomplete_fields = ("user",)


@admin.register(LoginCode)
class LoginCodeAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "channel", "purpose", "expires_at", "is_used", "attempts")
    list_filter = ("channel", "purpose", "is_used")
    search_fields = ("user__username", "user__email_hash", "user__phone_hash")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 35
PATH: accounts\apps.py
LANG: python
===== CONTENT START =====
# accounts/apps.py

from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "accounts"
    verbose_name = "Пользователи ParkShare"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 36
PATH: accounts\auth.py
LANG: python
===== CONTENT START =====
# accounts/auth.py

from __future__ import annotations

from typing import Optional

from django.contrib.auth import get_user_model

from core.utils import normalize_phone
from .utils import normalize_email, hash_email, hash_phone

User = get_user_model()


def _get_first_or_none(qs):
    try:
        return qs.first()
    except Exception:
        return None


def find_user_by_identifier(identifier: str) -> Optional[User]:
    """
    Ищем пользователя по:
    1) username (регистронезависимо);
    2) email (нормализованный, через email_hash);
    3) телефону (нормализованный, через phone_hash).

    В БД никогда не фильтруем по зашифрованным полям.
    """
    if not identifier:
        return None

    ident = identifier.strip()
    qs = User.objects.filter(is_active=True)

    # 1) Логин (username)
    try:
        return qs.get(username__iexact=ident)
    except User.DoesNotExist:
        pass
    except User.MultipleObjectsReturned:
        return _get_first_or_none(qs.filter(username__iexact=ident).order_by("date_joined"))

    # 2) Email
    if "@" in ident:
        email = normalize_email(ident)
        if not email:
            return None
        email_hash = hash_email(email)
        if not email_hash:
            return None
        try:
            return qs.get(email_hash=email_hash)
        except User.DoesNotExist:
            pass
        except User.MultipleObjectsReturned:
            return _get_first_or_none(qs.filter(email_hash=email_hash).order_by("date_joined"))
        return None

    # 3) Телефон
    phone = normalize_phone(ident)
    if not phone:
        return None
    phone_hash = hash_phone(phone)
    if not phone_hash:
        return None

    try:
        return qs.get(phone_hash=phone_hash)
    except User.DoesNotExist:
        return None
    except User.MultipleObjectsReturned:
        return _get_first_or_none(qs.filter(phone_hash=phone_hash).order_by("date_joined"))

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 37
PATH: accounts\authentication.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from datetime import datetime, timezone

from django.contrib.auth import get_user_model
from rest_framework.exceptions import AuthenticationFailed
from rest_framework_simplejwt.authentication import JWTAuthentication as BaseJWTAuthentication


class JWTAuthentication(BaseJWTAuthentication):
    """
    Расширяем проверку simplejwt: токен, выпущенный до последней смены пароля,
    считается недействительным.
    """

    def get_user(self, validated_token):
        user = None
        if hasattr(super(), "get_user"):
            user = super().get_user(validated_token)  # type: ignore[arg-type]
        if user is None:
            user_model = get_user_model()
            try:
                user = user_model.objects.get(pk=validated_token.get("user_id"))
            except user_model.DoesNotExist:
                raise AuthenticationFailed("User not found", code="user_not_found")
        issued_at = validated_token.get("iat")
        if issued_at:
            issued_dt = datetime.fromtimestamp(int(issued_at), tz=timezone.utc)
            last_pw = getattr(user, "last_password_change", None)
            last_mfa = getattr(user, "last_mfa_change", None)
            boundary = max(filter(None, [last_pw, last_mfa]), default=None)
            if boundary and issued_dt < boundary:
                raise AuthenticationFailed("Token issued before last credential change.", code="token_stale")
        return user

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 38
PATH: accounts\forms.py
LANG: python
===== CONTENT START =====
# accounts/forms.py

from typing import Any

from django import forms
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm
from django.utils.translation import gettext_lazy as _

from core.utils import normalize_phone
from .models import User


class LoginForm(AuthenticationForm):
    """
    Форма входа: одно поле для логина / email / телефона + пароль.
    """

    username = forms.CharField(
        label=_("Логин / Email / Телефон"),
        widget=forms.TextInput(attrs={"autofocus": True, "class": "ps-input"}),
    )

    def clean(self):
        """
        Подменяем username на реальный логин пользователя, чтобы
        AuthenticationForm могла вызвать authenticate() как обычно.
        """
        from .auth import find_user_by_identifier  # локальный импорт

        identifier = self.cleaned_data.get("username")
        password = self.cleaned_data.get("password")

        if identifier and password:
            user = find_user_by_identifier(identifier)
            if user is not None:
                self.cleaned_data["username"] = user.get_username()

        return super().clean()


class RegisterForm(UserCreationForm):
    """
    Регистрация через HTML-форму.
    Email и телефон — опциональные, сохраняются в зашифрованном виде.
    """

    email = forms.EmailField(
        label=_("Email (опционально)"),
        required=False,
        widget=forms.EmailInput(attrs={"class": "ps-input"}),
    )
    phone = forms.CharField(
        label=_("Телефон (опционально)"),
        required=False,
        widget=forms.TextInput(attrs={"class": "ps-input"}),
    )

    class Meta(UserCreationForm.Meta):
        model = User
        fields = ("username", "email", "phone")
        widgets = {
            "username": forms.TextInput(attrs={"class": "ps-input"}),
        }

    def clean_email(self) -> str:
        """
        Просто нормализуем email, без запросов к БД.
        """
        email = (self.cleaned_data.get("email") or "").strip().lower()
        return email

    def clean_phone(self) -> str:
        """
        Только нормализуем номер, без проверки уникальности.
        """
        phone = self.cleaned_data.get("phone") or ""
        if not phone:
            return ""

        phone = normalize_phone(phone)
        if not phone:
            raise forms.ValidationError(_("Некорректный формат телефона."))
        return phone

    def save(self, commit: bool = True) -> User:
        """
        Сохраняем пользователя и дублируем нормализованные значения
        в email_plain / phone_plain, чтобы их можно было показывать в UI.
        """
        user: User = super().save(commit=False)

        email = (self.cleaned_data.get("email") or "").strip().lower()
        phone = self.cleaned_data.get("phone") or ""

        user.email_plain = email or ""
        user.phone_plain = normalize_phone(phone or "") if phone else ""

        if commit:
            user.save()
        return user


class ProfileForm(forms.ModelForm):
    """
    Редактирование профиля пользователя (email/phone + базовые поля).
    """

    email = forms.EmailField(
        label=_("Email"),
        required=False,
        widget=forms.EmailInput(attrs={"class": "ps-input"}),
    )
    phone = forms.CharField(
        label=_("Телефон"),
        required=False,
        widget=forms.TextInput(attrs={"class": "ps-input"}),
    )

    class Meta:
        model = User
        fields = ("first_name", "last_name", "email", "phone")
        widgets = {
            "first_name": forms.TextInput(attrs={"class": "ps-input"}),
            "last_name": forms.TextInput(attrs={"class": "ps-input"}),
        }

    def clean_email(self) -> str:
        email = (self.cleaned_data.get("email") or "").strip().lower()
        return email

    def clean_phone(self) -> str:
        phone = self.cleaned_data.get("phone") or ""
        if not phone:
            return ""

        phone = normalize_phone(phone)
        if not phone:
            raise forms.ValidationError(_("Некорректный формат телефона."))
        # Больше НИКАКИХ запросов к User.objects.filter(phone_encrypted=...)
        return phone

    def save(self, commit: bool = True) -> Any:
        user: User = super().save(commit=False)

        email = (self.cleaned_data.get("email") or "").strip().lower()
        phone = self.cleaned_data.get("phone") or ""

        user.email_plain = email or ""
        user.phone_plain = normalize_phone(phone or "") if phone else ""

        if commit:
            user.save()
        return user

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 39
PATH: accounts\models.py
LANG: python
===== CONTENT START =====
# accounts/models.py

import uuid

from django.conf import settings
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django_cryptography.fields import encrypt

from core.models import TimeStampedUUIDModel
from .utils import hash_email, hash_phone

class User(AbstractUser):
    """
    Кастомный пользователь:
    - UUID как первичный ключ;
    - роль (driver / owner / admin);
    - email/телефон в зашифрованном виде (django-cryptography-django5);
    - отдельные хэши email/телефона для безопасного поиска/уникальности.
    """

    class Role(models.TextChoices):
        DRIVER = "driver", _("Водитель")
        OWNER = "owner", _("Владелец парковки")
        ADMIN = "admin", _("Администратор")

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    role = models.CharField(
        _("Роль"),
        max_length=16,
        choices=Role.choices,
        default=Role.DRIVER,
        help_text=_("Определяет права доступа в системе."),
    )

    # Шифрованные контактные поля
    email_encrypted = encrypt(
        models.EmailField(
            _("Email (зашифрованный)"),
            blank=True,
            null=True,
            help_text=_("Опциональный email, хранится в зашифрованном виде."),
        )
    )

    phone_encrypted = encrypt(
        models.CharField(
            _("Телефон (зашифрованный)"),
            max_length=32,
            blank=True,
            null=True,
            help_text=_("Опциональный телефон, хранится в зашифрованном виде."),
        )
    )

    # Отдельные хэши для поиска и проверки уникальности
    email_hash = models.CharField(
        _("Хэш нормализованного email"),
        max_length=64,
        blank=True,
        db_index=True,
        help_text=_("Используется только для поиска и проверки уникальности email."),
    )

    phone_hash = models.CharField(
        _("Хэш нормализованного телефона"),
        max_length=64,
        blank=True,
        db_index=True,
        help_text=_("Используется только для поиска и проверки уникальности телефона."),
    )

    owner_request_pending = models.BooleanField(
        _("Запрошено повышение до владельца"),
        default=False,
        help_text=_("Пользователь подал заявку на роль владельца парковки."),
    )

    class MFAMethod(models.TextChoices):
        NONE = "none", _("Без MFA")
        TOTP = "totp", _("TOTP (приложение)")
        SMS = "sms", _("SMS")
        EMAIL = "email", _("Email")

    mfa_enabled = models.BooleanField(
        _("MFA включена"), default=False, help_text=_("Требовать второй фактор при входе.")
    )
    mfa_method = models.CharField(
        _("Метод MFA"),
        max_length=16,
        choices=MFAMethod.choices,
        default=MFAMethod.NONE,
    )
    mfa_secret = models.CharField(
        _("Секрет TOTP"),
        max_length=64,
        blank=True,
        null=True,
        help_text=_("Используется только для TOTP-приложений."),
    )
    last_password_change = models.DateTimeField(
        _("Последняя смена пароля"),
        blank=True,
        null=True,
        help_text=_("Используется для инвалидирования сессий и JWT."),
    )
    last_mfa_change = models.DateTimeField(
        _("Последнее изменение MFA"),
        blank=True,
        null=True,
        help_text=_("Используется для инвалидирования сессий и токенов после изменения MFA."),
    )

    REQUIRED_FIELDS: list[str] = []

    class Meta:
        verbose_name = _("Пользователь")
        verbose_name_plural = _("Пользователи")

    def __str__(self) -> str:
        return self.username

    @property
    def email_plain(self) -> str:
        return self.email_encrypted or ""

    @email_plain.setter
    def email_plain(self, value: str) -> None:
        self.email_encrypted = value or None

    @property
    def phone_plain(self) -> str:
        return self.phone_encrypted or ""

    @phone_plain.setter
    def phone_plain(self, value: str) -> None:
        self.phone_encrypted = value or None

    @property
    def is_driver(self) -> bool:
        return self.role == self.Role.DRIVER

    @property
    def is_owner(self) -> bool:
        return self.role in (self.Role.OWNER, self.Role.ADMIN)

    @property
    def is_admin(self) -> bool:
        return self.role == self.Role.ADMIN or self.is_superuser

    def update_contact_hashes(self) -> None:
        self.email_hash = hash_email(self.email_plain)
        self.phone_hash = hash_phone(self.phone_plain)

    def save(self, *args, **kwargs) -> None:
        self.update_contact_hashes()
        super().save(*args, **kwargs)


class LoginCode(TimeStampedUUIDModel):
    """
    Одноразовый код для подтверждения email/телефона и входа.
    """

    class Channel(models.TextChoices):
        EMAIL = "email", _("Email")
        PHONE = "phone", _("Телефон")

    class Purpose(models.TextChoices):
        REGISTER = "register", _("Регистрация")
        LOGIN = "login", _("Вход")
        RESET_PASSWORD = "reset_password", _("Сброс пароля")
        MFA = "mfa", _("MFA подтверждение")

    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name="login_codes",
    )
    channel = models.CharField(
        _("Канал"),
        max_length=16,
        choices=Channel.choices,
    )
    purpose = models.CharField(
        _("Назначение"),
        max_length=32,
        choices=Purpose.choices,
    )
    code_hash = models.CharField(
        _("Хэш кода"),
        max_length=128,
        db_index=True,
    )
    expires_at = models.DateTimeField(_("Истекает в"))
    is_used = models.BooleanField(_("Использован"), default=False)
    attempts = models.PositiveSmallIntegerField(_("Попыток ввода"), default=0)
    status = models.CharField(
        _("Статус"),
        max_length=16,
        default="pending",
        help_text=_("pending/used/expired/blocked"),
    )

    class Meta:
        verbose_name = _("Код подтверждения")
        verbose_name_plural = _("Коды подтверждения")
        indexes = [
            models.Index(fields=["user", "purpose", "is_used"]),
        ]

    def __str__(self) -> str:
        return f"{self.purpose} code for {self.user_id}"

    @property
    def is_expired(self) -> bool:
        return timezone.now() >= self.expires_at

    def mark_used(self) -> None:
        self.is_used = True
        self.status = "used"
        self.save(update_fields=["is_used", "status", "updated_at"])


class SocialAccount(models.Model):
    """
    Link between local User and external OAuth provider account.
    Intended for VK, Yandex ID, Google and similar providers.
    """

    class Provider(models.TextChoices):
        VK = "vk", "VK"
        YANDEX = "yandex", "Yandex"
        GOOGLE = "google", "Google"

    id = models.BigAutoField(primary_key=True)
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="social_accounts",
        verbose_name=_("Пользователь"),
    )
    provider = models.CharField(
        _("Провайдер"),
        max_length=32,
        choices=Provider.choices,
    )
    external_id = models.CharField(
        _("Внешний ID"),
        max_length=255,
        help_text=_("Уникальный идентификатор пользователя в системе провайдера."),
    )
    email = models.EmailField(_("Email из профиля"), blank=True, null=True)
    display_name = models.CharField(_("Имя в профиле"), max_length=255, blank=True)
    extra_data = models.JSONField(
        _("Сырой профиль"),
        default=dict,
        blank=True,
        help_text=_("Небольшой JSON с частью профиля, не содержащей чувствительные данные."),
    )
    last_login_at = models.DateTimeField(_("Последний вход"), default=timezone.now)
    created_at = models.DateTimeField(_("Создано"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Обновлено"), auto_now=True)

    class Meta:
        verbose_name = _("Социальный аккаунт")
        verbose_name_plural = _("Социальные аккаунты")
        unique_together = [("provider", "external_id")]
        indexes = [
            models.Index(fields=["provider", "external_id"]),
            models.Index(fields=["user", "provider"]),
        ]

    def __str__(self) -> str:
        return f"{self.get_provider_display()}:{self.external_id} → {self.user_id}"


class UserLevel(TimeStampedUUIDModel):
    name = models.CharField(max_length=64)
    threshold = models.PositiveIntegerField(default=0, help_text="Количество завершённых бронирований для уровня")
    description = models.TextField(blank=True)

    class Meta:
        verbose_name = "Уровень пользователя"
        verbose_name_plural = "Уровни пользователей"
        ordering = ("threshold",)

    def __str__(self) -> str:
        return self.name


class UserBadge(TimeStampedUUIDModel):
    user = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="badges", verbose_name="Пользователь"
    )
    title = models.CharField(max_length=128)
    description = models.TextField(blank=True)
    icon = models.CharField(max_length=64, blank=True)
    level = models.ForeignKey(
        UserLevel,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="badges",
    )

    class Meta:
        verbose_name = "Бейдж"
        verbose_name_plural = "Бейджи"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"{self.title} — {self.user}"


class PromoReward(TimeStampedUUIDModel):
    code = models.CharField(max_length=32, unique=True)
    description = models.TextField(blank=True)
    active = models.BooleanField(default=True)
    usage_limit = models.PositiveIntegerField(default=1)

    class Meta:
        verbose_name = "Промо/бонус"
        verbose_name_plural = "Промо/бонусы"

    def __str__(self) -> str:
        return self.code

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 40
PATH: accounts\oauth.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import logging
from typing import Dict
from urllib.parse import urlencode

import httpx
from django.conf import settings

logger = logging.getLogger(__name__)

PROVIDERS: Dict[str, Dict[str, str]] = {
    "vk": {
        "auth_url": "https://oauth.vk.com/authorize",
        "token_url": "https://oauth.vk.com/access_token",
        "profile_url": "https://api.vk.com/method/users.get",
        "scope": "email",
        "api_version": "5.199",
    },
    "yandex": {
        "auth_url": "https://oauth.yandex.ru/authorize",
        "token_url": "https://oauth.yandex.ru/token",
        "profile_url": "https://login.yandex.ru/info",
        "scope": "login:email login:info",
    },
    "google": {
        "auth_url": "https://accounts.google.com/o/oauth2/v2/auth",
        "token_url": "https://oauth2.googleapis.com/token",
        "profile_url": "https://openidconnect.googleapis.com/v1/userinfo",
        "scope": "openid email profile",
    },
}


def _provider_config(provider: str) -> Dict[str, str]:
    cfg = getattr(settings, "SOCIAL_OAUTH_CONFIG", {}).get(provider, {}) or {}
    client_id = cfg.get("client_id")
    client_secret = cfg.get("client_secret")
    if not client_id or not client_secret:
        raise ValueError(f"OAuth provider {provider} is not configured")
    return cfg


def build_authorize_url(provider: str, state: str, redirect_uri: str) -> str:
    provider = provider.lower()
    meta = PROVIDERS.get(provider)
    if not meta:
        raise ValueError("Unsupported provider")
    cfg = _provider_config(provider)

    params = {
        "client_id": cfg["client_id"],
        "redirect_uri": redirect_uri,
        "response_type": "code",
        "scope": meta["scope"],
        "state": state,
    }
    if provider == "google":
        params["access_type"] = "offline"
        params["prompt"] = "consent"
    return f"{meta['auth_url']}?{urlencode(params)}"


def fetch_profile(provider: str, code: str, redirect_uri: str) -> Dict[str, str]:
    provider = provider.lower()
    meta = PROVIDERS.get(provider)
    if not meta:
        raise ValueError("Unsupported provider")

    # Test mode: bypass external HTTP to simplify local/dev flows.
    if getattr(settings, "SOCIAL_OAUTH_TEST_MODE", False) or (code and code.startswith("test_")):
        fake_id = code.replace("test_", "") or "demo"
        return {
            "provider": provider,
            "external_id": fake_id,
            "email": f"{fake_id}@{provider}.example",
            "display_name": f"Test {provider.title()} User",
            "raw": {"mode": "test"},
        }

    cfg = _provider_config(provider)
    token_payload = {
        "client_id": cfg["client_id"],
        "client_secret": cfg["client_secret"],
        "code": code,
        "redirect_uri": redirect_uri,
        "grant_type": "authorization_code",
    }

    with httpx.Client(timeout=5.0) as client:
        token_resp = client.post(meta["token_url"], data=token_payload)
        token_resp.raise_for_status()
        token_data = token_resp.json()
        access_token = token_data.get("access_token")
        if not access_token:
            raise ValueError("No access token returned")

        if provider == "vk":
            profile_resp = client.get(
                meta["profile_url"],
                params={
                    "access_token": access_token,
                    "v": meta["api_version"],
                    "fields": "id,first_name,last_name,photo_100",
                },
            )
            profile_resp.raise_for_status()
            data = profile_resp.json()
            response = (data.get("response") or [{}])[0]
            ext_id = response.get("id") or token_data.get("user_id")
            email = token_data.get("email")
            display_name = " ".join(
                filter(None, [response.get("first_name"), response.get("last_name")])
            ).strip()
            return {
                "provider": provider,
                "external_id": str(ext_id),
                "email": email,
                "display_name": display_name,
                "raw": {"vk": response},
            }

        if provider == "yandex":
            profile_resp = client.get(
                meta["profile_url"],
                headers={"Authorization": f"OAuth {access_token}"},
            )
            profile_resp.raise_for_status()
            data = profile_resp.json()
            return {
                "provider": provider,
                "external_id": str(data.get("id") or data.get("client_id") or ""),
                "email": data.get("default_email") or data.get("emails", [None])[0],
                "display_name": data.get("real_name") or data.get("display_name"),
                "raw": {"yandex": data},
            }

        # google
        profile_resp = client.get(
            meta["profile_url"],
            headers={"Authorization": f"Bearer {access_token}"},
        )
        profile_resp.raise_for_status()
        data = profile_resp.json()
        return {
            "provider": provider,
            "external_id": str(data.get("sub") or data.get("id") or ""),
            "email": data.get("email"),
            "display_name": data.get("name") or "",
            "raw": {"google": data},
        }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 41
PATH: accounts\serializers.py
LANG: python
===== CONTENT START =====
# accounts/serializers.py

from __future__ import annotations

from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from django.utils.translation import gettext_lazy as _
from rest_framework import serializers

from core.utils import normalize_phone
from .auth import find_user_by_identifier
from .models import LoginCode, SocialAccount, User
from .utils import (
    generate_username,
    hash_code,
    hash_email,
    hash_phone,
    invalidate_other_sessions,
    normalize_email,
)
from django.utils import timezone


class UserSerializer(serializers.ModelSerializer):
    """
    Базовое представление пользователя для админских API.
    Контактные данные не раскрываются.
    """

    has_email = serializers.SerializerMethodField()
    has_phone = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = (
            "id",
            "username",
            "role",
            "is_active",
            "date_joined",
            "has_email",
            "has_phone",
        )

    def get_has_email(self, obj: User) -> bool:
        return bool(obj.email_plain)

    def get_has_phone(self, obj: User) -> bool:
        return bool(obj.phone_plain)


class SocialAccountSerializer(serializers.ModelSerializer):
    """Вывод связанных соц-аккаунтов в профиле."""

    class Meta:
        model = SocialAccount
        fields = ("id", "provider", "external_id", "email", "display_name", "last_login_at")


class UserProfileSerializer(serializers.ModelSerializer):
    """
    Профиль текущего пользователя.
    Здесь можно редактировать email/телефон.
    """

    email = serializers.CharField(
        source="email_plain",
        allow_blank=True,
        required=False,
    )
    phone = serializers.CharField(
        source="phone_plain",
        allow_blank=True,
        required=False,
    )
    social_accounts = SocialAccountSerializer(many=True, read_only=True)

    class Meta:
        model = User
        fields = (
            "id",
            "username",
            "role",
            "email",
            "phone",
            "mfa_enabled",
            "mfa_method",
            "social_accounts",
        )

    def validate_phone(self, value: str) -> str:
        value = value or ""
        if not value:
            return ""

        normalized = normalize_phone(value)
        if not normalized:
            raise serializers.ValidationError(_("Некорректный формат телефона."))

        phone_hash = hash_phone(normalized)
        user = self.instance
        qs = User.objects.filter(phone_hash=phone_hash)
        if user is not None:
            qs = qs.exclude(pk=user.pk)
        if phone_hash and qs.exists():
            raise serializers.ValidationError(
                _("Пользователь с таким телефоном уже существует.")
            )
        return normalized

    def validate_email(self, value: str) -> str:
        value = normalize_email(value)
        if not value:
            return ""

        email_hash = hash_email(value)
        user = self.instance
        qs = User.objects.filter(email_hash=email_hash)
        if user is not None:
            qs = qs.exclude(pk=user.pk)
        if email_hash and qs.exists():
            raise serializers.ValidationError(
                _("Пользователь с таким email уже существует.")
            )
        return value


class RegisterSerializer(serializers.Serializer):
    """
    Регистрация через API.
    """

    username = serializers.CharField(max_length=150, required=False, allow_blank=True)
    password = serializers.CharField(write_only=True, min_length=8)
    email = serializers.EmailField(required=False, allow_blank=True)
    phone = serializers.CharField(required=False, allow_blank=True)

    def validate_username(self, value: str) -> str:
        if not value:
            return generate_username("user")
        if User.objects.filter(username=value).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким логином уже существует.")
            )
        return value

    def validate_email(self, value: str) -> str:
        email = normalize_email(value)
        if not email:
            return ""
        email_hash = hash_email(email)
        if email_hash and User.objects.filter(email_hash=email_hash).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким email уже зарегистрирован.")
            )
        return email

    def validate_phone(self, value: str) -> str:
        value = value or ""
        if not value:
            return ""
        normalized = normalize_phone(value)
        if not normalized:
            raise serializers.ValidationError(_("Некорректный формат телефона."))
        phone_hash = hash_phone(normalized)
        if phone_hash and User.objects.filter(phone_hash=phone_hash).exists():
            raise serializers.ValidationError(
                _("Пользователь с таким телефоном уже зарегистрирован.")
            )
        return normalized

    def validate_password(self, value: str) -> str:
        validate_password(value)
        return value

    def create(self, validated_data: dict) -> User:
        email = validated_data.pop("email", "")
        phone = validated_data.pop("phone", "")
        username = validated_data.get("username") or generate_username("user")

        user = User(username=username)
        user.set_password(validated_data["password"])

        if email:
            user.email_plain = email
        if phone:
            user.phone_plain = phone

        user.save()
        return user


class LoginSerializer(serializers.Serializer):
    """
    Логин через API (session-based).
    Позволяет использовать логин, email или телефон.
    """

    identifier = serializers.CharField(
        label=_("Логин / Email / Телефон"),
    )
    password = serializers.CharField(write_only=True)

    def validate(self, attrs: dict) -> dict:
        identifier = attrs.get("identifier")
        password = attrs.get("password")

        if not identifier or not password:
            raise serializers.ValidationError(
                _("Необходимо указать логин и пароль."),
                code="authorization",
            )

        user = find_user_by_identifier(identifier)
        if user is None:
            raise serializers.ValidationError(
                _("Неверный логин/email/телефон или пароль."),
                code="authorization",
            )

        auth_user = authenticate(
            username=user.username,
            password=password,
        )
        if auth_user is None:
            raise serializers.ValidationError(
                _("Неверный логин/email/телефон или пароль."),
                code="authorization",
            )

        if not auth_user.is_active:
            raise serializers.ValidationError(
                _("Пользователь деактивирован."),
                code="authorization",
            )

        attrs["user"] = auth_user
        return attrs


class ChangePasswordSerializer(serializers.Serializer):
    """
    Смена пароля текущего пользователя.
    """

    old_password = serializers.CharField(write_only=True)
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate_new_password(self, value: str) -> str:
        user = self.context["request"].user
        validate_password(value, user=user)
        return value

    def validate(self, attrs: dict) -> dict:
        user = self.context["request"].user
        old_password = attrs.get("old_password")
        if not user.check_password(old_password):
            raise serializers.ValidationError(
                {"old_password": _("Неверный текущий пароль.")}
            )
        return attrs

    def save(self, **kwargs) -> User:
        user = self.context["request"].user
        new_password = self.validated_data["new_password"]
        user.set_password(new_password)
        user.last_password_change = timezone.now()
        user.save(update_fields=["password", "last_password_change"])

        request = self.context.get("request")
        if request and hasattr(request, "session"):
            invalidate_other_sessions(user, keep_session_key=request.session.session_key)
            request.session.cycle_key()
        return user


class PasswordResetRequestSerializer(serializers.Serializer):
    """
    Запрос на сброс пароля по email (API).
    """

    email = serializers.EmailField()

    def validate_email(self, value: str) -> str:
        return normalize_email(value)


class OTPRequestSerializer(serializers.Serializer):
    identifier = serializers.CharField(label=_("Email или телефон"))
    purpose = serializers.ChoiceField(
        choices=LoginCode.Purpose.choices,
        default=LoginCode.Purpose.LOGIN,
    )

    def validate_identifier(self, value: str) -> str:
        value = (value or "").strip()
        if not value:
            raise serializers.ValidationError(_("Укажите email или телефон."))
        if "@" in value:
            normalized = normalize_email(value)
            if not normalized:
                raise serializers.ValidationError(_("Некорректный email."))
            return normalized
        normalized_phone = normalize_phone(value)
        if not normalized_phone:
            raise serializers.ValidationError(_("Некорректный номер телефона. Используйте формат +7..."))
        return normalized_phone

    def get_channel(self) -> str:
        identifier = self.validated_data.get("identifier", "")
        if "@" in identifier:
            return LoginCode.Channel.EMAIL
        return LoginCode.Channel.PHONE


class OTPVerifySerializer(serializers.Serializer):
    identifier = serializers.CharField(label=_("Email или телефон"))
    code = serializers.CharField(label=_("Код из сообщения"), max_length=12)
    purpose = serializers.ChoiceField(
        choices=LoginCode.Purpose.choices,
        default=LoginCode.Purpose.LOGIN,
    )

    def validate_identifier(self, value: str) -> str:
        value = (value or "").strip()
        if not value:
            raise serializers.ValidationError(_("Укажите email или телефон."))
        if "@" in value:
            normalized = normalize_email(value)
            if not normalized:
                raise serializers.ValidationError(_("Некорректный email."))
            return normalized
        normalized_phone = normalize_phone(value)
        if not normalized_phone:
            raise serializers.ValidationError(_("Некорректный номер телефона. Используйте формат +7..."))
        return normalized_phone

    def get_channel(self) -> str:
        identifier = self.validated_data.get("identifier", "")
        if "@" in identifier:
            return LoginCode.Channel.EMAIL
        return LoginCode.Channel.PHONE


class MFAVerifySerializer(serializers.Serializer):
    code = serializers.CharField(label=_("Код подтверждения"), max_length=12)


class MFASetupSerializer(serializers.Serializer):
    method = serializers.ChoiceField(
        choices=User.MFAMethod.choices,
        help_text=_("totp / sms / email"),
    )

    def validate_method(self, value: str) -> str:
        if value == User.MFAMethod.NONE:
            raise serializers.ValidationError(_("Выберите конкретный метод MFA."))
        return value


class MFAActivateSerializer(serializers.Serializer):
    code = serializers.CharField(label=_("Код подтверждения"), max_length=12)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 42
PATH: accounts\urls.py
LANG: python
===== CONTENT START =====
# accounts/urls.py

from django.contrib.auth import views as auth_views
from django.urls import path, reverse_lazy

from .views import (
    CustomLoginView,
    MFASettingsView,
    MFAVerifyPageView,
    ProfileView,
    RegisterView,
    SecurePasswordChangeView,
    logout_view,
)

app_name = "accounts"

urlpatterns = [
    path("login/", CustomLoginView.as_view(), name="login"),
    path("logout/", logout_view, name="logout"),
    path("register/", RegisterView.as_view(), name="register"),
    path("profile/", ProfileView.as_view(), name="profile"),
    path("mfa/setup/", MFASettingsView.as_view(), name="mfa_setup"),
    path("mfa/verify/", MFAVerifyPageView.as_view(), name="mfa_verify"),

    path(
        "password/change/",
        SecurePasswordChangeView.as_view(
            template_name="accounts/password_change.html",
            success_url=reverse_lazy("accounts:password_change_done"),
        ),
        name="password_change",
    ),
    path(
        "password/change/done/",
        auth_views.PasswordChangeDoneView.as_view(
            template_name="accounts/password_change_done.html"
        ),
        name="password_change_done",
    ),

    path(
        "password/reset/",
        auth_views.PasswordResetView.as_view(
            template_name="accounts/password_reset.html",
            email_template_name="accounts/password_reset_email.txt",
            subject_template_name="accounts/password_reset_subject.txt",
            success_url=reverse_lazy("accounts:password_reset_done"),
        ),
        name="password_reset",
    ),
    path(
        "password/reset/done/",
        auth_views.PasswordResetDoneView.as_view(
            template_name="accounts/password_reset_done.html"
        ),
        name="password_reset_done",
    ),
    path(
        "reset/<uidb64>/<token>/",
        auth_views.PasswordResetConfirmView.as_view(
            template_name="accounts/password_reset_confirm.html",
            success_url=reverse_lazy("accounts:password_reset_complete"),
        ),
        name="password_reset_confirm",
    ),
    path(
        "reset/done/",
        auth_views.PasswordResetCompleteView.as_view(
            template_name="accounts/password_reset_complete.html"
        ),
        name="password_reset_complete",
    ),
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 43
PATH: accounts\utils.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import hashlib
from typing import Optional

from django.conf import settings
from django.utils.crypto import get_random_string

from core.utils import normalize_phone as core_normalize_phone


def normalize_email(email: Optional[str]) -> str:
    if not email:
        return ""
    return email.strip().lower()


def normalize_phone(phone: Optional[str]) -> str:
    return core_normalize_phone(phone)


def _hash_value(kind: str, value: str) -> str:
    payload = f"{kind}:{value}:{settings.SECRET_KEY}".encode("utf-8")
    return hashlib.sha256(payload).hexdigest()


def hash_email(email: str) -> str:
    email = (email or "").strip().lower()
    if not email:
        return ""
    return _hash_value("email", email)


def hash_phone(phone: str) -> str:
    phone = (phone or "").strip()
    if not phone:
        return ""
    return _hash_value("phone", phone)


def hash_code(code: str) -> str:
    code = (code or "").strip()
    if not code:
        return ""
    return _hash_value("otp", code)


def generate_username(prefix: str = "user") -> str:
    return f"{prefix}_{get_random_string(10)}"


def invalidate_other_sessions(user, keep_session_key: str | None = None) -> None:
    from django.contrib.sessions.models import Session  # локальный импорт
    from django.utils import timezone

    now = timezone.now()
    for session in Session.objects.filter(expire_date__gt=now):
        data = session.get_decoded()
        if str(data.get("_auth_user_id")) != str(user.pk):
            continue
        if keep_session_key and session.session_key == keep_session_key:
            continue
        session.delete()


def build_totp_uri(username: str, issuer: str, secret: str) -> str:
    from urllib.parse import quote

    label = quote(f"{issuer}:{username}")
    issuer_q = quote(issuer)
    secret_q = quote(secret)
    return f"otpauth://totp/{label}?secret={secret_q}&issuer={issuer_q}&digits=6"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 44
PATH: accounts\views.py
LANG: python
===== CONTENT START =====
# accounts/views.py

from __future__ import annotations

import logging
import random
import secrets
from datetime import timedelta
from typing import Any, Optional
from urllib.parse import urlencode

import pyotp
from django.conf import settings
from django.contrib.auth import login as auth_login, logout as auth_logout
from django.contrib.auth import views as auth_views
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.views import LoginView as DjangoLoginView
from django.contrib.auth.forms import PasswordResetForm
from django.http import HttpRequest, HttpResponse, HttpResponseBadRequest
from django.shortcuts import redirect, render
from django.urls import reverse, reverse_lazy
from django.utils import timezone
from django.views import View
from django.views.generic import UpdateView
from rest_framework import permissions, status, viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenRefreshView

from core.observability import capture_exception
from core.permissions import IsSelfOrAdmin
from core.sms import get_sms_provider
from .auth import find_user_by_identifier
from .forms import LoginForm, ProfileForm, RegisterForm
from .models import LoginCode, SocialAccount, User
from .oauth import build_authorize_url, fetch_profile
from .serializers import (
    ChangePasswordSerializer,
    MFAActivateSerializer,
    MFASetupSerializer,
    MFAVerifySerializer,
    LoginSerializer,
    OTPRequestSerializer,
    OTPVerifySerializer,
    PasswordResetRequestSerializer,
    RegisterSerializer,
    SocialAccountSerializer,
    UserProfileSerializer,
    UserSerializer,
)
from .utils import (
    build_totp_uri,
    generate_username,
    hash_code,
    hash_email,
    hash_phone,
    invalidate_other_sessions,
    normalize_email,
    normalize_phone,
)

logger = logging.getLogger(__name__)


def _issue_tokens(user: User) -> dict[str, str]:
    refresh = RefreshToken.for_user(user)
    return {
        "access": str(refresh.access_token),
        "refresh": str(refresh),
    }


def _set_token_cookies(response: Response, tokens: dict[str, str]) -> None:
    """
    Выставляет httpOnly‑cookie для access/refresh, чтобы фронт (Next/Django) мог рефрешить без локального хранилища.
    """
    access_ttl = int(getattr(settings, "AUTH_ACCESS_COOKIE_AGE", 300))
    refresh_ttl = int(getattr(settings, "AUTH_REFRESH_COOKIE_AGE", 60 * 60 * 24 * 14))
    secure = getattr(settings, "AUTH_COOKIE_SECURE", not settings.DEBUG)
    response.set_cookie(
        "ps_access",
        tokens.get("access", ""),
        max_age=access_ttl,
        httponly=True,
        secure=secure,
        samesite="Lax",
        path="/",
    )
    response.set_cookie(
        "ps_refresh",
        tokens.get("refresh", ""),
        max_age=refresh_ttl,
        httponly=True,
        secure=secure,
        samesite="Lax",
        path="/",
    )


def _clear_token_cookies(response: Response) -> None:
    response.delete_cookie("ps_access", path="/")
    response.delete_cookie("ps_refresh", path="/")


def _clear_pre_auth(session) -> None:
    for key in (
        "pre_auth_user_id",
        "pre_auth_primary_ok",
        "pre_auth_method",
        "pre_auth_reason",
        "post_auth_redirect",
        "oauth_next",
    ):
        session.pop(key, None)


def _finalize_auth(request: HttpRequest, user: User) -> dict[str, str]:
    """
    Завершает аутентификацию: чистит pre-auth, логинит через Django и выдаёт JWT.
    """
    _clear_pre_auth(request.session)
    auth_login(request, user)
    try:
        request.session.cycle_key()
    except Exception:
        pass
    if getattr(settings, "AUTH_ROTATE_SESSIONS_ON_LOGIN", True):
        try:
            invalidate_other_sessions(user, keep_session_key=request.session.session_key)
        except Exception:
            logger.warning("Failed to rotate user sessions", exc_info=True)
    return _issue_tokens(user)


def _complete_login_response(
    request: HttpRequest,
    user: User,
    payload: Optional[dict[str, Any]] = None,
    status_code: int = status.HTTP_200_OK,
) -> Response:
    tokens = _finalize_auth(request, user)
    data = {"user": UserProfileSerializer(user).data, **tokens}
    if payload:
        data.update(payload)
    response = Response(data, status=status_code)
    _set_token_cookies(response, tokens)
    return response


def _otp_satisfies_mfa(user: User, channel: str) -> bool:
    """
    Единое правило: SMS/email‑OTP засчитывается как фактор только если метод MFA совпадает с каналом
    и MFA уже включена. TOTP всегда требует отдельного подтверждения.
    """
    if not getattr(user, "mfa_enabled", False):
        return True
    if user.mfa_method == User.MFAMethod.TOTP:
        return False
    if user.mfa_method == User.MFAMethod.SMS and channel == LoginCode.Channel.PHONE:
        return True
    if user.mfa_method == User.MFAMethod.EMAIL and channel == LoginCode.Channel.EMAIL:
        return True
    return False


def _get_pre_auth_user(request: HttpRequest) -> Optional[User]:
    user_id = request.session.get("pre_auth_user_id")
    if not user_id:
        return None
    try:
        return User.objects.get(pk=user_id)
    except User.DoesNotExist:
        return None


def _verify_totp(user: User, code: str) -> bool:
    if not user.mfa_secret:
        return False
    try:
        totp = pyotp.TOTP(user.mfa_secret)
    except Exception:
        return False
    return totp.verify(code, valid_window=1)


def _send_mfa_code(user: User) -> Optional[str]:
    """
    Отправляет одноразовый код для MFA по email или телефону.
    Возвращает строку канала (email/phone) либо None, если отправка не требуется.
    """
    method = user.mfa_method
    if method not in (User.MFAMethod.SMS, User.MFAMethod.EMAIL):
        return None

    channel = LoginCode.Channel.EMAIL if method == User.MFAMethod.EMAIL else LoginCode.Channel.PHONE
    identifier = user.email_plain if channel == LoginCode.Channel.EMAIL else user.phone_plain
    if not identifier:
        logger.warning("MFA %s requested but no identifier on user %s", method, user.pk)
        return None

    now = timezone.now()
    window_seconds = getattr(settings, "AUTH_OTP_WINDOW_SECONDS", 600)
    max_per_window = getattr(settings, "AUTH_OTP_MAX_PER_WINDOW", 5)
    window_start = now - timedelta(seconds=window_seconds)
    recent_count = (
        LoginCode.objects.filter(
            user=user,
            channel=channel,
            purpose=LoginCode.Purpose.MFA,
            created_at__gte=window_start,
        )
        .only("id")
        .count()
    )
    if recent_count >= max_per_window:
        return channel

    raw_code = f"{random.randint(0, 999999):06d}"
    code_hash = hash_code(raw_code)
    ttl_seconds = getattr(settings, "AUTH_OTP_CODE_TTL_SECONDS", 600)
    expires_at = now + timedelta(seconds=ttl_seconds)

    LoginCode.objects.create(
        user=user,
        channel=channel,
        purpose=LoginCode.Purpose.MFA,
        code_hash=code_hash,
        expires_at=expires_at,
    )

    try:
        if channel == LoginCode.Channel.EMAIL:
            subject = "Код подтверждения входа в ParkShare"
            message = (
                f"Ваш код подтверждения: {raw_code}\n"
                "Никогда не сообщайте его никому. Код действует несколько минут."
            )
            user.email_user(subject, message)
        else:
            text = f"ParkShare: код подтверждения входа {raw_code}"
            sms_provider = get_sms_provider()
            sms_provider.send_sms(identifier, text)
    except Exception as exc:
        capture_exception(
            exc,
            {
                "channel": channel,
                "user_id": str(user.pk),
                "context": "mfa_send",
            },
        )
    return channel


def _verify_mfa_code(user: User, code: str) -> bool:
    method = user.mfa_method
    code = (code or "").strip()
    if not code or method == User.MFAMethod.NONE:
        return False
    if method == User.MFAMethod.TOTP:
        return _verify_totp(user, code)

    channel = LoginCode.Channel.EMAIL if method == User.MFAMethod.EMAIL else LoginCode.Channel.PHONE
    qs = LoginCode.objects.filter(
        user=user,
        channel=channel,
        purpose=LoginCode.Purpose.MFA,
        is_used=False,
    ).order_by("-created_at")
    code_obj = qs.first()
    if not code_obj:
        return False

    max_attempts = getattr(settings, "AUTH_OTP_MAX_ATTEMPTS", 5)
    if code_obj.is_expired or code_obj.attempts >= max_attempts or code_obj.code_hash != hash_code(code):
        code_obj.attempts += 1
        if code_obj.attempts >= max_attempts:
            code_obj.is_used = True
            code_obj.status = "blocked"
        code_obj.save(update_fields=["attempts", "is_used", "status", "updated_at"])
        return False

    code_obj.is_used = True
    code_obj.attempts += 1
    code_obj.status = "used"
    code_obj.save(update_fields=["is_used", "status", "attempts", "updated_at"])
    return True


def _require_mfa(request: HttpRequest, user: User, reason: str = "login") -> dict[str, Any]:
    request.session["pre_auth_user_id"] = str(user.pk)
    request.session["pre_auth_primary_ok"] = True
    request.session["pre_auth_method"] = user.mfa_method
    request.session["pre_auth_reason"] = reason
    channel = _send_mfa_code(user)
    request.session.modified = True
    return {
        "mfa_required": True,
        "mfa_method": user.mfa_method,
        "mfa_channel": channel,
    }


class RegisterView(View):
    template_name = "accounts/register.html"

    def get(self, request: HttpRequest) -> HttpResponse:
        if request.user.is_authenticated:
            return redirect("user_dashboard")
        form = RegisterForm()
        return render(request, self.template_name, {"form": form})

    def post(self, request: HttpRequest) -> HttpResponse:
        if request.user.is_authenticated:
            return redirect("user_dashboard")
        form = RegisterForm(request.POST)
        if form.is_valid():
            user = form.save()
            auth_login(request, user)
            return redirect("user_dashboard")
        return render(request, self.template_name, {"form": form})


class ProfileView(LoginRequiredMixin, UpdateView):
    model = User
    form_class = ProfileForm
    template_name = "accounts/profile.html"
    success_url = reverse_lazy("user_dashboard")

    def get_object(self, queryset=None) -> User:
        return self.request.user


class MFASettingsView(LoginRequiredMixin, View):
    """
    Простая HTML-страница для управления MFA (TOTP или SMS/Email).
    """

    template_name = "accounts/mfa_setup.html"

    def get(self, request: HttpRequest) -> HttpResponse:
        user: User = request.user
        secret = request.session.get("mfa_setup_secret") or user.mfa_secret
        otpauth_url = None
        if secret and user.mfa_method == User.MFAMethod.TOTP:
            otpauth_url = build_totp_uri(user.username or str(user.pk), "ParkShare", secret)
        context = {
            "user": user,
            "secret": secret,
            "otpauth_url": otpauth_url,
            "method": user.mfa_method,
            "mfa_enabled": user.mfa_enabled,
            "status": request.GET.get("status"),
            "error": request.GET.get("error"),
        }
        return render(request, self.template_name, context)

    def post(self, request: HttpRequest) -> HttpResponse:
        user: User = request.user
        action = request.POST.get("action")
        status_msg = ""
        error_msg = ""

        if action == "start_totp":
            secret = pyotp.random_base32()
            user.mfa_secret = secret
            user.mfa_method = User.MFAMethod.TOTP
            user.mfa_enabled = False
            user.save(update_fields=["mfa_secret", "mfa_method", "mfa_enabled"])
            request.session["mfa_setup_secret"] = secret
            status_msg = "Секрет для TOTP сгенерирован. Просканируйте QR и введите код для активации."
        elif action == "start_sms":
            if not user.phone_plain:
                error_msg = "Добавьте номер телефона в профиле, чтобы включить SMS-MFA."
            else:
                user.mfa_method = User.MFAMethod.SMS
                user.mfa_enabled = False
                user.mfa_secret = None
                user.save(update_fields=["mfa_method", "mfa_enabled", "mfa_secret"])
                _send_mfa_code(user)
                status_msg = "Мы отправили код по SMS. Введите его ниже для активации."
        elif action == "start_email":
            if not user.email_plain:
                error_msg = "Добавьте email в профиле, чтобы включить MFA по email."
            else:
                user.mfa_method = User.MFAMethod.EMAIL
                user.mfa_enabled = False
                user.mfa_secret = None
                user.save(update_fields=["mfa_method", "mfa_enabled", "mfa_secret"])
                _send_mfa_code(user)
                status_msg = "Код отправлен на email. Проверьте почту и подтвердите ниже."
        elif action == "verify":
            code = request.POST.get("code", "")
            is_valid = _verify_totp(user, code) if user.mfa_method == User.MFAMethod.TOTP else _verify_mfa_code(user, code)
            if is_valid:
                user.mfa_enabled = True
                user.last_mfa_change = timezone.now()
                user.save(update_fields=["mfa_enabled", "last_mfa_change"])
                invalidate_other_sessions(user, keep_session_key=request.session.session_key)
                request.session.cycle_key()
                request.session.pop("mfa_setup_secret", None)
                status_msg = "MFA успешно включена."
            else:
                error_msg = "Код не подошёл. Попробуйте снова."
        elif action == "disable":
            user.mfa_enabled = False
            user.mfa_method = User.MFAMethod.NONE
            user.mfa_secret = None
            user.last_mfa_change = timezone.now()
            user.save(update_fields=["mfa_enabled", "mfa_method", "mfa_secret", "last_mfa_change"])
            invalidate_other_sessions(user, keep_session_key=request.session.session_key)
            request.session.cycle_key()
            request.session.pop("mfa_setup_secret", None)
            status_msg = "MFA выключена."

        params = {}
        if status_msg:
            params["status"] = status_msg
        if error_msg:
            params["error"] = error_msg
        query = f"?{urlencode(params)}" if params else ""
        return redirect(f"{reverse('accounts:mfa_setup')}{query}")


class MFAVerifyPageView(View):
    """
    HTML-страница ввода кода MFA после успешного первичного входа.
    """

    template_name = "accounts/mfa_verify.html"

    def get(self, request: HttpRequest) -> HttpResponse:
        user = _get_pre_auth_user(request)
        if not user:
            return redirect("accounts:login")
        method = request.session.get("pre_auth_method") or user.mfa_method
        channel = "email" if method == User.MFAMethod.EMAIL else "sms" if method == User.MFAMethod.SMS else None
        context = {
            "method": method,
            "channel": channel,
            "username": getattr(user, "username", ""),
            "error": None,
        }
        return render(request, self.template_name, context)

    def post(self, request: HttpRequest) -> HttpResponse:
        user = _get_pre_auth_user(request)
        if not user:
            return redirect("accounts:login")

        if request.POST.get("action") == "resend":
            _send_mfa_code(user)
            return redirect(f"{reverse('accounts:mfa_verify')}?status=resend")

        code = request.POST.get("code", "")
        if not _verify_mfa_code(user, code):
            method = request.session.get("pre_auth_method") or user.mfa_method
            channel = "email" if method == User.MFAMethod.EMAIL else "sms" if method == User.MFAMethod.SMS else None
            context = {
                "method": method,
                "channel": channel,
                "username": getattr(user, "username", ""),
                "error": "Код не подошёл. Попробуйте снова.",
            }
            return render(request, self.template_name, context, status=400)

        next_url = request.session.get("post_auth_redirect") or request.session.get("oauth_next")
        _finalize_auth(request, user)
        if next_url:
            return redirect(next_url)
        return redirect("user_dashboard")


class ProfileView(LoginRequiredMixin, UpdateView):
    model = User
    form_class = ProfileForm
    template_name = "accounts/profile.html"
    success_url = reverse_lazy("user_dashboard")

    def get_object(self, queryset=None) -> User:
        return self.request.user


class CustomLoginView(DjangoLoginView):
    """
    Обёртка над стандартным LoginView с русским шаблоном и кастомной формой.
    """

    template_name = "accounts/login.html"
    form_class = LoginForm

    def get_success_url(self) -> str:
        return reverse("user_dashboard")

    def form_valid(self, form):
        user = form.get_user()
        if getattr(user, "mfa_enabled", False) and user.mfa_method != User.MFAMethod.NONE:
            self.request.session["post_auth_redirect"] = self.get_success_url()
            _require_mfa(self.request, user, reason="password")
            return redirect(reverse("accounts:mfa_verify"))
        return super().form_valid(form)


class SecurePasswordChangeView(auth_views.PasswordChangeView):
    """
    Перехватываем смену пароля, чтобы инвалидировать старые сессии и отметить время смены.
    """

    def form_valid(self, form):
        response = super().form_valid(form)
        user: User = self.request.user
        user.last_password_change = timezone.now()
        user.save(update_fields=["last_password_change"])
        invalidate_other_sessions(user, keep_session_key=self.request.session.session_key)
        self.request.session.cycle_key()
        return response


def logout_view(request: HttpRequest) -> HttpResponse:
    _clear_pre_auth(request.session)
    auth_logout(request)
    response = redirect("landing")
    _clear_token_cookies(response)  # type: ignore[arg-type]
    return response


class UserViewSet(viewsets.ModelViewSet):
    """
    API для работы с пользователями.
    """

    queryset = User.objects.all().order_by("-date_joined")
    serializer_class = UserSerializer

    def get_permissions(self) -> list[Any]:
        if self.action in ("register", "login", "reset_password"):
            permission_classes = [permissions.AllowAny]
        elif self.action in ("list", "destroy"):
            permission_classes = [permissions.IsAdminUser]
        elif self.action in ("me", "change_password", "logout", "social_accounts"):
            permission_classes = [permissions.IsAuthenticated]
        else:
            permission_classes = [permissions.IsAuthenticated, IsSelfOrAdmin]
        return [perm() for perm in permission_classes]

    def get_queryset(self):
        user: User = self.request.user
        if not user.is_authenticated:
            return User.objects.none()
        if user.is_superuser or getattr(user, "is_admin", False):
            return User.objects.all().order_by("-date_joined")
        return User.objects.filter(pk=user.pk)

    def perform_destroy(self, instance: User) -> None:
        super().perform_destroy(instance)

    @action(detail=False, methods=["get", "patch"], url_path="me")
    def me(self, request):
        if request.method.lower() == "get":
            serializer = UserProfileSerializer(request.user)
            return Response(serializer.data)
        serializer = UserProfileSerializer(
            request.user, data=request.data, partial=True
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data)

    @action(detail=False, methods=["get"], url_path="social-accounts")
    def social_accounts(self, request):
        serializer = SocialAccountSerializer(
            request.user.social_accounts.all().order_by("provider"), many=True
        )
        return Response(serializer.data)

    @action(detail=False, methods=["post"], url_path="register")
    def register(self, request):
        serializer = RegisterSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user: User = serializer.save()
        return _complete_login_response(request, user, status_code=status.HTTP_201_CREATED)

    @action(detail=False, methods=["post"], url_path="login")
    def login(self, request):
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user: User = serializer.validated_data["user"]
        if user.mfa_enabled and user.mfa_method != User.MFAMethod.NONE:
            request.session["post_auth_redirect"] = request.data.get("next")
            challenge = _require_mfa(request, user, reason="password")
            return Response(
                {
                    **challenge,
                    "detail": "Требуется подтверждение второго фактора.",
                    "mfa_required": True,
                },
                status=status.HTTP_200_OK,
            )

        return _complete_login_response(request, user, status_code=status.HTTP_200_OK)

    @action(detail=False, methods=["post"], url_path="logout")
    def logout(self, request):
        response = Response({"detail": "Вы вышли из системы."}, status=status.HTTP_200_OK)
        _clear_token_cookies(response)
        auth_logout(request)
        return response

    @action(detail=False, methods=["post"], url_path="change-password")
    def change_password(self, request):
        serializer = ChangePasswordSerializer(
            data=request.data, context={"request": request}
        )
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(
            {"detail": "Пароль успешно изменён."},
            status=status.HTTP_200_OK,
        )

    @action(detail=False, methods=["post"], url_path="reset-password")
    def reset_password(self, request):
        serializer = PasswordResetRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        email = serializer.validated_data["email"]

        form = PasswordResetForm(data={"email": email})
        if form.is_valid():
            form.save(
                request=request,
                use_https=request.is_secure(),
                email_template_name="accounts/password_reset_email.txt",
                subject_template_name="accounts/password_reset_subject.txt",
            )

        return Response(
            {
                "detail": (
                    "Если пользователь с таким email существует, на него отправлена "
                    "инструкция по сбросу пароля."
                )
            },
            status=status.HTTP_200_OK,
        )


class TokenObtainPairView(APIView):
    """JWT-аутентификация по логину/email/телефону."""

    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.validated_data["user"]
        if user.mfa_enabled and user.mfa_method != User.MFAMethod.NONE:
            request.session["post_auth_redirect"] = request.data.get("next")
            challenge = _require_mfa(request, user, reason="jwt_login")
            return Response(
                {
                    **challenge,
                    "detail": "MFA требуется перед выдачей токенов.",
                    "mfa_required": True,
                },
                status=status.HTTP_200_OK,
            )

        return _complete_login_response(request, user, status_code=status.HTTP_200_OK)


class TokenRefreshSlidingView(TokenRefreshView):
    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        refresh_cookie = request.COOKIES.get("ps_refresh")
        if refresh_cookie and not request.data.get("refresh"):
            try:
                request.data._mutable = True  # type: ignore[attr-defined]
            except Exception:
                pass
            request.data["refresh"] = refresh_cookie
        response = super().post(request, *args, **kwargs)
        if hasattr(response, "data") and isinstance(response.data, dict):
            _set_token_cookies(response, response.data)
        return response


class AuthOTPRequestView(APIView):
    """
    Request one-time code for login/registration via email or phone (SMS).
    """

    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = OTPRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        identifier = serializer.validated_data["identifier"]
        purpose = serializer.validated_data["purpose"]
        channel = serializer.get_channel()

        user = self._get_or_create_user(identifier, channel)

        now = timezone.now()
        window_seconds = getattr(settings, "AUTH_OTP_WINDOW_SECONDS", 600)
        max_per_window = getattr(settings, "AUTH_OTP_MAX_PER_WINDOW", 5)
        window_start = now - timedelta(seconds=window_seconds)
        recent_count = (
            LoginCode.objects.filter(
                user=user,
                channel=channel,
                purpose=purpose,
                created_at__gte=window_start,
            )
            .only("id")
            .count()
        )
        if recent_count >= max_per_window:
            return Response(
                {"detail": "Слишком много запросов кода. Попробуйте позже."},
                status=status.HTTP_429_TOO_MANY_REQUESTS,
            )

        raw_code = f"{random.randint(0, 999999):06d}"
        code_hash = hash_code(raw_code)
        ttl_seconds = getattr(settings, "AUTH_OTP_CODE_TTL_SECONDS", 600)
        expires_at = now + timedelta(seconds=ttl_seconds)

        LoginCode.objects.create(
            user=user,
            channel=channel,
            purpose=purpose,
            code_hash=code_hash,
            expires_at=expires_at,
        )

        try:
            if channel == LoginCode.Channel.EMAIL:
                subject = "Код для входа в ParkShare"
                message = f"Ваш код для входа: {raw_code}\n\nСрок действия: {ttl_seconds // 60} минут."
                user.email_user(subject, message)
            else:
                text = f"Код для входа в ParkShare: {raw_code}. Не сообщайте его никому."
                sms_provider = get_sms_provider()
                sms_provider.send_sms(identifier, text)
        except Exception as exc:
            capture_exception(
                exc,
                {
                    "channel": channel,
                    "purpose": purpose,
                    "user_id": str(user.pk),
                },
            )

        return Response(
            {
                "detail": "Код отправлен.",
                "ttl_seconds": ttl_seconds,
                "channel": channel,
            },
            status=status.HTTP_200_OK,
        )

    def _get_or_create_user(self, identifier: str, channel: str) -> User:
        if channel == LoginCode.Channel.EMAIL:
            email_norm = normalize_email(identifier)
            email_hash = hash_email(email_norm)
            user = User.objects.filter(email_hash=email_hash).first()
            if user:
                return user
            user = User(username=generate_username("mail"))
            user.email_plain = email_norm
            user.save()
            return user

        phone_norm = normalize_phone(identifier)
        phone_hash = hash_phone(phone_norm)
        user = User.objects.filter(phone_hash=phone_hash).first()
        if user:
            return user
        user = User(username=generate_username("phone"))
        user.phone_plain = phone_norm
        user.save()
        return user


class AuthOTPVerifyView(APIView):
    """
    Verify one-time code and issue JWT tokens + session login.
    """

    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = OTPVerifySerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        identifier = serializer.validated_data["identifier"]
        code = serializer.validated_data["code"]
        purpose = serializer.validated_data["purpose"]
        channel = serializer.get_channel()

        user = find_user_by_identifier(identifier)
        if not user:
            return Response(
                {"detail": "Пользователь не найден."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        code_hash = hash_code(code)
        qs = LoginCode.objects.filter(
            user=user,
            purpose=purpose,
            channel=channel,
            is_used=False,
        ).order_by("-created_at")

        code_obj = qs.first()
        if not code_obj:
            return Response(
                {"detail": "Код не найден. Запросите новый."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        max_attempts = getattr(settings, "AUTH_OTP_MAX_ATTEMPTS", 5)
        if code_obj.is_expired or code_obj.attempts >= max_attempts or code_obj.code_hash != code_hash:
            code_obj.attempts += 1
            if code_obj.attempts >= max_attempts:
                code_obj.is_used = True
                code_obj.status = "blocked"
            code_obj.save(update_fields=["attempts", "is_used", "status", "updated_at"])
            return Response(
                {"detail": "Неверный или просроченный код."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        code_obj.is_used = True
        code_obj.attempts += 1
        code_obj.status = "used"
        code_obj.save(update_fields=["is_used", "status", "attempts", "updated_at"])

        if user.mfa_enabled and not _otp_satisfies_mfa(user, channel):
            request.session["post_auth_redirect"] = request.data.get("next")
            challenge = _require_mfa(request, user, reason="otp_login")
            return Response(
                {
                    **challenge,
                    "detail": "Необходим второй фактор (MFA).",
                    "mfa_required": True,
                },
                status=status.HTTP_200_OK,
            )

        return _complete_login_response(request, user, status_code=status.HTTP_200_OK)


class AuthMFAVerifyView(APIView):
    """
    Verify MFA code (TOTP or SMS/email) after успешного первичного входа.
    """

    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = MFAVerifySerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        user = _get_pre_auth_user(request)
        if not user or not request.session.get("pre_auth_primary_ok"):
            return Response(
                {"detail": "Сессия MFA не найдена или истекла."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        code = serializer.validated_data["code"]
        if not _verify_mfa_code(user, code):
            return Response({"detail": "Неверный код MFA."}, status=status.HTTP_400_BAD_REQUEST)

        next_url = request.session.get("post_auth_redirect") or request.session.get("oauth_next")
        extra = {"detail": "MFA подтверждена."}
        if next_url:
            extra["next"] = next_url
        return _complete_login_response(request, user, payload=extra, status_code=status.HTTP_200_OK)


class AuthMFASetupView(APIView):
    """
    Инициирует подключение MFA для текущего пользователя.
    """

    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        serializer = MFASetupSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        method = serializer.validated_data["method"]
        user: User = request.user

        if method == User.MFAMethod.TOTP:
            secret = pyotp.random_base32()
            user.mfa_secret = secret
            user.mfa_method = User.MFAMethod.TOTP
            user.mfa_enabled = False
            user.save(update_fields=["mfa_secret", "mfa_method", "mfa_enabled"])
            request.session["mfa_setup_secret"] = secret
            otpauth_url = build_totp_uri(user.username or str(user.pk), "ParkShare", secret)
            return Response(
                {
                    "secret": secret,
                    "otpauth_url": otpauth_url,
                    "mfa_method": user.mfa_method,
                },
                status=status.HTTP_200_OK,
            )

        if method == User.MFAMethod.SMS and not user.phone_plain:
            return Response({"detail": "Добавьте телефон в профиле для SMS-MFA."}, status=status.HTTP_400_BAD_REQUEST)
        if method == User.MFAMethod.EMAIL and not user.email_plain:
            return Response({"detail": "Добавьте email в профиле для Email-MFA."}, status=status.HTTP_400_BAD_REQUEST)

        user.mfa_method = method
        user.mfa_enabled = False
        user.mfa_secret = None
        user.save(update_fields=["mfa_method", "mfa_enabled", "mfa_secret"])
        channel = _send_mfa_code(user)

        return Response(
            {
                "detail": "Код отправлен. Подтвердите его, чтобы включить MFA.",
                "channel": channel,
                "mfa_method": user.mfa_method,
            },
            status=status.HTTP_200_OK,
        )


class AuthMFAActivateView(APIView):
    """
    Завершает подключение MFA (ввод кода TOTP/SMS/email).
    """

    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        serializer = MFAActivateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user: User = request.user
        if user.mfa_method == User.MFAMethod.NONE:
            return Response({"detail": "MFA не инициализирована."}, status=status.HTTP_400_BAD_REQUEST)

        code = serializer.validated_data["code"]
        is_valid = _verify_totp(user, code) if user.mfa_method == User.MFAMethod.TOTP else _verify_mfa_code(user, code)
        if not is_valid:
            return Response({"detail": "Код не подошёл."}, status=status.HTTP_400_BAD_REQUEST)

        user.mfa_enabled = True
        user.last_mfa_change = timezone.now()
        user.save(update_fields=["mfa_enabled", "last_mfa_change"])
        invalidate_other_sessions(user, keep_session_key=request.session.session_key)
        request.session.cycle_key()
        request.session.pop("mfa_setup_secret", None)
        return Response(
            {
                "detail": "MFA включена.",
                "mfa_method": user.mfa_method,
            },
            status=status.HTTP_200_OK,
        )


class AuthMFADisableView(APIView):
    """
    Отключает MFA, очищает секреты.
    """

    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        user: User = request.user
        user.mfa_enabled = False
        user.mfa_method = User.MFAMethod.NONE
        user.mfa_secret = None
        user.last_mfa_change = timezone.now()
        user.save(update_fields=["mfa_enabled", "mfa_method", "mfa_secret", "last_mfa_change"])
        invalidate_other_sessions(user, keep_session_key=request.session.session_key)
        request.session.cycle_key()
        _clear_pre_auth(request.session)
        return Response({"detail": "MFA отключена."}, status=status.HTTP_200_OK)


class SocialOAuthStartView(View):
    """Стартуем OAuth-авторизацию: формируем state и редиректим на провайдера."""

    def get(self, request: HttpRequest, provider: str) -> HttpResponse:
        state = secrets.token_urlsafe(24)
        request.session[f"oauth_state_{provider}"] = state
        next_url = request.GET.get("next")
        if next_url:
            request.session["oauth_next"] = next_url

        redirect_uri = request.build_absolute_uri(
            reverse("oauth_callback", args=[provider])
        )
        try:
            url = build_authorize_url(provider, state, redirect_uri)
        except ValueError:
            return HttpResponseBadRequest("Unsupported provider")
        return redirect(url)


class SocialOAuthCallbackView(APIView):
    """Принимаем код, валидируем state, создаём/линкуем пользователя и соц-аккаунт."""

    permission_classes = [permissions.AllowAny]

    def get(self, request, provider: str):
        state = request.GET.get("state")
        expected_state = request.session.pop(f"oauth_state_{provider}", None)
        if not expected_state or expected_state != state:
            return Response({"detail": "Некорректный state."}, status=status.HTTP_400_BAD_REQUEST)

        code = request.GET.get("code")
        if not code:
            return Response({"detail": "Не передан код авторизации."}, status=status.HTTP_400_BAD_REQUEST)

        redirect_uri = request.build_absolute_uri(
            reverse("oauth_callback", args=[provider])
        )
        try:
            profile = fetch_profile(provider, code, redirect_uri)
        except Exception as exc:
            capture_exception(exc, {"provider": provider})
            return Response(
                {
                    "detail": f"{provider.title()} временно недоступен. Используйте другой способ входа.",
                    "provider": provider,
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        user = self._resolve_user(request, profile)
        social_account, _ = SocialAccount.objects.update_or_create(
            provider=provider,
            external_id=profile["external_id"],
            defaults={
                "user": user,
                "email": profile.get("email"),
                "display_name": profile.get("display_name") or "",
                "extra_data": profile.get("raw") or {},
                "last_login_at": timezone.now(),
            },
        )
        social_account.save()

        next_url = request.session.get("oauth_next") or request.GET.get("next")
        expects_json = "application/json" in (request.headers.get("Accept") or "").lower()

        if user.mfa_enabled and user.mfa_method != User.MFAMethod.NONE:
            request.session["post_auth_redirect"] = next_url
            challenge = _require_mfa(request, user, reason="oauth")
            if expects_json:
                return Response(
                    {
                        **challenge,
                        "mfa_required": True,
                        "detail": "Для соц-входа включён второй фактор.",
                    },
                    status=status.HTTP_200_OK,
                )
            return redirect(reverse("accounts:mfa_verify"))

        response = _complete_login_response(
            request,
            user,
            payload={"detail": "Вход выполнен через социальную сеть.", "provider": provider},
            status_code=status.HTTP_200_OK,
        )
        request.session.pop("oauth_next", None)
        if next_url and not expects_json:
            return redirect(next_url)
        if next_url:
            response.data["next"] = next_url  # type: ignore[index]
        return response

    def _resolve_user(self, request: HttpRequest, profile: dict) -> User:
        if request.user.is_authenticated:
            return request.user

        existing = SocialAccount.objects.filter(
            provider=profile["provider"], external_id=profile["external_id"]
        ).select_related("user").first()
        if existing:
            return existing.user

        email = normalize_email(profile.get("email"))
        if email:
            email_hash = hash_email(email)
            user = User.objects.filter(email_hash=email_hash).first()
            if user:
                return user
            user = User(username=generate_username(profile.get("provider", "social")))
            user.email_plain = email
            user.save()
            return user

        user = User(username=generate_username(profile.get("provider", "social")))
        display_name = profile.get("display_name")
        if display_name:
            user.first_name = display_name.split(" ")[0]
        user.save()
        return user


class SocialAccountDetailView(APIView):
    """Unlink social accounts from profile."""

    permission_classes = [permissions.IsAuthenticated]

    def delete(self, request, pk: int):
        try:
            account = SocialAccount.objects.get(pk=pk, user=request.user)
        except SocialAccount.DoesNotExist:
            return Response(status=status.HTTP_404_NOT_FOUND)
        account.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 45
PATH: accounts\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
import django_cryptography.fields
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('email', models.EmailField(blank=True, max_length=254, verbose_name='email address')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('role', models.CharField(choices=[('driver', 'Водитель'), ('owner', 'Владелец парковки'), ('admin', 'Администратор')], default='driver', help_text='Определяет права доступа в системе.', max_length=16, verbose_name='Роль')),
                ('email_encrypted', django_cryptography.fields.encrypt(models.EmailField(blank=True, help_text='Опциональный email, хранится в зашифрованном виде.', max_length=254, null=True, verbose_name='Email (зашифрованный)'))),
                ('phone_encrypted', django_cryptography.fields.encrypt(models.CharField(blank=True, help_text='Опциональный телефон, хранится в зашифрованном виде.', max_length=32, null=True, verbose_name='Телефон (зашифрованный)'))),
                ('owner_request_pending', models.BooleanField(default=False, help_text='Пользователь подал заявку на роль владельца парковки.', verbose_name='Запрошено повышение до владельца')),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'Пользователь',
                'verbose_name_plural': 'Пользователи',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 46
PATH: accounts\migrations\0002_user_email_hash_user_phone_hash_logincode.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-23 15:00

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='user',
            name='email_hash',
            field=models.CharField(blank=True, db_index=True, help_text='Используется только для поиска и проверки уникальности email.', max_length=64, verbose_name='Хэш нормализованного email'),
        ),
        migrations.AddField(
            model_name='user',
            name='phone_hash',
            field=models.CharField(blank=True, db_index=True, help_text='Используется только для поиска и проверки уникальности телефона.', max_length=64, verbose_name='Хэш нормализованного телефона'),
        ),
        migrations.CreateModel(
            name='LoginCode',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('channel', models.CharField(choices=[('email', 'Email'), ('phone', 'Телефон')], max_length=16, verbose_name='Канал')),
                ('purpose', models.CharField(choices=[('register', 'Регистрация'), ('login', 'Вход'), ('reset_password', 'Сброс пароля')], max_length=32, verbose_name='Назначение')),
                ('code_hash', models.CharField(db_index=True, max_length=128, verbose_name='Хэш кода')),
                ('expires_at', models.DateTimeField(verbose_name='Истекает в')),
                ('is_used', models.BooleanField(default=False, verbose_name='Использован')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='login_codes', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Код подтверждения',
                'verbose_name_plural': 'Коды подтверждения',
                'indexes': [models.Index(fields=['user', 'purpose', 'is_used'], name='accounts_lo_user_id_024bc5_idx')],
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 47
PATH: accounts\migrations\0003_userlevel_userbadge_promoreward.py
LANG: python
===== CONTENT START =====
import uuid
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ('accounts', '0002_user_email_hash_user_phone_hash_logincode'),
    ]

    operations = [
        migrations.CreateModel(
            name='UserLevel',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=64)),
                ('threshold', models.PositiveIntegerField(default=0, help_text='Количество завершённых бронирований для уровня')),
                ('description', models.TextField(blank=True)),
            ],
            options={
                'verbose_name': 'Уровень пользователя',
                'verbose_name_plural': 'Уровни пользователей',
                'ordering': ('threshold',),
            },
        ),
        migrations.CreateModel(
            name='PromoReward',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('code', models.CharField(max_length=32, unique=True)),
                ('description', models.TextField(blank=True)),
                ('active', models.BooleanField(default=True)),
                ('usage_limit', models.PositiveIntegerField(default=1)),
            ],
            options={
                'verbose_name': 'Промо/бонус',
                'verbose_name_plural': 'Промо/бонусы',
            },
        ),
        migrations.CreateModel(
            name='UserBadge',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('title', models.CharField(max_length=128)),
                ('description', models.TextField(blank=True)),
                ('icon', models.CharField(blank=True, max_length=64)),
                ('level', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='badges', to='accounts.userlevel')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='badges', to='accounts.user', verbose_name='Пользователь')),
            ],
            options={
                'verbose_name': 'Бейдж',
                'verbose_name_plural': 'Бейджи',
                'ordering': ('-created_at',),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 48
PATH: accounts\migrations\0004_socialaccount.py
LANG: python
===== CONTENT START =====
# Generated for SocialAccount model

from django.conf import settings
from django.db import migrations, models
import django.utils.timezone


class Migration(migrations.Migration):

    dependencies = [
        ("accounts", "0003_userlevel_userbadge_promoreward"),
    ]

    operations = [
        migrations.CreateModel(
            name="SocialAccount",
            fields=[
                ("id", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                (
                    "provider",
                    models.CharField(
                        choices=[("vk", "VK"), ("yandex", "Yandex"), ("google", "Google")],
                        max_length=32,
                        verbose_name="Провайдер",
                    ),
                ),
                (
                    "external_id",
                    models.CharField(
                        help_text="Уникальный идентификатор пользователя в системе провайдера.",
                        max_length=255,
                        verbose_name="Внешний ID",
                    ),
                ),
                (
                    "email",
                    models.EmailField(
                        blank=True,
                        max_length=254,
                        null=True,
                        verbose_name="Email из профиля",
                    ),
                ),
                (
                    "display_name",
                    models.CharField(
                        blank=True,
                        max_length=255,
                        verbose_name="Имя в профиле",
                    ),
                ),
                (
                    "extra_data",
                    models.JSONField(
                        blank=True,
                        default=dict,
                        help_text="Небольшой JSON с частью профиля, не содержащей чувствительные данные.",
                        verbose_name="Сырой профиль",
                    ),
                ),
                (
                    "last_login_at",
                    models.DateTimeField(
                        default=django.utils.timezone.now,
                        verbose_name="Последний вход",
                    ),
                ),
                (
                    "created_at",
                    models.DateTimeField(
                        auto_now_add=True,
                        verbose_name="Создано",
                    ),
                ),
                (
                    "updated_at",
                    models.DateTimeField(
                        auto_now=True,
                        verbose_name="Обновлено",
                    ),
                ),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=models.deletion.CASCADE,
                        related_name="social_accounts",
                        to=settings.AUTH_USER_MODEL,
                        verbose_name="Пользователь",
                    ),
                ),
            ],
            options={
                "verbose_name": "Социальный аккаунт",
                "verbose_name_plural": "Социальные аккаунты",
                "unique_together": {("provider", "external_id")},
            },
        ),
        migrations.AddIndex(
            model_name="socialaccount",
            index=models.Index(fields=["provider", "external_id"], name="accounts_so_provide_3a0cdb_idx"),
        ),
        migrations.AddIndex(
            model_name="socialaccount",
            index=models.Index(fields=["user", "provider"], name="accounts_so_user_id_3f2c3e_idx"),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 49
PATH: accounts\migrations\0005_logincode_attempts_status.py
LANG: python
===== CONTENT START =====
# Generated to add attempts/status to LoginCode for OTP hardening
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("accounts", "0004_socialaccount"),
    ]

    operations = [
        migrations.AddField(
            model_name="logincode",
            name="attempts",
            field=models.PositiveSmallIntegerField(
                default=0, verbose_name="Попыток ввода"
            ),
        ),
        migrations.AddField(
            model_name="logincode",
            name="status",
            field=models.CharField(
                default="pending",
                help_text="pending/used/expired/blocked",
                max_length=16,
                verbose_name="Статус",
            ),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 50
PATH: accounts\migrations\0006_user_mfa_fields.py
LANG: python
===== CONTENT START =====
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("accounts", "0005_logincode_attempts_status"),
    ]

    operations = [
        migrations.AddField(
            model_name="user",
            name="last_password_change",
            field=models.DateTimeField(
                blank=True,
                help_text="Используется для инвалидирования сессий и JWT.",
                null=True,
                verbose_name="Последняя смена пароля",
            ),
        ),
        migrations.AddField(
            model_name="user",
            name="mfa_enabled",
            field=models.BooleanField(
                default=False,
                help_text="Требовать второй фактор при входе.",
                verbose_name="MFA включена",
            ),
        ),
        migrations.AddField(
            model_name="user",
            name="mfa_method",
            field=models.CharField(
                choices=[
                    ("none", "Без MFA"),
                    ("totp", "TOTP (приложение)"),
                    ("sms", "SMS"),
                    ("email", "Email"),
                ],
                default="none",
                max_length=16,
                verbose_name="Метод MFA",
            ),
        ),
        migrations.AddField(
            model_name="user",
            name="mfa_secret",
            field=models.CharField(
                blank=True,
                help_text="Используется только для TOTP-приложений.",
                max_length=64,
                null=True,
                verbose_name="Секрет TOTP",
            ),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 51
PATH: accounts\migrations\0007_user_last_mfa_change.py
LANG: python
===== CONTENT START =====
# Generated by ChatGPT on 2025-12-08
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("accounts", "0006_user_mfa_fields"),
    ]

    operations = [
        migrations.AddField(
            model_name="user",
            name="last_mfa_change",
            field=models.DateTimeField(
                blank=True,
                null=True,
                verbose_name="Последнее изменение MFA",
                help_text="Используется для инвалидирования сессий и токенов после изменения MFA.",
            ),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 52
PATH: accounts\migrations\0008_rename_accounts_so_provide_3a0cdb_idx_accounts_so_provide_98721f_idx_and_more.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-12-07 21:29

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('accounts', '0007_user_last_mfa_change'),
    ]

    operations = [
        migrations.RenameIndex(
            model_name='socialaccount',
            new_name='accounts_so_provide_98721f_idx',
            old_name='accounts_so_provide_3a0cdb_idx',
        ),
        migrations.RenameIndex(
            model_name='socialaccount',
            new_name='accounts_so_user_id_0a462a_idx',
            old_name='accounts_so_user_id_3f2c3e_idx',
        ),
        migrations.AlterField(
            model_name='logincode',
            name='purpose',
            field=models.CharField(choices=[('register', 'Регистрация'), ('login', 'Вход'), ('reset_password', 'Сброс пароля'), ('mfa', 'MFA подтверждение')], max_length=32, verbose_name='Назначение'),
        ),
        migrations.AlterField(
            model_name='socialaccount',
            name='id',
            field=models.BigAutoField(primary_key=True, serialize=False),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 53
PATH: accounts\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 54
PATH: accounts\tests\__init__.py
LANG: python
===== CONTENT START =====
# Package marker for accounts tests

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 55
PATH: accounts\tests\test_mfa.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.utils import timezone
from rest_framework.exceptions import AuthenticationFailed
from rest_framework_simplejwt.tokens import AccessToken

from accounts.authentication import JWTAuthentication
from accounts.models import User
from accounts.views import _otp_satisfies_mfa


class MFARulesTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="mfa_user", password="secret123")
        self.user.mfa_enabled = True
        self.user.mfa_method = User.MFAMethod.SMS
        self.user.phone_plain = "+70000000000"
        self.user.save()

    def test_sms_code_satisfies_mfa_when_method_matches(self):
        self.assertTrue(_otp_satisfies_mfa(self.user, "phone"))
        self.assertFalse(_otp_satisfies_mfa(self.user, "email"))

    def test_totp_always_requires_second_step(self):
        self.user.mfa_method = User.MFAMethod.TOTP
        self.user.save(update_fields=["mfa_method"])
        self.assertFalse(_otp_satisfies_mfa(self.user, "phone"))

    def test_jwt_invalidated_after_mfa_change(self):
        self.user.last_mfa_change = timezone.now()
        self.user.save(update_fields=["last_mfa_change"])
        token = AccessToken()
        token["user_id"] = str(self.user.pk)
        token["iat"] = int((timezone.now() - timezone.timedelta(minutes=5)).timestamp())
        with self.assertRaises(AuthenticationFailed):
            JWTAuthentication().get_user(token)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 56
PATH: ai\__init__.py
LANG: python
===== CONTENT START =====
default_app_config = "ai.apps.AiConfig"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 57
PATH: ai\admin.py
LANG: python
===== CONTENT START =====
from django.contrib import admin

from .models import ChatFeedback, ChatMessage, ChatSession, DeviceProfile, UiEvent


@admin.register(DeviceProfile)
class DeviceProfileAdmin(admin.ModelAdmin):
    list_display = ("device_id", "user", "layout_profile", "theme", "created_at")
    search_fields = ("device_id", "user__username")


@admin.register(UiEvent)
class UiEventAdmin(admin.ModelAdmin):
    list_display = ("event_type", "device_profile", "created_at")
    list_filter = ("event_type",)


@admin.register(ChatSession)
class ChatSessionAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "created_at", "last_activity_at")
    search_fields = ("id", "user__username")


@admin.register(ChatMessage)
class ChatMessageAdmin(admin.ModelAdmin):
    list_display = ("session", "role", "created_at")
    list_filter = ("role",)
    search_fields = ("text",)


@admin.register(ChatFeedback)
class ChatFeedbackAdmin(admin.ModelAdmin):
    list_display = ("message", "rating", "created_at")
    list_filter = ("rating",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 58
PATH: ai\apps.py
LANG: python
===== CONTENT START =====
from django.apps import AppConfig


class AiConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    # ВАЖНО: здесь должен быть реальный путь до пакета приложения
    # Папка называется "ai", лежит в корне проекта -> name = "ai"
    name = "ai"
    verbose_name = "AI и рекомендации ParkShare"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 59
PATH: ai\features.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import pandas as pd

from parking.models import Booking


def bookings_dataframe() -> pd.DataFrame:
    """
    Собирает историю бронирований в DataFrame для обучения/аналитики.
    """
    qs = Booking.objects.filter(
        status__in=[
            Booking.Status.CONFIRMED,
            Booking.Status.ACTIVE,
            Booking.Status.COMPLETED,
        ]
    ).select_related("spot", "spot__lot")

    rows = []
    for b in qs:
        rows.append(
            {
                "booking_id": str(b.id),
                "spot_id": str(b.spot_id),
                "lot_id": str(b.spot.lot_id),
                "city": b.spot.lot.city,
                "start": b.start_at,
                "end": b.end_at,
                "duration_hours": (b.end_at - b.start_at).total_seconds() / 3600.0,
                "price": float(b.total_price),
                "dow": b.start_at.weekday(),
                "hour": b.start_at.hour,
            }
        )

    if not rows:
        return pd.DataFrame()

    df = pd.DataFrame(rows)
    df["is_weekend"] = df["dow"] >= 5
    return df

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 60
PATH: ai\models.py
LANG: python
===== CONTENT START =====
# ai/models.py

from __future__ import annotations

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel, TimeStampedUUIDModel


class DeviceProfile(TimeStampedUUIDModel):
    """
    Профиль устройства/клиента для адаптивного UI.

    Связан либо с пользователем, либо с анонимным device_id (из cookies/LS).
    """

    class LayoutProfile(models.TextChoices):
        COMPACT = "compact", _("Компактный")
        COMFORTABLE = "comfortable", _("Комфортный")

    class Theme(models.TextChoices):
        LIGHT = "light", _("Светлая")
        DARK = "dark", _("Тёмная")
        SYSTEM = "system", _("Системная")

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="device_profiles",
    )
    device_id = models.CharField(
        _("ID устройства"),
        max_length=64,
        db_index=True,
    )

    viewport_width = models.IntegerField(_("Ширина viewport"), null=True, blank=True)
    viewport_height = models.IntegerField(_("Высота viewport"), null=True, blank=True)
    pixel_ratio = models.FloatField(_("Pixel ratio"), null=True, blank=True)
    user_agent = models.TextField(_("User‑Agent"), blank=True)

    layout_profile = models.CharField(
        _("Профиль компоновки"),
        max_length=32,
        choices=LayoutProfile.choices,
        default=LayoutProfile.COMPACT,
    )
    theme = models.CharField(
        _("Тема"),
        max_length=16,
        choices=Theme.choices,
        default=Theme.SYSTEM,
    )

    class Meta:
        verbose_name = _("Профиль устройства")
        verbose_name_plural = _("Профили устройств")
        unique_together = ("device_id", "user")

    def __str__(self) -> str:
        return f"DeviceProfile({self.device_id}, {self.layout_profile})"


class UiEvent(TimeStampedUUIDModel):
    """
    Сырые события UI/адаптивности (scroll, resize, layout_probe и т.п.).
    """

    device_profile = models.ForeignKey(
        DeviceProfile,
        on_delete=models.CASCADE,
        related_name="events",
    )
    event_type = models.CharField(_("Тип события"), max_length=64)
    payload = models.JSONField(_("Payload"), null=True, blank=True)

    class Meta:
        verbose_name = _("UI‑событие")
        verbose_name_plural = _("UI‑события")

    def __str__(self) -> str:
        return f"UiEvent({self.event_type})"


class ChatSession(TimeStampedUUIDModel):
    """Сессия чата (cookie ps_chat_sid)."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="chat_sessions",
    )
    client_info = models.JSONField("Данные клиента", null=True, blank=True)
    last_activity_at = models.DateTimeField("Последняя активность", auto_now=True)

    class Meta:
        verbose_name = "Сессия чата"
        verbose_name_plural = "Сессии чата"

    def __str__(self) -> str:
        return f"ChatSession({self.id})"


class ChatMessage(TimeStampedModel):
    """Сообщения в рамках сессии."""

    class Role(models.TextChoices):
        USER = "user", "User"
        ASSISTANT = "assistant", "Assistant"

    session = models.ForeignKey(
        ChatSession,
        on_delete=models.CASCADE,
        related_name="messages",
    )
    role = models.CharField("Роль", max_length=16, choices=Role.choices)
    text = models.TextField("Текст")
    meta = models.JSONField("Метаданные", null=True, blank=True)

    class Meta:
        verbose_name = "Сообщение чата"
        verbose_name_plural = "Сообщения чата"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"[{self.role}] {self.text[:30]}"


class ChatFeedback(TimeStampedModel):
    """Оценки ответов ассистента."""

    message = models.ForeignKey(
        ChatMessage,
        on_delete=models.CASCADE,
        related_name="feedback",
    )
    rating = models.IntegerField("Оценка", default=0)

    class Meta:
        verbose_name = "Фидбек чата"
        verbose_name_plural = "Фидбек чата"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Feedback({self.rating})"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 61
PATH: ai\orchestrator.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from decimal import Decimal
from typing import Any, Dict

from django.utils import timezone

from ai.pricing import recommend_price_for_spot


class PricingDecision:
    def __init__(self, payload: Dict[str, Any]):
        self.payload = payload

    @property
    def price(self) -> Decimal:
        return Decimal(str(self.payload.get("recommended_price", 0)))

    def to_dict(self) -> Dict[str, Any]:
        return self.payload


class AvailabilityDecision:
    def __init__(self, payload: Dict[str, Any]):
        self.payload = payload

    def to_dict(self) -> Dict[str, Any]:
        return self.payload


def apply_ai_pricing(booking) -> PricingDecision | None:
    """Подключает ML/GBM модель динамического ценообразования.

    Для MVP используем существующую recommend_price_for_spot, но сохраняем
    полную структуру для будущих CatBoost/GBM моделей (ParkMate).
    """

    suggestion = recommend_price_for_spot(booking.spot)
    if not suggestion:
        return None

    hours = max(Decimal("1"), Decimal((booking.end_at - booking.start_at).total_seconds()) / Decimal(3600))
    base_total = Decimal(str(booking.total_price))
    ai_hour_price = Decimal(str(suggestion["recommended_price"]))
    ai_total = (ai_hour_price * hours).quantize(Decimal("0.01"))

    booking.total_price = ai_total
    booking.dynamic_pricing_applied = True
    booking.ai_snapshot = {
        "pricing": suggestion,
        "calculated_at": timezone.now().isoformat(),
    }
    return PricingDecision({
        **suggestion,
        "applied_total": str(ai_total),
        "hours": str(hours),
    })


def attach_availability_forecast(booking, forecast: Dict[str, Any] | None = None) -> None:
    if forecast:
        booking.ai_snapshot = {
            **(booking.ai_snapshot or {}),
            "availability": forecast,
        }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 62
PATH: ai\pricing.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, Optional

import numpy as np
from django.conf import settings
from django.utils import timezone

try:  # optional heavy deps (sklearn/joblib) guarded for minimal envs
    import joblib
    from sklearn.ensemble import RandomForestRegressor
except Exception:  # pragma: no cover - fallback when deps missing
    joblib = None
    RandomForestRegressor = None

from core.utils import round_price
from parking.models import ParkingSpot
from .features import bookings_dataframe

MODEL_PATH = Path(getattr(settings, "BASE_DIR", ".")) / "ai_models" / "pricing_model.pkl"


def train_pricing_model(df=None) -> Optional[RandomForestRegressor]:
    """
    Обучает простую RandomForest-модель для оценки цены за час.
    """
    if RandomForestRegressor is None or joblib is None:
        return None
    if df is None:
        df = bookings_dataframe()
    if df.empty or len(df) < 20:
        return None

    df = df.copy()
    df["price_per_hour"] = df["price"] / df["duration_hours"].clip(lower=0.5)
    X = df[["hour", "dow", "is_weekend"]].values
    y = df["price_per_hour"].values

    model = RandomForestRegressor(
        n_estimators=50,
        random_state=42,
        n_jobs=-1,
    )
    model.fit(X, y)

    MODEL_PATH.parent.mkdir(parents=True, exist_ok=True)
    joblib.dump(model, MODEL_PATH)
    return model


def load_pricing_model() -> Optional[RandomForestRegressor]:
    if RandomForestRegressor is None or joblib is None:
        return None
    if not MODEL_PATH.exists():
        return None
    try:
        model: RandomForestRegressor = joblib.load(MODEL_PATH)
        return model
    except Exception:
        return None


def recommend_price_for_spot(spot: ParkingSpot) -> Optional[Dict[str, Any]]:
    """
    Возвращает диапазон рекомендованных цен для владельца места.
    Учитывает:
    - базовую цену;
    - загрузку места за 7 дней (occupancy_7d);
    - (по возможности) предсказание ML‑модели.
    """
    base_price = float(spot.hourly_price or 0.0)
    if base_price <= 0:
        return None

    now = timezone.now()
    features = np.array([[now.hour, now.weekday(), 1 if now.weekday() >= 5 else 0]])

    model = load_pricing_model()
    predicted = None
    if model is not None:
        try:
            predicted_value = float(model.predict(features)[0])
            if predicted_value > 0:
                predicted = predicted_value
        except Exception:
            predicted = None

    occupancy = float(getattr(spot, "occupancy_7d", 0.0) or 0.0)
    factor = 1.0
    reason_parts = []

    if occupancy > 0.8:
        factor += 0.15
        reason_parts.append("место часто занято (высокая загрузка)")
    elif occupancy < 0.3:
        factor -= 0.1
        reason_parts.append("место простаивает (низкая загрузка)")

    if predicted is not None:
        ai_price = round_price(predicted, step=5.0)
        reason_parts.append("ML‑модель учитывает исторические цены по району")
    else:
        ai_price = base_price

    recommended = round_price(ai_price * factor, step=5.0)
    min_price = round_price(recommended * 0.9, step=5.0)
    max_price = round_price(recommended * 1.1, step=5.0)

    if not reason_parts:
        reason_parts.append("используется базовая ставка и средняя загрузка")

    reason = "На основе: " + "; ".join(reason_parts) + "."
    return {
        "base_price": base_price,
        "recommended_price": recommended,
        "min_price": min_price,
        "max_price": max_price,
        "reason": reason,
    }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 63
PATH: ai\serializers.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 64
PATH: ai\tasks.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from datetime import timedelta

from celery import shared_task
from django.utils import timezone

from parking.models import Booking, ParkingLot, ParkingSpot
from .features import bookings_dataframe
from .pricing import train_pricing_model


@shared_task
def update_models() -> None:
    """
    Периодически обучает модель цен и обновляет метрики загруженности.

    Делает три вещи:
    1) обучает/переобучает ML‑модель ценообразования;
    2) считает occupancy_7d для активных мест;
    3) считает stress_index для парковок (средняя загрузка мест).
    """
    df = bookings_dataframe()
    train_pricing_model(df)

    now = timezone.now()
    window_start = now - timedelta(days=7)

    # 1–2. Обновляем occupancy_7d для мест
    active_spots = ParkingSpot.objects.filter(
        status=ParkingSpot.SpotStatus.ACTIVE,
        lot__is_active=True,
        lot__is_approved=True,
    ).select_related("lot")

    total_period_hours = 24 * 7

    for spot in active_spots:
        qs = Booking.objects.filter(
            spot=spot,
            start_at__lt=now,
            end_at__gt=window_start,
            status__in=[
                Booking.Status.CONFIRMED,
                Booking.Status.ACTIVE,
                Booking.Status.COMPLETED,
            ],
        )

        booked_hours = 0.0
        for b in qs:
            start = max(b.start_at, window_start)
            end = min(b.end_at, now)
            delta_h = max((end - start).total_seconds() / 3600.0, 0.0)
            booked_hours += delta_h

        occupancy = booked_hours / float(total_period_hours)
        spot.occupancy_7d = max(0.0, min(occupancy, 1.0))
        spot.save(update_fields=["occupancy_7d"])

    # 3. Индекс загруженности по объектам парковки
    lots = ParkingLot.objects.filter(is_active=True, is_approved=True)
    for lot in lots:
        spots = lot.spots.all()
        if not spots:
            lot.stress_index = 0.0
            lot.save(update_fields=["stress_index"])
            continue
        values = [max(0.0, min(s.occupancy_7d, 1.0)) for s in spots]
        lot.stress_index = sum(values) / len(values)
        lot.save(update_fields=["stress_index"])

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 65
PATH: ai\tools.py
LANG: python
===== CONTENT START =====
"""Tool layer for the assistant to operate on parking/search/booking primitives."""
from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import timedelta
from typing import Any, Dict, Iterable, List, Optional

from django.contrib.auth import get_user_model
from django.db import transaction
from django.shortcuts import get_object_or_404
from django.utils import timezone
from django.utils.dateparse import parse_datetime

from core.utils import haversine_distance_km
from parking.models import Booking, FavoriteParkingSpot, ParkingSpot
from ai.models import DeviceProfile, UiEvent

User = get_user_model()
logger = logging.getLogger(__name__)


@dataclass
class ToolError(Exception):
    code: str
    message: str
    details: Optional[dict] = None

    def as_dict(self) -> dict[str, Any]:
        return {"code": self.code, "message": self.message, "details": self.details or {}}


def _serialize_spot(spot: ParkingSpot, distance_km: float | None = None) -> dict[str, Any]:
    return {
        "id": str(spot.id),
        "name": spot.name,
        "lot": {
            "id": str(spot.lot_id),
            "name": spot.lot.name,
            "city": spot.lot.city,
            "address": spot.lot.address,
            "stress_index": float(spot.lot.stress_index or 0.0),
        },
        "coords": {
            "lat": spot.lot.latitude,
            "lng": spot.lot.longitude,
        },
        "status": spot.status,
        "price": {
            "hourly": float(spot.hourly_price or 0),
            "nightly": float(spot.nightly_price or 0),
            "daily": float(spot.daily_price or 0),
        },
        "features": {
            "ev": spot.has_ev_charging,
            "covered": spot.is_covered,
            "is_24_7": spot.is_24_7,
            "allow_dynamic_pricing": spot.allow_dynamic_pricing,
        },
        "distance_km": distance_km,
        "occupancy_7d": float(spot.occupancy_7d or 0.0),
    }


def search_parking(params: dict[str, Any], user: Optional[User] = None) -> list[dict[str, Any]]:
    qs = (
        ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )
        .select_related("lot")
        .order_by("lot__stress_index", "hourly_price")
    )

    lat = params.get("lat")
    lng = params.get("lng")
    radius_km = params.get("radius_km") or 5
    budget = params.get("max_price") or params.get("budget")

    if params.get("has_ev") or params.get("ev"):
        qs = qs.filter(has_ev_charging=True)
    if params.get("covered"):
        qs = qs.filter(is_covered=True)
    if params.get("is_24_7"):
        qs = qs.filter(is_24_7=True)
    if budget:
        try:
            qs = qs.filter(hourly_price__lte=float(budget))
        except (TypeError, ValueError):
            pass

    results: list[dict[str, Any]] = []
    for spot in qs[:150]:
        distance = None
        if lat is not None and lng is not None and spot.lot.latitude and spot.lot.longitude:
            distance = haversine_distance_km(lat, lng, spot.lot.latitude, spot.lot.longitude)
            if distance is not None and distance > float(radius_km):
                continue
        results.append(_serialize_spot(spot, distance))
    return results[:50]


def get_availability(spot_id: str, time_range: dict[str, Any]) -> dict[str, Any]:
    spot = get_object_or_404(
        ParkingSpot,
        pk=spot_id,
        status=ParkingSpot.SpotStatus.ACTIVE,
        lot__is_active=True,
        lot__is_approved=True,
    )
    start_iso = time_range.get("start_at")
    end_iso = time_range.get("end_at")
    start_at = parse_datetime(start_iso) if start_iso else timezone.now()
    end_at = parse_datetime(end_iso) if end_iso else start_at + timedelta(hours=1)
    if start_at and timezone.is_naive(start_at):
        start_at = timezone.make_aware(start_at)
    if end_at and timezone.is_naive(end_at):
        end_at = timezone.make_aware(end_at)

    is_free = Booking.is_spot_available(spot, start_at, end_at)
    return {
        "spot": _serialize_spot(spot),
        "available": is_free,
        "start_at": start_at,
        "end_at": end_at,
        "occupancy_7d": float(spot.occupancy_7d or 0.0),
        "stress_index": float(spot.lot.stress_index or 0.0),
    }


def create_booking(
    user: User,
    spot_id: str,
    time_range: dict[str, Any],
    vehicle_id: Optional[str] = None,
    payment_method: Optional[str] = None,
    flags: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
    if not user or not user.is_authenticated:
        raise ToolError("auth_required", "Нужно войти, чтобы бронировать.")

    spot = get_object_or_404(
        ParkingSpot,
        pk=spot_id,
        status=ParkingSpot.SpotStatus.ACTIVE,
        lot__is_active=True,
        lot__is_approved=True,
    )

    start_iso = time_range.get("start_at")
    end_iso = time_range.get("end_at")
    duration_hours = time_range.get("hours") or 1
    booking_type = time_range.get("booking_type") or Booking.BookingType.HOURLY

    start_at = parse_datetime(start_iso) if start_iso else timezone.now()
    if start_at and timezone.is_naive(start_at):
        start_at = timezone.make_aware(start_at)
    if end_iso:
        end_at = parse_datetime(end_iso)
    else:
        end_at = start_at + timedelta(hours=duration_hours)
    if end_at and timezone.is_naive(end_at):
        end_at = timezone.make_aware(end_at)

    if not Booking.is_spot_available(spot, start_at, end_at):
        raise ToolError("not_available", "Место занято в выбранный промежуток.")

    with transaction.atomic():
        booking = Booking.objects.create(
            user=user,
            spot=spot,
            vehicle_id=vehicle_id,
            booking_type=booking_type,
            start_at=start_at,
            end_at=end_at,
            status=Booking.Status.PENDING,
            total_price=0,
        )
        booking.calculate_price()
        if flags and flags.get("business_trip"):
            booking.ai_snapshot = {"business_trip": True}
        booking.status = Booking.Status.CONFIRMED if payment_method else Booking.Status.PENDING
        booking.save(update_fields=["total_price", "status", "ai_snapshot"])

    return {
        "booking_id": booking.id,
        "status": booking.status,
        "total_price": float(booking.total_price),
        "currency": booking.currency,
        "start_at": booking.start_at,
        "end_at": booking.end_at,
        "spot": _serialize_spot(spot),
    }


def extend_booking(user: User, booking_id: str, time_delta_minutes: int) -> dict[str, Any]:
    if not user or not user.is_authenticated:
        raise ToolError("auth_required", "Нужно войти, чтобы продлить бронь.")
    booking = get_object_or_404(Booking, pk=booking_id, user=user)
    if booking.has_ended:
        raise ToolError("already_finished", "Эту бронь уже нельзя продлить.")

    new_end = booking.end_at + timedelta(minutes=time_delta_minutes or 30)
    if not Booking.is_spot_available(booking.spot, booking.start_at, new_end, exclude_booking_id=booking.id):
        raise ToolError("not_available", "Перекрывается с другой бронью.")
    booking.end_at = new_end
    booking.calculate_price()
    booking.status = Booking.Status.CONFIRMED
    booking.save(update_fields=["end_at", "total_price", "status"])
    return {
        "booking_id": booking.id,
        "status": booking.status,
        "total_price": float(booking.total_price),
        "end_at": booking.end_at,
    }


def cancel_booking(user: User, booking_id: str) -> dict[str, Any]:
    if not user or not user.is_authenticated:
        raise ToolError("auth_required", "Нужно войти, чтобы отменять бронь.")
    booking = get_object_or_404(Booking, pk=booking_id, user=user)
    if booking.has_started:
        raise ToolError("already_started", "Нельзя отменить уже начавшуюся бронь.")
    booking.status = Booking.Status.CANCELLED
    booking.save(update_fields=["status"])
    return {"booking_id": booking.id, "status": booking.status}


def toggle_favorite(user: User, spot_id: str) -> dict[str, Any]:
    if not user or not user.is_authenticated:
        raise ToolError("auth_required", "Войдите, чтобы сохранять избранное.")
    spot = get_object_or_404(ParkingSpot, pk=spot_id)
    fav, created = FavoriteParkingSpot.objects.get_or_create(user=user, spot=spot)
    if not created:
        fav.delete()
    return {"spot_id": str(spot.id), "favorite": created}


# -------- Preferences helpers (lightweight, stored in UiEvent) --------


def detect_preferences(text: str) -> dict[str, Any]:
    lowered = (text or "").lower()
    prefs: dict[str, Any] = {}
    if "крыт" in lowered or "подзем" in lowered:
        prefs["prefers_covered"] = True
    if "ев" in lowered or "заряд" in lowered or "электро" in lowered:
        prefs["prefers_ev"] = True
    if "ноч" in lowered:
        prefs["prefers_night"] = True
    if "деш" in lowered or "дёш" in lowered or "бюдж" in lowered:
        prefs["budget_tier"] = "budget"
    if "преми" in lowered or "дорог" in lowered:
        prefs["budget_tier"] = "premium"
    import re

    price_match = re.search(r"(\d{2,5})\s*(?:₽|р|руб)", lowered)
    if price_match:
        try:
            prefs["budget_max"] = int(price_match.group(1))
        except ValueError:
            pass
    return prefs


def persist_preferences(profile: DeviceProfile, prefs: dict[str, Any]) -> None:
    if not prefs:
        return
    try:
        UiEvent.objects.create(device_profile=profile, event_type="preferences", payload=prefs)
    except Exception:  # pragma: no cover - безопасный фолбэк
        logger.warning("Failed to persist preferences", exc_info=True)


def load_preferences(profile: DeviceProfile) -> dict[str, Any]:
    try:
        event = UiEvent.objects.filter(device_profile=profile, event_type="preferences").order_by("-created_at").first()
        return event.payload or {} if event else {}
    except Exception:  # pragma: no cover
        logger.warning("Failed to load preferences", exc_info=True)
        return {}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 66
PATH: ai\views.py
LANG: python
===== CONTENT START =====
# backend/ai/views.py

from __future__ import annotations

import logging
import uuid
from typing import Any

from asgiref.sync import async_to_sync
from django.http import StreamingHttpResponse
from django.utils import timezone
from rest_framework import status
from rest_framework.permissions import AllowAny, IsAuthenticatedOrReadOnly
from rest_framework.throttling import UserRateThrottle, AnonRateThrottle
from rest_framework.response import Response
from rest_framework.views import APIView

from parking.models import Booking, ParkingLot, ParkingSpot
from ai.pricing import recommend_price_for_spot
from ai.models import DeviceProfile, UiEvent
from core.metrics import record_assistant_tool
from services.llm import check_llm_health
from ai.chat.parking_assistant import generate_chat_reply
from ai import tools


def api_error(code: str, message: str, status_code=status.HTTP_400_BAD_REQUEST, details=None):
    return Response({"code": code, "message": message, "details": details or {}}, status=status_code)

logger = logging.getLogger(__name__)



def _active_sessions_payload(user) -> tuple[list[dict], list[dict]]:
    """
    Собирает активные сессии бронирования и предупреждения об окончании.
    """
    if not user or not user.is_authenticated:
        return [], []

    sessions: list[dict] = []
    alerts: list[dict] = []
    now = timezone.now()
    qs = (
        Booking.objects.filter(
            user=user,
            status__in=[Booking.Status.ACTIVE, Booking.Status.CONFIRMED],
        )
        .select_related("spot", "spot__lot")
        .order_by("end_at")
    )
    for b in qs:
        remaining = max(0, int((b.end_at - now).total_seconds()))
        sessions.append(
            {
                "id": str(b.id),
                "spot_id": str(b.spot_id),
                "spot_name": b.spot.name,
                "lot_name": b.spot.lot.name,
                "end_at": b.end_at,
                "status": b.status,
                "remaining_seconds": remaining,
                "is_paid": b.is_paid,
            }
        )
        if remaining <= 900:
            alerts.append(
                {
                    "type": "booking_expiring",
                    "booking_id": str(b.id),
                    "spot": b.spot.name,
                    "minutes_left": max(1, remaining // 60),
                }
            )
    return sessions, alerts


class RecommendationsAPIView(APIView):
    """
    Реальные AI-рекомендации по парковкам.

    Пример:
    GET /api/ai/recommendations/?city=Москва&limit=10
    """

    def get(self, request, *args: Any, **kwargs: Any) -> Response:
        city = request.query_params.get("city")
        limit = int(request.query_params.get("limit", 10))

        qs = ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        ).select_related("lot")

        if city:
            qs = qs.filter(lot__city__iexact=city)

        # Сначала берём самые "менее загруженные" и дешёвые места
        qs = qs.order_by("lot__stress_index", "hourly_price")[: limit * 2]

        recommendations: list[dict[str, Any]] = []
        now = timezone.now()

        for spot in qs[:limit]:
            try:
                pricing = recommend_price_for_spot(spot)
            except Exception:
                pricing = None

            rec: dict[str, Any] = {
                "spot_id": str(spot.id),
                "lot_id": str(spot.lot_id),
                "lot_name": spot.lot.name,
                "city": spot.lot.city,
                "address": spot.lot.address,
                "vehicle_type": spot.get_vehicle_type_display(),
                "hourly_price": float(spot.hourly_price or 0),
                "occupancy_7d": float(spot.occupancy_7d or 0.0),
                "stress_index": float(spot.lot.stress_index or 0.0),
                "is_covered": spot.is_covered,
                "has_ev_charging": spot.has_ev_charging,
                "is_24_7": spot.is_24_7,
                "now": now,
            }

            if pricing:
                rec.update(
                    {
                        "ai_recommended_hourly_price": float(
                            pricing.get("recommended_price", 0.0)
                        ),
                        "ai_base_price": float(pricing.get("base_price", 0.0)),
                        "ai_min_price": float(pricing.get("min_price", 0.0)),
                        "ai_max_price": float(pricing.get("max_price", 0.0)),
                        "ai_reason": pricing.get("reason", ""),
                        "ai_discount_percent": float(
                            pricing.get("discount_percent") or 0.0
                        ),
                        "ai_is_discount": bool(pricing.get("is_discount") or False),
                    }
                )

            recommendations.append(rec)

        return Response(
            {
                "count": len(recommendations),
                "results": recommendations,
            },
            status=status.HTTP_200_OK,
        )


class StressIndexAPIView(APIView):
    """
    Реальный индекс загруженности по городам / парковкам.

    Пример:
    GET /api/ai/stress-index/          # общий срез
    GET /api/ai/stress-index/?city=СПб
    """

    def get(self, request, *args: Any, **kwargs: Any) -> Response:
        city = request.query_params.get("city")

        lots_qs = ParkingLot.objects.filter(is_active=True, is_approved=True)
        if city:
            lots_qs = lots_qs.filter(city__iexact=city)

        lots = list(
            lots_qs.values(
                "id",
                "name",
                "city",
                "address",
                "stress_index",
            )
        )

        if not lots:
            return Response(
                {
                    "stress_index": 0.0,
                    "lots": [],
                    "details": "Нет активных парковок для выбранного фильтра",
                },
                status=status.HTTP_200_OK,
            )

        values = [float(l["stress_index"] or 0.0) for l in lots]
        avg = sum(values) / len(values)
        max_val = max(values)
        min_val = min(values)

        return Response(
            {
                "stress_index": round(avg, 3),
                "min": round(min_val, 3),
                "max": round(max_val, 3),
                "lots": lots,
            },
            status=status.HTTP_200_OK,
        )


class DepartureAssistantAPIView(APIView):
    """
    Простейший помощник по времени выезда (пока без внешних API).

    Принимает:
    POST /api/ai/departure-assistant/
    {
      "desired_arrival_iso": "2025-11-22T19:00:00+03:00",
      "parking_buffer_minutes": 10,
      "traffic_buffer_minutes": 20
    }
    """

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        from datetime import timedelta
        from django.utils.dateparse import parse_datetime

        desired_arrival_iso = request.data.get("desired_arrival_iso")
        parking_buffer = int(request.data.get("parking_buffer_minutes", 10))
        traffic_buffer = int(request.data.get("traffic_buffer_minutes", 20))

        if not desired_arrival_iso:
            return Response(
                {
                    "detail": "Нужен параметр desired_arrival_iso в ISO-формате",
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        desired_arrival = parse_datetime(desired_arrival_iso)
        if desired_arrival is None:
            return Response(
                {
                    "detail": "Не удалось распарсить desired_arrival_iso",
                },
                status=status.HTTP_400_BAD_REQUEST,
            )

        total_buffer = timedelta(
            minutes=parking_buffer + traffic_buffer,
        )
        suggested_departure = desired_arrival - total_buffer

        return Response(
            {
                "suggested_departure_time": suggested_departure,
                "desired_arrival_time": desired_arrival,
                "parking_buffer_minutes": parking_buffer,
                "traffic_buffer_minutes": traffic_buffer,
                "message": "Пока без пробок/погоды, но уже считает буферы времени.",
            },
            status=status.HTTP_200_OK,
        )


class LLMServiceHealthAPIView(APIView):
    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        try:
            health = async_to_sync(check_llm_health)()
        except Exception as exc:  # pragma: no cover - сеть/IO
            logger.warning("LLM health check failed", exc_info=exc)
            return Response(
                {"ok": False, "detail": str(exc)},
                status=status.HTTP_503_SERVICE_UNAVAILABLE,
            )
        return Response(health, status=status.HTTP_200_OK if health.get("ok") else status.HTTP_503_SERVICE_UNAVAILABLE)


class ChatStreamAPIView(APIView):
    """
    Минимальный чат‑эндпоинт для AI concierge на Django-страницах.
    Принимает список сообщений в формате [{role, content}] и возвращает потоковый текстовый ответ.
    """

    permission_classes = [AllowAny]
    throttle_classes = [UserRateThrottle, AnonRateThrottle]

    def post(self, request, *args, **kwargs):
        data = request.data or {}
        messages = data.get("messages") or []
        if not isinstance(messages, list) or not messages:
            return api_error("bad_request", "messages is required")

        prefer_structured = bool(data.get("structured", True))
        stream_text = bool(data.get("stream"))

        last = messages[-1] if isinstance(messages[-1], dict) else {}
        user_text = (last.get("content") or "").strip()
        if len(user_text) > 5000:
            return api_error("input_too_long", "Запрос слишком длинный", status.HTTP_400_BAD_REQUEST)
        history = [m for m in messages[:-1] if isinstance(m, dict)]
        reply_text = "Сервис временно недоступен. Попробуйте позже."

        # device profile for preferences memory
        device_id = request.COOKIES.get("ps_device_id") or f"ps_{uuid.uuid4().hex}"
        profile, _ = DeviceProfile.objects.get_or_create(
            device_id=device_id,
            user=request.user if request.user.is_authenticated else None,
            defaults={"layout_profile": DeviceProfile.LayoutProfile.COMPACT},
        )

        detected_prefs = tools.detect_preferences(user_text)
        if detected_prefs:
            tools.persist_preferences(profile, detected_prefs)
        stored_prefs = tools.load_preferences(profile)

        try:
            reply_payload = generate_chat_reply(
                user_text,
                history,
                request.user if request.user.is_authenticated else None,
                preferences=stored_prefs,
            )
            reply_text = (reply_payload.get("reply") or reply_text).strip()
        except Exception as exc:  # pragma: no cover - внешние сервисы
            logger.warning("Chat reply failed", exc_info=exc)
            reply_payload = {"reply": reply_text, "suggestions": []}

        if stream_text and not prefer_structured:
            response = StreamingHttpResponse(
                (token + " " for token in reply_text.split()),
                content_type="text/plain; charset=utf-8",
            )
            response.set_cookie("ps_device_id", device_id, max_age=60 * 60 * 24 * 365)
            return response

        suggestions = reply_payload.get("suggestions") or []
        sessions, alerts = _active_sessions_payload(request.user)
        actions = []
        for item in suggestions:
            actions.append(
                {
                    "type": "focus_map",
                    "spot_id": item.get("spot_id"),
                    "coords": item.get("coords"),
                    "title": item.get("title"),
                    "price": item.get("price"),
                }
            )
            actions.append(
                {
                    "type": "book",
                    "spot_id": item.get("spot_id"),
                    "title": item.get("title"),
                }
            )
            actions.append(
                {
                    "type": "booking_start",
                    "spot_id": item.get("spot_id"),
                    "title": item.get("title"),
                    "duration_minutes": 60,
                }
            )

        for session in sessions:
            actions.append(
                {
                    "type": "booking_extend",
                    "booking_id": session["id"],
                    "extend_minutes": 30,
                }
            )
            actions.append(
                {
                    "type": "booking_stop",
                    "booking_id": session["id"],
                }
            )

        if actions:
            record_assistant_tool("booking_cta")

        payload = {
            "reply": reply_text,
            "suggestions": suggestions,
            "actions": actions,
            "preferences": stored_prefs,
            "sessions": sessions,
            "alerts": alerts,
        }
        response = Response(payload, status=status.HTTP_200_OK)
        response.set_cookie("ps_device_id", device_id, max_age=60 * 60 * 24 * 365)
        return response


# ===== ParkMate AI — конфиг и предсказания (price/availability) =====


class ParkMateConfigAPIView(APIView):
    """
    AI‑помощник адаптивности:
    - принимает телеметрию клиента (viewport, pixelRatio, platform);
    - создаёт/обновляет DeviceProfile;
    - записывает UiEvent;
    - возвращает layout_profile / design_mode / theme.
    """

    permission_classes = [AllowAny]

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        data = request.data or {}
        client = data.get("client") or {}
        action = data.get("action") or "adaptive-profile"

        width = int(client.get("width") or 0)
        height = int(client.get("height") or 0)
        pixel_ratio = float(client.get("pixelRatio") or client.get("pixel_ratio") or 1.0)
        platform = (client.get("platform") or "RU")[:8]
        device_id = (request.COOKIES.get("ps_device_id") or client.get("deviceId") or "anonymous")[:64]
        user_agent = request.META.get("HTTP_USER_AGENT", "")[:1024]

        # Эвристика layout‑профиля
        if width < 640:
            layout = DeviceProfile.LayoutProfile.COMPACT
        elif width < 1024:
            layout = DeviceProfile.LayoutProfile.COMFORTABLE
        else:
            layout = DeviceProfile.LayoutProfile.COMFORTABLE

        design_mode = "pwa" if width < 1024 else "desktop"

        user = request.user if request.user.is_authenticated else None
        profile, _ = DeviceProfile.objects.get_or_create(
            device_id=device_id,
            user=user,
            defaults={
                "viewport_width": width,
                "viewport_height": height,
                "pixel_ratio": pixel_ratio,
                "user_agent": user_agent,
                "layout_profile": layout,
            },
        )

        # Обновляем основные параметры
        profile.viewport_width = width
        profile.viewport_height = height
        profile.pixel_ratio = pixel_ratio
        profile.layout_profile = layout
        profile.save(update_fields=["viewport_width", "viewport_height", "pixel_ratio", "layout_profile", "updated_at"])

        UiEvent.objects.create(
            device_profile=profile,
            event_type=action,
            payload={
                "width": width,
                "height": height,
                "pixel_ratio": pixel_ratio,
                "platform": platform,
            },
        )

        return Response(
            {
                "layout_profile": layout,
                "design_mode": design_mode,
                "theme": profile.theme,
            }
        )

    def get(self, request, *args: Any, **kwargs: Any) -> Response:
        """
        Возвращает фронту конфиг ParkMateAI (контракты/URL‑ы сервисов).
        Формат согласован с static/js/parkmate-ai.ts (ParkMateAI).
        """
        data = {
            "voiceCommands": {
                "booking": "Забронировать парковку рядом",
                "navigation": "Построить маршрут до парковки",
                "payment": "Оплатить текущую парковку",
                "support": "Связаться с поддержкой ParkShare",
            },
            "computerVision": {
                "licensePlateRecognition": "/api/ai/cv/license-plate/",
                "parkingSpotDetection": "/api/ai/cv/parking-occupancy/",
                "damageDetection": "/api/ai/cv/vehicle-damage/",  # зарезервировано
                "occupancyAnalytics": "/api/ai/stress-index/",
            },
            "predictions": {
                "arrivalTime": "/api/ai/departure-assistant/",
                "priceForecast": "/api/ai/parkmate/price-forecast/",
                "availability": "/api/ai/parkmate/availability/",
            },
        }
        return Response(data, status=status.HTTP_200_OK)


# Остальные классы (RecommendationsAPIView, StressIndexAPIView, DepartureAssistantAPIView,
# ParkMatePriceForecastAPIView, ParkMateAvailabilityForecastAPIView) остаются без изменений


class ParkMatePriceForecastAPIView(APIView):
    """
    Эндпоинт ParkMate для прогноза цены по конкретному месту.

    POST /api/ai/parkmate/price-forecast/
    {
      "spot_id": "uuid"
    }
    """

    permission_classes = [AllowAny]

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        from django.shortcuts import get_object_or_404

        spot_id = request.data.get("spot_id")
        if not spot_id:
            return Response(
                {"detail": "spot_id is required."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        spot = get_object_or_404(
            ParkingSpot,
            pk=spot_id,
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )

        pricing = recommend_price_for_spot(spot)
        if not pricing:
            return Response(
                {"detail": "AI pricing is not available for this spot."},
                status=status.HTTP_404_NOT_FOUND,
            )

        base_price = float(pricing.get("base_price", 0.0))
        recommended_price = float(pricing.get("recommended_price", base_price))
        min_price = float(pricing.get("min_price", recommended_price))
        max_price = float(pricing.get("max_price", recommended_price))
        discount_percent = float(pricing.get("discount_percent") or 0.0)
        is_discount = bool(pricing.get("is_discount") or False)

        data = {
            "spot_id": str(spot.id),
            "lot_id": str(spot.lot_id),
            "currency": "RUB",
            "base_price": base_price,
            "recommended_price": recommended_price,
            "min_price": min_price,
            "max_price": max_price,
            "discount_percent": discount_percent,
            "is_discount": is_discount,
            "reason": pricing.get("reason", ""),
        }
        return Response(data, status=status.HTTP_200_OK)


class ParkMateAvailabilityForecastAPIView(APIView):
    """
    Эндпоинт ParkMate для прогноза доступности места.

    POST /api/ai/parkmate/availability/
    {
      "spot_id": "uuid"        # либо
      "occupancy_7d": 0.4,
      "stress_index": 0.5
    }
    """

    permission_classes = [AllowAny]

    def post(self, request, *args: Any, **kwargs: Any) -> Response:
        from django.shortcuts import get_object_or_404

        spot_id = request.data.get("spot_id")
        occupancy_7d = request.data.get("occupancy_7d")
        stress_index = request.data.get("stress_index")

        spot = None
        if spot_id:
            spot = get_object_or_404(
                ParkingSpot,
                pk=spot_id,
                status=ParkingSpot.SpotStatus.ACTIVE,
                lot__is_active=True,
                lot__is_approved=True,
            )
            occupancy_7d = float(spot.occupancy_7d or 0.0)
            stress_index = float(spot.lot.stress_index or 0.0)
        else:
            try:
                occupancy_7d = float(occupancy_7d or 0.0)
                stress_index = float(stress_index or 0.0)
            except (TypeError, ValueError):
                return Response(
                    {
                        "detail": (
                            "occupancy_7d и stress_index должны быть числами, "
                            "если не передан spot_id."
                        )
                    },
                    status=status.HTTP_400_BAD_REQUEST,
                )

        # Нормализация
        occupancy_7d = max(0.0, min(float(occupancy_7d), 1.0))
        stress_index = max(0.0, min(float(stress_index), 1.0))

        # Простая эвристика: чем выше загрузка/стресс, тем ниже вероятность доступности
        base_avail = 1.0 - 0.7 * occupancy_7d - 0.3 * stress_index
        base_avail = max(0.0, min(base_avail, 1.0))

        next_1h = round(base_avail, 3)
        next_3h = round(max(0.0, base_avail - 0.1), 3)
        next_24h = round(max(0.0, base_avail - 0.2), 3)

        now = timezone.now()

        data = {
            "spot_id": str(spot.id) if spot else None,
            "occupancy_7d": occupancy_7d,
            "stress_index": stress_index,
            "as_of": now,
            "availability": {
                "next_1h": next_1h,
                "next_3h": next_3h,
                "next_24h": next_24h,
            },
        }
        return Response(data, status=status.HTTP_200_OK)


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 67
PATH: ai\chat\__init__.py
LANG: python
===== CONTENT START =====
"""Chat helpers for local parking assistant."""
from .parking_assistant import generate_chat_reply

__all__ = ["generate_chat_reply"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 68
PATH: ai\chat\parking_assistant.py
LANG: python
===== CONTENT START =====
"""
Умный помощник подбирает парковки по текстовому запросу, используя
простые правила и существующие данные модели парковок. При желании сюда
можно подключить обученные NLP-модели.
"""
from __future__ import annotations

import logging
import random
import re
from functools import lru_cache
from typing import Any, Dict, Iterable, List, Optional, Tuple

try:
    from sklearn.feature_extraction.text import TfidfVectorizer
    from sklearn.metrics.pairwise import cosine_similarity
except Exception:  # pragma: no cover - безопасный фолбэк без зависимостей
    TfidfVectorizer = None
    cosine_similarity = None

from asgiref.sync import async_to_sync
from django.contrib.auth import get_user_model
from django.db.models import Q

from parking.models import ParkingSpot
from services.llm import LLMClientError, parse_search_query

User = get_user_model()
logger = logging.getLogger(__name__)


def _extract_budget(text: str) -> Optional[int]:
    match = re.search(r"(\d{2,5})\s*(?:₽|р|руб)", text)
    if match:
        try:
            return int(match.group(1))
        except ValueError:
            return None
    return None


def _extract_time_hint(text: str) -> str:
    if "завтра" in text:
        return "на завтра"
    if "ноч" in text:
        return "на ночь"
    if re.search(r"\b(\d{1,2})\s*[-–]\s*(\d{1,2})\b", text):
        return "в указанное окно времени"
    if "сейчас" in text or "прямо сейчас" in text:
        return "на ближайший час"
    return "скоро"


def _extract_time_window(text: str) -> tuple[Optional[int], Optional[int], str]:
    """Парсинг диапазона времени (часы) или быстрых подсказок."""

    match = re.search(r"\b(\d{1,2})\s*[-–]\s*(\d{1,2})\b", text)
    if match:
        start_h, end_h = match.groups()
        try:
            return int(start_h), int(end_h), f"с {start_h}:00 до {end_h}:00"
        except ValueError:
            return None, None, ""

    lowered = text.lower()
    if "сейчас" in lowered or "прямо сейчас" in lowered:
        return None, None, "на ближайший час"
    if "завтра" in lowered:
        return None, None, "на завтра"
    if "ноч" in lowered:
        return None, None, "на ночь"
    return None, None, ""


INTENT_CORPUS: list[tuple[str, str]] = [
    ("ev", "зарядка для электромобиля ev электромобиль tesla leaf"),
    ("budget", "самая дешёвая дёшево бюджет эконом"),
    ("night", "ночь ночевка оставить на ночь круглосуточно"),
    ("covered", "крытая парковка подземная защита от дождя"),
    ("fast", "сейчас ближайшая возле меня рядом срочно прямо сейчас"),
]


@lru_cache(maxsize=1)
def _intent_vectorizer():
    if not TfidfVectorizer:
        return None, None
    labels, texts = zip(*INTENT_CORPUS)
    vect = TfidfVectorizer(stop_words=None)
    matrix = vect.fit_transform(texts)
    return vect, (labels, matrix)


def _detect_intents(text: str) -> list[str]:
    vect, payload = _intent_vectorizer()
    if not vect or not payload:
        return []
    labels, matrix = payload
    query_vec = vect.transform([text])
    sims = cosine_similarity(query_vec, matrix).flatten()
    ranked: list[Tuple[float, str]] = sorted(zip(sims, labels), reverse=True)
    return [lbl for score, lbl in ranked if score > 0.18][:3]


def _build_base_queryset() -> Iterable[ParkingSpot]:
    return (
        ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )
        .select_related("lot")
    )


def _parse_with_llm(text: str) -> dict[str, Any] | None:
    """Try to parse a query using the external LLM service.

    Returns None if the service is unavailable or any error occurs so that we can
    gracefully fallback to the rule-based parsing.
    """

    try:
        logger.info(
            "Invoking LLM parser for chat message",
            extra={"query": text[:200]},
        )
        parsed = async_to_sync(parse_search_query)(text)
        logger.info(
            "LLM parsed query",
            extra={"query": text, "parsed": parsed},
        )
        return parsed
    except (LLMClientError, ValueError) as exc:
        logger.warning(
            "LLM parsing failed, using rule-based fallback",
            extra={"query": text},
            exc_info=exc,
        )
    except Exception as exc:  # pragma: no cover - непредвиденная ошибка
        logger.exception(
            "Unexpected LLM parse error, using fallback", extra={"query": text}
        )
    return None


def _apply_llm_filters(queryset, payload: dict[str, Any]):
    q_filter = Q()
    city = payload.get("city")
    if city:
        q_filter &= Q(lot__city__iexact=city) | Q(lot__address__icontains=city)

    if payload.get("has_ev_charging") is True:
        q_filter &= Q(has_ev_charging=True)
    if payload.get("covered") is True:
        q_filter &= Q(is_covered=True)

    max_price = payload.get("max_price_per_hour")
    if max_price is not None:
        try:
            q_filter &= Q(hourly_price__lte=float(max_price))
        except (TypeError, ValueError):
            logger.debug("Skip invalid max_price_per_hour", extra={"value": max_price})

    near_metro = payload.get("near_metro")
    if near_metro:
        q_filter &= Q(lot__address__icontains="метро") | Q(lot__name__icontains="метро")

    if q_filter:
        queryset = queryset.filter(q_filter)
    return queryset


def _apply_intents(queryset, text: str):
    lowered = text.lower()
    q_filter = Q()
    intents = set(_detect_intents(lowered))
    if "ev" in lowered or "заряд" in lowered or "электро" in lowered or "ev" in intents:
        q_filter &= Q(has_ev_charging=True)
    if "крыт" in lowered or "covered" in intents:
        q_filter &= Q(is_covered=True)
    if "24/7" in lowered or "круглосуточ" in lowered or "night" in intents:
        q_filter &= Q(is_24_7=True)
    if "budget" in intents:
        q_filter &= Q(hourly_price__lte=300)
    metro_match = re.search(r"метро\s+([\wёЁ\-\s]+)", lowered)
    if metro_match:
        station = metro_match.group(1).strip()
        q_filter &= Q(lot__address__icontains=station) | Q(lot__name__icontains=station)
    address_match = re.search(r"(ул\.|улица|проспект|шоссе|пл\.|площадь)\s+([\wёЁ\s\-]+)", lowered)
    if address_match:
        fragment = address_match.group(0)
        q_filter &= Q(lot__address__icontains=fragment)
    budget = _extract_budget(lowered)
    if budget:
        q_filter &= Q(hourly_price__lte=budget)
    if q_filter:
        queryset = queryset.filter(q_filter)
    return queryset, intents


def _spot_payload(spot: ParkingSpot) -> dict[str, Any]:
    tags = []
    if spot.has_ev_charging:
        tags.append("EV")
    if spot.is_covered:
        tags.append("крытая")
    if spot.is_24_7:
        tags.append("24/7")
    if getattr(spot, "allow_dynamic_pricing", False):
        tags.append("AI")
    return {
        "spot_id": str(spot.id),
        "title": f"{spot.lot.name} — {spot.name}",
        "price": float(spot.hourly_price or 0),
        "distance_m": getattr(spot, "distance_km", None) * 1000 if getattr(spot, "distance_km", None) else None,
        "tags": tags,
        "occupancy_now": float(getattr(spot, "occupancy_7d", 0.0) or 0.0),
        "features": {
            "ev": spot.has_ev_charging,
            "covered": spot.is_covered,
            "is_24_7": spot.is_24_7,
            "allow_dynamic_pricing": getattr(spot, "allow_dynamic_pricing", False),
        },
        "coords": {
            "lat": spot.lot.latitude,
            "lng": spot.lot.longitude,
        },
    }


def _compose_reply(context: dict[str, Any], count: int) -> str:
    templates = [
        "Нашёл для вас {count} вариантов около {area}. Цены от {min_price} до {max_price} ₽/час. Сейчас свободно примерно {availability}%.",
        "Подобрал {count} парковок {time_hint}. Минимальный тариф {min_price} ₽/час, максимальный {max_price} ₽/час.",
        "Есть {count} подходящих мест {area}. Чтобы расширить выбор, можно скорректировать бюджет {budget_hint}.",
    ]
    area = context.get("area") or "рядом"
    min_price = context.get("min_price", 0)
    max_price = context.get("max_price", max(min_price, min_price + 50))
    availability = context.get("availability", 60)
    budget_hint = f"до {context['budget']} ₽" if context.get("budget") else "или радиус"
    time_hint = context.get("time_hint", "")
    template = random.choice(templates)
    return template.format(
        count=count or 0,
        area=area,
        min_price=min_price,
        max_price=max_price,
        availability=availability,
        budget_hint=budget_hint,
        time_hint=time_hint,
    )


def _llm_time_hint(payload: dict[str, Any]) -> str:
    start_at = payload.get("start_at")
    end_at = payload.get("end_at")
    if start_at and end_at:
        return "на выбранный интервал"
    if start_at:
        return "к указанному времени"
    return "скоро"


def _prepare_context(
    spots: list[ParkingSpot], area: Optional[str], budget: Optional[int], time_hint: str
) -> dict[str, Any]:
    prices = [float(s.hourly_price or 0) for s in spots] or [0]
    return {
        "area": area or "рядом",
        "min_price": int(min(prices)),
        "max_price": int(max(prices)),
        "availability": int(
            100
            - (sum([float(getattr(s, "occupancy_7d", 0.0) or 0) for s in spots]) / len(prices))
            * 100
        )
        if spots
        else 0,
        "budget": budget,
        "time_hint": time_hint,
    }


def _reply_payload(spots: list[ParkingSpot], context: dict[str, Any], reasoning: str) -> dict[str, Any]:
    suggestions = [_spot_payload(spot) for spot in spots][:6]
    if not suggestions:
        reply = "Сейчас нет парковок под эти условия. Попробуйте увеличить бюджет или выбрать другой район."
        reasoning = reasoning or "Запрос слишком узкий или в базе пока нет подходящих мест."
    else:
        reply = _compose_reply(context, len(suggestions))
    return {
        "reply": reply,
        "suggestions": suggestions,
        "reason": reasoning,
        "intents": context.get("intents", []),
    }


def _filter_by_preferences(spots: list[ParkingSpot], prefs: Optional[dict[str, Any]]):
    if not prefs:
        return spots
    filtered = spots
    if prefs.get("prefers_ev"):
        filtered = [s for s in filtered if s.has_ev_charging]
    if prefs.get("prefers_covered"):
        filtered = [s for s in filtered if s.is_covered]
    budget = prefs.get("budget_max")
    if budget:
        try:
            limit = float(budget)
            filtered = [s for s in filtered if float(s.hourly_price or 0) <= limit]
        except (TypeError, ValueError):
            pass
    return filtered or spots


def _handle_llm_flow(text: str, preferences: Optional[dict[str, Any]] = None):
    parsed = _parse_with_llm(text)
    if not parsed:
        logger.debug(
            "LLM returned no result; will use rule-based fallback",
            extra={"query": text[:120]},
        )
        return None

    qs = _apply_llm_filters(_build_base_queryset(), parsed)
    qs = qs.order_by("lot__stress_index", "hourly_price")[:12]
    spots = _filter_by_preferences(list(qs), preferences)

    area_hint = None
    if parsed.get("near_metro"):
        area_hint = "рядом с метро"
    if parsed.get("city"):
        area_hint = parsed["city"]

    budget = parsed.get("max_price_per_hour")
    time_hint = _llm_time_hint(parsed)
    context = _prepare_context(spots, area_hint, budget, time_hint)
    reasoning_parts = ["LLM разобрал намерение пользователя"]
    if parsed.get("has_ev_charging"):
        reasoning_parts.append("учтена EV-зарядка")
    if parsed.get("covered"):
        reasoning_parts.append("оставлены крытые места")
    if budget:
        reasoning_parts.append("отфильтровано по бюджету")
    context["intents"] = []

    context["preferences_applied"] = bool(preferences)
    return _reply_payload(spots, context, ", ".join(reasoning_parts))


def _handle_rule_based_flow(lowered: str, preferences: Optional[dict[str, Any]] = None):
    qs, intents = _apply_intents(_build_base_queryset(), lowered)
    budget = _extract_budget(lowered)
    if budget:
        qs = qs.filter(hourly_price__lte=budget)

    qs = qs.order_by("lot__stress_index", "hourly_price")[:12]
    spots = _filter_by_preferences(list(qs), preferences)

    area_hint = None
    metro_match = re.search(r"метро\s+([\wёЁ\-\s]+)", lowered)
    if metro_match:
        area_hint = f"у метро {metro_match.group(1).strip().title()}"
    start_h, end_h, time_hint_parsed = _extract_time_window(lowered)
    time_hint = time_hint_parsed or _extract_time_hint(lowered)
    context = _prepare_context(spots, area_hint, budget, time_hint)
    context["intents"] = list(intents)
    if start_h is not None and end_h is not None:
        context["time_hint"] = f"с {start_h}:00 до {end_h}:00"

    why = []
    if "ev" in intents:
        why.append("учёл наличие EV-зарядки")
    if "budget" in intents or budget:
        why.append("отсортировал по цене")
    if "night" in intents:
        why.append("оставил только круглосуточные")
    if time_hint_parsed:
        why.append(f"учёл интервал {time_hint_parsed}")
    reasoning = ", ".join(why) if why else "использовал ближайшие и менее загруженные места"
    context["preferences_applied"] = bool(preferences)
    return _reply_payload(spots, context, reasoning)


def generate_chat_reply(message: str, history: Optional[List[dict]], user: Optional[User], preferences: Optional[dict[str, Any]] = None) -> dict[str, Any]:
    text = (message or "").strip()
    logger.info(
        "Incoming parking chat message",
        extra={
            "user_message": text[:200],
            "history_len": len(history or []),
            "user": getattr(user, "id", None),
        },
    )
    if not text:
        logger.info("Empty chat message, returning friendly prompt")
        return {
            "reply": "Опишите улицу, метро, бюджет и время: например, \"Тверская, с 9 до 11, до 350 ₽/ч, крытая\".",
            "suggestions": [],
            "reason": "empty_message",
        }

    lowered = text.lower()

    try:
        llm_response = _handle_llm_flow(text, preferences=preferences)
        if llm_response:
            return llm_response
    except Exception as exc:  # pragma: no cover - непредвиденная ошибка
        logger.exception("LLM flow errored, forcing rule-based fallback", exc_info=exc)
        fallback = _handle_rule_based_flow(lowered, preferences=preferences)
        fallback["reason"] = (fallback.get("reason") or "") + " · AI сервис недоступен, используем эвристику"
        fallback["reply"] = fallback.get("reply") or "Работаю в упрощённом режиме без внешнего AI, но покажу подходящие места."
        return fallback

    logger.info("Falling back to rule-based parser")
    response = _handle_rule_based_flow(lowered, preferences=preferences)
    if not response.get("suggestions"):
        response["reply"] = (
            "Не очень понял запрос. Попробуйте формат: ‘Курская, парковка с 9 до 11, до 300 ₽/час, с зарядкой EV’."
        )
    return response

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 69
PATH: ai\management\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 70
PATH: ai\management\commands\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 71
PATH: ai\management\commands\train_chat_intents_from_logs.py
LANG: python
===== CONTENT START =====
from django.core.management.base import BaseCommand

from ai.models import ChatMessage


class Command(BaseCommand):
    help = "Проходится по логам чата и подготавливает данные для обучения NLP/intent моделей."

    def handle(self, *args, **options):
        total = ChatMessage.objects.count()
        assistant_messages = ChatMessage.objects.filter(role=ChatMessage.Role.ASSISTANT).count()
        user_messages = total - assistant_messages
        self.stdout.write(self.style.SUCCESS("Всего сообщений: %s" % total))
        self.stdout.write(f"Ответов ассистента: {assistant_messages}")
        self.stdout.write(f"Сообщений пользователей: {user_messages}")
        # TODO: выгружать диалоги и обучать намерения
        self.stdout.write("Подготовка к обучению завершена (заглушка).")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 72
PATH: ai\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated manually to include initial AI models
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ChatSession',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('client_info', models.JSONField(blank=True, null=True, verbose_name='Данные клиента')),
                ('last_activity_at', models.DateTimeField(auto_now=True, verbose_name='Последняя активность')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='chat_sessions', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Сессия чата',
                'verbose_name_plural': 'Сессии чата',
            },
        ),
        migrations.CreateModel(
            name='DeviceProfile',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('device_id', models.CharField(db_index=True, max_length=64, verbose_name='ID устройства')),
                ('viewport_width', models.IntegerField(blank=True, null=True, verbose_name='Ширина viewport')),
                ('viewport_height', models.IntegerField(blank=True, null=True, verbose_name='Высота viewport')),
                ('pixel_ratio', models.FloatField(blank=True, null=True, verbose_name='Pixel ratio')),
                ('user_agent', models.TextField(blank=True, verbose_name='User‑Agent')),
                ('layout_profile', models.CharField(choices=[('compact', 'Компактный'), ('comfortable', 'Комфортный')], default='compact', max_length=32, verbose_name='Профиль компоновки')),
                ('theme', models.CharField(choices=[('light', 'Светлая'), ('dark', 'Тёмная'), ('system', 'Системная')], default='system', max_length=16, verbose_name='Тема')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='device_profiles', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Профиль устройства',
                'verbose_name_plural': 'Профили устройств',
                'unique_together': {('device_id', 'user')},
            },
        ),
        migrations.CreateModel(
            name='UiEvent',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('event_type', models.CharField(max_length=64, verbose_name='Тип события')),
                ('payload', models.JSONField(blank=True, null=True, verbose_name='Payload')),
                ('device_profile', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='events', to='ai.deviceprofile')),
            ],
            options={
                'verbose_name': 'UI‑событие',
                'verbose_name_plural': 'UI‑события',
            },
        ),
        migrations.CreateModel(
            name='ChatMessage',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('role', models.CharField(choices=[('user', 'User'), ('assistant', 'Assistant')], max_length=16, verbose_name='Роль')),
                ('text', models.TextField(verbose_name='Текст')),
                ('meta', models.JSONField(blank=True, null=True, verbose_name='Метаданные')),
                ('session', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='messages', to='ai.chatsession')),
            ],
            options={
                'verbose_name': 'Сообщение чата',
                'verbose_name_plural': 'Сообщения чата',
                'ordering': ('-created_at',),
            },
        ),
        migrations.CreateModel(
            name='ChatFeedback',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('rating', models.IntegerField(default=0, verbose_name='Оценка')),
                ('message', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='feedback', to='ai.chatmessage')),
            ],
            options={
                'verbose_name': 'Фидбек чата',
                'verbose_name_plural': 'Фидбек чата',
                'ordering': ('-created_at',),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 73
PATH: ai\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 74
PATH: ai\tests\__init__.py
LANG: python
===== CONTENT START =====
# Package marker for ai tests

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 75
PATH: ai\tests\test_assistant_sessions.py
LANG: python
===== CONTENT START =====
from django.utils import timezone
from rest_framework.test import APITestCase, APIRequestFactory, force_authenticate

from accounts.models import User
from ai.views import ChatStreamAPIView
from parking.models import Booking, ParkingLot, ParkingSpot


class AssistantSessionFlowTest(APITestCase):
    def setUp(self):
        self.factory = APIRequestFactory()
        self.user = User.objects.create_user(username="assistant_user", password="secret123")
        self.lot = ParkingLot.objects.create(
            owner=self.user,
            name="Test Lot",
            city="Москва",
            address="ул. Тестовая",
            latitude=55.75,
            longitude=37.61,
        )
        self.spot = ParkingSpot.objects.create(
            lot=self.lot,
            name="A1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=100,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )
        start = timezone.now()
        end = start + timezone.timedelta(hours=1)
        self.booking = Booking.objects.create(
            user=self.user,
            spot=self.spot,
            start_at=start,
            end_at=end,
            status=Booking.Status.ACTIVE,
            total_price=100,
        )

    def test_structured_response_contains_sessions_and_actions(self):
        view = ChatStreamAPIView.as_view()
        request = self.factory.post(
            "/api/v1/assistant/chat/",
            {"messages": [{"role": "user", "content": "Привет"}], "structured": True},
            format="json",
        )
        force_authenticate(request, user=self.user)
        response = view(request)
        self.assertEqual(response.status_code, 200)
        data = response.data
        self.assertIn("sessions", data)
        self.assertTrue(data["sessions"])
        self.assertTrue(any(action.get("type") == "booking_extend" for action in data.get("actions", [])))

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 76
PATH: ai_services\__init__.py
LANG: python
===== CONTENT START =====
"""
AI microservices for ParkShare / ParkShare RU.

Содержит отдельные FastAPI‑приложения:
- ai_pricing_service: динамическое ценообразование;
- cv_service: Computer Vision (распознавание номеров, заполненность и т.д.).
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 77
PATH: ai_services\ai_pricing_service\__init__.py
LANG: python
===== CONTENT START =====
"""
AI Pricing microservice (FastAPI) for dynamic parking spot pricing.
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 78
PATH: ai_services\ai_pricing_service\main.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from decimal import Decimal, ROUND_HALF_UP
from typing import Optional

from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI(
    title="ParkShare AI Pricing Service",
    version="0.1.0",
    description=(
        "Отдельный микросервис ParkMate AI для динамического ценообразования "
        "парковочных мест. Пока использует простые эвристики, но интерфейс "
        "готов для подключения CatBoost/Transformer‑моделей."
    ),
)


def round_price(value: float, step: float = 10.0) -> float:
    """
    Локальная реализация round_price, не зависящая от Django.
    Округляет цену к ближайшему step (по умолчанию 10 ₽).
    """
    if step <= 0:
        return float(Decimal(str(value)).quantize(Decimal("0.01")))

    v = Decimal(str(value))
    step_dec = Decimal(str(step))
    scaled = (v / step_dec).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    result = scaled * step_dec
    return float(result)


# ai_services/ai_pricing_service/main.py

class PricingRequest(BaseModel):
    base_price: float = Field(
        ...,
        gt=0,
        description="Базовая цена за час, ₽",
    )
    occupancy_7d: float = Field(
        0.0,
        ge=0.0,
        le=1.0,
        description="Загруженность места за последние 7 дней (0..1)",
    )
    stress_index: float = Field(
        0.0,
        ge=0.0,
        le=1.0,
        description="Индекс загруженности парковки (0..1)",
    )
    hour: Optional[int] = Field(
        None,
        ge=0,
        le=23,
        description="Час суток (0–23, локальное время парковки)",
    )
    dow: Optional[int] = Field(
        None,
        ge=0,
        le=6,
        description="День недели (0=понедельник, 6=воскресенье)",
    )
    use_ml: bool = Field(
        False,
        description=(
            "Флаг для использования ML‑модели (зарезервировано; "
            "пока используется только эвристика)."
        ),
    )



class PricingResponse(BaseModel):
    base_price: float
    recommended_price: float
    min_price: float
    max_price: float
    discount_percent: float
    is_discount: bool
    reason: str


@app.get("/health", tags=["health"])
def health() -> dict:
    """
    Простой healthcheck.
    """
    return {"status": "ok"}


@app.post(
    "/api/v1/pricing/recommend",
    response_model=PricingResponse,
    tags=["pricing"],
    summary="Получить рекомендованную цену за час",
)
def recommend_price(payload: PricingRequest) -> PricingResponse:
    """
    Эвристическое ценообразование на основе:
    - базовой цены;
    - загруженности места/парковки;
    - времени суток (час пик / не час пик).

    В дальнейшем сюда можно подставить CatBoost/Transformer‑модель.
    """
    base_price = payload.base_price
    occ = float(payload.occupancy_7d or 0.0)
    stress = float(payload.stress_index or 0.0)

    factor = 1.0
    reasons: list[str] = []

    # Загруженность места
    if occ > 0.8:
        factor += 0.15
        reasons.append("место часто занято (высокая загруженность за 7 дней)")
    elif occ < 0.3:
        factor -= 0.10
        reasons.append("место простаивает (низкая загруженность за 7 дней)")

    # Стресс по парковке
    if stress > 0.7:
        factor += 0.10
        reasons.append("высокий парковочный стресс по объекту")
    elif stress < 0.3:
        factor -= 0.05
        reasons.append("низкий парковочный стресс по объекту")

    # Время суток
    if payload.hour is not None:
        hour = payload.hour
        if 8 <= hour <= 11 or 17 <= hour <= 21:
            factor += 0.10
            reasons.append("час пик")
        else:
            factor -= 0.05
            reasons.append("не час пик")

    # Ограничиваем фактор
    if factor < 0.5:
        factor = 0.5
    if factor > 1.5:
        factor = 1.5

    recommended = round_price(base_price * factor, step=5.0)
    min_price = round_price(recommended * 0.9, step=5.0)
    max_price = round_price(recommended * 1.1, step=5.0)

    # Скидка относительно базовой цены
    discount_percent = 0.0
    is_discount = False
    if recommended < base_price:
        diff = (base_price - recommended) / base_price
        discount_percent = float(
            (Decimal(str(diff)) * Decimal("100")).quantize(Decimal("0.1"))
        )
        is_discount = True

    if not reasons:
        reasons.append("используется только базовая ставка")

    reason = "; ".join(reasons)

    return PricingResponse(
        base_price=base_price,
        recommended_price=recommended,
        min_price=min_price,
        max_price=max_price,
        discount_percent=discount_percent,
        is_discount=is_discount,
        reason=reason,
    )

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 79
PATH: ai_services\cv_service\__init__.py
LANG: python
===== CONTENT START =====
"""
Computer Vision microservice (FastAPI) for ParkShare:
- распознавание номеров;
- оценка заполненности парковок по кадрам камер.
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 80
PATH: ai_services\cv_service\main.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from datetime import datetime, timezone
from typing import Optional

from fastapi import FastAPI
from pydantic import BaseModel, Field, root_validator

app = FastAPI(
    title="ParkShare CV Service",
    version="0.1.0",
    description=(
        "Заглушечный CV‑сервис ParkMate AI. "
        "Интерфейс готов под интеграцию OpenCV/ONNX/WebGPU‑моделей."
    ),
)


class LicensePlateRequest(BaseModel):
    image_url: Optional[str] = Field(
        None,
        description="URL до кадра/фото с номером автомобиля (если используется серверная загрузка).",
    )
    image_base64: Optional[str] = Field(
        None,
        description="Base64‑кодированное изображение (если отправляем напрямую).",
    )
    region: str = Field("RU", description="Код региона/страны (например, RU, EU, US).")

    @root_validator
    def validate_source(cls, values):
        if not values.get("image_url") and not values.get("image_base64"):
            raise ValueError("Нужно передать либо image_url, либо image_base64.")
        return values


class LicensePlateResponse(BaseModel):
    plate: str
    normalized_plate: str
    region: str
    confidence: float


class ParkingOccupancyRequest(BaseModel):
    image_url: Optional[str] = Field(
        None,
        description="URL до кадра камеры с парковкой.",
    )
    camera_id: Optional[str] = Field(
        None,
        description="ID камеры/потока в вашем домене.",
    )
    total_slots: Optional[int] = Field(
        None,
        gt=0,
        description="Общее количество мест (если известно заранее).",
    )

    @root_validator
    def validate_source(cls, values):
        if not values.get("image_url") and not values.get("camera_id"):
            raise ValueError("Нужно указать image_url или camera_id.")
        return values


class ParkingOccupancyResponse(BaseModel):
    occupied_slots: int
    total_slots: int
    occupancy_rate: float = Field(..., ge=0.0, le=1.0)
    timestamp: datetime


@app.get("/health", tags=["health"])
def health() -> dict:
    return {"status": "ok"}


@app.post(
    "/api/v1/cv/license-plate",
    response_model=LicensePlateResponse,
    tags=["cv"],
    summary="Распознавание госномера (заглушка)",
)
def recognize_plate(payload: LicensePlateRequest) -> LicensePlateResponse:
    """
    Заглушка для распознавания госномера.
    Реальная логика должна вызывать модель (OpenCV+ONNX и т.п.).
    """
    # TODO: заменить на вызов реальной модели/сервиса
    fake_plate = "A000AA197"
    normalized = fake_plate.replace(" ", "")
    return LicensePlateResponse(
        plate=fake_plate,
        normalized_plate=normalized,
        region=payload.region,
        confidence=0.85,
    )


@app.post(
    "/api/v1/cv/parking-occupancy",
    response_model=ParkingOccupancyResponse,
    tags=["cv"],
    summary="Оценка заполненности парковки по кадру (заглушка)",
)
def parking_occupancy(payload: ParkingOccupancyRequest) -> ParkingOccupancyResponse:
    """
    Заглушка для оценки заполненности парковки:
    - если total_slots известен, считаем примерно 50% занятости;
    - если нет, предполагаем 20 мест и 40% занято.
    """
    total_slots = payload.total_slots or 20
    occupied_slots = max(1, int(total_slots * 0.4))
    occupancy_rate = occupied_slots / float(total_slots)
    return ParkingOccupancyResponse(
        occupied_slots=occupied_slots,
        total_slots=total_slots,
        occupancy_rate=round(occupancy_rate, 3),
        timestamp=datetime.now(timezone.utc),
    )

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 81
PATH: backend\__init__.py
LANG: python
===== CONTENT START =====
"""
Top-level package marker for the Django project.
Ensures the project package has a concrete module file so multiprocessing
on Windows (used by Celery's prefork pool) can resolve the project
location without raising errors when __file__ is missing.
"""

# Expose Celery app for shared imports
from backend.backend.config.celery import app as celery_app

__all__ = ("celery_app",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 82
PATH: backend\manage.py
LANG: python
===== CONTENT START =====
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""

import os
import sys
from pathlib import Path


def main() -> None:
    """
    Точка входа для manage.py.

    ВАЖНО: добавляем корень репозитория в sys.path, чтобы пакеты
    уровня `accounts`, `parking`, `payments` и т.п. корректно импортировались,
    даже если запускаем `python backend/manage.py ...`.
    """
    current_file = Path(__file__).resolve()
    backend_dir = current_file.parent           # .../parkshare_ru_part1/backend
    project_root = backend_dir.parent           # .../parkshare_ru_part1

    # Гарантируем, что корень проекта в PYTHONPATH
    project_root_str = str(project_root)
    if project_root_str not in sys.path:
        sys.path.insert(0, project_root_str)

    # Если переменная окружения не задана – по умолчанию используем dev-настройки
    # Обязательно полный путь "backend.backend.settings.*", иначе Celery/uvicorn
    # падают с ModuleNotFoundError: backend.settings
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Не удалось импортировать Django. Убедись, что виртуальное "
            "окружение активировано и зависимости установлены."
        ) from exc

    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 83
PATH: backend\backend\__init__.py
LANG: python
===== CONTENT START =====
from .config.celery import app as celery_app

__all__ = ("celery_app",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 84
PATH: backend\backend\health.py
LANG: python
===== CONTENT START =====
from django.http import JsonResponse
from django.db import connections
from django.db.utils import OperationalError


def healthz(request):
    return JsonResponse({"status": "ok"})


def readyz(request):
    try:
        conn = connections["default"]
        conn.cursor()
        return JsonResponse({"status": "ready"})
    except OperationalError:
        return JsonResponse({"status": "db_unavailable"}, status=503)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 85
PATH: backend\backend\config\__init__.py
LANG: python
===== CONTENT START =====
"""Django config package for ASGI/WSGI and Celery app exposure."""

import os

# Гарантируем, что Celery и Django получают настройки даже при запуске воркеров напрямую.
# Используем полный путь, чтобы избежать ModuleNotFoundError при вызове Celery/uvicorn.
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

from .celery import app as celery_app  # noqa: E402

__all__ = ("celery_app",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 86
PATH: backend\backend\config\asgi.py
LANG: python
===== CONTENT START =====
import os

from django.core.asgi import get_asgi_application

settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module:
    raise RuntimeError(
        "DJANGO_SETTINGS_MODULE не задан. "
        "Укажи backend.backend.settings.local (dev) или backend.backend.settings.production (prod)."
    )

application = get_asgi_application()


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 87
PATH: backend\backend\config\celery.py
LANG: python
===== CONTENT START =====
# backend/backend/config/celery.py

from __future__ import annotations

import os

from celery import Celery


# Устанавливаем DJANGO_SETTINGS_MODULE до импорта Django.
settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module or settings_module.startswith("backend.settings"):
    # Позволяет запускать Celery локально без эксплицитного экспорта переменной.
    # Путь backend.settings.* больше не существует — используем полный путь пакета.
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

# Создаём Celery-приложение, конфигурацию читаем из Django settings с префиксом CELERY_.
app = Celery("backend")
app.config_from_object("django.conf:settings", namespace="CELERY")

# Авто-обнаружение tasks.py во всех Django-приложениях.
app.autodiscover_tasks()


@app.task(bind=True)
def debug_task(self) -> None:
    print(f"Debug task: Request: {self.request!r}")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 88
PATH: backend\backend\config\urls.py
LANG: python
===== CONTENT START =====
from django.conf import settings
from django.conf.urls.static import static
from django.contrib import admin
from django.contrib.staticfiles import finders
from django.http import Http404, HttpResponse
from django.urls import include, path
from django.views.decorators.cache import never_cache
from django.views.generic import TemplateView
from drf_spectacular.views import (
    SpectacularAPIView,
    SpectacularRedocView,
    SpectacularSwaggerView,
)
from rest_framework import routers

from accounts import views as accounts_api
from ai import views as ai_api
from core.metrics import metrics_view
from parking import views as parking_views
from payments import views as payments_api
from vehicles import views as vehicles_api

from ..health import healthz, readyz

ENABLE_LABS = getattr(settings, "ENABLE_LAB_ENDPOINTS", False)
router = routers.DefaultRouter()

router.register(r"accounts/users", accounts_api.UserViewSet, basename="user")
router.register(r"vehicles", vehicles_api.VehicleViewSet, basename="vehicle")
router.register(r"parking/lots", parking_views.ParkingLotViewSet, basename="parking-lot")
router.register(r"parking/spots", parking_views.ParkingSpotViewSet, basename="parking-spot")
router.register(r"parking/bookings", parking_views.BookingViewSet, basename="booking")
router.register(r"parking/waitlist", parking_views.WaitlistViewSet, basename="waitlist")
router.register(r"parking/complaints", parking_views.ComplaintViewSet, basename="complaint")
router.register(
    r"parking/favorites", parking_views.FavoriteParkingSpotViewSet, basename="favorite-spot"
)
router.register(
    r"parking/saved-places", parking_views.SavedPlaceViewSet, basename="saved-place"
)
router.register(
    r"parking/push-subscriptions",
    parking_views.PushSubscriptionViewSet,
    basename="push-subscription",
)
router.register(r"payments", payments_api.PaymentViewSet, basename="payment")
router.register(
    r"payment-methods", payments_api.PaymentMethodViewSet, basename="payment-method"
)
router.register(
    r"payments/methods", payments_api.PaymentMethodViewSet, basename="payment-method-nested"
)

api_v1_patterns = [
    path("", include(router.urls)),
    path("search/", parking_views.ParkingSearchAPIView.as_view(), name="v1_search"),
    path("details/<uuid:spot_id>/", parking_views.ParkingDetailsAPIView.as_view(), name="v1_details"),
    path("booking/start/", parking_views.BookingStartAPIView.as_view(), name="v1_booking_start"),
    path("booking/extend/", parking_views.BookingExtendAPIView.as_view(), name="v1_booking_extend"),
    path("booking/stop/", parking_views.BookingStopAPIView.as_view(), name="v1_booking_stop"),
    path("booking/active/", parking_views.ActiveBookingAPIView.as_view(), name="v1_booking_active"),
    path("assistant/chat/", ai_api.ChatStreamAPIView.as_view(), name="v1_assistant_chat"),
    path("auth/token/", accounts_api.TokenObtainPairView.as_view(), name="v1_token_obtain_pair"),
    path("auth/token/refresh/", accounts_api.TokenRefreshSlidingView.as_view(), name="v1_token_refresh"),
    path("auth/register/", accounts_api.UserViewSet.as_view({"post": "register"}), name="v1_auth_register"),
    path("auth/login/", accounts_api.UserViewSet.as_view({"post": "login"}), name="v1_auth_login"),
    path("auth/logout/", accounts_api.UserViewSet.as_view({"post": "logout"}), name="v1_auth_logout"),
    path("auth/mfa/verify/", accounts_api.AuthMFAVerifyView.as_view(), name="v1_auth_mfa_verify"),
    path("auth/mfa/setup/", accounts_api.AuthMFASetupView.as_view(), name="v1_auth_mfa_setup"),
    path("auth/mfa/activate/", accounts_api.AuthMFAActivateView.as_view(), name="v1_auth_mfa_activate"),
    path("auth/mfa/disable/", accounts_api.AuthMFADisableView.as_view(), name="v1_auth_mfa_disable"),
    path("auth/otp/request/", accounts_api.AuthOTPRequestView.as_view(), name="v1_auth_otp_request"),
    path("auth/otp/verify/", accounts_api.AuthOTPVerifyView.as_view(), name="v1_auth_otp_verify"),
    path("ai/chat/", ai_api.ChatStreamAPIView.as_view(), name="v1_ai_chat_stream"),
    path("ai/parkmate/config/", ai_api.ParkMateConfigAPIView.as_view(), name="v1_parkmate_config"),
    path("parking/map/", parking_views.ParkingMapAPIView.as_view(), name="v1_parking_map"),
    path("geocode/", parking_views.GeocodeAPIView.as_view(), name="v1_geocode"),
]


@never_cache
def service_worker(request):
    path = finders.find("service-worker.js")
    if not path:
        raise Http404("Service worker not found")
    with open(path, "rb") as f:
        content = f.read()
    return HttpResponse(content, content_type="application/javascript")


@never_cache
def manifest(request):
    path = finders.find("manifest.webmanifest")
    if not path:
        raise Http404("Manifest not found")
    with open(path, "rb") as f:
        content = f.read()
    return HttpResponse(content, content_type="application/manifest+json")


urlpatterns = [
    path("admin/", admin.site.urls),
    path("healthz", healthz, name="healthz"),
    path("readyz", readyz, name="readyz"),
    path("metrics", metrics_view, name="metrics"),

    path("service-worker.js", service_worker, name="service_worker"),
    path("manifest.webmanifest", manifest, name="manifest"),

    path("", parking_views.LandingPageView.as_view(), name="landing"),
    path("map/", parking_views.MapPageView.as_view(), name="map_page"),
    path("pwa-install/", parking_views.PWAInstallGuideView.as_view(), name="pwa_install"),
    path("личный-кабинет/", parking_views.UserDashboardView.as_view(), name="user_dashboard"),
    path("кабинет-владельца/", parking_views.OwnerDashboardView.as_view(), name="owner_dashboard"),
    path("booking/confirm/", parking_views.BookingConfirmView.as_view(), name="booking_confirm"),
    path("payments/methods/", parking_views.PaymentMethodsPageView.as_view(), name="payment_methods"),
    path("profile/settings/", parking_views.ProfileSettingsView.as_view(), name="profile_settings"),
    path("promos/activate/", parking_views.PromoActivateView.as_view(), name="promo_activate"),
    path("business/reports/", parking_views.BusinessReportsView.as_view(), name="business_reports"),
    path("admin/metrics-lite/", parking_views.MetricsDashboardView.as_view(), name="metrics_dashboard"),
    path("offline/", TemplateView.as_view(template_name="offline.html"), name="offline"),
    path("assistant/", TemplateView.as_view(template_name="ai/concierge.html"), name="ai_chat"),
    path("ai/", TemplateView.as_view(template_name="ai/concierge.html")),

    path("accounts/", include("accounts.urls")),

    path("auth/otp/request/", accounts_api.AuthOTPRequestView.as_view(), name="auth_otp_request"),
    path("auth/otp/verify/", accounts_api.AuthOTPVerifyView.as_view(), name="auth_otp_verify"),
    path("auth/mfa/verify/", accounts_api.AuthMFAVerifyView.as_view(), name="auth_mfa_verify"),
    path("auth/mfa/setup/", accounts_api.AuthMFASetupView.as_view(), name="auth_mfa_setup_api"),
    path("auth/mfa/activate/", accounts_api.AuthMFAActivateView.as_view(), name="auth_mfa_activate_api"),
    path("auth/mfa/disable/", accounts_api.AuthMFADisableView.as_view(), name="auth_mfa_disable_api"),
    path("auth/oauth/<str:provider>/start/", accounts_api.SocialOAuthStartView.as_view(), name="oauth_start"),
    path("auth/oauth/<str:provider>/callback/", accounts_api.SocialOAuthCallbackView.as_view(), name="oauth_callback"),

    path("api/", include(router.urls)),
    path("api/v1/", include((api_v1_patterns, "api_v1"), namespace="api_v1")),

    path(
        "api/auth/token/",
        accounts_api.TokenObtainPairView.as_view(),
        name="token_obtain_pair",
    ),
    path(
        "api/auth/token/refresh/",
        accounts_api.TokenRefreshSlidingView.as_view(),
        name="token_refresh",
    ),
    path("api/auth/mfa/verify/", accounts_api.AuthMFAVerifyView.as_view(), name="api_auth_mfa_verify"),
    path("api/auth/mfa/setup/", accounts_api.AuthMFASetupView.as_view(), name="api_auth_mfa_setup"),
    path("api/auth/mfa/activate/", accounts_api.AuthMFAActivateView.as_view(), name="api_auth_mfa_activate"),
    path("api/auth/mfa/disable/", accounts_api.AuthMFADisableView.as_view(), name="api_auth_mfa_disable"),

    path("api/auth/request-code/", accounts_api.AuthOTPRequestView.as_view(), name="auth_request_code"),
    path("api/auth/verify-code/", accounts_api.AuthOTPVerifyView.as_view(), name="auth_verify_code"),
    path("api/accounts/social-accounts/<int:pk>/", accounts_api.SocialAccountDetailView.as_view(), name="social_account_unlink"),

    path("api/schema/", SpectacularAPIView.as_view(), name="api-schema"),
    path(
        "api/docs/",
        SpectacularSwaggerView.as_view(url_name="api-schema"),
        name="api-docs",
    ),
    path(
        "api/docs/redoc/",
        SpectacularRedocView.as_view(url_name="api-schema"),
        name="api-docs-redoc",
    ),

    path("api/parking/map/", parking_views.ParkingMapAPIView.as_view(), name="parking_map"),
    path("api/geocode/", parking_views.GeocodeAPIView.as_view(), name="geocode"),

    path("payments/webhook/yookassa/", payments_api.YooKassaWebhookView.as_view(), name="yookassa_webhook"),
    path("payments/webhook/stripe/", payments_api.StripeWebhookView.as_view(), name="stripe_webhook"),

    path("api-auth/", include("rest_framework.urls")),
]

if ENABLE_LABS:
    urlpatterns += [
        path("api/ai/recommendations/", ai_api.RecommendationsAPIView.as_view(), name="ai_recommendations"),
        path("api/ai/stress-index/", ai_api.StressIndexAPIView.as_view(), name="ai_stress_index"),
        path("api/ai/departure-assistant/", ai_api.DepartureAssistantAPIView.as_view(), name="ai_departure_assistant"),
        path("api/ai/parkmate/config/", ai_api.ParkMateConfigAPIView.as_view(), name="parkmate_config"),
        path("api/ai/parkmate/price-forecast/", ai_api.ParkMatePriceForecastAPIView.as_view(), name="parkmate_price_forecast"),
        path("api/chat/", ai_api.ChatStreamAPIView.as_view(), name="ai_chat_stream"),
        path("api/ai/llm/health/", ai_api.LLMServiceHealthAPIView.as_view(), name="ai_llm_health"),
    ]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 89
PATH: backend\backend\config\wsgi.py
LANG: python
===== CONTENT START =====
import os

from django.core.wsgi import get_wsgi_application

settings_module = os.environ.get("DJANGO_SETTINGS_MODULE")
if not settings_module:
    raise RuntimeError(
        "DJANGO_SETTINGS_MODULE не задан. "
        "Укажи backend.backend.settings.local (dev) или backend.backend.settings.production (prod)."
    )

application = get_wsgi_application()


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 90
PATH: backend\backend\settings\__init__.py
LANG: python
===== CONTENT START =====
"""
Пакет настроек Django для ParkShare.

Важно:
- Не используйте DJANGO_SETTINGS_MODULE=backend.settings.
- Всегда указывайте конкретный модуль:

    - backend.backend.settings.local      — для локальной разработки
    - backend.backend.settings.production — для продакшена

Это согласовано с проверками в backend.backend.config.wsgi / asgi / celery.
"""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 91
PATH: backend\backend\settings\base.py
LANG: python
===== CONTENT START =====
import os
from datetime import timedelta
from pathlib import Path
from typing import List

import environ

from .regions import REGION_PROFILES
from dotenv import load_dotenv
import os

# Project root (repo root) for consistent path handling and .env discovery.
BASE_DIR = Path(__file__).resolve().parents[3]
load_dotenv(BASE_DIR / ".env")
PROJECT_ROOT = BASE_DIR

env = environ.Env(
    DEBUG=(bool, False),
)

env_file = PROJECT_ROOT / ".env"
if env_file.exists():
    environ.Env.read_env(str(env_file))

DEBUG: bool = env.bool("DEBUG", default=False)
SECRET_KEY: str = env("SECRET_KEY", default=env("DJANGO_SECRET_KEY", default=""))
if not SECRET_KEY:
    raise RuntimeError("SECRET_KEY is required. Set SECRET_KEY in environment.")

ALLOWED_HOSTS: List[str] = env.list(
    "ALLOWED_HOSTS", default=["localhost", "127.0.0.1"]
)

PLATFORM_MODE: str = env("PLATFORM_MODE", default="RU").upper()

REGION_PROFILE: str = env("REGION_PROFILE", default="RU")
REGION = REGION_PROFILES.get(REGION_PROFILE, REGION_PROFILES["RU"])

MAP_PROVIDER: str = env("MAP_PROVIDER", default=REGION["maps"]["primary"])
MAP_PROVIDER_FALLBACK: str = env(
    "MAP_PROVIDER_FALLBACK", default=REGION["maps"].get("fallback", "leaflet")
)
YANDEX_MAP_API_KEY: str = env("YANDEX_MAP_API_KEY", default="")
MAPBOX_TOKEN: str = env("MAPBOX_TOKEN", default="")

MAP_DEFAULT_CENTER = REGION["maps"].get("default_center", [55.75, 37.61])
MAP_DEFAULT_ZOOM = REGION["maps"].get("default_zoom", 11)

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "corsheaders",
    "django_cryptography",
    "drf_spectacular",
    "accounts",
    "vehicles",
    "parking",
    "payments",
    "ai",
    "core",
]

MIDDLEWARE = [
    "core.middleware.RateLimitMiddleware",
    "core.metrics.RequestMetricsMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "core.middleware.SecurityHeadersMiddleware",
    "core.middleware.MaintenanceModeMiddleware",
    "django.middleware.gzip.GZipMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "backend.backend.config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "core.context_processors.global_settings",
            ],
        },
    },
]

WSGI_APPLICATION = "backend.backend.config.wsgi.application"
ASGI_APPLICATION = "backend.backend.config.asgi.application"

DATABASES = {
    "default": env.db(
        "DATABASE_URL", default=f"sqlite:///{BASE_DIR / 'db.sqlite3'}"
    )
}

if DATABASES["default"]["ENGINE"] == "django.db.backends.postgresql":
    DATABASES["default"]["ENGINE"] = "django.contrib.gis.db.backends.postgis"

DATABASE_REPLICA_URL = env("DATABASE_REPLICA_URL", default="")
if DATABASE_REPLICA_URL:
    DATABASES["replica"] = env.db("DATABASE_REPLICA_URL")
    if DATABASES["replica"]["ENGINE"] == "django.db.backends.postgresql":
        DATABASES["replica"]["ENGINE"] = "django.contrib.gis.db.backends.postgis"

DATABASE_ROUTERS = (
    ["core.db_router.ReadReplicaRouter"] if "replica" in DATABASES else []
)

AUTH_USER_MODEL = "accounts.User"

AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator", "OPTIONS": {"min_length": 8}},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

LANGUAGE_CODE = env("LANGUAGE_CODE", default="ru-ru")
TIME_ZONE = env("TIME_ZONE", default="Europe/Moscow")
USE_I18N = True
USE_L10N = True
USE_TZ = True

STATIC_URL = "/static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [BASE_DIR / "static"]

MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"

PWA_APP_NAME = "ParkShare RU"
PWA_APP_SHORT_NAME = "ParkShare"
PWA_THEME_COLOR = "#0d6efd"
PWA_BACKGROUND_COLOR = "#050816"

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "accounts.authentication.JWTAuthentication",
        "rest_framework.authentication.SessionAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticatedOrReadOnly",
    ],
    "DEFAULT_PAGINATION_CLASS": "core.pagination.DefaultPageNumberPagination",
    "PAGE_SIZE": 20,
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
}

SPECTACULAR_SETTINGS = {
    "TITLE": "ParkShare RU API",
    "DESCRIPTION": "API сервиса бронирования парковочных мест ParkShare RU.",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": False,
}

CORS_ALLOWED_ORIGINS = env.list("CORS_ALLOWED_ORIGINS", default=[])
CORS_ALLOWED_ORIGIN_REGEXES = env.list("CORS_ALLOWED_ORIGIN_REGEXES", default=[])
CORS_ALLOW_CREDENTIALS = True
CSRF_TRUSTED_ORIGINS = env.list("CSRF_TRUSTED_ORIGINS", default=[])

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=15),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
    "ROTATE_REFRESH_TOKENS": True,
    "BLACKLIST_AFTER_ROTATION": True,
    "ALGORITHM": "HS256",
    "SIGNING_KEY": SECRET_KEY,
    "AUTH_HEADER_TYPES": ("Bearer",),
    "AUTH_TOKEN_CLASSES": ("rest_framework_simplejwt.tokens.AccessToken",),
    "UPDATE_LAST_LOGIN": True,
}

REDIS_URL = env("REDIS_URL", default="redis://redis:6379/0")

CELERY_BROKER_URL = env("CELERY_BROKER_URL", default=REDIS_URL)
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND", default=REDIS_URL)
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TIMEZONE = TIME_ZONE

CELERY_BEAT_SCHEDULE = {
    "expire_unpaid_bookings": {"task": "parking.tasks.expire_unpaid_bookings", "schedule": 60 * 10},
    "update_ai_models": {"task": "ai.tasks.update_models", "schedule": 60 * 60},
    "check_stale_payments": {"task": "payments.tasks.check_stale_payments", "schedule": 60 * 15},
}

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {"format": "[{asctime}] {levelname} {name} {message}", "style": "{"},
        "simple": {"format": "{levelname} {message}", "style": "{"},
    },
    "handlers": {
        "console": {"class": "logging.StreamHandler", "formatter": "verbose"},
    },
    "loggers": {
        "django": {"handlers": ["console"], "level": "INFO"},
        "parkshare": {"handlers": ["console"], "level": "INFO"},
        "ai": {"handlers": ["console"], "level": "DEBUG", "propagate": False},
        "services": {"handlers": ["console"], "level": "DEBUG", "propagate": False},
    },
}

MAINTENANCE_MODE = env.bool("MAINTENANCE_MODE", default=False)
ENABLE_EXPERIMENTAL_ASSISTANT = env.bool("ENABLE_EXPERIMENTAL_ASSISTANT", default=True)
ENABLE_AB_VARIANTS = env.bool("ENABLE_AB_VARIANTS", default=True)

EMAIL_BACKEND = env(
    "EMAIL_BACKEND",
    default="django.core.mail.backends.console.EmailBackend",
)
DEFAULT_FROM_EMAIL = env(
    "DEFAULT_FROM_EMAIL",
    default="ParkShare RU <noreply@example.com>",
)
SERVER_EMAIL = env("SERVER_EMAIL", default=DEFAULT_FROM_EMAIL)

SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=False)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=False)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=False)
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = False
SESSION_COOKIE_SAMESITE = "Lax"
CSRF_COOKIE_SAMESITE = "Lax"
X_FRAME_OPTIONS = "DENY"
SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")

CONTENT_SECURITY_POLICY = env(
    "CONTENT_SECURITY_POLICY",
    default=(
        "default-src 'self'; "
        "script-src 'self' 'unsafe-inline' https:; "
        "style-src 'self' 'unsafe-inline' https:; "
        "img-src 'self' data: https:; "
        "connect-src 'self' https:; "
        "font-src 'self' https: data:; "
        "frame-ancestors 'none'; "
        "form-action 'self';"
    ),
)

if DEBUG:
    X_FRAME_OPTIONS = "SAMEORIGIN"
    CONTENT_SECURITY_POLICY = (
        "default-src 'self'; "
        "script-src 'self' 'unsafe-inline' https:; "
        "style-src 'self' 'unsafe-inline' https:; "
        "img-src 'self' data: https:; "
        "connect-src 'self' https: http://localhost:3000 http://127.0.0.1:3000; "
        "font-src 'self' https: data:; "
        "frame-src 'self' http://localhost:3000 http://127.0.0.1:3000; "
        "frame-ancestors 'self'; "
        "form-action 'self';"
    )

REFERRER_POLICY = env("REFERRER_POLICY", default="strict-origin-when-cross-origin")
PERMISSIONS_POLICY = env(
    "PERMISSIONS_POLICY",
    default="geolocation=(self), camera=(), microphone=(), payment=()",
)

CROSS_ORIGIN_OPENER_POLICY = env("CROSS_ORIGIN_OPENER_POLICY", default="")
CROSS_ORIGIN_EMBEDDER_POLICY = env("CROSS_ORIGIN_EMBEDDER_POLICY", default="")
CROSS_ORIGIN_RESOURCE_POLICY = env("CROSS_ORIGIN_RESOURCE_POLICY", default="")

RATE_LIMIT_CACHE = env("RATE_LIMIT_CACHE", default="default")
RATE_LIMIT_WINDOW = env.int("RATE_LIMIT_WINDOW", default=60)
RATE_LIMIT_REQUESTS = env.int("RATE_LIMIT_REQUESTS", default=120)
RATE_LIMIT_WHITELIST = env.list("RATE_LIMIT_WHITELIST", default=["127.0.0.1", "::1"])

DJANGO_CRYPTography_KEY = SECRET_KEY

VEHICLE_PLATE_SALT = env("VEHICLE_PLATE_SALT", default="change_me_vehicle_salt")

YOOKASSA_SHOP_ID = env("YOOKASSA_SHOP_ID", default="")
YOOKASSA_SECRET_KEY = env("YOOKASSA_SECRET_KEY", default="")
YOOKASSA_RETURN_URL = env("YOOKASSA_RETURN_URL", default="")
YOOKASSA_WEBHOOK_SECRET = env("YOOKASSA_WEBHOOK_SECRET", default="")
STRIPE_SECRET_KEY = env("STRIPE_SECRET_KEY", default="")
STRIPE_WEBHOOK_SECRET = env("STRIPE_WEBHOOK_SECRET", default="")
DEFAULT_PAYMENT_PROVIDER = env(
    "PAYMENT_PROVIDER",
    default="yookassa" if PLATFORM_MODE == "RU" else "stripe",
)

SERVICE_COMMISSION_PERCENT = env.int("SERVICE_COMMISSION_PERCENT", default=10)

AUTH_OTP_CODE_TTL_SECONDS = env.int("AUTH_OTP_CODE_TTL_SECONDS", default=600)
AUTH_OTP_WINDOW_SECONDS = env.int("AUTH_OTP_WINDOW_SECONDS", default=600)
AUTH_OTP_MAX_PER_WINDOW = env.int("AUTH_OTP_MAX_PER_WINDOW", default=5)
AUTH_OTP_MAX_ATTEMPTS = env.int("AUTH_OTP_MAX_ATTEMPTS", default=5)

SMS_PROVIDER = env.str("SMS_PROVIDER", default="console")
SMS_DEFAULT_FROM = env.str("SMS_DEFAULT_FROM", default="ParkShare")

ENABLE_METRICS = env.bool("ENABLE_METRICS", default=True)

SOCIAL_OAUTH_CONFIG = {
    "vk": {
        "client_id": env.str("VK_OAUTH_CLIENT_ID", default=""),
        "client_secret": env.str("VK_OAUTH_CLIENT_SECRET", default=""),
    },
    "yandex": {
        "client_id": env.str("YANDEX_OAUTH_CLIENT_ID", default=""),
        "client_secret": env.str("YANDEX_OAUTH_CLIENT_SECRET", default=""),
    },
    "google": {
        "client_id": env.str("GOOGLE_OAUTH_CLIENT_ID", default=""),
        "client_secret": env.str("GOOGLE_OAUTH_CLIENT_SECRET", default=""),
    },
}
SOCIAL_OAUTH_TEST_MODE = env.bool("SOCIAL_OAUTH_TEST_MODE", default=False)

CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
        "LOCATION": "parkshare_cache",
    }
}

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 92
PATH: backend\backend\settings\local.py
LANG: python
===== CONTENT START =====
from .base import *  # noqa: F401,F403

# Локальная разработка

DEBUG = env.bool("DEBUG", default=True)
ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=["127.0.0.1", "localhost"])

INTERNAL_IPS = ["127.0.0.1"]

SECURE_SSL_REDIRECT = False
SESSION_COOKIE_SECURE = False
CSRF_COOKIE_SECURE = False

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 93
PATH: backend\backend\settings\production.py
LANG: python
===== CONTENT START =====
from django.core.exceptions import ImproperlyConfigured

from .base import *  # noqa: F401,F403

DEBUG = False

ALLOWED_HOSTS = env.list("ALLOWED_HOSTS", default=[])
if not ALLOWED_HOSTS:
    raise ImproperlyConfigured(
        "В продакшене ALLOWED_HOSTS не должен быть пустым. "
        "Задайте ALLOWED_HOSTS в .env"
    )

SECURE_SSL_REDIRECT = env.bool("SECURE_SSL_REDIRECT", default=True)
SESSION_COOKIE_SECURE = env.bool("SESSION_COOKIE_SECURE", default=True)
CSRF_COOKIE_SECURE = env.bool("CSRF_COOKIE_SECURE", default=True)
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = False
SESSION_COOKIE_SAMESITE = env("SESSION_COOKIE_SAMESITE", default="Lax")
CSRF_COOKIE_SAMESITE = env("CSRF_COOKIE_SAMESITE", default="Lax")

SECURE_HSTS_SECONDS = env.int("SECURE_HSTS_SECONDS", default=60 * 60 * 24)
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 94
PATH: backend\backend\settings\regions.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

"""
Региональные профили ParkShare.

RU — основной профиль (ParkShare RU) с Яндекс.Картами, российскими платёжками
и провайдерами аутентификации.

EU/US — заготовки для будущих рынков.
"""

REGION_PROFILES = {
    "RU": {
        "code": "RU",
        "name": "Russia",
        "maps": {
            # Важно: логические идентификаторы, а не "маркетинговые" названия
            "primary": "yandex",
            "fallback": "leaflet",
            "language": "ru_RU",
            "default_center": [55.75, 37.61],  # Москва
            "default_zoom": 11,
        },
        "payments": {
            "required": [
                "sberbank_online",
                "tinkoff",
                "yoomoney",
                "mir_pay",
                "qiwi",
            ],
        },
        "auth": [
            "gosuslugi",
            "vk_id",
            "yandex_id",
            "sber_id",
        ],
        "holidays": {
            "provider": "ru_holidays",
        },
    },
    "EU": {
        "code": "EU",
        "name": "European Union",
        "maps": {
            "primary": "leaflet",
            "fallback": "leaflet",
            "language": "en_US",
            "default_center": [52.52, 13.405],  # Берлин как условный центр
            "default_zoom": 11,
        },
        "payments": {
            "required": [
                "visa_mastercard",
            ],
        },
        "auth": ["email_password"],
        "holidays": {
            "provider": "eu_holidays",
        },
    },
    "US": {
        "code": "US",
        "name": "United States",
        "maps": {
            "primary": "leaflet",
            "fallback": "leaflet",
            "language": "en_US",
            "default_center": [40.7128, -74.0060],  # Нью-Йорк
            "default_zoom": 11,
        },
        "payments": {
            "required": [
                "visa_mastercard",
                "apple_pay",
                "google_pay",
            ],
        },
        "auth": ["email_password"],
        "holidays": {
            "provider": "us_holidays",
        },
    },
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 95
PATH: backend\rest_framework_simplejwt\__init__.py
LANG: python
===== CONTENT START =====
"""Stub for rest_framework_simplejwt to allow offline checks."""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 96
PATH: backend\rest_framework_simplejwt\authentication.py
LANG: python
===== CONTENT START =====
from rest_framework.authentication import BaseAuthentication


class JWTAuthentication(BaseAuthentication):
    def authenticate(self, request):
        return None

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 97
PATH: backend\rest_framework_simplejwt\tokens.py
LANG: python
===== CONTENT START =====
class RefreshToken:
    @classmethod
    def for_user(cls, user):
        return cls()

    def __str__(self):
        return "stub-token"

    @property
    def access_token(self):
        return "stub-access"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 98
PATH: backend\rest_framework_simplejwt\views.py
LANG: python
===== CONTENT START =====
from rest_framework.response import Response
from rest_framework.views import APIView


class TokenObtainPairView(APIView):
    def post(self, request, *args, **kwargs):
        return Response({"access": "stub", "refresh": "stub"})


class TokenRefreshView(APIView):
    def post(self, request, *args, **kwargs):
        return Response({"access": "stub"})


class TokenRefreshSlidingView(TokenRefreshView):
    pass

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 99
PATH: backend\tests\__init__.py
LANG: python
===== CONTENT START =====
# Пакет с базовыми тестами проекта ParkShare RU.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 100
PATH: backend\tests\test_access_control.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from accounts.models import User


class AccessControlTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="user", password="pass")

    def test_metrics_requires_staff(self):
        self.client.login(username="user", password="pass")
        resp = self.client.get(reverse("metrics_dashboard"))
        self.assertEqual(resp.status_code, 302)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 101
PATH: backend\tests\test_analytics.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.utils import timezone
from accounts.models import User
from ai.models import DeviceProfile, UiEvent, ChatSession
from parking.models import ParkingLot, ParkingSpot, Booking
from parking import analytics


class AnalyticsTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="ana", password="pass")
        self.profile = DeviceProfile.objects.create(user=self.user, device_id="devana")
        lot = ParkingLot.objects.create(
            owner=self.user,
            name="Lot",
            city="Москва",
            address="Адрес",
            latitude=55.75,
            longitude=37.61,
            is_active=True,
            is_approved=True,
        )
        self.spot = ParkingSpot.objects.create(
            lot=lot,
            name="S1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=100,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )

    def test_compute_funnel_counts(self):
        UiEvent.objects.create(device_profile=self.profile, event_type="map_open")
        UiEvent.objects.create(device_profile=self.profile, event_type="spot_select")
        UiEvent.objects.create(device_profile=self.profile, event_type="booking_confirm_open")
        Booking.objects.create(
            user=self.user,
            spot=self.spot,
            start_at=timezone.now(),
            end_at=timezone.now() + timezone.timedelta(hours=1),
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=Booking.BillingMode.PAYG,
            total_price=100,
            status=Booking.Status.CONFIRMED,
        )
        ChatSession.objects.create(user=self.user)
        data = analytics.compute_funnel(7)
        self.assertGreaterEqual(data["funnel"]["map_open"], 1)
        self.assertGreaterEqual(data["funnel"]["booking_created"], 1)
        self.assertGreaterEqual(data["assistant_sessions"], 1)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 102
PATH: backend\tests\test_assistant_tools.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from accounts.models import User
from parking.models import ParkingLot, ParkingSpot, FavoriteParkingSpot
from ai import tools
from ai.tools import ToolError
from django.utils import timezone


class AssistantToolsTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="tool", password="pass")
        lot = ParkingLot.objects.create(
            owner=self.user,
            name="Lot",
            city="Москва",
            address="Адрес",
            latitude=55.75,
            longitude=37.61,
            is_active=True,
            is_approved=True,
        )
        self.spot = ParkingSpot.objects.create(
            lot=lot,
            name="S1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=100,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )

    def test_search_parking(self):
        results = tools.search_parking({"city": "Москва"}, self.user)
        self.assertTrue(any(r["id"] == str(self.spot.id) for r in results))

    def test_toggle_favorite(self):
        res = tools.toggle_favorite(self.user, str(self.spot.id))
        self.assertTrue(res["favorite"])
        res2 = tools.toggle_favorite(self.user, str(self.spot.id))
        self.assertFalse(res2["favorite"])

    def test_booking_requires_auth(self):
        with self.assertRaises(ToolError):
            tools.create_booking(None, str(self.spot.id), {"hours": 1})

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 103
PATH: backend\tests\test_auth_api.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from rest_framework.test import APIClient


class AuthApiTests(TestCase):
    def setUp(self) -> None:
        self.client = APIClient()
        self.password = "StrongPass123"

    def test_register_and_login_by_username_email_and_phone(self):
        # Регистрация
        resp = self.client.post(
            "/api/accounts/users/register/",
            {
                "username": "demo",
                "password": self.password,
                "email": "demo@example.com",
                "phone": "+7 (999) 123-45-67",
            },
            format="json",
        )
        self.assertEqual(resp.status_code, 201)
        self.client.logout()

        # Логин по логину
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "demo", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(resp.data["username"], "demo")
        self.client.logout()

        # Логин по email
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "demo@example.com", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)
        self.client.logout()

        # Логин по телефону (в любом удобном формате)
        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": "+7 999 123-45-67", "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 104
PATH: backend\tests\test_auth_mfa.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from datetime import timedelta

import pyotp
from django.test import TestCase, override_settings
from django.utils import timezone
from rest_framework.exceptions import AuthenticationFailed
from rest_framework.test import APIClient

from accounts.authentication import JWTAuthentication
from accounts.models import SocialAccount, User


class MFATestCase(TestCase):
    def setUp(self) -> None:
        self.client = APIClient()
        self.password = "StrongPass123"

    def _create_totp_user(self) -> tuple[User, str]:
        secret = pyotp.random_base32()
        user = User.objects.create_user(username="mfa_user", password=self.password)
        user.mfa_enabled = True
        user.mfa_method = User.MFAMethod.TOTP
        user.mfa_secret = secret
        user.save()
        return user, secret

    def test_totp_mfa_flow(self):
        user, secret = self._create_totp_user()

        resp = self.client.post(
            "/api/accounts/users/login/",
            {"identifier": user.username, "password": self.password},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)
        self.assertTrue(resp.data.get("mfa_required"))

        code = pyotp.TOTP(secret).now()
        resp = self.client.post("/api/auth/mfa/verify/", {"code": code}, format="json")
        self.assertEqual(resp.status_code, 200)
        self.assertIn("access", resp.data)
        self.assertEqual(resp.data["user"]["id"], str(user.pk))

    def test_totp_mfa_rejects_wrong_code(self):
        user, _ = self._create_totp_user()
        self.client.post(
            "/api/accounts/users/login/",
            {"identifier": user.username, "password": self.password},
            format="json",
        )
        resp = self.client.post(
            "/api/auth/mfa/verify/", {"code": "000000"}, format="json"
        )
        self.assertEqual(resp.status_code, 400)

    @override_settings(SOCIAL_OAUTH_TEST_MODE=True)
    def test_oauth_callback_with_mfa_redirects(self):
        user, secret = self._create_totp_user()
        social = SocialAccount.objects.create(
            user=user,
            provider=SocialAccount.Provider.VK,
            external_id="demo",
        )
        social.save()
        session = self.client.session
        session["oauth_state_vk"] = "abc"
        session.save()

        resp = self.client.get("/auth/oauth/vk/callback/?state=abc&code=test_demo")
        self.assertEqual(resp.status_code, 302)
        self.assertIn("/accounts/mfa/verify", resp["Location"])
        session = self.client.session
        self.assertEqual(session.get("pre_auth_user_id"), str(user.pk))

        code = pyotp.TOTP(secret).now()
        resp = self.client.post("/auth/mfa/verify/", {"code": code})
        self.assertIn(resp.status_code, (200, 302))

    def test_jwt_rejected_after_password_change(self):
        user = User.objects.create_user(username="jwt_user", password=self.password)
        user.last_password_change = timezone.now()
        user.save(update_fields=["last_password_change"])

        stale_token = {
            "user_id": str(user.id),
            "iat": int((timezone.now() - timedelta(days=1)).timestamp()),
        }
        auth = JWTAuthentication()
        with self.assertRaises(AuthenticationFailed):
            auth.get_user(stale_token)

    def test_other_sessions_invalidated_on_password_change(self):
        user = User.objects.create_user(username="multi", password=self.password)

        client_a = APIClient()
        client_b = APIClient()
        for c in (client_a, client_b):
            resp = c.post(
                "/api/accounts/users/login/",
                {"identifier": user.username, "password": self.password},
                format="json",
            )
            self.assertEqual(resp.status_code, 200)

        resp = client_a.post(
            "/api/accounts/users/change-password/",
            {"old_password": self.password, "new_password": "NewPass123!"},
            format="json",
        )
        self.assertEqual(resp.status_code, 200)

        resp_after = client_b.get("/api/accounts/users/me/")
        self.assertEqual(resp_after.status_code, 403)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 105
PATH: backend\tests\test_billing_modes.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.utils import timezone
from accounts.models import User
from parking.models import ParkingLot, ParkingSpot, Booking


class BillingModesTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="u1", password="pass")
        self.lot = ParkingLot.objects.create(
            owner=self.user,
            name="Test Lot",
            city="Москва",
            address="Тестовая 1",
            latitude=55.75,
            longitude=37.61,
            is_approved=True,
            is_active=True,
        )
        self.spot = ParkingSpot.objects.create(
            lot=self.lot,
            name="A1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=100,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )

    def test_payg_price(self):
        start = timezone.now()
        end = start + timezone.timedelta(hours=1)
        booking = Booking(
            user=self.user,
            spot=self.spot,
            start_at=start,
            end_at=end,
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=Booking.BillingMode.PAYG,
            total_price=0,
        )
        price = booking.calculate_price()
        self.assertEqual(float(price), 100.0)

    def test_payg_rounds_15_minutes(self):
        start = timezone.now()
        end = start + timezone.timedelta(minutes=20)
        booking = Booking(
            user=self.user,
            spot=self.spot,
            start_at=start,
            end_at=end,
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=Booking.BillingMode.PAYG,
            total_price=0,
        )
        price = booking.calculate_price()
        # 20 минут -> 0.5 часа
        self.assertEqual(float(price), 50.0)

    def test_prepaid_block_price_rounds_up(self):
        start = timezone.now()
        end = start + timezone.timedelta(hours=1)
        booking = Booking(
            user=self.user,
            spot=self.spot,
            start_at=start,
            end_at=end,
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=Booking.BillingMode.PREPAID_BLOCK,
            total_price=0,
        )
        # emulate block of 2 hours
        booking.end_at = start + timezone.timedelta(hours=2)
        price = booking.calculate_price()
        self.assertEqual(float(price), 200.0)

    def test_prepaid_block_to_four_hours(self):
        start = timezone.now()
        end = start + timezone.timedelta(hours=3, minutes=10)
        booking = Booking(
            user=self.user,
            spot=self.spot,
            start_at=start,
            end_at=end,
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=Booking.BillingMode.PREPAID_BLOCK,
            total_price=0,
        )
        price = booking.calculate_price()
        self.assertEqual(float(price), 400.0)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 106
PATH: backend\tests\test_booking_model.py
LANG: python
===== CONTENT START =====
from datetime import timedelta
from decimal import Decimal

from django.test import TestCase
from django.utils import timezone

from accounts.models import User
from parking.models import Booking, ParkingLot, ParkingSpot


class BookingModelTests(TestCase):
    def setUp(self) -> None:
        self.owner = User.objects.create_user(
            username="owner",
            password="StrongPass123",
            role=User.Role.OWNER,
        )
        self.driver = User.objects.create_user(
            username="driver",
            password="StrongPass123",
            role=User.Role.DRIVER,
        )

        self.lot = ParkingLot.objects.create(
            owner=self.owner,
            name="Test Lot",
            city="Test City",
            address="Test street, 1",
        )
        self.spot = ParkingSpot.objects.create(
            lot=self.lot,
            name="A1",
            hourly_price=Decimal("100.00"),
        )

    def test_calculate_price_hourly_with_commission(self):
        now = timezone.now()
        booking = Booking(
            user=self.driver,
            spot=self.spot,
            booking_type=Booking.BookingType.HOURLY,
            start_at=now,
            end_at=now + timedelta(hours=1, minutes=30),
            total_price=Decimal("0.00"),
            currency="RUB",
        )
        total = booking.calculate_price()
        # 2 часа * 100 ₽ + 10% комиссии = 220
        self.assertEqual(total, Decimal("220.00"))

    def test_is_spot_available(self):
        now = timezone.now()
        existing = Booking.objects.create(
            user=self.driver,
            spot=self.spot,
            booking_type=Booking.BookingType.HOURLY,
            start_at=now,
            end_at=now + timedelta(hours=2),
            status=Booking.Status.CONFIRMED,
            total_price=Decimal("200.00"),
            currency="RUB",
        )

        # Пересекающийся интервал — недоступен
        self.assertFalse(
            Booking.is_spot_available(
                self.spot,
                now + timedelta(minutes=30),
                now + timedelta(hours=3),
            )
        )

        # Непересекающийся интервал — доступен
        self.assertTrue(
            Booking.is_spot_available(
                self.spot,
                existing.end_at + timedelta(minutes=1),
                existing.end_at + timedelta(hours=1),
            )
        )

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 107
PATH: backend\tests\test_business_reports.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from django.utils import timezone

from accounts.models import User
from parking.models import ParkingLot, ParkingSpot, Booking


class BusinessReportsViewTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="biz", password="pass")
        self.client.login(username="biz", password="pass")
        lot = ParkingLot.objects.create(
            owner=self.user,
            name="Lot",
            city="Москва",
            address="Адрес 1",
            latitude=55.75,
            longitude=37.61,
        )
        spot = ParkingSpot.objects.create(
            lot=lot,
            name="S1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=100,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )
        now = timezone.now()
        for i in range(2):
            b = Booking.objects.create(
                user=self.user,
                spot=spot,
                start_at=now - timezone.timedelta(days=i),
                end_at=now - timezone.timedelta(days=i) + timezone.timedelta(hours=1),
                booking_type=Booking.BookingType.HOURLY,
                billing_mode=Booking.BillingMode.PAYG,
                total_price=100,
                status=Booking.Status.CONFIRMED,
                ai_snapshot={"business_trip": True},
            )
            b.calculate_price()

    def test_reports_page(self):
        resp = self.client.get(reverse("business_reports"))
        self.assertEqual(resp.status_code, 200)
        self.assertIn("bookings", resp.context)
        self.assertGreaterEqual(len(resp.context["bookings"]), 1)

    def test_csv_export(self):
        resp = self.client.get(reverse("business_reports") + "?export=csv")
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(resp["Content-Type"], "text/csv")
        content = resp.content.decode("utf-8")
        self.assertIn("Режим биллинга", content)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 108
PATH: backend\tests\test_error_formats.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from accounts.models import User


class ErrorFormatTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="err", password="pass")
        self.client.login(username="err", password="pass")

    def test_payment_invalid_card_error_shape(self):
        resp = self.client.post(
            reverse("payment_methods_page"),
            {"card_number": "123", "exp": "12/30"},
            HTTP_ACCEPT="application/json",
        )
        self.assertEqual(resp.status_code, 400)
        data = resp.json()
        self.assertIn("code", data)
        self.assertIn("message", data)

    def test_promo_invalid_error_shape(self):
        resp = self.client.post(reverse("promo_activate"), {"code": "NOPE"}, HTTP_ACCEPT="application/json")
        self.assertEqual(resp.status_code, 400)
        data = resp.json()
        self.assertEqual(data["code"], "invalid_promo")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 109
PATH: backend\tests\test_health.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse


class HealthChecksTests(TestCase):
    def test_healthz(self):
        resp = self.client.get(reverse("healthz"))
        self.assertEqual(resp.status_code, 200)
        self.assertJSONEqual(resp.content, {"status": "ok"})

    def test_readyz(self):
        resp = self.client.get(reverse("readyz"))
        self.assertEqual(resp.status_code, 200)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 110
PATH: backend\tests\test_input_limits.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from accounts.models import User


class InputLimitsTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="limit", password="pass")
        self.client.login(username="limit", password="pass")

    def test_promo_length_limit(self):
        code = "X" * 200
        resp = self.client.post(reverse("promo_activate"), {"code": code}, HTTP_ACCEPT="application/json")
        self.assertEqual(resp.status_code, 400)
        data = resp.json()
        self.assertEqual(data["code"], "invalid_promo")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 111
PATH: backend\tests\test_maintenance_mode.py
LANG: python
===== CONTENT START =====
from django.test import TestCase, override_settings
from django.urls import reverse
from accounts.models import User
from parking.models import ParkingLot, ParkingSpot


@override_settings(MAINTENANCE_MODE=True)
class MaintenanceModeTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="m1", password="pass")
        self.client.login(username="m1", password="pass")
        lot = ParkingLot.objects.create(
            owner=self.user,
            name="Lot",
            city="Москва",
            address="Адрес",
            latitude=55.75,
            longitude=37.61,
            is_active=True,
            is_approved=True,
        )
        self.spot = ParkingSpot.objects.create(
            lot=lot,
            name="S1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=100,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )

    def test_booking_blocked(self):
        resp = self.client.post(reverse("booking_confirm"), {"spot_id": self.spot.id, "hours": 1})
        self.assertEqual(resp.status_code, 503)

    def test_payment_blocked(self):
        resp = self.client.post(reverse("payment_methods_page"), {"card_number": "4111111111111111", "exp": "12/30"})
        self.assertEqual(resp.status_code, 200)  # HTML path shows banner message

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 112
PATH: backend\tests\test_notification_scheduling.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.utils import timezone
from accounts.models import User
from parking.models import ParkingLot, ParkingSpot, Booking, PushSubscription
from parking.models_notification import NotificationSettings
from parking.notifications import bookings_expiring_within


class NotificationSchedulingTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="notif2", password="pass")
        NotificationSettings.objects.create(user=self.user)
        lot = ParkingLot.objects.create(
            owner=self.user,
            name="Lot",
            city="Москва",
            address="Адрес",
            latitude=55.75,
            longitude=37.61,
            is_active=True,
            is_approved=True,
        )
        self.spot = ParkingSpot.objects.create(
            lot=lot,
            name="S1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=100,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )
        PushSubscription.objects.create(user=self.user, endpoint="e1", p256dh="p", auth="a")

    def test_booking_expiring_detected(self):
        start = timezone.now()
        end = start + timezone.timedelta(minutes=10)
        Booking.objects.create(
            user=self.user,
            spot=self.spot,
            start_at=start,
            end_at=end,
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=Booking.BillingMode.PAYG,
            total_price=100,
            status=Booking.Status.CONFIRMED,
        )
        eligible = bookings_expiring_within(15)
        self.assertEqual(len(eligible), 1)

    def test_disabled_notifications_not_selected(self):
        start = timezone.now()
        end = start + timezone.timedelta(minutes=10)
        Booking.objects.create(
            user=self.user,
            spot=self.spot,
            start_at=start,
            end_at=end,
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=Booking.BillingMode.PAYG,
            total_price=100,
            status=Booking.Status.CONFIRMED,
        )
        self.user.notification_settings.notify_booking_expiry = False
        self.user.notification_settings.save()
        eligible = bookings_expiring_within(15)
        self.assertEqual(len(eligible), 0)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 113
PATH: backend\tests\test_notification_settings.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from accounts.models import User
from parking.models_notification import NotificationSettings


class NotificationSettingsTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="notif", password="pass")
        self.client.login(username="notif", password="pass")

    def test_toggle_settings(self):
        resp = self.client.post(
            reverse("profile_settings"),
            {"notify_booking_expiry": "on", "notify_night_restrictions": "on"},
        )
        self.assertEqual(resp.status_code, 200)
        ns = NotificationSettings.objects.get(user=self.user)
        self.assertTrue(ns.notify_booking_expiry)
        self.assertTrue(ns.notify_night_restrictions)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 114
PATH: backend\tests\test_offline_onboarding.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from django.template.loader import render_to_string


class OfflineOnboardingTests(TestCase):
    def test_offline_template_renders(self):
        resp = self.client.get(reverse("offline"))
        self.assertEqual(resp.status_code, 200)
        self.assertContains(resp, "Оффлайн-режим")

    def test_base_has_onboarding_markup(self):
        html = render_to_string("base.html")
        self.assertIn("data-onboarding", html)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 115
PATH: backend\tests\test_payment_methods_view.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from accounts.models import User
from payments.models import PaymentMethod


class PaymentMethodsViewTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="pay", password="pass")
        self.client.login(username="pay", password="pass")

    def test_get_methods_page(self):
        resp = self.client.get(reverse("payment_methods_page"))
        self.assertEqual(resp.status_code, 200)
        self.assertIn("methods", resp.context)

    def test_add_and_delete_method(self):
        resp = self.client.post(
            reverse("payment_methods_page"),
            {"card_number": "4111111111111111", "exp": "12/30", "label": "Test"},
        )
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(PaymentMethod.objects.filter(user=self.user).count(), 1)
        pm = PaymentMethod.objects.get(user=self.user)
        resp_del = self.client.post(reverse("payment_methods_page"), {"delete_id": pm.id})
        self.assertEqual(resp_del.status_code, 200)
        self.assertEqual(PaymentMethod.objects.filter(user=self.user).count(), 0)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 116
PATH: backend\tests\test_preferences_view.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from accounts.models import User
from ai.models import DeviceProfile, UiEvent


class PreferencesViewTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="prefs", password="pass")
        self.client.login(username="prefs", password="pass")
        self.profile = DeviceProfile.objects.create(user=self.user, device_id="dev1")
        UiEvent.objects.create(device_profile=self.profile, event_type="preferences", payload={"prefers_ev": True})

    def test_get_shows_preferences(self):
        resp = self.client.get(reverse("profile_settings"))
        self.assertEqual(resp.status_code, 200)
        self.assertIn("preferences", resp.context)

    def test_reset_preferences(self):
        resp = self.client.post(reverse("profile_settings"), {"reset_prefs": "1"})
        self.assertEqual(resp.status_code, 200)
        self.assertEqual(UiEvent.objects.filter(device_profile=self.profile, event_type="preferences").count(), 0)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 117
PATH: backend\tests\test_promo_activate.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse
from accounts.models import User, PromoReward


class PromoActivateTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="promo", password="pass")
        self.client.login(username="promo", password="pass")
        self.reward = PromoReward.objects.create(code="PROMO1", description="Бонус")

    def test_activate_valid(self):
        resp = self.client.post(reverse("promo_activate"), {"code": "PROMO1"}, HTTP_ACCEPT="application/json")
        self.assertEqual(resp.status_code, 200)
        self.assertJSONEqual(resp.content, {"message": "Промокод применён: Бонус"})

    def test_activate_invalid(self):
        resp = self.client.post(reverse("promo_activate"), {"code": "BAD"}, HTTP_ACCEPT="application/json")
        self.assertEqual(resp.status_code, 400)
        data = resp.json()
        self.assertEqual(data["code"], "invalid_promo")
        self.assertIn("Промокод недействителен", data["message"])

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 118
PATH: backend\tests\test_security_headers.py
LANG: python
===== CONTENT START =====
from django.test import TestCase
from django.urls import reverse


class SecurityHeadersTests(TestCase):
    def test_headers_present(self):
        resp = self.client.get(reverse("landing"))
        self.assertIn("Content-Security-Policy", resp.headers)
        self.assertEqual(resp.headers.get("X-Content-Type-Options"), "nosniff")
        self.assertIn("Referrer-Policy", resp.headers)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 119
PATH: backend\tests\test_ui_theme_chat.py
LANG: python
===== CONTENT START =====
from django.contrib.auth import get_user_model
from django.test import Client, TestCase
from django.urls import reverse


class UIThemeTests(TestCase):
    def setUp(self):
        self.client = Client()

    def test_landing_has_theme_toggle(self):
        response = self.client.get(reverse("landing"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "ParkShare")
        self.assertContains(response, "data-theme-toggle")
        self.assertContains(response, "data-search-bar")
        self.assertContains(response, "data-map-panel")
        self.assertContains(response, "data-spots-list")
        self.assertContains(response, "Рекомендации")
        self.assertContains(response, 'data-nav="assistant"')
        self.assertContains(response, "data-geocode-input")

    def test_map_page_renders(self):
        response = self.client.get(reverse("map_page"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-map-panel")

    def test_assistant_page_renders(self):
        response = self.client.get(reverse("ai_chat"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-ai-chat")
        self.assertContains(response, "ps-ai-prompts")
        self.assertContains(response, "data-ai-send")

    def test_bookings_page_for_user(self):
        User = get_user_model()
        user = User.objects.create_user(username="demo", password="pass")
        self.client.login(username="demo", password="pass")
        response = self.client.get(reverse("user_dashboard"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-route=\"bookings\"")
        self.assertContains(response, "Мои бронирования")

    def test_owner_page_for_owner_role(self):
        User = get_user_model()
        owner = User.objects.create_user(username="owner", password="pass", role=User.Role.OWNER)
        self.client.login(username="owner", password="pass")
        response = self.client.get(reverse("owner_dashboard"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "data-route=\"parking\"")


class ChatAPITests(TestCase):
    def setUp(self):
        self.client = Client()

    def test_chat_api_requires_messages(self):
        response = self.client.post("/api/chat/", data={}, content_type="application/json")
        self.assertEqual(response.status_code, 400)

    def test_chat_api_returns_text(self):
        payload = {"messages": [{"role": "user", "content": "Привет"}]}
        response = self.client.post("/api/chat/", data=payload, content_type="application/json")
        self.assertEqual(response.status_code, 200)
        self.assertIn("text/plain", response.headers.get("Content-Type", ""))

    def test_chat_api_rejects_wrong_type(self):
        payload = {"messages": "not-a-list"}
        response = self.client.post("/api/chat/", data=payload, content_type="application/json")
        self.assertEqual(response.status_code, 400)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 120
PATH: core\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 121
PATH: core\admin.py
LANG: python
===== CONTENT START =====
from django.contrib import admin

from .models import ApiKey, AuditLog, FeatureFlag


@admin.register(FeatureFlag)
class FeatureFlagAdmin(admin.ModelAdmin):
    list_display = ("name", "enabled", "rollout_percentage", "updated_at")
    search_fields = ("name",)
    list_filter = ("enabled",)


@admin.register(ApiKey)
class ApiKeyAdmin(admin.ModelAdmin):
    list_display = ("name", "prefix", "revoked_at", "last_used_at", "created_at")
    search_fields = ("name", "prefix")
    list_filter = ("revoked_at",)


@admin.register(AuditLog)
class AuditLogAdmin(admin.ModelAdmin):
    list_display = ("action", "actor", "target_type", "target_id", "created_at")
    search_fields = ("action", "target_type", "target_id")
    list_filter = ("action",)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 122
PATH: core\api_keys.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import hashlib
import secrets
from functools import wraps
from typing import Callable, TypeVar

from django.http import HttpRequest, HttpResponse, HttpResponseForbidden
from django.utils import timezone

from .models import ApiKey

F = TypeVar("F", bound=Callable[..., HttpResponse])


def _hash(raw: str) -> str:
    return hashlib.sha256(raw.encode("utf-8")).hexdigest()


def generate_api_key(name: str) -> tuple[str, ApiKey]:
    """Generate and persist a new API key. Returns raw key and model instance."""
    raw = secrets.token_urlsafe(28)
    prefix = raw[:8]
    instance = ApiKey.objects.create(name=name, prefix=prefix, key_hash=_hash(raw))
    return raw, instance


def require_api_key(view_func: F) -> F:
    """Decorator to protect partner endpoints with X-API-Key header."""

    @wraps(view_func)
    def wrapper(request: HttpRequest, *args, **kwargs):
        header_key = request.headers.get("X-API-Key") or request.META.get("HTTP_X_API_KEY")
        if not header_key:
            return HttpResponseForbidden("API key required")
        prefix = header_key[:8]
        try:
            record = ApiKey.objects.get(prefix=prefix, revoked_at__isnull=True)
        except ApiKey.DoesNotExist:
            return HttpResponseForbidden("Invalid API key")
        if record.key_hash != _hash(header_key):
            return HttpResponseForbidden("Invalid API key")
        record.last_used_at = timezone.now()
        record.save(update_fields=["last_used_at"])
        return view_func(request, *args, **kwargs)

    return wrapper  # type: ignore[return-value]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 123
PATH: core\apps.py
LANG: python
===== CONTENT START =====
# core/apps.py

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"
    verbose_name = "Ядро ParkShare"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 124
PATH: core\context_processors.py
LANG: python
===== CONTENT START =====
# core/context_processors.py

from __future__ import annotations

from django.conf import settings


def global_settings(request):
    """
    Глобальные настройки, которые нужны во всех шаблонах:
    регион, карта, ключи и дефолтный центр.
    """
    return {
        "REGION_PROFILE": getattr(settings, "REGION_PROFILE", "RU"),
        "PLATFORM_MODE": getattr(settings, "PLATFORM_MODE", "RU"),
        "MAP_PROVIDER": getattr(settings, "MAP_PROVIDER", "yandex"),
        "MAP_PROVIDER_FALLBACK": getattr(settings, "MAP_PROVIDER_FALLBACK", "leaflet"),
        "YANDEX_MAP_API_KEY": getattr(settings, "YANDEX_MAP_API_KEY", ""),
        "MAPBOX_TOKEN": getattr(settings, "MAPBOX_TOKEN", ""),
        "MAP_DEFAULT_CENTER": getattr(
            settings,
            "MAP_DEFAULT_CENTER",
            [55.75, 37.61],
        ),
        "MAP_DEFAULT_ZOOM": getattr(settings, "MAP_DEFAULT_ZOOM", 11),
    }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 125
PATH: core\db_router.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from django.conf import settings


class ReadReplicaRouter:
    """
    Directs read queries to a replica when DATABASE_REPLICA_URL is configured.
    Write operations always go to the primary.
    """

    replica_alias = "replica"

    def _has_replica(self) -> bool:
        return self.replica_alias in getattr(settings, "DATABASES", {})

    def db_for_read(self, model, **hints):
        if self._has_replica():
            return self.replica_alias
        return None

    def db_for_write(self, model, **hints):
        return "default"

    def allow_relation(self, obj1, obj2, **hints):
        return True

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if db == self.replica_alias:
            # Migrations must run only on primary.
            return False
        return True

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 126
PATH: core\feature_flags.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import hashlib
import logging
from typing import Optional

from django.conf import settings

from .models import FeatureFlag

logger = logging.getLogger(__name__)


def _hit(identifier: str, percentage: int) -> bool:
    if percentage >= 100:
        return True
    if percentage <= 0:
        return False
    h = hashlib.sha256(identifier.encode("utf-8")).hexdigest()
    bucket = int(h[:8], 16) % 100
    return bucket < percentage


def is_feature_enabled(flag_name: str, user=None, request=None) -> bool:
    """
    Deterministic процентные флаги. При отсутствии записи возвращает False,
    чтобы новые флаги не включались случайно.
    """
    try:
        flag = FeatureFlag.objects.get(name=flag_name)
    except FeatureFlag.DoesNotExist:
        return False

    if not flag.enabled:
        return False

    identifier = "anonymous"
    if user and getattr(user, "pk", None):
        identifier = str(user.pk)
    elif request:
        identifier = request.META.get("REMOTE_ADDR") or "anonymous"

    hit = _hit(identifier, flag.rollout_percentage)
    if settings.DEBUG:
        logger.debug("feature_flag", extra={"flag": flag.name, "hit": hit, "id": identifier})
    return hit

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 127
PATH: core\integrations.py
LANG: python
===== CONTENT START =====
"""core/integrations.py

Адаптеры для интеграций по регионам:
- карты (RU: Яндекс, GLOBAL: Mapbox/OSM);
- платежи (RU: YooKassa, GLOBAL: Stripe);
- аутентификация (RU: ЕСИА/VK/Яндекс, GLOBAL: generic OAuth2).

Цель — единая точка выбора провайдера через PLATFORM_MODE
(ENV: PLATFORM_MODE=RU|GLOBAL) без раздувания микросервисов.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict

from django.conf import settings


@dataclass
class MapProviderAdapter:
    key: str
    api_key: str
    language: str
    default_center: list[float]
    default_zoom: int

    def as_frontend_payload(self) -> Dict[str, str | list[float] | int]:
        return {
            "provider": self.key,
            "language": self.language,
            "api_key": self.api_key,
            "center": self.default_center,
            "zoom": self.default_zoom,
        }


@dataclass
class PaymentGatewayAdapter:
    key: str
    webhook_url: str
    return_url: str

    def as_dict(self) -> Dict[str, str]:
        return {
            "provider": self.key,
            "webhook_url": self.webhook_url,
            "return_url": self.return_url,
        }


@dataclass
class AuthProviderAdapter:
    key: str
    client_id: str
    authorization_url: str
    scopes: list[str]

    def as_dict(self) -> Dict[str, str | list[str]]:
        return {
            "provider": self.key,
            "client_id": self.client_id,
            "authorization_url": self.authorization_url,
            "scopes": self.scopes,
        }


RU_INTEGRATIONS = {
    "maps": MapProviderAdapter(
        key=settings.MAP_PROVIDER,
        api_key=settings.YANDEX_MAP_API_KEY,
        language=settings.REGION.get("maps", {}).get("language", "ru_RU"),
        default_center=settings.MAP_DEFAULT_CENTER,
        default_zoom=settings.MAP_DEFAULT_ZOOM,
    ),
    "payments": PaymentGatewayAdapter(
        key=settings.DEFAULT_PAYMENT_PROVIDER,
        webhook_url="/payments/webhook/yookassa/",
        return_url=settings.YOOKASSA_RETURN_URL,
    ),
    "auth": [
        AuthProviderAdapter(
            key="gosuslugi",
            client_id="GOSUSLUGI_CLIENT_ID_PLACEHOLDER",
            authorization_url="https://esia.gosuslugi.ru/aas/oauth2/ac",
            scopes=["openid", "profile"],
        ),
        AuthProviderAdapter(
            key="vk_id",
            client_id="VK_CLIENT_ID_PLACEHOLDER",
            authorization_url="https://id.vk.com/authorize",
            scopes=["email"],
        ),
    ],
}

GLOBAL_INTEGRATIONS = {
    "maps": MapProviderAdapter(
        key=settings.MAP_PROVIDER if settings.PLATFORM_MODE == "GLOBAL" else "mapbox",
        api_key=settings.MAPBOX_TOKEN,
        language="en_US",
        default_center=settings.MAP_DEFAULT_CENTER,
        default_zoom=settings.MAP_DEFAULT_ZOOM,
    ),
    "payments": PaymentGatewayAdapter(
        key=settings.DEFAULT_PAYMENT_PROVIDER,
        webhook_url="/payments/webhook/stripe/",
        return_url="/payments/return/",
    ),
    "auth": [
        AuthProviderAdapter(
            key="google",
            client_id="GOOGLE_OAUTH_CLIENT_ID",
            authorization_url="https://accounts.google.com/o/oauth2/v2/auth",
            scopes=["openid", "email", "profile"],
        ),
        AuthProviderAdapter(
            key="apple",
            client_id="APPLE_CLIENT_ID",
            authorization_url="https://appleid.apple.com/auth/authorize",
            scopes=["name", "email"],
        ),
    ],
}


def get_integrations() -> dict:
    if settings.PLATFORM_MODE == "GLOBAL":
        return GLOBAL_INTEGRATIONS
    return RU_INTEGRATIONS

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 128
PATH: core\metrics.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import time
from typing import Optional

from django.conf import settings
from django.http import HttpRequest, HttpResponse, HttpResponseForbidden
from prometheus_client import CONTENT_TYPE_LATEST, Counter, Histogram, generate_latest

# Request-level metrics
request_counter = Counter(
    "parkshare_http_requests_total",
    "HTTP requests by method/path/status",
    ["method", "path", "status"],
)
request_latency = Histogram(
    "parkshare_http_request_duration_seconds",
    "Request latency by method/path",
    ["method", "path"],
    buckets=(0.05, 0.1, 0.25, 0.5, 1, 2, 5),
)

# Domain counters
booking_events = Counter(
    "parkshare_booking_events_total",
    "Booking events",
    ["event"],
)
payment_events = Counter(
    "parkshare_payment_events_total",
    "Payment attempts and statuses",
    ["provider", "status"],
)
assistant_invocations = Counter(
    "parkshare_assistant_invocations_total",
    "AI assistant tool invocations",
    ["tool"],
)


def metrics_view(request: HttpRequest) -> HttpResponse:
    """Expose Prometheus metrics when ENABLE_METRICS=true."""
    if not getattr(settings, "ENABLE_METRICS", False):
        return HttpResponseForbidden("Metrics disabled")
    return HttpResponse(generate_latest(), content_type=CONTENT_TYPE_LATEST)


def record_booking_event(event: str) -> None:
    if not getattr(settings, "ENABLE_METRICS", False):
        return
    booking_events.labels(event=event or "unknown").inc()


def record_payment_event(provider: Optional[str], status: str) -> None:
    if not getattr(settings, "ENABLE_METRICS", False):
        return
    payment_events.labels(provider=provider or "unknown", status=status or "unknown").inc()


def record_assistant_tool(tool: str) -> None:
    if not getattr(settings, "ENABLE_METRICS", False):
        return
    assistant_invocations.labels(tool=tool or "unknown").inc()


class RequestMetricsMiddleware:
    """Collect request count/latency when metrics enabled."""

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request: HttpRequest):
        if not getattr(settings, "ENABLE_METRICS", False):
            return self.get_response(request)

        start = time.perf_counter()
        response = self.get_response(request)
        duration = time.perf_counter() - start

        path_label = getattr(request, "resolver_match", None)
        if path_label and path_label.view_name:
            path_value = path_label.view_name
        else:
            path_value = (request.path or "").split("?")[0]

        status_code = getattr(response, "status_code", 0)
        request_counter.labels(method=request.method, path=path_value, status=str(status_code)).inc()
        request_latency.labels(method=request.method, path=path_value).observe(duration)
        return response

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 129
PATH: core\middleware.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import time
from typing import Callable

from django.conf import settings
from django.core.cache import caches
from django.http import HttpRequest, HttpResponse, JsonResponse
from django.utils.deprecation import MiddlewareMixin


# core/middleware.py

from django.conf import settings


class SecurityHeadersMiddleware:
    """
    Добавляет базовые защитные заголовки.
    COOP/COEP/CORP берём из settings.* и в DEBUG по умолчанию отключаем,
    чтобы не ломать dev-фичи вроде Leaflet / внешних API.
    """

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        # CSP
        csp = getattr(settings, "CONTENT_SECURITY_POLICY", None)
        if csp:
            response.setdefault("Content-Security-Policy", csp)

        # X-Frame-Options
        frame_option = getattr(settings, "X_FRAME_OPTIONS", "DENY")
        if frame_option:
            response.setdefault("X-Frame-Options", frame_option)

        # X-Content-Type-Options
        response.setdefault("X-Content-Type-Options", "nosniff")

        # Referrer-Policy
        referrer = getattr(settings, "REFERRER_POLICY", None)
        if referrer:
            response.setdefault("Referrer-Policy", referrer)

        # Permissions-Policy
        perm = getattr(settings, "PERMISSIONS_POLICY", None)
        if perm:
            response.setdefault("Permissions-Policy", perm)

        # --- COOP / COEP / CORP ---

        if settings.DEBUG:
            # В dev вообще не ставим их, и заодно сносим, если кто-то выше их повесил
            for header in (
                "Cross-Origin-Opener-Policy",
                "Cross-Origin-Embedder-Policy",
                "Cross-Origin-Resource-Policy",
            ):
                if header in response:
                    del response[header]
        else:
            coop = getattr(settings, "CROSS_ORIGIN_OPENER_POLICY", None)
            coep = getattr(settings, "CROSS_ORIGIN_EMBEDDER_POLICY", None)
            corp = getattr(settings, "CROSS_ORIGIN_RESOURCE_POLICY", None)

            if coop:
                response.setdefault("Cross-Origin-Opener-Policy", coop)
            if coep:
                response.setdefault("Cross-Origin-Embedder-Policy", coep)
            if corp:
                response.setdefault("Cross-Origin-Resource-Policy", corp)

        return response


class RateLimitMiddleware:
    """Простейший rate limiting на уровне приложения.

    Используем cache (Redis в продакшене) для подсчёта количества запросов
    в фиксированное окно. Если лимит превышен — отдаём 429 и заголовок
    ``Retry-After``.
    """

    def __init__(self, get_response: Callable):
        self.get_response = get_response
        self.cache = caches[getattr(settings, "RATE_LIMIT_CACHE", "default")]
        self.window = int(getattr(settings, "RATE_LIMIT_WINDOW", 60))
        self.limit = int(getattr(settings, "RATE_LIMIT_REQUESTS", 120))
        self.whitelist = set(getattr(settings, "RATE_LIMIT_WHITELIST", []))

    def __call__(self, request: HttpRequest) -> HttpResponse:
        if request.method.upper() == "OPTIONS":
            return self.get_response(request)

        client_ip = self._get_client_ip(request)
        if client_ip and client_ip not in self.whitelist:
            if self._is_rate_limited(client_ip):
                retry_after = self.window
                return JsonResponse(
                    {"detail": "Too many requests, please retry later."},
                    status=429,
                    headers={"Retry-After": str(retry_after)},
                )

        return self.get_response(request)

    def _get_client_ip(self, request: HttpRequest) -> str:
        forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        return request.META.get("REMOTE_ADDR", "")

    def _is_rate_limited(self, client_ip: str) -> bool:
        window_start = int(time.time() // self.window) * self.window
        cache_key = f"ratelimit:{client_ip}:{window_start}"

        added = self.cache.add(cache_key, 1, timeout=self.window)
        if added:
            return False

        try:
            current = self.cache.incr(cache_key)
        except Exception:
            # Fallback: если бекенд не поддерживает incr, пробуем читать/писать вручную.
            current = int(self.cache.get(cache_key) or 0) + 1
            self.cache.set(cache_key, current, timeout=self.window)

        return current > self.limit


class MaintenanceModeMiddleware(MiddlewareMixin):
    """Блокирует изменения в режиме обслуживания, разрешая безопасное чтение карты и статики."""

    def process_view(self, request: HttpRequest, view_func, view_args, view_kwargs):
        maintenance = getattr(settings, "MAINTENANCE_MODE", False)
        if not maintenance:
            return None
        if request.method in ("POST", "PUT", "PATCH", "DELETE"):
            return JsonResponse(
                {"code": "maintenance", "message": "Сервис временно обслуживается. Попробуйте позже.", "details": {}},
                status=503,
            )
        return None

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 130
PATH: core\models.py
LANG: python
===== CONTENT START =====
# backend/core/models.py
import uuid

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _


class TimeStampedModel(models.Model):
    """
    Абстрактная модель с полями created_at/updated_at.

    Используется для единообразного аудита времени создания и обновления
    записей в базовых моделях (парковки, бронирования, платежи и т.п.).
    """

    created_at = models.DateTimeField(_("Дата создания"), auto_now_add=True)
    updated_at = models.DateTimeField(_("Дата обновления"), auto_now=True)

    class Meta:
        abstract = True


class UUIDModel(models.Model):
    """Абстрактная модель с UUID в качестве первичного ключа."""

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    class Meta:
        abstract = True


class TimeStampedUUIDModel(TimeStampedModel, UUIDModel):
    """Комбо UUID + таймстемпы."""

    class Meta:
        abstract = True


class FeatureFlag(TimeStampedUUIDModel):
    """Управление фичами и процентными раскатками."""

    name = models.CharField(max_length=64, unique=True)
    description = models.TextField(blank=True)
    enabled = models.BooleanField(default=False)
    rollout_percentage = models.PositiveSmallIntegerField(
        default=100,
        help_text="0-100, deterministic по пользователю",
    )
    conditions = models.JSONField(default=dict, blank=True)

    class Meta:
        verbose_name = "Фича-флаг"
        verbose_name_plural = "Фича-флаги"

    def __str__(self) -> str:  # pragma: no cover - удобочитаемость в админке
        return self.name


class ApiKey(TimeStampedUUIDModel):
    """Простой API-ключ для партнёрских S2S-интеграций."""

    name = models.CharField(max_length=128)
    prefix = models.CharField(max_length=8, db_index=True)
    key_hash = models.CharField(max_length=128, db_index=True)
    revoked_at = models.DateTimeField(null=True, blank=True)
    last_used_at = models.DateTimeField(null=True, blank=True)

    class Meta:
        verbose_name = "API-ключ"
        verbose_name_plural = "API-ключи"

    def __str__(self) -> str:
        return f"{self.name} ({self.prefix})"


class AuditLog(TimeStampedUUIDModel):
    """Мини-аудит для операций с пользователем/настройками."""

    actor = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="audit_logs",
    )
    action = models.CharField(max_length=128)
    target_type = models.CharField(max_length=64, blank=True)
    target_id = models.CharField(max_length=64, blank=True)
    metadata = models.JSONField(default=dict, blank=True)

    class Meta:
        verbose_name = "Аудит"
        verbose_name_plural = "Аудит-лог"
        indexes = [
            models.Index(fields=["action"]),
            models.Index(fields=["target_type", "target_id"]),
        ]

    def __str__(self) -> str:
        return f"{self.action} -> {self.target_type}:{self.target_id}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 131
PATH: core\observability.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import json
import logging
import time
import traceback
from contextlib import contextmanager
from contextvars import ContextVar
from typing import Any, Dict, Optional
from urllib import request as urlrequest

from django.conf import settings

request_id_ctx: ContextVar[str | None] = ContextVar("request_id", default=None)
user_ctx: ContextVar[str | None] = ContextVar("request_user", default=None)


def set_request_context(request_id: str | None, user_id: str | None = None) -> None:
    request_id_ctx.set(request_id)
    user_ctx.set(user_id)


def clear_request_context() -> None:
    request_id_ctx.set(None)
    user_ctx.set(None)


def get_request_id() -> str | None:
    return request_id_ctx.get()


def get_request_user() -> str | None:
    return user_ctx.get()


class RequestIDLogFilter(logging.Filter):
    """Injects request_id/user_id into log records for structured logging."""

    def filter(self, record: logging.LogRecord) -> bool:  # type: ignore[override]
        record.request_id = get_request_id() or "-"
        record.user_id = get_request_user() or getattr(record, "user", None) or "-"
        return True


def capture_exception(exc: BaseException, context: Optional[Dict[str, Any]] = None) -> None:
    """
    Lightweight error-reporting hook. Logs locally and, if SENTRY_DSN is set,
    POSTs a minimal payload. Failures are swallowed to avoid cascading errors.
    """
    logger = logging.getLogger("parkshare.errors")
    payload = {
        "error": exc.__class__.__name__,
        "message": str(exc),
        "trace": traceback.format_exc(),
        "request_id": get_request_id(),
        "context": context or {},
    }
    logger.error("Exception captured", extra={"payload": payload})

    dsn = getattr(settings, "SENTRY_DSN", "") or ""
    if not dsn:
        return

    try:
        data = json.dumps(payload).encode("utf-8")
        req = urlrequest.Request(
            dsn,
            data=data,
            headers={"Content-Type": "application/json"},
            method="POST",
        )
        urlrequest.urlopen(req, timeout=2)
    except Exception:
        logger.warning("Failed to forward exception to Sentry-compatible DSN")


class Span:
    """Minimal tracing span for timing critical operations."""

    def __init__(self, name: str, attributes: Optional[Dict[str, Any]] = None):
        self.name = name
        self.attributes = attributes or {}
        self.start = time.perf_counter()
        self._logger = logging.getLogger("parkshare.tracing")

    def __enter__(self):
        self._logger.debug(
            "span_start",
            extra={
                "span": self.name,
                "attrs": self.attributes,
                "request_id": get_request_id(),
            },
        )
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        duration = time.perf_counter() - self.start
        extra = {
            "span": self.name,
            "duration_ms": int(duration * 1000),
            "attrs": self.attributes,
            "request_id": get_request_id(),
        }
        if exc_val:
            extra["error"] = str(exc_val)
        self._logger.info("span_end", extra=extra)


@contextmanager
def start_span(name: str, **attrs: Any):
    if not getattr(settings, "ENABLE_TRACING", True):
        yield None
        return
    with Span(name, attrs):
        yield None

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 132
PATH: core\pagination.py
LANG: python
===== CONTENT START =====
# core/pagination.py

from django.conf import settings
from rest_framework.pagination import PageNumberPagination


class DefaultPageNumberPagination(PageNumberPagination):
    """
    Базовый пагинатор для API.
    Размер страницы берётся из настроек DRF (PAGE_SIZE), с возможностью
    переопределения через query-параметр ?page_size=.
    """

    page_size = settings.REST_FRAMEWORK.get("PAGE_SIZE", 20)
    page_size_query_param = "page_size"
    max_page_size = 100

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 133
PATH: core\permissions.py
LANG: python
===== CONTENT START =====
# core/permissions.py

from typing import Any

from django.contrib.auth import get_user_model
from rest_framework.permissions import BasePermission, SAFE_METHODS

User = get_user_model()


def _is_admin(user: User) -> bool:
    """
    Утилита: определение админа по суперпользователю или роли.
    """
    if not user.is_authenticated:
        return False

    role_cls = getattr(User, "Role", None)
    admin_value = None
    if role_cls is not None:
        admin_value = getattr(role_cls, "ADMIN", None)

    if admin_value is not None:
        return bool(user.is_superuser or getattr(user, "role", "") == admin_value)

    return bool(user.is_superuser or getattr(user, "is_staff", False))


class IsAdminOrReadOnly(BasePermission):
    """
    Разрешает только администраторам изменять данные, остальным — только чтение.
    """

    def has_permission(self, request, view) -> bool:
        if request.method in SAFE_METHODS:
            return True
        user: User = request.user
        return _is_admin(user)


class IsSelfOrAdmin(BasePermission):
    """
    Доступ к объекту пользователя: либо сам пользователь, либо админ.
    """

    def has_object_permission(self, request, view, obj: Any) -> bool:
        user: User = request.user
        if not user.is_authenticated:
            return False
        if _is_admin(user):
            return True
        return getattr(obj, "pk", None) == getattr(user, "pk", None)


class IsOwnerObject(BasePermission):
    """
    Доступ к объектам, у которых есть атрибут owner: только владелец или админ.
    """

    def has_object_permission(self, request, view, obj: Any) -> bool:
        user: User = request.user
        if not user.is_authenticated:
            return False
        if _is_admin(user):
            return True
        owner = getattr(obj, "owner", None)
        return owner == user

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 134
PATH: core\sms.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from typing import Dict, Type

from django.conf import settings

logger = logging.getLogger("parkshare.sms")


class SmsProvider(ABC):
    """
    Abstract SMS provider interface.

    Implementations must be stateless and reusable; configuration is passed
    via Django settings / environment variables.
    """

    @abstractmethod
    def send_sms(self, to: str, text: str) -> None:
        """
        Send SMS message to a single recipient.

        Implementations MUST NOT raise on remote failures in a way that breaks
        the main request flow; prefer logging + best‑effort semantics.
        """
        raise NotImplementedError


class ConsoleSmsProvider(SmsProvider):
    """
    Development / default provider: logs SMS contents instead of sending.
    """

    def send_sms(self, to: str, text: str) -> None:
        logger.info(
            "SMS send (console backend)",
            extra={
                "to": to,
                "chars": len(text),
                "preview": text[:64],
            },
        )


_PROVIDER_REGISTRY: Dict[str, Type[SmsProvider]] = {
    "console": ConsoleSmsProvider,
}


def get_sms_provider() -> SmsProvider:
    """
    Resolve concrete SmsProvider based on SMS_PROVIDER setting.

    For production, plug in a custom implementation by:
      * Implementing SmsProvider subclass in your own module.
      * Adding it to _PROVIDER_REGISTRY at import time (e.g. via AppConfig.ready()).
      * Setting SMS_PROVIDER env var to the corresponding key.
    """
    backend_name = getattr(settings, "SMS_PROVIDER", "console") or "console"
    provider_cls = _PROVIDER_REGISTRY.get(backend_name, ConsoleSmsProvider)
    return provider_cls()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 135
PATH: core\utils.py
LANG: python
===== CONTENT START =====
# backend/core/utils.py

import hashlib
import math
from contextlib import contextmanager
from decimal import Decimal, ROUND_HALF_UP
from typing import Optional

from django.conf import settings
from django.db import connections


def hash_plate_digits(plate: str) -> str:
    """
    Хэширует только цифры госномера с солью (SHA‑256).
    Буквы и пробелы игнорируются.
    В БД мы сохраняем только этот хэш.
    """
    if not plate:
        return ""
    digits = "".join(ch for ch in plate if ch.isdigit())
    salted = f"{settings.VEHICLE_PLATE_SALT}:{digits}"
    return hashlib.sha256(salted.encode("utf-8")).hexdigest()


def mask_plate_for_display(plate: str) -> str:
    """
    Возвращает маску номера для отображения (если вдруг нужно выводить).
    Фактический номер мы нигде не храним, поэтому функция может применяться
    только к введённому пользователем значению до хэширования.
    """
    digits = "".join(ch for ch in plate if ch.isdigit())
    if not digits:
        return ""
    if len(digits) <= 2:
        return "*" * len(digits)
    return "*" * (len(digits) - 2) + digits[-2:]


def normalize_phone(phone: Optional[str]) -> str:
    """
    Нормализация телефона:

    - убираем все символы кроме цифр и '+';
    - для РФ приводим к формату +7XXXXXXXXXX, если возможно;
    - для остальных стран просто добавляем '+' перед цифрами.
    """
    if not phone:
        return ""
    raw = phone.strip()

    # Оставляем плюс только в начале
    plus = "+" if raw.startswith("+") else ""
    digits = "".join(ch for ch in raw if ch.isdigit())
    if not digits:
        return ""

    # РФ: 10 или 11 цифр, начинающихся с 8/7
    if len(digits) == 11 and digits.startswith("8"):
        digits = "7" + digits[1:]
    elif len(digits) == 10:
        digits = "7" + digits

    if plus or digits.startswith("7"):
        return "+" + digits
    return "+" + digits  # простой фолбэк


def haversine_distance_km(
    lat1: float, lon1: float, lat2: float, lon2: float
) -> float:
    """
    Расстояние между двумя точками на сфере Земли (км).

    Используем для поиска парковок «рядом» без обязательной привязки
    к PostGIS (работает и на SQLite).
    """
    try:
        lat1_f = float(lat1)
        lon1_f = float(lon1)
        lat2_f = float(lat2)
        lon2_f = float(lon2)
    except (TypeError, ValueError):
        return 0.0

    radius = 6371.0  # км

    d_lat = math.radians(lat2_f - lat1_f)
    d_lon = math.radians(lon2_f - lon1_f)
    r_lat1 = math.radians(lat1_f)
    r_lat2 = math.radians(lat2_f)

    a = (
        math.sin(d_lat / 2) ** 2
        + math.cos(r_lat1) * math.cos(r_lat2) * math.sin(d_lon / 2) ** 2
    )
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return radius * c


def parse_float(value: Optional[str]) -> Optional[float]:
    """
    Аккуратно парсит строку в float, возвращая None при ошибке.
    Удобно для работы с query‑параметрами API.
    """
    if value is None:
        return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def round_price(value: float | Decimal, step: float = 10.0) -> float:
    """
    Округляет цену к ближайшему шагу (step), по умолчанию — 10 ₽.

    Используется в AI-модуле ценообразования.
    """
    if step <= 0:
        return float(Decimal(str(value)).quantize(Decimal("0.01")))

    v = Decimal(str(value))
    step_dec = Decimal(str(step))
    scaled = (v / step_dec).quantize(Decimal("1"), rounding=ROUND_HALF_UP)
    result = scaled * step_dec
    return float(result)


# ---------------------------------------------------------------------------
# Read-replica helpers
# ---------------------------------------------------------------------------


def read_db_alias() -> str:
    """Return replica alias if configured, otherwise default."""
    return "replica" if "replica" in settings.DATABASES else "default"


def read_replica_queryset(queryset):
    """Route queryset to replica when available; no-op otherwise."""
    alias = read_db_alias()
    try:
        return queryset.using(alias)
    except Exception:
        return queryset


@contextmanager
def read_replica_cursor():
    """Context manager yielding a cursor on the replica (or default)."""
    alias = read_db_alias()
    conn = connections[alias]
    with conn.cursor() as cursor:
        yield cursor

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 136
PATH: core\management\__init__.py
LANG: python
===== CONTENT START =====
# Management package for cross-cutting operational commands (migrations, backups, retention).

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 137
PATH: core\management\commands\__init__.py
LANG: python
===== CONTENT START =====
# Namespace for core management commands.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 138
PATH: core\management\commands\migrate_safe.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import contextlib

from django.core.management import BaseCommand, CommandError, call_command
from django.db import connections


class Command(BaseCommand):
    help = (
        "Runs migrations with a two-phase, production-safe workflow. "
        "Phase 1 prints a plan; Phase 2 applies migrations with --noinput."
    )

    def add_arguments(self, parser):
        parser.add_argument(
            "--database",
            default="default",
            help="Database alias to migrate (default: default).",
        )
        parser.add_argument(
            "--plan-only",
            action="store_true",
            help="Only show the migration plan without applying changes.",
        )
        parser.add_argument(
            "--apply",
            action="store_true",
            help="Apply migrations after showing the plan (non-interactive).",
        )

    def handle(self, *args, **options):
        database = options["database"]
        plan_only = options["plan_only"]
        apply = options["apply"]

        self.stdout.write(self.style.NOTICE(f"Checking database connection [{database}]..."))
        with contextlib.suppress(Exception):
            connections[database].ensure_connection()

        try:
            self.stdout.write(self.style.NOTICE("Phase 1: migration plan"))
            call_command("migrate", database=database, plan=True)
        except Exception as exc:
            raise CommandError(f"Failed to build migration plan: {exc}") from exc

        if plan_only and not apply:
            self.stdout.write(self.style.SUCCESS("Plan generated. Skipping apply (--plan-only)."))
            return

        if not apply:
            self.stdout.write(
                self.style.WARNING(
                    "No --apply flag provided. Review plan above and rerun with --apply to execute."
                )
            )
            return

        self.stdout.write(self.style.NOTICE("Phase 2: applying migrations (non-interactive)..."))
        try:
            call_command("migrate", database=database, interactive=False)
        except Exception as exc:
            raise CommandError(f"Migration apply failed: {exc}") from exc

        self.stdout.write(self.style.SUCCESS("Migrations applied successfully."))

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 139
PATH: core\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated for FeatureFlag/ApiKey/AuditLog models
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion
import uuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="ApiKey",
            fields=[
                ("id", models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ("created_at", models.DateTimeField(auto_now_add=True, verbose_name="Дата создания")),
                ("updated_at", models.DateTimeField(auto_now=True, verbose_name="Дата обновления")),
                ("name", models.CharField(max_length=128)),
                ("prefix", models.CharField(db_index=True, max_length=8)),
                ("key_hash", models.CharField(db_index=True, max_length=128)),
                ("revoked_at", models.DateTimeField(blank=True, null=True)),
                ("last_used_at", models.DateTimeField(blank=True, null=True)),
            ],
            options={
                "verbose_name": "API-ключ",
                "verbose_name_plural": "API-ключи",
            },
        ),
        migrations.CreateModel(
            name="FeatureFlag",
            fields=[
                ("id", models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ("created_at", models.DateTimeField(auto_now_add=True, verbose_name="Дата создания")),
                ("updated_at", models.DateTimeField(auto_now=True, verbose_name="Дата обновления")),
                ("name", models.CharField(max_length=64, unique=True)),
                ("description", models.TextField(blank=True)),
                ("enabled", models.BooleanField(default=False)),
                ("rollout_percentage", models.PositiveSmallIntegerField(default=100, help_text="0-100, deterministic по пользователю")),
                ("conditions", models.JSONField(blank=True, default=dict)),
            ],
            options={
                "verbose_name": "Фича-флаг",
                "verbose_name_plural": "Фича-флаги",
            },
        ),
        migrations.CreateModel(
            name="AuditLog",
            fields=[
                ("id", models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ("created_at", models.DateTimeField(auto_now_add=True, verbose_name="Дата создания")),
                ("updated_at", models.DateTimeField(auto_now=True, verbose_name="Дата обновления")),
                ("action", models.CharField(max_length=128)),
                ("target_type", models.CharField(blank=True, max_length=64)),
                ("target_id", models.CharField(blank=True, max_length=64)),
                ("metadata", models.JSONField(blank=True, default=dict)),
                ("actor", models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name="audit_logs", to=settings.AUTH_USER_MODEL)),
            ],
            options={
                "verbose_name": "Аудит",
                "verbose_name_plural": "Аудит-лог",
            },
        ),
        migrations.AddIndex(
            model_name="auditlog",
            index=models.Index(fields=["action"], name="core_audit_action_6abf09_idx"),
        ),
        migrations.AddIndex(
            model_name="auditlog",
            index=models.Index(fields=["target_type", "target_id"], name="core_audit_target__e9a95a_idx"),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 140
PATH: core\migrations\0002_rename_core_audit_action_6abf09_idx_core_auditl_action_d9fb24_idx_and_more.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-12-07 21:29

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.RenameIndex(
            model_name='auditlog',
            new_name='core_auditl_action_d9fb24_idx',
            old_name='core_audit_action_6abf09_idx',
        ),
        migrations.RenameIndex(
            model_name='auditlog',
            new_name='core_auditl_target__6c66b3_idx',
            old_name='core_audit_target__e9a95a_idx',
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 141
PATH: core\migrations\__init__.py
LANG: python
===== CONTENT START =====
# core migrations package

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 142
PATH: core\tests\test_feature_flags.py
LANG: python
===== CONTENT START =====
from django.test import SimpleTestCase

from core.feature_flags import _hit


class FeatureFlagsTest(SimpleTestCase):
    def test_rollout_is_deterministic(self):
        self.assertTrue(_hit("any", 100))
        self.assertFalse(_hit("any", 0))
        first = _hit("user-xyz", 50)
        second = _hit("user-xyz", 50)
        self.assertEqual(first, second)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 143
PATH: docs\auth_mfa_and_social_login.md
LANG: markdown
===== CONTENT START =====
# Auth, MFA и социальный вход

## Модель данных
- `accounts.User` расширен полями `mfa_enabled`, `mfa_method` (`none|totp|sms|email`), `mfa_secret`, `last_password_change`.
- `LoginCode.Purpose` содержит `mfa` для одноразовых кодов второго фактора.
- `SocialAccount` без изменений, но OAuth теперь учитывает MFA.

## Потоки входа
- **Пароль/OTP**: после первичной проверки мы не логиним сразу, если `mfa_enabled=True`. В сессии сохраняется `pre_auth_user_id`, `pre_auth_primary_ok`, `pre_auth_method`, `post_auth_redirect`. Ответ API содержит `mfa_required=true`.
- **Проверка MFA**: POST `/auth/mfa/verify/` (или `/api/auth/mfa/verify/`) с полем `code`. Для TOTP проверяется `mfa_secret` через `pyotp`; для SMS/email — последний неиспользованный `LoginCode` c `purpose=mfa`. При успехе создаётся полноценная сессия и JWT.
- **OAuth**: после успешного callback, если у пользователя включена MFA, происходит редирект на `/accounts/mfa/verify/` с сохранением `next` в сессии.

## Подключение/отключение MFA
- HTML: `/accounts/mfa/setup/` — выбор метода, генерация TOTP QR, ввод кода для активации, кнопка отключения.
- API: `/auth/mfa/setup/` (POST `{method}`) генерирует секрет/отправляет код; `/auth/mfa/activate/` (POST `{code}`) включает; `/auth/mfa/disable/` отключает.
- Для TOTP используется `pyotp.random_base32()` и otpauth:// URI из `accounts.utils.build_totp_uri`.

## Безопасность сессий и JWT
- При смене пароля (`change-password` API и HTML) обновляется `last_password_change`, удаляются чужие сессии пользователя и ротируется текущий ключ.
- Кастомный `accounts.authentication.JWTAuthentication` отклоняет токены с `iat` старше `last_password_change`.
- В продакшене включены защищённые cookie-флаги: secure, httpOnly (кроме CSRF), samesite=Lax.

## Клиентское хранение
- Вместо открытого `localStorage` данные пользователя шифруются в `frontend/next-app/lib/authStorage.ts` (AES-GCM, ключ `NEXT_PUBLIC_AUTH_ENC_KEY`).
- При ошибке дешифрования хранилище очищается автоматически.

## Социальный вход UI
- **Next.js**: компонент `SocialLoginButtons` с полноширинными баннерами Google/VK/Yandex, подсказками о правах и состоянием загрузки.
- **Django PWA**: на странице входа брендовские баннеры, подсказки, блок про недоступность провайдеров.
- MFA запрашивается после любого OAuth, если включена.

## Как включить MFA для пользователя
1. В профиле на сайте откройте `/accounts/mfa/setup/`, выберите метод.
2. Для TOTP — отсканируйте QR, введите код, дождитесь подтверждения.
3. Для SMS/email — отправьте код и подтвердите его.
4. При потере устройства отключите MFA тем же экраном и подключите заново.

## Настройка переменных
- `NEXT_PUBLIC_AUTH_ENC_KEY` — 32+ символа для AES-GCM на фронтенде.
- OAuth ключи: `VK_OAUTH_CLIENT_ID/SECRET`, `YANDEX_OAUTH_CLIENT_ID/SECRET`, `GOOGLE_OAUTH_CLIENT_ID/SECRET`.
- OTP/MFA лимиты: `AUTH_OTP_CODE_TTL_SECONDS`, `AUTH_OTP_WINDOW_SECONDS`, `AUTH_OTP_MAX_PER_WINDOW`, `AUTH_OTP_MAX_ATTEMPTS`.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 144
PATH: docs\deploy.md
LANG: markdown
===== CONTENT START =====
# Kubernetes / Helm blueprint

High-availability topology for ParkShare without changing local docker-compose flows.

## Components
- `k8s/web-deployment.yaml`: Django/Gunicorn pods behind `k8s/web-service.yaml`, rolling update (maxUnavailable=0, maxSurge=1) and readiness/liveness probes on `/readyz`/`/healthz`.
- `k8s/worker-deployment.yaml`: Celery worker replicas (HPA ready), same image/env as web.
- `k8s/beat-deployment.yaml`: Celery beat scheduler (1 replica, non-root).
- `k8s/hpa.yaml`: CPU-based autoscaling for web and worker, behavior tuned for graceful scale-down.
- `k8s/configmap.yaml` / `k8s/secret-example.yaml`: non-sensitive vs secret env separation; wire to Vault/SM/SealedSecrets in real clusters.
- `k8s/ingress.yaml`: nginx ingress with sane timeouts and TLS secret placeholder.

## Deployment strategy
- Default: RollingUpdate (0 downtime) with `maxUnavailable:0` / `maxSurge:1`. Readiness gate is `/readyz`; slow-start is handled by Gunicorn workers.
- Blue/green: create a parallel deployment (e.g., `parkshare-web-green`) with the same selectors except color, then flip Service/Ingress selector to the new color; keep both colors for fast rollback.
- Canary: split traffic by Ingress annotations or Gateway routes; HPA supports separate scaling for canary if selector differs.

## Migration workflow (high-traffic safe)
1) Build/push image.
2) Run migrations out of band before traffic cutover:
   ```bash
   python manage.py migrate_safe --plan-only  # review plan
   python manage.py migrate_safe --apply      # non-interactive apply
   ```
3) Deploy app pods (rolling or blue/green).
4) If schema includes new columns, ship code that is backward-compatible first; avoid destructive drops until the next deploy.
5) For locking migrations, run them in maintenance window (toggle `MAINTENANCE_MODE=true` via env/ConfigMap) or temporarily scale web to 0.

## Read replicas
- Configure `DATABASE_REPLICA_URL` to enable the read replica alias (`replica`) and router (`core.db_router.ReadReplicaRouter`).
- Analytics/heavy read queries automatically route to the replica; writes stay on `default`. If no replica is set, everything stays on primary.
- For explicit usage in tasks:
  ```python
  from core.utils import read_replica_queryset
  qs = read_replica_queryset(MyModel.objects.all())
  ```

## Safe rollout hooks
- Health: `/healthz` for liveness, `/readyz` for readiness.
- Metrics: `/metrics` (when `ENABLE_METRICS=true`) for Prometheus scraping; protect via network policy or auth if exposed.
- Celery: liveness probes run lightweight `celery inspect ping`; keep broker/Redis highly available.

## Externalized services
- PostgreSQL/PostGIS and Redis are assumed managed (RDS/Cloud SQL, MemoryDB/Elasticache). Provide URLs via secrets; no in-cluster stateful components are required.
- Object storage/CDN for staticfiles should be mounted via bucket sync or baked into the image; `staticfiles` volume is an `emptyDir` placeholder here.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 145
PATH: drf_spectacular\__init__.py
LANG: python
===== CONTENT START =====
"""Локальный заглушечный пакет drf_spectacular для офлайн-среды."""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 146
PATH: drf_spectacular\openapi.py
LANG: python
===== CONTENT START =====
from rest_framework.schemas.openapi import AutoSchema  # type: ignore

__all__ = ["AutoSchema"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 147
PATH: drf_spectacular\views.py
LANG: python
===== CONTENT START =====
from rest_framework.response import Response
from rest_framework.views import APIView


class SpectacularAPIView(APIView):
    def get(self, request, *args, **kwargs):
        return Response({"schema": "stub"})


class SpectacularSwaggerView(APIView):
    url_name = None

    def get(self, request, *args, **kwargs):
        return Response({"swagger": "stub"})


class SpectacularRedocView(APIView):
    url_name = None

    def get(self, request, *args, **kwargs):
        return Response({"redoc": "stub"})

__all__ = [
    "SpectacularAPIView",
    "SpectacularSwaggerView",
    "SpectacularRedocView",
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 148
PATH: frontend\next-app\.env.local
LANG: text
===== CONTENT START =====
# базовый адрес фронтенда в dev
NEXTAUTH_URL=http://localhost:3000

# любая длинная случайная строка (секрет для подписи JWT)
NEXTAUTH_SECRET=change_me_to_long_random_string

# сюда вставишь реальные значения из Google Cloud
GOOGLE_CLIENT_ID=82639895776-qrfcc2pggusro3pauh3b5q8n9j8m4vqf.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=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

# ключ для OpenAI (или совместимого провайдера)
OPENAI_API_KEY=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
AI_MODEL=gpt-4o

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 149
PATH: frontend\next-app\.eslintrc.json
LANG: json
===== CONTENT START =====
{
  "extends": "next/core-web-vitals"
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 150
PATH: frontend\next-app\Dockerfile
LANG: text
===== CONTENT START =====
# Multi-stage build for the Next.js AI Concierge
FROM node:18-alpine AS deps
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm ci || npm install

FROM deps AS builder
WORKDIR /app
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
ENV NODE_ENV=production
ENV PORT=3000
WORKDIR /app
COPY --from=builder /app/package.json ./
COPY --from=builder /app/next.config.mjs ./next.config.mjs
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/tailwind.config.ts ./tailwind.config.ts
COPY --from=builder /app/postcss.config.js ./postcss.config.js
COPY --from=builder /app/tsconfig.json ./tsconfig.json

USER node
EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=5s --start-period=20s CMD wget --quiet --spider http://localhost:3000/ || exit 1
CMD ["npm", "start"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 151
PATH: frontend\next-app\jest.config.js
LANG: javascript
===== CONTENT START =====
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  dir: './'
});

const customJestConfig = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
    '^uuid$': require.resolve('uuid')
  },
  testPathIgnorePatterns: ['<rootDir>/.next/', '<rootDir>/node_modules/'],
  transformIgnorePatterns: ['node_modules/(?!(nanoid)/)']
};

module.exports = createJestConfig(customJestConfig);

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 152
PATH: frontend\next-app\jest.setup.ts
LANG: typescript
===== CONTENT START =====
import '@testing-library/jest-dom';

const { TextEncoder, TextDecoder } = require('util');
if (!global.TextEncoder) {
  global.TextEncoder = TextEncoder;
}
if (!global.TextDecoder) {
  global.TextDecoder = TextDecoder;
}

if (!global.crypto) {
  const { webcrypto } = require('crypto');
  global.crypto = webcrypto as Crypto;
}

if (!global.ReadableStream) {
  const { ReadableStream } = require('stream/web');
  global.ReadableStream = ReadableStream as typeof global.ReadableStream;
}

if (!global.fetch || !global.Response) {
  const { fetch, Headers, Request, Response } = require('undici');
  if (!global.fetch) {
    global.fetch = fetch;
  }
  if (!global.Headers) {
    global.Headers = Headers;
  }
  if (!global.Request) {
    global.Request = Request;
  }
  if (!global.Response) {
    global.Response = Response;
  }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 153
PATH: frontend\next-app\next-env.d.ts
LANG: typescript
===== CONTENT START =====
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 154
PATH: frontend\next-app\next.config.mjs
LANG: text
===== CONTENT START =====
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    serverActions: {
      bodySizeLimit: '2mb'
    }
  },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**'
      }
    ]
  },
  async headers() {
    const isDev = process.env.NODE_ENV !== 'production';
    const connectSrc = [
      "'self'",
      'https://www.googleapis.com',
      'https://accounts.google.com',
      'https://api.openai.com'
    ];

    const extraOrigins = [process.env.LLM_API_URL, process.env.NEXT_PUBLIC_AUTH_API_URL, process.env.NEXT_PUBLIC_AUTH_API_BASE]
      .filter(Boolean)
      .map((value) => {
        try {
          return new URL(value).origin;
        } catch (error) {
          return null;
        }
      })
      .filter(Boolean);

    connectSrc.push(...extraOrigins);

    const csp = [
      "default-src 'self'",
      // Next.js injects small inline hydration/runtime scripts; keep inline until moved to a nonce-based policy.
      "script-src 'self' 'unsafe-inline'",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' data:",
      `connect-src ${connectSrc.join(' ')}`,
      "frame-src 'self' https://accounts.google.com",
      "worker-src 'self'",
      "manifest-src 'self'",
      "object-src 'none'",
      "base-uri 'self'",
      "frame-ancestors 'self' http://localhost:8000 http://127.0.0.1:8000",
      "form-action 'self'"
    ].join('; ');

    const securityHeaders = [
      {
        key: 'Content-Security-Policy',
        value: csp
      },
      ...(!isDev
        ? [
            {
              key: 'X-Frame-Options',
              value: 'DENY'
            }
          ]
        : []),
      {
        key: 'X-Content-Type-Options',
        value: 'nosniff'
      },
      {
        key: 'Referrer-Policy',
        value: 'strict-origin-when-cross-origin'
      },
      {
        key: 'Permissions-Policy',
        value: 'geolocation=(), microphone=(), camera=()'
      },
      {
        key: 'Strict-Transport-Security',
        value: 'max-age=63072000; includeSubDomains; preload'
      }
    ];

    return [
      {
        source: '/(.*)',
        headers: securityHeaders
      }
    ];
  }
};

export default nextConfig;

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 155
PATH: frontend\next-app\package.json
LANG: json
===== CONTENT START =====
{
  "name": "parkshare-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.19",
    "@heroicons/react": "^2.1.5",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-config-next": "^14.2.5",
    "highlight.js": "^11.9.0",
    "next": "^14.2.5",
    "postcss": "^8.4.39",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.2.1",
    "react-markdown": "^9.0.3",
    "rehype-highlight": "^5.0.2",
    "rehype-sanitize": "^6.0.0",
    "remark-gfm": "^4.0.0",
    "tailwind-merge": "^2.2.0",
    "tailwindcss": "^3.4.4",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.8",
    "@testing-library/react": "^14.2.2",
    "@testing-library/user-event": "^14.5.2",
    "@types/jest": "^29.5.12",
    "@types/node": "^20.14.10",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.5.4",
    "undici": "^6.19.8"
  }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 156
PATH: frontend\next-app\postcss.config.js
LANG: javascript
===== CONTENT START =====
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {}
  }
};

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 157
PATH: frontend\next-app\tailwind.config.ts
LANG: typescript
===== CONTENT START =====
import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: 'class',
  content: [
    './app/**/*.{js,ts,jsx,tsx}',
    './components/**/*.{js,ts,jsx,tsx}',
    './lib/**/*.{js,ts,jsx,tsx}'
  ],
  theme: {
    extend: {
      colors: {
        surface: '#f5f5f5',
        'surface-dark': '#0f172a'
      }
    }
  },
  plugins: []
};

export default config;

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 158
PATH: frontend\next-app\tsconfig.json
LANG: json
===== CONTENT START =====
{
  "compilerOptions": {
    "target": "ES5",
    "lib": [
      "DOM",
      "DOM.Iterable",
      "ESNext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "types": ["jest", "node"],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.mjs",
    ".next/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 159
PATH: frontend\next-app\app\globals.css
LANG: css
===== CONTENT START =====
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    color-scheme: light;
    --font-sans: 'SF Pro Display', 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    --font-mono: 'SFMono-Regular', 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    --bg-surface: #f4f7fb;
    --bg-elevated: #ffffff;
    --bg-soft: #eef2f8;
    --text-primary: #0f172a;
    --text-muted: #5f6a7a;
    --accent: #4fc3ff;
    --accent-strong: #1c64f2;
    --border-subtle: #e5e7eb;
    --radius-lg: 20px;
    --shadow-soft: 0 18px 38px rgba(15, 23, 42, 0.08);
    --ps-bg: var(--bg-surface);
    --ps-bg-elevated: var(--bg-elevated);
    --ps-bg-card: #ffffff;
    --ps-text-primary: var(--text-primary);
    --ps-text-muted: var(--text-muted);
    --ps-border-subtle: var(--border-subtle);
    --ps-accent: var(--accent);
    --ps-accent-strong: var(--accent-strong);
    --ps-radius-card: 22px;
  }

  :root.dark {
    color-scheme: dark;
    --bg-surface: #0b1220;
    --bg-elevated: #0f172a;
    --bg-soft: #0c1424;
    --text-primary: #e5e7eb;
    --text-muted: #94a3b8;
    --accent: #5dd6ff;
    --accent-strong: #8fc8ff;
    --border-subtle: #1f2937;
    --radius-lg: 20px;
    --shadow-soft: 0 18px 38px rgba(0, 0, 0, 0.45);
    --ps-bg: var(--bg-surface);
    --ps-bg-elevated: var(--bg-elevated);
    --ps-bg-card: var(--bg-elevated);
    --ps-text-primary: var(--text-primary);
    --ps-text-muted: var(--text-muted);
    --ps-border-subtle: var(--border-subtle);
    --ps-accent: var(--accent);
    --ps-accent-strong: var(--accent-strong);
    --ps-radius-card: 22px;
  }

  * {
    @apply antialiased;
  }

  body {
    @apply min-h-screen text-[var(--text-primary)];
    font-family: var(--font-sans);
    background: radial-gradient(circle at 20% 20%, rgba(51, 94, 220, 0.05), transparent 28%),
      radial-gradient(circle at 80% 0%, rgba(63, 125, 244, 0.06), transparent 25%),
      linear-gradient(180deg, #f7f9fc 0%, #f1f5f9 60%, #eef2f8 100%);
    color: var(--text-primary);
  }

  .dark body {
    background: radial-gradient(circle at 20% 20%, rgba(140, 158, 255, 0.07), transparent 25%),
      radial-gradient(circle at 80% 10%, rgba(108, 168, 255, 0.08), transparent 24%),
      linear-gradient(180deg, #0c1222 0%, #0b1020 50%, #0b1324 100%);
  }

  a {
    @apply underline decoration-2 underline-offset-4 transition-colors;
    color: var(--accent-strong);
  }

  input,
  textarea {
    @apply w-full rounded-2xl border border-[var(--border-subtle)] bg-[var(--bg-elevated)] px-4 py-3 text-sm text-[var(--text-primary)] shadow-sm outline-none transition focus:-translate-y-[1px] focus:border-[var(--accent)] focus:shadow-[0_10px_30px_rgba(79,70,229,0.06)];
    font-family: var(--font-sans);
  }

  button {
    @apply rounded-2xl px-4 py-2 text-sm font-medium transition duration-200 ease-out;
  }

  h1, h2, h3, h4, h5 {
    font-family: var(--font-sans);
    @apply tracking-tight text-[var(--text-primary)];
  }

  code, pre {
    font-family: var(--font-mono);
  }

  ::selection {
    background: rgba(63, 125, 244, 0.15);
  }
  }

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 160
PATH: frontend\next-app\app\layout.tsx
LANG: tsx
===== CONTENT START =====
import './globals.css';
import type { ReactNode } from 'react';

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="ru" suppressHydrationWarning>
      <head>
        <meta name="theme-color" content="#0f172a" />
      </head>
      <body className="bg-[var(--bg-surface)] text-[var(--text-primary)]">{children}</body>
    </html>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 161
PATH: frontend\next-app\app\(site)\layout.tsx
LANG: tsx
===== CONTENT START =====
import { Providers } from '@/components/providers';
import { Header } from '@/components/header';
import { ServiceWorkerRegistrar } from '@/components/pwa/register-service-worker';
import { ChatWidget } from '@/components/widget/chat-widget';

export default function SiteLayout({ children }: { children: React.ReactNode }) {
  return (
    <Providers>
      <div className="flex min-h-screen flex-col bg-surface dark:bg-surface-dark">
        <Header />
        <main className="mx-auto flex w-full max-w-6xl flex-1 flex-col gap-4 p-4">{children}</main>
        <ServiceWorkerRegistrar />
        <ChatWidget />
      </div>
    </Providers>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 162
PATH: frontend\next-app\app\(site)\page.tsx
LANG: tsx
===== CONTENT START =====
import { ChatPanel } from '@/components/chat/chat-panel';

export default function HomePage() {
  return (
    <section className="flex flex-1 flex-col gap-6">
      <div className="overflow-hidden rounded-[28px] border border-[var(--border-subtle)]/80 bg-gradient-to-r from-white/85 via-[var(--bg-surface)] to-white/90 p-6 shadow-[0_25px_60px_rgba(15,23,42,0.08)] backdrop-blur dark:border-slate-800 dark:from-slate-950 dark:via-slate-900 dark:to-indigo-950/40">
        <div className="flex flex-col gap-3">
          <p className="text-[11px] font-semibold uppercase tracking-[0.3em] text-[var(--accent-strong)]">AI Concierge</p>
          <h1 className="text-3xl font-semibold leading-tight text-[var(--text-primary)] sm:text-4xl">Премиальный чат для парковок и гостей ParkShare</h1>
          <p className="max-w-3xl text-sm text-[var(--text-muted)] sm:text-base">
            Сфокусирован на мобильном опыте: липкое поле ввода, аккуратные карточки, мгновенные подсказки и готовность к офлайн.
            Начните новый диалог или возобновите прежний в один тап.
          </p>
          <div className="flex flex-wrap gap-2 text-[11px] font-semibold uppercase tracking-[0.15em] text-[var(--text-muted)]">
            <span className="rounded-full border border-[var(--border-subtle)]/60 bg-white px-3 py-1 shadow-sm">Локальная история</span>
            <span className="rounded-full border border-[var(--border-subtle)]/60 bg-white px-3 py-1 shadow-sm">Поддержка тем</span>
            <span className="rounded-full border border-[var(--border-subtle)]/60 bg-white px-3 py-1 shadow-sm">AI потоковые ответы</span>
          </div>
        </div>
      </div>
      <ChatPanel />
      <div id="features" className="grid grid-cols-1 gap-4 md:grid-cols-3">
        {[
          { title: 'Мульти-провайдерный AI', desc: 'LLM через OpenAI/прокси. Потоковые ответы, обработка ошибок и перегенерация.' },
          { title: 'Безопасный вход', desc: 'Телефон + OTP, почта + пароль, VK/Яндекс OAuth. История привязывается к профилю.' },
          { title: 'PWA и офлайн', desc: 'Сервис-воркер, манифест, кеш оболочки и мягкие лоадеры для мобильного опыта.' }
        ].map((feature) => (
          <div
            key={feature.title}
            className="rounded-[22px] border border-[var(--border-subtle)]/70 bg-[var(--bg-elevated)] p-4 shadow-[0_14px_40px_rgba(15,23,42,0.06)]"
          >
            <p className="text-sm font-semibold text-[var(--text-primary)]">{feature.title}</p>
            <p className="mt-1 text-sm text-[var(--text-muted)]">{feature.desc}</p>
          </div>
        ))}
      </div>
    </section>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 163
PATH: frontend\next-app\app\(site)\auth\page.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { useEffect, useMemo, useState } from 'react';
import {
  ArrowRightIcon,
  EnvelopeIcon,
  LockClosedIcon,
  PhoneIcon,
  SparklesIcon,
  ShieldCheckIcon
} from '@heroicons/react/24/outline';
import { useAuth } from '@/hooks/useAuth';
import SocialLoginButtons from '@/components/auth/SocialLoginButtons';

export default function AuthPage() {
  const {
    user,
    isAuthenticated,
    loading: authLoading,
    loginWithEmail,
    registerWithEmail,
    requestPhoneOtp,
    verifyPhoneOtp,
    verifyMfaCode,
    loginWithVK,
    loginWithYandex,
    logout,
    mfaChallenge
  } = useAuth();

  const [phone, setPhone] = useState('');
  const [otp, setOtp] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [mode, setMode] = useState<'login' | 'register'>('login');
  const [status, setStatus] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [otpRequested, setOtpRequested] = useState(false);
  const [mfaCode, setMfaCode] = useState('');

  const isPhoneValid = useMemo(() => phone.replace(/[^\d]/g, '').length >= 10, [phone]);

  useEffect(() => {
    if (mfaChallenge) {
      setStatus('Требуется подтверждение второго фактора. Введите код ниже.');
    }
  }, [mfaChallenge]);

  const handleSendOtp = async () => {
    setIsSubmitting(true);
    setError(null);
    setStatus(null);
    try {
      await requestPhoneOtp(phone);
      setOtpRequested(true);
      setStatus('Код отправлен. Введите его, чтобы подтвердить вход.');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Не удалось отправить код.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleVerifyMfa = async () => {
    setIsSubmitting(true);
    setError(null);
    setStatus(null);
    try {
      const verified = await verifyMfaCode(mfaCode);
      if (verified) {
        setStatus('MFA подтверждена, вход завершён.');
        setMfaCode('');
      } else {
        setError('Не удалось подтвердить MFA.');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Код MFA не подошёл.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleVerifyOtp = async () => {
    setIsSubmitting(true);
    setError(null);
    setStatus(null);
    try {
      const verified = await verifyPhoneOtp(phone, otp);
      if (verified) {
        setStatus('Успешно! Сессия активна и готова к работе.');
      } else if (mfaChallenge) {
        setStatus('SMS/Email код принят. Подтвердите MFA.');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Не удалось подтвердить код.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleEmailAuth = async () => {
    setIsSubmitting(true);
    setError(null);
    setStatus(null);
    try {
      if (mode === 'login') {
        const loggedIn = await loginWithEmail(email, password);
        if (loggedIn) {
          setStatus('Вход выполнен. Продолжайте в чате.');
        } else if (mfaChallenge) {
          setStatus('Требуется подтверждение MFA. Введите код ниже.');
        }
      } else {
        const created = await registerWithEmail(email, password);
        if (created) {
          setStatus('Аккаунт создан, вы уже вошли.');
        } else if (mfaChallenge) {
          setStatus('Аккаунт создан. Подтвердите MFA, чтобы закончить.');
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Не удалось выполнить действие.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="mx-auto flex w-full max-w-4xl flex-col gap-6 py-6">
      <div className="flex flex-col gap-3 rounded-[28px] border border-[var(--border-subtle)]/80 bg-[var(--bg-elevated)] p-6 shadow-[0_25px_60px_rgba(15,23,42,0.08)]">
        <div className="flex items-start gap-3">
          <div className="flex h-12 w-12 items-center justify-center rounded-2xl bg-gradient-to-br from-[var(--accent)] to-[var(--accent-strong)] text-white shadow-[0_14px_38px_rgba(59,130,246,0.35)]">
            <SparklesIcon className="h-6 w-6" />
          </div>
          <div className="flex-1">
            <p className="text-[11px] font-semibold uppercase tracking-[0.3em] text-[var(--accent-strong)]">Единый вход</p>
            <h1 className="text-3xl font-semibold leading-tight text-[var(--text-primary)]">Вход в ParkShare</h1>
            <p className="mt-2 text-sm text-[var(--text-muted)]">
              Выберите способ: телефон с OTP, почта с паролем или VK/Яндекс. Одна учётка для всех сервисов ParkShare.
            </p>
            {isAuthenticated && (
              <div className="mt-3 flex items-center gap-3 rounded-2xl border border-emerald-200 bg-emerald-50 px-4 py-3 text-sm text-emerald-800 shadow-sm dark:border-emerald-800/60 dark:bg-emerald-950/40 dark:text-emerald-100">
                <ShieldCheckIcon className="h-5 w-5" />
                <div>
                  <p className="font-semibold">Вы вошли как {user?.name || user?.email || user?.phone || 'пользователь'}</p>
                  <p className="text-xs text-emerald-700/80 dark:text-emerald-100/80">Продолжайте в чате или выйдите, чтобы сменить профиль.</p>
                </div>
                <button
                  onClick={() => void logout()}
                  className="rounded-full bg-white/80 px-3 py-1 text-xs font-semibold text-emerald-700 transition hover:-translate-y-[1px] hover:shadow-sm"
                >
                  Выйти
                </button>
              </div>
            )}
          </div>
        </div>
        {status && (
          <p className="rounded-2xl border border-emerald-200 bg-emerald-50 px-4 py-3 text-sm text-emerald-700 shadow-sm dark:border-emerald-900/60 dark:bg-emerald-950/40 dark:text-emerald-100">
            {status}
          </p>
        )}
        {error && (
          <p className="rounded-2xl border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-700 shadow-sm dark:border-red-900/60 dark:bg-red-950/40 dark:text-red-100">
            {error}
          </p>
        )}
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          <div className="rounded-[20px] border border-[var(--border-subtle)]/70 bg-white/70 p-4 shadow-sm backdrop-blur dark:border-slate-800 dark:bg-slate-900/70">
            <div className="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)]">
              <PhoneIcon className="h-5 w-5" />
              <span>Телефон + SMS</span>
            </div>
            <p className="mt-1 text-xs text-[var(--text-muted)]">Отправим код на ваш номер. Без пароля.</p>
            <div className="mt-3 space-y-2">
              <input
                type="tel"
                inputMode="tel"
                placeholder="+7 (___) ___-__-__"
                value={phone}
                onChange={(e) => setPhone(e.target.value)}
              />
              <div className="flex gap-2">
                <button
                  className="w-full rounded-2xl bg-gradient-to-r from-[var(--accent)] to-[var(--accent-strong)] px-4 py-2 text-sm font-semibold text-white shadow-[0_14px_38px_rgba(59,130,246,0.35)] disabled:cursor-not-allowed disabled:opacity-60"
                  onClick={handleSendOtp}
                  disabled={!isPhoneValid || isSubmitting || authLoading}
                >
                  {otpRequested ? 'Отправить снова' : 'Отправить код'}
                </button>
                <button
                  className="min-w-[110px] rounded-2xl border border-[var(--border-subtle)]/70 bg-[var(--bg-elevated)] px-3 py-2 text-xs font-semibold text-[var(--text-primary)] shadow-sm disabled:opacity-50"
                  onClick={handleVerifyOtp}
                  disabled={!otp || isSubmitting || authLoading}
                >
                  Подтвердить
                </button>
              </div>
              <input
                type="text"
                inputMode="numeric"
                placeholder="Код из SMS"
                value={otp}
                onChange={(e) => setOtp(e.target.value)}
              />
            </div>
          </div>
          <div className="flex flex-col gap-3 rounded-[20px] border border-[var(--border-subtle)]/70 bg-white/70 p-4 shadow-sm backdrop-blur dark:border-slate-800 dark:bg-slate-900/70">
            <div className="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)]">
              <EnvelopeIcon className="h-5 w-5" />
              <span>Почта + пароль</span>
            </div>
            <div className="flex items-center gap-2 text-xs text-[var(--text-muted)]">
              <button
                onClick={() => setMode('login')}
                className={`rounded-full px-2 py-1 font-semibold transition ${mode === 'login' ? 'bg-[var(--bg-surface)] text-[var(--text-primary)] shadow-sm' : 'text-[var(--text-muted)]'}`}
              >
                Вход
              </button>
              <button
                onClick={() => setMode('register')}
                className={`rounded-full px-2 py-1 font-semibold transition ${mode === 'register' ? 'bg-[var(--bg-surface)] text-[var(--text-primary)] shadow-sm' : 'text-[var(--text-muted)]'}`}
              >
                Регистрация
              </button>
            </div>
            <input type="email" placeholder="you@example.com" value={email} onChange={(e) => setEmail(e.target.value)} />
            <input
              type="password"
              placeholder="••••••••"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
            <button
              className="flex items-center justify-center gap-2 rounded-2xl bg-[var(--text-primary)] px-4 py-3 text-sm font-semibold text-white shadow-[0_14px_38px_rgba(15,23,42,0.15)] transition hover:-translate-y-[1px] hover:shadow-lg disabled:opacity-50"
              onClick={handleEmailAuth}
              disabled={!email || !password || isSubmitting || authLoading}
            >
              <LockClosedIcon className="h-4 w-4" />
              {mode === 'login' ? 'Войти' : 'Создать аккаунт'}
              <ArrowRightIcon className="h-4 w-4" />
            </button>
            <p className="text-[11px] text-[var(--text-muted)]">Пароли передаются только по HTTPS. После входа используйте чат или бронирования без повторного подтверждения.</p>
          </div>
        </div>
        <div className="rounded-[20px] border border-[var(--border-subtle)]/70 bg-white/70 p-4 shadow-sm backdrop-blur dark:border-slate-800 dark:bg-slate-900/70">
          <p className="text-sm font-semibold text-[var(--text-primary)]">Соцсети</p>
          <p className="text-xs text-[var(--text-muted)]">VK и Яндекс через OAuth с редиректом назад в ParkShare.</p>
          <div className="mt-3">
            <SocialLoginButtons
              onVK={loginWithVK}
              onYandex={loginWithYandex}
              onGoogle={() => {
                window.location.href = '/api/auth/signin';
              }}
            />
          </div>
          <p className="mt-2 text-[11px] text-[var(--text-muted)]">OAuth перенаправит вас к провайдеру, затем вернёт сюда. MFA запрашивается после соц-входа, если включена.</p>
        </div>
      </div>
      {mfaChallenge && (
        <div className="mt-4 rounded-[20px] border border-[var(--border-subtle)]/70 bg-white/80 p-4 shadow-sm dark:border-slate-800 dark:bg-slate-900/80">
          <div className="flex items-center gap-2 text-sm font-semibold text-[var(--text-primary)]">
            <ShieldCheckIcon className="h-5 w-5" />
            <span>Подтверждение MFA ({mfaChallenge.method})</span>
          </div>
          <p className="mt-1 text-xs text-[var(--text-muted)]">Введите код из приложения или сообщения. Мы не храним коды в браузере.</p>
          <div className="mt-3 flex flex-col gap-2 sm:flex-row">
            <input
              type="text"
              inputMode="numeric"
              placeholder="Код MFA"
              value={mfaCode}
              onChange={(e) => setMfaCode(e.target.value)}
              className="sm:w-1/3"
            />
            <button
              onClick={handleVerifyMfa}
              disabled={!mfaCode || isSubmitting || authLoading}
              className="rounded-2xl bg-[var(--text-primary)] px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg disabled:opacity-50"
            >
              Подтвердить MFA
            </button>
          </div>
          <p className="mt-2 text-[11px] text-[var(--text-muted)]">Если провайдер не доставляет код — переключитесь на TOTP в настройках профиля.</p>
        </div>
      )}
    </div>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 164
PATH: frontend\next-app\app\api\chat\route.ts
LANG: typescript
===== CONTENT START =====
import type { NextRequest } from 'next/server';

export const runtime = 'nodejs';

export async function POST(req: NextRequest) {
  let body: any = {};
  try {
    body = await req.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid JSON body' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const apiBase = process.env.NEXT_PUBLIC_API_BASE || process.env.API_BASE || 'http://localhost:8000/api/v1';
  const endpoint = `${apiBase.replace(/\/$/, '')}/assistant/chat/`;
  const resp = await fetch(endpoint, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
    credentials: 'include'
  });

  const text = await resp.text();
  return new Response(text, {
    status: resp.status,
    headers: {
      'Content-Type': resp.headers.get('content-type') || 'application/json',
      'Cache-Control': 'no-store'
    }
  });
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 165
PATH: frontend\next-app\app\embed\page.tsx
LANG: tsx
===== CONTENT START =====
import { CompactChatPanel } from '@/components/chat/compact-chat-panel';

export const metadata = {
  title: 'AI Concierge – Embed'
};

export default function EmbedPage() {
  return (
    <main className="min-h-screen bg-slate-950 flex items-center justify-center p-2">
      <div className="w-full max-w-md h-[80vh] rounded-3xl bg-slate-900/90 shadow-2xl border border-slate-700/80 overflow-hidden">
        <CompactChatPanel />
      </div>
    </main>
  );
}
===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 166
PATH: frontend\next-app\components\header.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { ThemeToggle } from './theme-toggle';
import { Bars3Icon } from '@heroicons/react/24/outline';
import { useAuth } from '@/hooks/useAuth';

export function Header() {
  const { user, isAuthenticated, logout, loading } = useAuth();
  const userLabel = user?.name || user?.email || user?.phone || 'Гость';

  return (
    <header className="sticky top-0 z-20 border-b border-[var(--border-subtle)]/60 bg-[var(--bg-elevated)]/90 backdrop-blur-lg">
      <div className="mx-auto flex max-w-6xl items-center justify-between px-4 py-3">
        <div className="flex items-center gap-3">
          <div className="flex h-11 w-11 items-center justify-center rounded-2xl bg-gradient-to-br from-[var(--accent)] to-[var(--accent-strong)] text-white shadow-[0_10px_30px_rgba(59,130,246,0.25)]">
            <Bars3Icon className="h-6 w-6" />
          </div>
          <div className="leading-tight">
            <p className="text-lg font-semibold tracking-tight">ParkShare Concierge</p>
            <p className="text-xs text-[var(--text-muted)]">Премиальный ассистент для партнёров</p>
          </div>
        </div>
        <nav className="hidden items-center gap-4 text-sm font-medium text-[var(--text-muted)] sm:flex">
          <a className="rounded-full px-3 py-1 transition hover:text-[var(--text-primary)] hover:shadow-sm" href="/">Чат</a>
          <a className="rounded-full px-3 py-1 transition hover:text-[var(--text-primary)] hover:shadow-sm" href="/auth">Вход</a>
          <a className="rounded-full px-3 py-1 transition hover:text-[var(--text-primary)] hover:shadow-sm" href="#features">Особенности</a>
        </nav>
        <div className="flex items-center gap-3">
          <ThemeToggle />
          <div className="hidden sm:flex items-center gap-2 rounded-full border border-[var(--border-subtle)]/70 bg-[var(--bg-surface)] px-3 py-1.5 text-xs font-semibold text-[var(--text-muted)] shadow-sm">
            <span
              className={`h-2 w-2 rounded-full ${isAuthenticated ? 'bg-emerald-400' : 'bg-amber-400'}`}
              aria-hidden
            />
            <span className="text-[var(--text-primary)]">{loading ? 'Загрузка…' : userLabel}</span>
            {isAuthenticated ? (
              <button
                onClick={() => void logout()}
                className="rounded-full bg-white/70 px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] transition hover:-translate-y-[1px] hover:text-[var(--text-primary)]"
              >
                Выйти
              </button>
            ) : (
              <a
                href="/auth"
                className="rounded-full bg-white/80 px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] transition hover:-translate-y-[1px] hover:text-[var(--text-primary)]"
              >
                Войти
              </a>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 167
PATH: frontend\next-app\components\providers.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { ThemeProvider } from './theme-provider';
import { AuthProvider } from '@/context/AuthContext';

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider>
      <AuthProvider>{children}</AuthProvider>
    </ThemeProvider>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 168
PATH: frontend\next-app\components\theme-provider.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { createContext, useContext, useEffect, useMemo, useState } from 'react';

type Theme = 'light' | 'dark';

interface ThemeContextValue {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light');

  useEffect(() => {
    const savedTheme = (typeof window !== 'undefined' && localStorage.getItem('theme')) as Theme | null;
    if (savedTheme === 'dark' || savedTheme === 'light') {
      setTheme(savedTheme);
      return;
    }
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    setTheme(prefersDark ? 'dark' : 'light');
  }, []);

  useEffect(() => {
    const root = document.documentElement;
    root.classList.remove(theme === 'dark' ? 'light' : 'dark');
    root.classList.add(theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  const value = useMemo(
    () => ({
      theme,
      toggleTheme: () => setTheme((prev) => (prev === 'dark' ? 'light' : 'dark'))
    }),
    [theme]
  );

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 169
PATH: frontend\next-app\components\theme-toggle.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { MoonIcon, SunIcon } from '@heroicons/react/24/solid';
import { useTheme } from './theme-provider';

export function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();

  return (
    <button
      onClick={toggleTheme}
      className="flex items-center gap-2 border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 text-slate-800 dark:text-slate-100 hover:bg-slate-50 dark:hover:bg-slate-700 px-3 py-2 rounded-lg"
      aria-label="Toggle theme"
      type="button"
    >
      {theme === 'dark' ? <SunIcon className="h-5 w-5" /> : <MoonIcon className="h-5 w-5" />}
      <span className="hidden sm:inline">{theme === 'dark' ? 'Light' : 'Dark'} mode</span>
    </button>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 170
PATH: frontend\next-app\components\auth\SocialLoginButtons.tsx
LANG: tsx
===== CONTENT START =====
import { useState } from 'react';

type Props = {
  onVK?: () => void;
  onYandex?: () => void;
  onGoogle?: () => void;
};

function GoogleLogo() {
  return (
    <svg viewBox="0 0 24 24" aria-hidden="true" className="h-6 w-6">
      <path fill="#4285F4" d="M21.6 12.23c0-.8-.07-1.6-.21-2.36H12v4.48h5.36a4.6 4.6 0 0 1-2 3.02v2.5h3.24c1.9-1.75 3-4.33 3-7.64Z" />
      <path fill="#34A853" d="M12 22c2.7 0 4.96-.9 6.62-2.43l-3.24-2.5c-.9.6-2.06.96-3.38.96-2.6 0-4.8-1.76-5.58-4.12H3.08v2.59A10 10 0 0 0 12 22Z" />
      <path fill="#FBBC05" d="M6.42 13.91c-.2-.6-.32-1.24-.32-1.91s.12-1.32.32-1.91V7.5H3.08A10 10 0 0 0 2 12c0 1.6.38 3.1 1.08 4.5l3.34-2.59Z" />
      <path fill="#EA4335" d="M12 6.08c1.46 0 2.77.5 3.8 1.47l2.84-2.84C16.96 2.9 14.7 2 12 2 7.92 2 4.36 4.3 3.08 7.5l3.34 2.59C7.2 7.84 9.4 6.08 12 6.08Z" />
    </svg>
  );
}

function VkLogo() {
  return (
    <svg viewBox="0 0 24 24" aria-hidden="true" className="h-6 w-6">
      <path
        d="M3.5 7h2.7l2.2 4 2.1-4h2.4l-1.4 4.3 3.2-4.3h2.6l-4.2 5.3 3.8 5.7h-2.7l-2.3-3.5-2.3 3.5H8.9l3.8-5.4L7.6 7H3.5Z"
        fill="currentColor"
      />
    </svg>
  );
}

function YandexLogo() {
  return (
    <svg viewBox="0 0 24 24" aria-hidden="true" className="h-6 w-6">
      <path d="M8 3h3.6l2 6.3L15.6 3H19l-3.5 8V21h-2.6v-5.5L8 3Z" fill="currentColor" />
    </svg>
  );
}

export default function SocialLoginButtons({ onVK, onYandex, onGoogle }: Props) {
  const [loading, setLoading] = useState<string | null>(null);

  const handleClick = (key: string, fn?: () => void) => {
    if (!fn) return;
    setLoading(key);
    fn();
  };

  return (
    <div className="space-y-3">
      <button
        type="button"
        aria-label="Sign in with Google"
        onClick={() => handleClick('google', onGoogle)}
        disabled={loading === 'google'}
        className="group relative flex w-full items-center gap-3 overflow-hidden rounded-2xl border border-slate-200 bg-white px-4 py-3 text-left shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg disabled:opacity-60 dark:border-slate-800 dark:bg-slate-900"
      >
        <span className="absolute inset-y-0 left-0 w-1.5 bg-[#4285F4]/80" aria-hidden="true" />
        <span className="flex h-12 w-16 items-center justify-center rounded-xl border border-slate-200 bg-white text-lg font-bold shadow-inner dark:border-slate-700">
          <GoogleLogo />
        </span>
        <div className="flex flex-col gap-0.5 leading-tight">
          <span className="text-sm font-semibold text-slate-900 dark:text-white">
            {loading === 'google' ? 'Перенаправляем…' : 'Sign in with Google'}
          </span>
          <span className="text-[11px] text-slate-500 dark:text-slate-300">Быстрый вход по аккаунту Google</span>
        </div>
        <span className="ml-auto text-xs font-semibold text-slate-400 dark:text-slate-300" aria-hidden="true">
          →
        </span>
      </button>

      <button
        type="button"
        aria-label="Войти через VK ID"
        onClick={() => handleClick('vk', onVK)}
        disabled={loading === 'vk'}
        className="group relative flex w-full items-center gap-3 overflow-hidden rounded-2xl border border-[#4c75a3]/60 bg-white px-4 py-3 text-left shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg disabled:opacity-60 dark:border-[#4c75a3]/50 dark:bg-slate-900"
      >
        <span className="absolute inset-y-0 left-0 w-1.5 bg-[#4c75a3]" aria-hidden="true" />
        <span className="flex h-12 w-16 items-center justify-center rounded-xl bg-[#4c75a3] text-white shadow-inner shadow-[#4c75a3]/30">
          <VkLogo />
        </span>
        <div className="flex flex-col gap-0.5 leading-tight">
          <span className="text-sm font-semibold text-slate-900 dark:text-white">
            {loading === 'vk' ? 'Перенаправляем…' : 'Войти через VK ID'}
          </span>
          <span className="text-[11px] text-slate-500 dark:text-slate-300">Имя и email, без публикаций</span>
        </div>
        <span className="ml-auto text-xs font-semibold text-slate-400 dark:text-slate-300" aria-hidden="true">
          →
        </span>
      </button>

      <button
        type="button"
        aria-label="Войти через Яндекс ID"
        onClick={() => handleClick('yandex', onYandex)}
        disabled={loading === 'yandex'}
        className="group relative flex w-full items-center gap-3 overflow-hidden rounded-2xl border border-[#ffcc00]/50 bg-white px-4 py-3 text-left shadow-sm transition hover:-translate-y-[1px] hover:shadow-lg disabled:opacity-60 dark:border-[#ffcc00]/40 dark:bg-slate-900"
      >
        <span className="absolute inset-y-0 left-0 w-1.5 bg-[#ffcc00]" aria-hidden="true" />
        <span className="flex h-12 w-16 items-center justify-center rounded-xl bg-[#ffcc00] text-black shadow-inner shadow-amber-200/60">
          <YandexLogo />
        </span>
        <div className="flex flex-col gap-0.5 leading-tight">
          <span className="text-sm font-semibold text-slate-900 dark:text-white">
            {loading === 'yandex' ? 'Перенаправляем…' : 'Войти через Яндекс ID'}
          </span>
          <span className="text-[11px] text-slate-500 dark:text-slate-300">Профиль без лишних прав</span>
        </div>
        <span className="ml-auto text-xs font-semibold text-slate-400 dark:text-slate-300" aria-hidden="true">
          →
        </span>
      </button>
    </div>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 171
PATH: frontend\next-app\components\chat\chat-panel.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import dynamic from 'next/dynamic';
import {
  PaperAirplaneIcon,
  SparklesIcon,
  ClockIcon,
  ArrowPathIcon,
  Bars3Icon,
  ClipboardIcon,
  ExclamationTriangleIcon
} from '@heroicons/react/24/outline';
import { ChatMessage } from '@/lib/aiProvider';
import { Conversation, MessageWithId } from './types';
import { ConversationList } from './conversation-list';
import { SuggestedPrompts } from './suggested-prompts';
import { apiRequest, type AssistantAction, type AssistantResponse, type BookingSession } from '@/lib/apiClient';
import { useAuth } from '@/hooks/useAuth';

const MarkdownMessage = dynamic(() => import('./markdown-message'), {
  ssr: false,
  loading: () => <div className="h-4 w-24 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />
});

const STORAGE_KEY_BASE = 'parkshare_conversations_v2';
const ONBOARDING_KEY = 'parkshare_onboarding_seen';
const MAX_HISTORY = 14;
const FAVORITE_PROMPTS = [
  'Сформируй чат-скрипт для диспетчера парковки с VIP-клиентами.',
  'Собери сводку по пиковым часам и дай рекомендации по динамическим тарифам.',
  'Сценарий поддержки: клиент не может найти въезд. Какие шаги предложить?',
  'Что добавить в онбординг партнёра, чтобы повысить NPS?',
  'Сделай контрольный чек-лист для запуска новой парковки на выходные.'
];

const createWelcomeMessage = (): MessageWithId => ({
  id: crypto.randomUUID(),
  role: 'assistant',
  content: 'Привет! Я ParkShare AI Concierge. Спроси про загрузку, цены, сценарии для гостей или подготовку персонала.',
  createdAt: Date.now()
});

const createConversation = (title = 'New conversation'): Conversation => ({
  id: crypto.randomUUID(),
  title,
  messages: [createWelcomeMessage()],
  updatedAt: Date.now()
});

const storageKeyForUser = (userId?: string | null) => `${STORAGE_KEY_BASE}:${userId ?? 'guest'}`;

export function ChatPanel() {
  const { user, isAuthenticated } = useAuth();
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [showSidebar, setShowSidebar] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [showOnboarding, setShowOnboarding] = useState(false);
  const [sessions, setSessions] = useState<BookingSession[]>([]);
  const [alerts, setAlerts] = useState<{ booking_id?: string; type: string; minutes_left?: number; spot?: string }[]>([]);
  const [actions, setActions] = useState<AssistantAction[]>([]);
  const [sessionsFetchedAt, setSessionsFetchedAt] = useState<number | null>(null);
  const [actionRunning, setActionRunning] = useState<string | null>(null);
  const [tick, setTick] = useState(0);
  const chatEndRef = useRef<HTMLDivElement | null>(null);
  const lastStorageKey = useRef<string | null>(null);

  const storageKey = useMemo(() => storageKeyForUser(user?.id), [user?.id]);

  useEffect(() => {
    if (typeof window === 'undefined' || lastStorageKey.current === storageKey) return;
    lastStorageKey.current = storageKey;
    try {
      const stored = localStorage.getItem(storageKey);
      if (stored) {
        const parsed: Conversation[] = JSON.parse(stored);
        setConversations(parsed);
        setActiveConversationId(parsed[0]?.id ?? null);
        return;
      }
    } catch (error) {
      console.warn('Failed to parse saved conversations', error);
    }
    // TODO: Mirror conversation history to a backend store for multi-device sync and tenant scoping.
    const starter = createConversation('Welcome thread');
    setConversations([starter]);
    setActiveConversationId(starter.id);
  }, [storageKey]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    localStorage.setItem(storageKey, JSON.stringify(conversations));
  }, [conversations, storageKey]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    const seen = localStorage.getItem(ONBOARDING_KEY);
    if (!seen) {
      setShowOnboarding(true);
      localStorage.setItem(ONBOARDING_KEY, 'true');
    }
  }, []);

  useEffect(() => {
    const id = setInterval(() => setTick((t) => t + 1), 1000);
    return () => clearInterval(id);
  }, []);

  useEffect(() => {
    void fetchSessions();
  }, [fetchSessions]);

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: 'smooth', block: 'end' });
  }, [conversations, activeConversationId]);

  const currentConversation = useMemo(
    () => conversations.find((conv) => conv.id === activeConversationId) ?? null,
    [conversations, activeConversationId]
  );

  const bookingActions = useMemo(
    () => actions.filter((a) => a.type === 'booking_start' || a.type === 'booking_extend' || a.type === 'booking_stop'),
    [actions]
  );

  const actionLabel = useCallback((action: AssistantAction) => {
    if (action.type === 'booking_start') return 'Начать парковку';
    if (action.type === 'booking_extend') return 'Продлить сессию';
    if (action.type === 'booking_stop') return 'Завершить сессию';
    return 'Действие';
  }, []);

  const updateConversation = useCallback(
    (id: string, updater: (conversation: Conversation) => Conversation) => {
      setConversations((prev) => prev.map((conv) => (conv.id === id ? updater(conv) : conv)));
    },
    []
  );

  const handleCreate = useCallback(() => {
    const conversation = createConversation('New idea');
    setConversations((prev) => [conversation, ...prev]);
    setActiveConversationId(conversation.id);
  }, []);

  const fetchSessions = useCallback(async () => {
    if (!isAuthenticated) {
      setSessions([]);
      setSessionsFetchedAt(Date.now());
      return;
    }
    try {
      const response = await apiRequest<{ results: BookingSession[] }>('/booking/active/', { method: 'GET' });
      setSessions(response.results || []);
      setSessionsFetchedAt(Date.now());
    } catch (error) {
      console.warn('Failed to load active sessions', error);
    }
  }, [isAuthenticated]);

  const handleRename = useCallback((id: string, name: string) => {
    updateConversation(id, (conv) => ({ ...conv, title: name, updatedAt: Date.now() }));
  }, [updateConversation]);

  const handleDelete = useCallback(
    (id: string) => {
      setConversations((prev) => {
        const remaining = prev.filter((conv) => conv.id !== id);
        if (id === activeConversationId) {
          setActiveConversationId(remaining[0]?.id ?? null);
        }
        return remaining;
      });
    },
    [activeConversationId]
  );

  const handleSelectConversation = useCallback((id: string) => {
    setActiveConversationId(id);
    setShowSidebar(false);
  }, []);

  const deliverAssistantReply = useCallback(
    (conversationId: string, assistantMessageId: string, reply: string) => {
      updateConversation(conversationId, (conv) => ({
        ...conv,
        messages: conv.messages.map((msg) => (msg.id === assistantMessageId ? { ...msg, content: reply } : msg)),
        updatedAt: Date.now()
      }));
    },
    [updateConversation]
  );

  const requestAssistant = useCallback(
    async (conversationId: string, assistantMessageId: string, history: ChatMessage[]) => {
      const response = await apiRequest<AssistantResponse>('/assistant/chat/', {
        method: 'POST',
        body: { messages: history, structured: true }
      });
      deliverAssistantReply(conversationId, assistantMessageId, response.reply || 'Сервис временно недоступен.');
      setActions(response.actions || []);
      setAlerts(response.alerts || []);
      if (response.sessions) {
        setSessions(response.sessions);
        setSessionsFetchedAt(Date.now());
      }
      return response;
    },
    [deliverAssistantReply]
  );

  const handleAction = useCallback(
    async (action: AssistantAction) => {
      const actionKey = action.booking_id || action.spot_id || action.type;
      setActionRunning(actionKey || null);
      try {
        if (action.type === 'booking_start' && action.spot_id) {
          await apiRequest('/booking/start/', {
            method: 'POST',
            body: { spot_id: action.spot_id, duration_minutes: action.duration_minutes || 60 }
          });
        } else if (action.type === 'booking_extend' && action.booking_id) {
          await apiRequest('/booking/extend/', {
            method: 'POST',
            body: { booking_id: action.booking_id, extend_minutes: action.extend_minutes || 30 }
          });
        } else if (action.type === 'booking_stop' && action.booking_id) {
          await apiRequest('/booking/stop/', { method: 'POST', body: { booking_id: action.booking_id } });
        } else if (action.type === 'focus_map' && action.spot_id) {
          try {
            sessionStorage.setItem('ps_focus_spot', action.spot_id);
          } catch (err) {
            console.warn('Cannot persist focus spot', err);
          }
          window.location.href = '/';
        } else if (action.type === 'book' && action.spot_id) {
          window.location.href = `/booking/confirm/?spot_id=${encodeURIComponent(action.spot_id)}`;
        }
        await fetchSessions();
      } catch (err) {
        console.error('Action failed', err);
        setErrorMessage(err instanceof Error ? err.message : 'Не удалось выполнить действие ассистента.');
      } finally {
        setActionRunning(null);
      }
    },
    [fetchSessions]
  );

  const computeRemaining = useCallback(
    (session: BookingSession) => {
      const elapsed = sessionsFetchedAt ? Math.floor((Date.now() - sessionsFetchedAt) / 1000) : 0;
      return Math.max(0, session.remaining_seconds - elapsed);
    },
    [sessionsFetchedAt]
  );

  const handleSend = useCallback(async () => {
    if (!currentConversation || !input.trim() || isLoading) return;
    const userMessage: MessageWithId = {
      id: crypto.randomUUID(),
      role: 'user',
      content: input.trim(),
      createdAt: Date.now()
    };

    setInput('');
    setIsLoading(true);
    setErrorMessage(null);

    const historyPayload: ChatMessage[] = currentConversation.messages
      .concat(userMessage)
      .slice(-MAX_HISTORY)
      .map(({ id, createdAt, ...rest }) => rest as ChatMessage);

    updateConversation(currentConversation.id, (conv) => {
      const trimmedHistory = [...conv.messages, userMessage].slice(-MAX_HISTORY);
      return { ...conv, messages: trimmedHistory, updatedAt: Date.now() };
    });

    const assistantMessage: MessageWithId = { id: crypto.randomUUID(), role: 'assistant', content: '', createdAt: Date.now() };
    updateConversation(currentConversation.id, (conv) => ({
      ...conv,
      messages: [...conv.messages, assistantMessage].slice(-MAX_HISTORY),
      updatedAt: Date.now()
    }));

    try {
      await requestAssistant(currentConversation.id, assistantMessage.id, historyPayload);
    } catch (error) {
      console.error(error);
      setErrorMessage('Мы не смогли обратиться к ассистенту. Попробуйте снова или проверьте подключение.');
      deliverAssistantReply(
        currentConversation.id,
        assistantMessage.id,
        'Ассистент временно недоступен. Проверьте подключение или авторизацию и повторите.'
      );
    } finally {
      setIsLoading(false);
    }
  }, [currentConversation, input, isLoading, requestAssistant, deliverAssistantReply, updateConversation]);

  const handleKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      void handleSend();
    }
  };

  const handleClear = useCallback(() => {
    if (!currentConversation) return;
    updateConversation(currentConversation.id, (conv) => ({
      ...conv,
      messages: [createWelcomeMessage()],
      updatedAt: Date.now()
    }));
    setInput('');
    setErrorMessage(null);
    setActions([]);
    setAlerts([]);
  }, [currentConversation, updateConversation]);

  const handleRegenerate = useCallback(
    async (assistantMessageId: string) => {
      if (!currentConversation || isLoading) return;
      const targetIndex = currentConversation.messages.findIndex((msg) => msg.id === assistantMessageId);
      if (targetIndex <= 0) return;
      const historyBefore = currentConversation.messages.slice(0, targetIndex);
      const lastUserIndex = [...historyBefore].reverse().findIndex((msg) => msg.role === 'user');
      if (lastUserIndex === -1) return;
      const userIndex = historyBefore.length - 1 - lastUserIndex;
      const historyToSend = currentConversation.messages.slice(0, userIndex + 1);

      setIsLoading(true);
      setErrorMessage(null);

      const assistantMessage: MessageWithId = { id: crypto.randomUUID(), role: 'assistant', content: '', createdAt: Date.now() };
      updateConversation(currentConversation.id, (conv) => ({
        ...conv,
        messages: [...historyToSend, assistantMessage].slice(-MAX_HISTORY),
        updatedAt: Date.now()
      }));

      const payloadMessages: ChatMessage[] = historyToSend.map(({ id, createdAt, ...rest }) => rest as ChatMessage);

      try {
        await requestAssistant(currentConversation.id, assistantMessage.id, payloadMessages);
      } catch (error) {
        console.error(error);
        setErrorMessage('Не удалось перегенерировать ответ. Попробуйте снова.');
        deliverAssistantReply(currentConversation.id, assistantMessage.id, 'Ассистент недоступен. Повторите позже.');
      } finally {
        setIsLoading(false);
      }
    },
    [currentConversation, isLoading, requestAssistant, updateConversation, deliverAssistantReply]
  );

  const handlePrefill = useCallback((prompt: string) => {
    setInput(prompt);
  }, []);

  const sendDisabled = isLoading || !input.trim();

  return (
    <div className="relative flex min-h-[70vh] flex-1 flex-col overflow-hidden rounded-[28px] border border-[var(--border-subtle)]/80 bg-gradient-to-br from-white via-[var(--bg-surface)] to-white p-4 shadow-[0_18px_42px_rgba(15,23,42,0.08)] dark:border-slate-800/80 dark:from-slate-950 dark:via-slate-900 dark:to-indigo-950/40">
      <div className="mb-4 flex flex-col gap-4 rounded-3xl border border-slate-200/60 bg-white/70 p-4 backdrop-blur dark:border-slate-800/70 dark:bg-slate-900/60">
        <div className="flex flex-wrap items-center justify-between gap-4">
          <div className="flex items-center gap-3">
            <div className="flex h-12 w-12 items-center justify-center rounded-2xl bg-gradient-to-r from-blue-500 to-indigo-500 text-white shadow-md">
              <SparklesIcon className="h-6 w-6" />
            </div>
            <div className="space-y-0.5">
              <p className="text-lg font-semibold text-slate-900 dark:text-slate-50">AI Concierge</p>
              <p className="text-sm text-slate-600 dark:text-slate-400">Потоковые ответы, готовые пресеты и офлайн-поведение.</p>
              <p className="text-xs text-slate-500 dark:text-slate-400">
                Статус: {isAuthenticated ? 'Личный профиль' : 'Гостевой режим'} • История хранится локально
              </p>
            </div>
          </div>
          <div className="flex flex-wrap items-center gap-2">
            <button
              className="flex items-center gap-2 rounded-full border border-slate-200 bg-white/60 px-3 py-2 text-xs font-medium text-slate-700 shadow-sm transition hover:border-indigo-300 hover:text-indigo-700 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200 dark:hover:border-indigo-500/60"
              onClick={handleCreate}
            >
              <ArrowPathIcon className="h-4 w-4" />
              Новый диалог
            </button>
            <button
              onClick={handleClear}
              className="flex items-center gap-2 rounded-full border border-slate-200 bg-white/60 px-3 py-2 text-xs font-medium text-slate-700 shadow-sm transition hover:border-red-200 hover:text-red-600 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200"
            >
              <StopCircleIcon className="h-4 w-4" />
              Очистить
            </button>
            <button
              className="inline-flex items-center gap-2 rounded-full border border-indigo-200/80 bg-indigo-50 px-3 py-2 text-xs font-semibold text-indigo-700 shadow-sm transition hover:-translate-y-[1px] hover:shadow-md dark:border-indigo-500/50 dark:bg-indigo-900/40 dark:text-indigo-100"
              onClick={() => setShowSidebar(true)}
            >
              <Bars3Icon className="h-4 w-4" />
              Диалоги
            </button>
          </div>
        </div>
        <div className="flex flex-wrap items-center justify-between gap-2">
          <div className="flex items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
            <ClockIcon className="h-4 w-4" />
            <span>Контекст до 14 сообщений. Профиль влияет на подсказки и историю.</span>
          </div>
          {isLoading && (
            <div className="inline-flex items-center gap-2 rounded-full bg-indigo-50 px-3 py-1 text-[11px] font-semibold text-indigo-700 shadow-sm dark:bg-indigo-900/50 dark:text-indigo-100">
              <span className="h-2 w-2 animate-pulse rounded-full bg-indigo-500" />
              Генерируем ответ
            </div>
          )}
        </div>
        <SuggestedPrompts onSelect={handlePrefill} />
        <div className="flex flex-wrap items-center gap-2">
          {FAVORITE_PROMPTS.map((prompt) => (
            <button
              key={prompt}
              onClick={() => handlePrefill(prompt)}
              className="group rounded-full border border-slate-200/70 bg-white/70 px-3 py-2 text-xs text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-slate-300 hover:bg-white dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200"
            >
              <span className="mr-2 inline-block h-2 w-2 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 transition group-hover:scale-110" />
              {prompt}
            </button>
          ))}
        </div>
        {showOnboarding && (
          <div className="rounded-2xl border border-indigo-200 bg-indigo-50/80 px-4 py-3 text-xs text-indigo-800 shadow-sm dark:border-indigo-800/70 dark:bg-indigo-900/40 dark:text-indigo-100">
            <div className="flex items-center justify-between gap-2">
              <p>Подсказки и история сохраняются локально. Нажмите «Диалоги» для быстрого переключения веток.</p>
              <button
                onClick={() => setShowOnboarding(false)}
                className="rounded-full bg-white/70 px-3 py-1 text-[11px] font-semibold text-indigo-700 shadow-sm transition hover:-translate-y-[1px] dark:bg-indigo-800/60 dark:text-indigo-100"
              >
                Понятно
              </button>
            </div>
          </div>
        )}
        {!isAuthenticated && (
          <div className="flex items-center justify-between gap-2 rounded-2xl border border-amber-200 bg-amber-50 px-4 py-3 text-xs text-amber-800 shadow-sm dark:border-amber-800 dark:bg-amber-950/50 dark:text-amber-100">
            <p>Войдите, чтобы закрепить историю за аккаунтом и продолжать с любого устройства.</p>
            <a
              href="/auth"
              className="rounded-full bg-white/70 px-3 py-1 text-[11px] font-semibold text-amber-800 shadow-sm transition hover:-translate-y-[1px] dark:bg-amber-900 dark:text-amber-50"
            >
              Войти
            </a>
          </div>
        )}
      </div>

      {alerts.length > 0 && (
        <div className="mb-3 grid gap-2">
          {alerts.map((alert) => {
            const remaining = alert.minutes_left ?? 0;
            return (
              <div
                key={`${alert.booking_id}-${alert.type}`}
                className="flex items-center justify-between gap-2 rounded-2xl border border-amber-200 bg-amber-50 px-3 py-2 text-xs text-amber-800 shadow-sm dark:border-amber-900/60 dark:bg-amber-950/40 dark:text-amber-100"
              >
                <div className="flex items-center gap-2">
                  <ExclamationTriangleIcon className="h-4 w-4" />
                  <p>
                    {alert.type === 'booking_expiring'
                      ? `Бронь ${alert.spot || ''} заканчивается через ~${remaining} мин.`
                      : 'Обратите внимание на сессию парковки.'}
                  </p>
                </div>
              </div>
            );
          })}
        </div>
      )}

      {sessions.length > 0 && (
        <div className="mb-4 space-y-2 rounded-3xl border border-[var(--border-subtle)]/70 bg-white/80 p-3 shadow-sm dark:border-slate-800 dark:bg-slate-900/60">
          <div className="flex items-center justify-between gap-2">
            <p className="text-sm font-semibold text-[var(--text-primary)]">Активные сессии парковки</p>
            <button
              className="text-xs font-semibold text-[var(--text-muted)] underline decoration-dotted underline-offset-4"
              onClick={() => void fetchSessions()}
            >
              Обновить
            </button>
          </div>
          <div className="grid grid-cols-1 gap-2 md:grid-cols-2">
            {sessions.map((session) => {
              const remaining = computeRemaining(session);
              const minutes = Math.max(0, Math.floor(remaining / 60));
              const isExpiring = minutes <= 15;
              return (
                <div
                  key={session.id}
                  className="flex flex-col gap-2 rounded-2xl border border-[var(--border-subtle)]/80 bg-[var(--bg-elevated)] p-3 shadow-sm dark:border-slate-800 dark:bg-slate-900/70"
                >
                  <div className="flex items-start justify-between gap-2">
                    <div>
                      <p className="text-sm font-semibold text-[var(--text-primary)]">
                        {session.spot_name} · {session.lot_name}
                      </p>
                      <p className="text-[11px] text-[var(--text-muted)]">Статус: {session.status}</p>
                    </div>
                    <span
                      className={`rounded-full px-2 py-1 text-[11px] font-semibold ${
                        isExpiring
                          ? 'bg-amber-100 text-amber-800 dark:bg-amber-900/60 dark:text-amber-100'
                          : 'bg-emerald-100 text-emerald-800 dark:bg-emerald-900/60 dark:text-emerald-100'
                      }`}
                    >
                      ~{minutes} мин
                    </span>
                  </div>
                  <div className="flex flex-wrap gap-2">
                    <button
                      disabled={isLoading || actionRunning === session.id}
                      onClick={() => void handleAction({ type: 'booking_extend', booking_id: session.id, extend_minutes: 30 })}
                      className="rounded-full border border-[var(--border-subtle)]/70 bg-white px-3 py-1 text-xs font-semibold text-[var(--text-primary)] shadow-sm transition hover:-translate-y-[1px] dark:border-slate-700 dark:bg-slate-800 dark:text-slate-100 disabled:opacity-50"
                    >
                      +30 мин
                    </button>
                    <button
                      disabled={isLoading || actionRunning === session.id}
                      onClick={() => void handleAction({ type: 'booking_stop', booking_id: session.id })}
                      className="rounded-full border border-red-200 bg-red-50 px-3 py-1 text-xs font-semibold text-red-700 shadow-sm transition hover:-translate-y-[1px] dark:border-red-800 dark:bg-red-950/40 dark:text-red-100 disabled:opacity-50"
                    >
                      Завершить
                    </button>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}


      <div className="grid h-full grid-cols-1 gap-4 lg:grid-cols-[320px,1fr]">
        <div className="hidden lg:block">
          <ConversationList
            conversations={conversations}
            activeId={activeConversationId}
            onSelect={handleSelectConversation}
            onCreate={handleCreate}
            onRename={handleRename}
            onDelete={handleDelete}
          />
        </div>
        <div className="flex flex-col overflow-hidden rounded-[22px] border border-[var(--border-subtle)]/80 bg-[var(--bg-elevated)] shadow-[0_16px_36px_rgba(15,23,42,0.08)] backdrop-blur dark:border-slate-800/70 dark:bg-slate-900/70">
          <div className="flex-1 space-y-4 overflow-y-auto px-4 py-6">
            {bookingActions.length > 0 && (
              <div className="rounded-2xl border border-[var(--border-subtle)]/70 bg-white/80 p-3 shadow-sm dark:border-slate-800 dark:bg-slate-900/60">
                <p className="mb-2 text-xs font-semibold uppercase tracking-[0.12em] text-[var(--text-muted)]">Быстрые действия</p>
                <div className="flex flex-wrap gap-2">
                  {bookingActions.map((action, idx) => {
                    const key = action.booking_id || action.spot_id || `${action.type}-${idx}`;
                    return (
                      <button
                        key={key}
                        disabled={isLoading || actionRunning === key}
                        onClick={() => void handleAction(action)}
                        className="rounded-full border border-[var(--border-subtle)]/70 bg-white px-3 py-2 text-xs font-semibold text-[var(--text-primary)] shadow-sm transition hover:-translate-y-[1px] dark:border-slate-700 dark:bg-slate-800 dark:text-slate-100 disabled:opacity-50"
                      >
                        {actionLabel(action)}
                      </button>
                    );
                  })}
                </div>
              </div>
            )}
            {currentConversation && currentConversation.messages.length <= 1 ? (
              <div className="flex flex-col gap-3 rounded-2xl border border-dashed border-slate-200 bg-white/60 p-4 text-sm text-slate-700 shadow-sm dark:border-slate-800 dark:bg-slate-900/60 dark:text-slate-200">
                <p className="font-semibold text-slate-900 dark:text-slate-50">Начните новый диалог</p>
                <p className="text-xs text-slate-500 dark:text-slate-400">
                  Добавьте первый запрос или выберите одну из заготовок. История сохранится локально и привяжется к вашему профилю.
                </p>
                <div className="flex flex-wrap gap-2">
                  {FAVORITE_PROMPTS.slice(0, 3).map((prompt) => (
                    <button
                      key={prompt}
                      onClick={() => handlePrefill(prompt)}
                      className="rounded-full border border-slate-200/70 bg-white px-3 py-2 text-xs font-semibold text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-indigo-300 hover:text-indigo-700 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200"
                    >
                      {prompt}
                    </button>
                  ))}
                </div>
              </div>
            ) : (
              currentConversation?.messages.map((message) => (
                <MessageBubble key={message.id} message={message} isLoading={isLoading} onRegenerate={handleRegenerate} />
              ))
            )}
            <div ref={chatEndRef} />
          </div>
          <div className="sticky bottom-0 border-t border-[var(--border-subtle)]/80 bg-gradient-to-r from-white/95 via-[var(--bg-elevated)] to-white/95 p-4 backdrop-blur dark:border-slate-800 dark:from-slate-900/90 dark:via-slate-900 dark:to-slate-900/90">
            <div className="flex flex-col gap-2">
              <label htmlFor="chat-input" className="text-sm font-medium text-slate-700 dark:text-slate-200">
                Спросить ассистента
              </label>
              {!isAuthenticated && (
                <p className="text-[11px] text-amber-700 dark:text-amber-200">
                  Гостевой режим: история сохраняется только в этом браузере. Войдите, чтобы привязать её к профилю.
                </p>
              )}
              {errorMessage && (
                <div className="flex items-start justify-between gap-3 rounded-xl border border-red-200 bg-red-50 px-3 py-2 text-xs text-red-700 shadow-sm dark:border-red-900 dark:bg-red-950/40 dark:text-red-100">
                  <div className="flex items-start gap-2">
                    <ExclamationTriangleIcon className="mt-0.5 h-4 w-4" />
                    <p>{errorMessage}</p>
                  </div>
                  <button
                    onClick={() => setErrorMessage(null)}
                    className="rounded-md px-2 py-1 text-[11px] font-semibold text-red-700 transition hover:bg-red-100 dark:text-red-50 dark:hover:bg-red-900/60"
                    aria-label="Dismiss error"
                  >
                    Dismiss
                  </button>
                </div>
              )}
              <div className="flex flex-col gap-3 rounded-2xl border border-slate-200/70 bg-white/70 p-3 shadow-sm transition focus-within:border-indigo-200 focus-within:ring-1 focus-within:ring-indigo-200 dark:border-slate-800/60 dark:bg-slate-900/70 dark:focus-within:border-indigo-500/50 dark:focus-within:ring-indigo-500/50">
                <textarea
                  id="chat-input"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  onKeyDown={handleKeyDown}
                  rows={3}
                  className="flex-1 resize-none border-none bg-transparent text-sm text-slate-900 outline-none placeholder:text-slate-400 dark:text-slate-100"
                  placeholder="Как оптимизировать тарифы на выходные или при событиях?"
                />
                <div className="flex flex-wrap items-center justify-between gap-3">
                  <div className="flex flex-wrap items-center gap-3 text-xs text-slate-500 dark:text-slate-400">
                    <span>Enter — отправить • Shift+Enter — перенос строки</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <button
                      onClick={handleClear}
                      className="rounded-full border border-slate-200 bg-white px-3 py-2 text-xs font-semibold text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-indigo-200 dark:border-slate-700 dark:bg-slate-800 dark:text-slate-200"
                    >
                      Очистить
                    </button>
                    <button
                      onClick={() => void handleSend()}
                      disabled={sendDisabled}
                      className="inline-flex items-center gap-2 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 px-4 py-2 text-sm font-semibold text-white shadow-md transition hover:-translate-y-[1px] hover:shadow-lg disabled:cursor-not-allowed disabled:opacity-60"
                    >
                      <PaperAirplaneIcon className="h-5 w-5" />
                      Отправить
                    </button>
                  </div>
                </div>
              </div>
              {isLoading && (
                <p className="flex items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
                  <span className="h-2 w-2 animate-pulse rounded-full bg-indigo-500" /> Запрашиваем ассистента…
                </p>
              )}
            </div>
          </div>
        </div>
      </div>

      {showSidebar && (
        <div className="fixed inset-0 z-30 flex bg-black/50 backdrop-blur-sm lg:hidden">
          <div className="m-4 flex w-full max-w-sm flex-col">
            <ConversationList
              conversations={conversations}
              activeId={activeConversationId}
              onSelect={handleSelectConversation}
              onCreate={() => {
                handleCreate();
                setShowSidebar(false);
              }}
              onRename={handleRename}
              onDelete={handleDelete}
              onClose={() => setShowSidebar(false)}
            />
            <button
              onClick={() => setShowSidebar(false)}
              className="mt-3 rounded-2xl border border-slate-200 bg-white/90 px-3 py-2 text-sm text-slate-700 shadow-sm dark:border-slate-700 dark:bg-slate-800 dark:text-slate-200"
            >
              Close
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

const MessageBubble = React.memo(function MessageBubble({
  message,
  isLoading,
  onRegenerate
}: {
  message: MessageWithId;
  isLoading: boolean;
  onRegenerate?: (id: string) => void;
}) {
  const isUser = message.role === 'user';
  const timestamp = useMemo(() => new Date(message.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }), [message.createdAt]);
  const bubbleClass = useMemo(
    () =>
      `group relative max-w-3xl rounded-2xl px-4 py-3 text-sm shadow-sm transition-all duration-200 ${
        isUser
          ? 'ml-auto bg-gradient-to-r from-indigo-500 to-blue-500 text-white'
          : 'bg-slate-100/90 text-slate-900 dark:bg-slate-800/80 dark:text-slate-50'
      }`,
    [isUser]
  );
  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(() => {
    if (!message.content) return;
    navigator.clipboard
      ?.writeText(message.content)
      .then(() => {
        setCopied(true);
        setTimeout(() => setCopied(false), 1500);
      })
      .catch(() => setCopied(false));
  }, [message.content]);

  return (
    <div className={`flex ${isUser ? 'justify-end' : 'justify-start'}`}>
      <div className={bubbleClass}>
        <div className="mb-1 flex items-center gap-2 text-[11px] font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
          <span className="inline-flex items-center rounded-full bg-slate-200 px-2 py-0.5 text-[10px] font-semibold text-slate-700 dark:bg-slate-700 dark:text-slate-200">
            {isUser ? 'You' : 'AI'}
          </span>
          <span className="text-[10px] text-slate-500 dark:text-slate-400">{timestamp}</span>
        </div>
        {!isUser && message.content && (
          <div className="absolute -right-3 -top-3 flex items-center gap-1">
            <button
              onClick={handleCopy}
              className="flex items-center gap-1 rounded-full border border-[var(--border-subtle)]/70 bg-white px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] shadow-sm transition hover:-translate-y-[1px] hover:text-[var(--text-primary)] dark:bg-slate-900"
              aria-label="Copy message"
            >
              <ClipboardIcon className="h-3.5 w-3.5" />
              {copied ? 'Скопировано' : 'Копия'}
            </button>
            {onRegenerate && (
              <button
                onClick={() => onRegenerate(message.id)}
                className="flex items-center gap-1 rounded-full border border-[var(--border-subtle)]/70 bg-white px-2 py-1 text-[11px] font-semibold text-[var(--text-muted)] shadow-sm transition hover:-translate-y-[1px] hover:text-[var(--text-primary)] dark:bg-slate-900"
                aria-label="Regenerate"
              >
                <ArrowPathIcon className="h-3.5 w-3.5" />
                Повторить
              </button>
            )}
          </div>
        )}
        {isUser ? (
          <p className="whitespace-pre-line leading-relaxed">{message.content}</p>
        ) : message.content ? (
          <div className="transition-opacity duration-200">
            <MarkdownMessage content={message.content} />
          </div>
        ) : (
          <div className="flex flex-col gap-2">
            <div className="h-3 w-24 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />
            <div className="h-3 w-36 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />
            {isLoading && <div className="h-3 w-16 animate-pulse rounded-full bg-slate-200 dark:bg-slate-700" />}
          </div>
        )}
      </div>
    </div>
  );
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 172
PATH: frontend\next-app\components\chat\compact-chat-panel.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { ChatPanel } from './chat-panel';

export function CompactChatPanel() {
  // На будущее сюда можно будет передать пропсы для "урезанного" вида,
  // сейчас просто используем существующую панель.
  return <ChatPanel />;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 173
PATH: frontend\next-app\components\chat\conversation-list.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { useMemo } from 'react';
import { Conversation } from './types';
import { PlusIcon, PencilSquareIcon, TrashIcon } from '@heroicons/react/24/outline';

interface ConversationListProps {
  conversations: Conversation[];
  activeId: string | null;
  onSelect: (id: string) => void;
  onCreate: () => void;
  onRename: (id: string, name: string) => void;
  onDelete: (id: string) => void;
  onClose?: () => void;
}

function formatTimestamp(timestamp: number) {
  const diff = Date.now() - timestamp;
  const minutes = Math.floor(diff / (1000 * 60));
  if (minutes < 60) return `${minutes || 1}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}

export function ConversationList({ conversations, activeId, onSelect, onCreate, onRename, onDelete, onClose }: ConversationListProps) {
  const sorted = useMemo(() => [...conversations].sort((a, b) => b.updatedAt - a.updatedAt), [conversations]);

  return (
    <aside className="flex h-full flex-col rounded-3xl border border-slate-200/80 bg-white/70 p-4 shadow-md backdrop-blur dark:border-slate-800/60 dark:bg-slate-900/70">
      <div className="mb-4 flex items-center justify-between gap-3">
        <div>
          <p className="text-sm font-semibold text-slate-800 dark:text-slate-100">Диалоги</p>
          <p className="text-xs text-slate-500 dark:text-slate-400">Возвращайтесь к предыдущим веткам</p>
        </div>
        <button
          onClick={onCreate}
          className="flex items-center gap-1 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 px-3 py-2 text-xs font-semibold text-white shadow-sm transition hover:shadow-md"
        >
          <PlusIcon className="h-4 w-4" />
          Новый
        </button>
      </div>
      <div className="flex-1 space-y-2 overflow-y-auto pr-1">
        {sorted.map((conversation) => {
          const isActive = conversation.id === activeId;
          const lastMessage = conversation.messages[conversation.messages.length - 1];
          return (
            <div
              key={conversation.id}
              className={`group relative overflow-hidden rounded-2xl border border-transparent transition hover:border-indigo-200 hover:bg-indigo-50/50 dark:hover:border-indigo-600/40 dark:hover:bg-indigo-950/30 ${
                isActive
                  ? 'border-indigo-300 bg-indigo-50 dark:border-indigo-600/60 dark:bg-indigo-900/40'
                  : 'border-slate-100 dark:border-slate-800'
              }`}
            >
              <button
                onClick={() => {
                  onSelect(conversation.id);
                  onClose?.();
                }}
                className="flex w-full flex-col gap-1 px-3 py-3 text-left"
              >
                <div className="flex items-center justify-between gap-2">
                  <p className="line-clamp-1 text-sm font-semibold text-slate-800 dark:text-slate-50">{conversation.title}</p>
                  <span className="text-[11px] text-slate-500 dark:text-slate-400">{formatTimestamp(conversation.updatedAt)}</span>
                </div>
                <p className="line-clamp-2 text-xs text-slate-500 dark:text-slate-400">
                  {lastMessage?.content || 'Ветка пустая'}
                </p>
              </button>
              <div className="absolute right-2 top-2 flex gap-1 opacity-0 transition group-hover:opacity-100">
                <button
                  aria-label="Rename conversation"
                  onClick={() => {
                    const nextName = prompt('Rename conversation', conversation.title);
                    if (nextName?.trim()) {
                      onRename(conversation.id, nextName.trim());
                    }
                  }}
                  className="rounded-full bg-white/90 p-1 text-slate-500 shadow hover:text-indigo-600 dark:bg-slate-800/80"
                >
                  <PencilSquareIcon className="h-4 w-4" />
                </button>
                <button
                  aria-label="Delete conversation"
                  onClick={() => {
                    const confirmed = confirm('Удалить этот диалог? Действие необратимо.');
                    if (confirmed) {
                      onDelete(conversation.id);
                    }
                  }}
                  className="rounded-full bg-white/90 p-1 text-slate-500 shadow hover:text-red-600 dark:bg-slate-800/80"
                >
                  <TrashIcon className="h-4 w-4" />
                </button>
              </div>
            </div>
          );
        })}
        {sorted.length === 0 && (
          <div className="rounded-2xl border border-dashed border-slate-300 bg-slate-50/70 p-4 text-center text-sm text-slate-500 dark:border-slate-700 dark:bg-slate-800/40 dark:text-slate-400">
            Пока нет диалогов.
          </div>
        )}
      </div>
    </aside>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 174
PATH: frontend\next-app\components\chat\markdown-message.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeSanitize from 'rehype-sanitize';
import rehypeHighlight from 'rehype-highlight';

interface Props {
  content: string;
}

export default function MarkdownMessage({ content }: Props) {
  return (
    <ReactMarkdown
      remarkPlugins={[remarkGfm]}
      rehypePlugins={[rehypeSanitize as any, rehypeHighlight as any]}
      className="prose prose-sm max-w-none dark:prose-invert"
    >
      {content}
    </ReactMarkdown>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 175
PATH: frontend\next-app\components\chat\suggested-prompts.tsx
LANG: tsx
===== CONTENT START =====
'use client';

interface SuggestedPromptsProps {
  onSelect: (prompt: string) => void;
}

const PROMPTS = [
  'Analyze occupancy trends for the last 7 days.',
  'Suggest dynamic pricing for weekend events.',
  'Generate a customer journey improvement plan.',
  'What KPIs should I monitor for a new garage launch?',
  'Draft a personalized outreach message for high-value partners.'
];

export function SuggestedPrompts({ onSelect }: SuggestedPromptsProps) {
  return (
    <div className="flex flex-wrap items-center gap-2">
      {PROMPTS.map((prompt) => (
        <button
          key={prompt}
          onClick={() => onSelect(prompt)}
          className="group rounded-full border border-slate-200/70 bg-white/70 px-3 py-2 text-xs text-slate-700 shadow-sm transition hover:-translate-y-[1px] hover:border-indigo-300 hover:bg-indigo-50 hover:text-indigo-700 dark:border-slate-800 dark:bg-slate-800/80 dark:text-slate-200 dark:hover:border-indigo-500/60 dark:hover:bg-indigo-900/40 dark:hover:text-indigo-100"
        >
          <span className="mr-1 inline-block h-2 w-2 rounded-full bg-gradient-to-r from-blue-500 to-indigo-500 transition group-hover:scale-110" />
          {prompt}
        </button>
      ))}
    </div>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 176
PATH: frontend\next-app\components\chat\types.ts
LANG: typescript
===== CONTENT START =====
import { ChatMessage } from '@/lib/aiProvider';

export interface MessageWithId extends ChatMessage {
  id: string;
  createdAt: number;
}

export interface Conversation {
  id: string;
  title: string;
  messages: MessageWithId[];
  updatedAt: number;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 177
PATH: frontend\next-app\components\pwa\register-service-worker.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { useEffect, useState } from 'react';

export function ServiceWorkerRegistrar() {
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (process.env.NODE_ENV !== 'production') return;
    if (!('serviceWorker' in navigator)) return;

    const register = async () => {
      try {
        await navigator.serviceWorker.register('/service-worker.js');
        console.info('Service worker registered');
      } catch (error) {
        console.error('Failed to register service worker', error);
        setError('Offline mode is temporarily unavailable. We will retry soon.');
      }
    };

    register();
  }, []);

  if (!error) return null;

  return (
    <div className="fixed bottom-4 right-4 z-30 max-w-sm rounded-xl border border-amber-200 bg-amber-50 px-4 py-3 text-sm text-amber-900 shadow-md dark:border-amber-800 dark:bg-amber-950/70 dark:text-amber-100">
      <div className="flex items-start gap-3">
        <span className="mt-0.5 inline-flex h-5 w-5 items-center justify-center rounded-full bg-amber-200 text-xs font-bold text-amber-800 dark:bg-amber-800 dark:text-amber-100">!</span>
        <div className="space-y-1">
          <p className="font-semibold">Offline caching issue</p>
          <p className="text-xs leading-relaxed">{error}</p>
        </div>
      </div>
    </div>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 178
PATH: frontend\next-app\components\widget\chat-widget.tsx
LANG: tsx
===== CONTENT START =====
'use client';
import { useState } from 'react';
import { ChatPanel } from '@/components/chat/chat-panel';
import { XMarkIcon } from '@heroicons/react/24/outline';

export function ChatWidget() {
  const [open, setOpen] = useState(false);

  return (
    <>
      {!open && (
        <button
          onClick={() => setOpen(true)}
          className="fixed bottom-6 right-6 z-50 rounded-full bg-gradient-to-r from-indigo-500 to-blue-500 px-5 py-3 text-sm font-semibold text-white shadow-xl transition hover:-translate-y-[1px] hover:shadow-2xl"
        >
          AI Assistant
        </button>
      )}

      {open && (
        <div className="fixed bottom-6 right-6 z-50 bg-white dark:bg-slate-900 rounded-2xl shadow-2xl w-[420px] max-h-[80vh] flex flex-col border border-slate-200 dark:border-slate-700">
          <div className="flex justify-between items-center p-3 border-b dark:border-slate-700">
            <h3 className="font-semibold text-slate-800 dark:text-slate-200">AI Assistant</h3>
            <button
              onClick={() => setOpen(false)}
              className="rounded-full border border-slate-200 bg-white p-1 text-slate-600 shadow-sm transition hover:-translate-y-[1px] hover:border-slate-300 dark:border-slate-700 dark:bg-slate-800 dark:text-slate-200"
              aria-label="Закрыть виджет"
            >
              <XMarkIcon className="h-4 w-4" />
            </button>
          </div>
          <div className="flex-1 overflow-y-auto">
            <ChatPanel />
          </div>
        </div>
      )}
    </>
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 179
PATH: frontend\next-app\context\AuthContext.tsx
LANG: tsx
===== CONTENT START =====
'use client';

import { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import {
  type AuthUser,
  getCurrentUser,
  loginWithEmailPassword,
  logout as apiLogout,
  registerWithEmailPassword,
  requestOtp,
  startOAuth,
  verifyMfa,
  verifyOtp
} from '@/lib/authClient';
import { clearUserSecure, getUserSecure, saveUserSecure } from '@/lib/authStorage';

type MfaChallenge = {
  method: string | null;
  channel?: string | null;
};

interface AuthContextValue {
  user: AuthUser | null;
  loading: boolean;
  mfaChallenge: MfaChallenge | null;
  loginWithEmail: (email: string, password: string) => Promise<AuthUser | null>;
  registerWithEmail: (email: string, password: string, name?: string) => Promise<AuthUser | null>;
  requestPhoneOtp: (phone: string) => Promise<void>;
  verifyPhoneOtp: (phone: string, code: string) => Promise<AuthUser | null>;
  verifyMfaCode: (code: string) => Promise<AuthUser | null>;
  loginWithVK: () => void;
  loginWithYandex: () => void;
  clearMfaChallenge: () => void;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [loading, setLoading] = useState(true);
  const [mfaChallenge, setMfaChallenge] = useState<MfaChallenge | null>(null);

  useEffect(() => {
    const bootstrap = async () => {
      try {
        const saved = await getUserSecure();
        if (saved) {
          setUser(saved);
          setLoading(false);
          return;
        }
        const serverUser = await getCurrentUser();
        if (serverUser) {
          setUser(serverUser);
          await saveUserSecure(serverUser);
        }
      } catch (error) {
        console.warn('Auth bootstrap failed', error);
      } finally {
        setLoading(false);
      }
    };

    void bootstrap();
  }, []);

  const persistUser = useCallback(async (nextUser: AuthUser | null) => {
    setUser(nextUser);
    if (nextUser) {
      await saveUserSecure(nextUser);
    } else {
      clearUserSecure();
    }
    setMfaChallenge(null);
  }, []);

  const loginWithEmail = useCallback(
    async (email: string, password: string) => {
      const response = await loginWithEmailPassword(email, password);
      if (response.mfa_required) {
        setMfaChallenge({ method: response.mfa_method ?? 'totp', channel: response.mfa_channel ?? null });
        return null;
      }
      if (response.user) {
        await persistUser(response.user);
        return response.user;
      }
      return null;
    },
    [persistUser]
  );

  const registerWithEmail = useCallback(
    async (email: string, password: string, name?: string) => {
      const response = await registerWithEmailPassword(email, password, name);
      if (response.mfa_required) {
        setMfaChallenge({ method: response.mfa_method ?? 'totp', channel: response.mfa_channel ?? null });
        return null;
      }
      if (response.user) {
        await persistUser(response.user);
        return response.user;
      }
      return null;
    },
    [persistUser]
  );

  const requestPhoneOtp = useCallback(async (phone: string) => {
    await requestOtp(phone);
  }, []);

  const verifyPhoneOtp = useCallback(
    async (phone: string, code: string) => {
      const response = await verifyOtp(phone, code);
      if (response.mfa_required) {
        setMfaChallenge({ method: response.mfa_method ?? 'totp', channel: response.mfa_channel ?? null });
        return null;
      }
      if (response.user) {
        await persistUser(response.user);
        return response.user;
      }
      return null;
    },
    [persistUser]
  );

  const verifyMfaCode = useCallback(
    async (code: string) => {
      const response = await verifyMfa(code);
      if (response.user) {
        await persistUser(response.user);
        return response.user;
      }
      return null;
    },
    [persistUser]
  );

  const loginWithVK = useCallback(() => startOAuth('vk'), []);
  const loginWithYandex = useCallback(() => startOAuth('yandex'), []);

  const logout = useCallback(async () => {
    await apiLogout();
    await persistUser(null);
  }, [persistUser]);

  const value = useMemo(
    () => ({
      user,
      loading,
      mfaChallenge,
      loginWithEmail,
      registerWithEmail,
      requestPhoneOtp,
      verifyPhoneOtp,
      verifyMfaCode,
      loginWithVK,
      loginWithYandex,
      clearMfaChallenge: () => setMfaChallenge(null),
      logout
    }),
    [
      user,
      loading,
      mfaChallenge,
      loginWithEmail,
      registerWithEmail,
      requestPhoneOtp,
      verifyPhoneOtp,
      verifyMfaCode,
      loginWithVK,
      loginWithYandex,
      logout
    ]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuthContext() {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error('useAuthContext must be used within AuthProvider');
  }
  return ctx;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 180
PATH: frontend\next-app\hooks\useAuth.ts
LANG: typescript
===== CONTENT START =====
'use client';

import { useMemo } from 'react';
import { useAuthContext } from '@/context/AuthContext';

export function useAuth() {
  const ctx = useAuthContext();

  return useMemo(
    () => ({
      ...ctx,
      isAuthenticated: Boolean(ctx.user)
    }),
    [ctx]
  );
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 181
PATH: frontend\next-app\lib\aiProvider.ts
LANG: typescript
===== CONTENT START =====
export { streamChat as streamChatResponse } from './llmClient';
export type { LLMMessage as ChatMessage } from './llmClient';

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 182
PATH: frontend\next-app\lib\apiClient.ts
LANG: typescript
===== CONTENT START =====
export type HttpMethod = 'GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE';

export interface ApiError extends Error {
  status?: number;
  payload?: unknown;
}

export interface ApiRequestOptions<TBody = unknown> {
  method?: HttpMethod;
  body?: TBody;
  headers?: Record<string, string>;
  signal?: AbortSignal;
  credentials?: RequestCredentials;
  retries?: number;
  refreshOn401?: boolean;
}

const API_BASE = process.env.NEXT_PUBLIC_API_BASE || '/api/v1';

async function parseError(response: Response): Promise<ApiError> {
  let payload: unknown = null;
  try {
    payload = await response.json();
  } catch {
    try {
      payload = await response.text();
    } catch {
      payload = null;
    }
  }
  const error: ApiError = new Error((payload as any)?.detail || response.statusText || 'API error');
  error.status = response.status;
  error.payload = payload;
  return error;
}

async function refreshTokens() {
  const refreshUrl = `${API_BASE}/auth/token/refresh/`;
  const resp = await fetch(refreshUrl, { method: 'POST', credentials: 'include' });
  if (!resp.ok) {
    throw await parseError(resp);
  }
  return resp.json();
}

export async function apiRequest<TResponse = unknown, TBody = unknown>(
  endpoint: string,
  options: ApiRequestOptions<TBody> = {},
  attempt = 0
): Promise<TResponse> {
  const url = endpoint.startsWith('http') ? endpoint : `${API_BASE}${endpoint.startsWith('/') ? endpoint : `/${endpoint}`}`;
  const { method = 'GET', body, headers, signal, refreshOn401 = true } = options;
  const retries = options.retries ?? 1;

  let resp: Response;

  try {
    resp = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...(headers || {})
      },
      body: body ? JSON.stringify(body) : undefined,
      credentials: options.credentials || 'include',
      signal
    });
  } catch (error) {
    if (attempt < retries) {
      return apiRequest(endpoint, options, attempt + 1);
    }
    throw error;
  }

  if (resp.status === 401 && refreshOn401 && attempt <= retries) {
    try {
      await refreshTokens();
      return apiRequest(endpoint, { ...options, refreshOn401: false }, attempt + 1);
    } catch (refreshError) {
      throw refreshError;
    }
  }

  if (!resp.ok) {
    throw await parseError(resp);
  }

  const contentType = resp.headers.get('content-type') || '';
  if (contentType.includes('application/json')) {
    return (await resp.json()) as TResponse;
  }
  return (await resp.text()) as unknown as TResponse;
}

export * from './apiTypes';

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 183
PATH: frontend\next-app\lib\apiTypes.ts
LANG: typescript
===== CONTENT START =====
export type Coordinates = { lat: number; lng: number };

export interface SpotSummary {
  id: string;
  title: string;
  price?: number;
  tags?: string[];
  coords?: Coordinates;
}

export interface BookingSession {
  id: string;
  spot_id: string;
  spot_name: string;
  lot_name: string;
  status: string;
  end_at: string;
  remaining_seconds: number;
  is_paid?: boolean;
}

export type AssistantActionType = 'focus_map' | 'book' | 'booking_start' | 'booking_extend' | 'booking_stop';

export interface AssistantAction {
  type: AssistantActionType;
  spot_id?: string;
  booking_id?: string;
  coords?: Coordinates;
  title?: string;
  price?: number;
  duration_minutes?: number;
  extend_minutes?: number;
}

export interface AssistantAlert {
  type: string;
  booking_id?: string;
  spot?: string;
  minutes_left?: number;
}

export interface AssistantResponse {
  reply: string;
  suggestions: SpotSummary[];
  actions: AssistantAction[];
  sessions?: BookingSession[];
  alerts?: AssistantAlert[];
}

export interface SearchResponse {
  count: number;
  results: SpotSummary[];
}


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 184
PATH: frontend\next-app\lib\authClient.ts
LANG: typescript
===== CONTENT START =====
import { apiRequest } from './apiClient';

export type AuthUser = {
  id: string;
  email?: string;
  phone?: string;
  name?: string;
  avatarUrl?: string;
  provider?: string;
};

export type AuthResponse = {
  success?: boolean;
  message?: string;
  user?: AuthUser;
  data?: unknown;
  mfa_required?: boolean;
  mfa_method?: string;
  mfa_channel?: string | null;
};

export async function requestOtp(identifier: string) {
  if (!identifier) throw new Error('Введите номер телефона или email');
  return apiRequest<AuthResponse>('/auth/otp/request/', { method: 'POST', body: { identifier, purpose: 'login' } });
}

export async function verifyOtp(identifier: string, code: string) {
  if (!identifier || !code) throw new Error('Введите контакт и код');
  return apiRequest<AuthResponse>('/auth/otp/verify/', {
    method: 'POST',
    body: { identifier, code, purpose: 'login' }
  });
}

export async function loginWithEmailPassword(identifier: string, password: string) {
  if (!identifier || !password) throw new Error('Нужны логин/email/телефон и пароль');
  return apiRequest<AuthResponse>('/auth/token/', { method: 'POST', body: { identifier, password } });
}

export async function registerWithEmailPassword(email: string, password: string, name?: string) {
  if (!email || !password) throw new Error('Укажите почту и пароль');
  return apiRequest<AuthResponse>('/auth/register/', { method: 'POST', body: { email, password, name } });
}

export async function logout() {
  return apiRequest<AuthResponse>('/auth/logout/', { method: 'POST' });
}

export async function verifyMfa(code: string) {
  if (!code) throw new Error('Введите код MFA');
  return apiRequest<AuthResponse>('/auth/mfa/verify/', { method: 'POST', body: { code } });
}

export async function getCurrentUser() {
  try {
    const data = await apiRequest<AuthUser>('/accounts/users/me/', { method: 'GET' });
    return data ?? null;
  } catch {
    return null;
  }
}

function buildOAuthUrl(provider: 'vk' | 'yandex' | 'google') {
  const base = process.env.NEXT_PUBLIC_AUTH_API_URL || process.env.NEXT_PUBLIC_AUTH_API_BASE || '/api';
  const returnTo = encodeURIComponent(typeof window !== 'undefined' ? window.location.href : '/');
  return `${base}/auth/oauth/${provider}/start/?next=${returnTo}`;
}

export function startOAuth(provider: 'vk' | 'yandex' | 'google') {
  const url = buildOAuthUrl(provider);
  window.location.href = url;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 185
PATH: frontend\next-app\lib\authStorage.ts
LANG: typescript
===== CONTENT START =====
import type { AuthUser } from './authClient';

const STORAGE_KEY = 'ps_secure_user';
const ENC_KEY = process.env.NEXT_PUBLIC_AUTH_ENC_KEY || '';

const encoder = new TextEncoder();
const decoder = new TextDecoder();

function toBase64(buf: ArrayBuffer): string {
  return btoa(String.fromCharCode(...new Uint8Array(buf)));
}

function fromBase64(value: string): Uint8Array {
  const bin = atob(value);
  const bytes = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i += 1) {
    bytes[i] = bin.charCodeAt(i);
  }
  return bytes;
}

async function deriveKey() {
  if (!ENC_KEY || typeof window === 'undefined' || !window.crypto?.subtle) return null;
  const hash = await crypto.subtle.digest('SHA-256', encoder.encode(ENC_KEY));
  return crypto.subtle.importKey('raw', hash, 'AES-GCM', false, ['encrypt', 'decrypt']);
}

export async function saveUserSecure(user: AuthUser) {
  if (typeof window === 'undefined') return;
  const key = await deriveKey();
  if (!key) return;
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const payload = encoder.encode(JSON.stringify(user));
  try {
    const cipher = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, payload);
    localStorage.setItem(`${STORAGE_KEY}:iv`, toBase64(iv.buffer));
    localStorage.setItem(`${STORAGE_KEY}:data`, toBase64(cipher));
  } catch (error) {
    console.warn('Encrypt user failed', error);
  }
}

export async function getUserSecure(): Promise<AuthUser | null> {
  if (typeof window === 'undefined') return null;
  const ivRaw = localStorage.getItem(`${STORAGE_KEY}:iv`);
  const dataRaw = localStorage.getItem(`${STORAGE_KEY}:data`);
  if (!ivRaw || !dataRaw) return null;
  const key = await deriveKey();
  if (!key) return null;
  try {
    const iv = fromBase64(ivRaw);
    const cipher = fromBase64(dataRaw);
    const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, cipher);
    const text = decoder.decode(plain);
    return JSON.parse(text) as AuthUser;
  } catch (error) {
    console.warn('Decrypt user failed, cleaning storage', error);
    clearUserSecure();
    return null;
  }
}

export function clearUserSecure() {
  if (typeof window === 'undefined') return;
  localStorage.removeItem(`${STORAGE_KEY}:iv`);
  localStorage.removeItem(`${STORAGE_KEY}:data`);
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 186
PATH: frontend\next-app\lib\bottomSheet.ts
LANG: typescript
===== CONTENT START =====
export type SheetState = 'collapsed' | 'half' | 'full';

export function nextState(current: SheetState): SheetState {
  if (current === 'collapsed') return 'half';
  if (current === 'half') return 'full';
  return 'collapsed';
}

export function clampShift(shift: number, height: number) {
  const max = Math.max(height - 56, 120);
  if (shift < 0) return 0;
  if (shift > max) return max;
  return shift;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 187
PATH: frontend\next-app\lib\chatClient.ts
LANG: typescript
===== CONTENT START =====
import { ChatMessage } from './aiProvider';
import { apiRequest, type AssistantResponse } from './apiClient';

type StreamChatOptions = {
  onChunk?: (chunk: string) => void;
  signal?: AbortSignal;
};

export async function streamChatFromApi(messages: ChatMessage[], options: StreamChatOptions = {}) {
  const response = await apiRequest<AssistantResponse>('/assistant/chat/', {
    method: 'POST',
    body: { messages, structured: true },
    signal: options.signal
  });
  if (response.reply && options.onChunk) {
    options.onChunk(response.reply);
  }
  return response;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 188
PATH: frontend\next-app\lib\llmClient.ts
LANG: typescript
===== CONTENT START =====
import type { ReadableStream } from 'stream/web';

export type LLMMessage = {
  role: 'user' | 'assistant' | 'system';
  content: string;
};

export type LLMProvider = 'openai' | 'proxy' | 'custom';

export interface LLMClientConfig {
  provider: LLMProvider;
  apiUrl: string;
  apiKey?: string;
  model?: string;
  authHeader?: string;
  authScheme?: string;
}

const encoder = new TextEncoder();

function fallbackStream(message: string) {
  return new ReadableStream<Uint8Array>({
    start(controller) {
      controller.enqueue(encoder.encode(message));
      controller.close();
    }
  });
}

function resolveConfig(): LLMClientConfig {
  return {
    provider: (process.env.LLM_PROVIDER as LLMProvider) || 'openai',
    apiUrl: process.env.LLM_API_URL || 'https://api.openai.com/v1/chat/completions',
    apiKey: process.env.LLM_API_KEY || process.env.OPENAI_API_KEY,
    model: process.env.LLM_MODEL || 'gpt-4o-mini',
    authHeader: process.env.LLM_AUTH_HEADER || 'Authorization',
    authScheme: process.env.LLM_AUTH_SCHEME || 'Bearer'
  };
}

async function createRequest(messages: LLMMessage[], stream: boolean, signal?: AbortSignal): Promise<Response> {
  const config = resolveConfig();

  if (!config.apiUrl) {
    throw new Error('LLM_API_URL is not configured');
  }

  const headers: Record<string, string> = {
    'Content-Type': 'application/json'
  };

  if (config.apiKey) {
    headers[config.authHeader || 'Authorization'] = `${config.authScheme || 'Bearer'} ${config.apiKey}`.trim();
  }

  const body = {
    model: config.model,
    messages,
    stream
  };

  return fetch(config.apiUrl, {
    method: 'POST',
    headers,
    body: JSON.stringify(body),
    signal
  });
}

export async function streamChat(messages: LLMMessage[], { signal, stream = true }: { signal?: AbortSignal; stream?: boolean } = {}) {
  if (!messages || !Array.isArray(messages) || messages.length === 0) {
    return fallbackStream('No messages provided to LLM.');
  }

  try {
    const response = await createRequest(messages, stream, signal);

    if (!response.ok || !response.body) {
      const errorText = await response.text();
      return fallbackStream(errorText || 'The LLM provider responded with an error.');
    }

    if (!stream) {
      // Non-streaming: return one chunk with the final message.
      const result = await response.json();
      const content =
        result?.choices?.[0]?.message?.content ||
        result?.message ||
        'The LLM provider did not return a message.';
      return fallbackStream(content);
    }

    const decoder = new TextDecoder();
    const reader = response.body.getReader();

    return new ReadableStream<Uint8Array>({
      async pull(controller) {
        const { done, value } = await reader.read();
        if (done) {
          controller.close();
          return;
        }

        const textChunk = decoder.decode(value, { stream: true });
        const lines = textChunk
          .split('\n')
          .map((line) => line.trim())
          .filter(Boolean);

        for (const line of lines) {
          const data = line.startsWith('data:') ? line.replace('data:', '').trim() : line;
          if (data === '[DONE]') {
            controller.close();
            return;
          }

          try {
            const payload = JSON.parse(data) as { choices?: Array<{ delta?: { content?: string } }> };
            const token = payload.choices?.[0]?.delta?.content;
            if (token) {
              controller.enqueue(encoder.encode(token));
              continue;
            }
          } catch {
            // Not JSON or not OpenAI-shaped – stream raw text.
          }

          if (data) {
            controller.enqueue(encoder.encode(data));
          }
        }
      },
      cancel() {
        reader.cancel().catch(() => undefined);
      }
    });
  } catch (error) {
    console.error('LLM streaming failed', error);
    return fallbackStream('LLM is unreachable. Check configuration or network.');
  }
}

export const isLLMConfigured = () => Boolean(process.env.LLM_API_URL || process.env.OPENAI_API_KEY || process.env.LLM_API_KEY);

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 189
PATH: frontend\next-app\public\manifest.webmanifest
LANG: text
===== CONTENT START =====
{
  "name": "ParkShare AI Concierge",
  "short_name": "PS Concierge",
  "start_url": "/",
  "display": "standalone",
  "theme_color": "#0f172a",
  "background_color": "#f4f7fb",
  "icons": [
    {
      "src": "/icons/icon-192.svg",
      "sizes": "192x192",
      "type": "image/svg+xml"
    },
    {
      "src": "/icons/icon-512.svg",
      "sizes": "512x512",
      "type": "image/svg+xml"
    }
  ]
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 190
PATH: frontend\next-app\public\offline.html
LANG: html
===== CONTENT START =====
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ParkShare AI Concierge – Offline</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        background: radial-gradient(circle at 20% 20%, #eef2ff, #f8fafc);
      }
      body {
        margin: 0;
        display: grid;
        place-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(14, 165, 233, 0.08)), #0f172a;
        color: #e2e8f0;
      }
      .card {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 24px;
        padding: 28px;
        width: min(480px, 90vw);
        box-shadow: 0 16px 48px rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(12px);
      }
      h1 {
        margin: 0 0 8px 0;
        font-size: 22px;
      }
      p {
        margin: 4px 0;
        line-height: 1.6;
        color: rgba(226, 232, 240, 0.9);
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        background: rgba(99, 102, 241, 0.15);
        border: 1px solid rgba(99, 102, 241, 0.4);
        color: #c7d2fe;
      }
    </style>
  </head>
  <body>
    <div class="card">
      <div class="pill">Offline mode</div>
      <h1>ParkShare AI Concierge</h1>
      <p>You're currently offline. We'll keep your latest sessions saved on this device.</p>
      <p>Reconnect to resume chatting or send queued prompts.</p>
    </div>
  </body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 191
PATH: frontend\next-app\public\service-worker.js
LANG: javascript
===== CONTENT START =====
const CACHE_NAME = 'ps-concierge-v2';
const CORE_ASSETS = ['/', '/offline.html', '/manifest.webmanifest'];

self.addEventListener('install', (event) => {
  event.waitUntil(caches.open(CACHE_NAME).then((cache) => cache.addAll(CORE_ASSETS)).then(() => self.skipWaiting()));
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((keys) =>
        Promise.all(
          keys.map((key) => {
            if (key !== CACHE_NAME) {
              return caches.delete(key);
            }
            return undefined;
          })
        )
      )
      .then(() => self.clients.claim())
  );
});

const staticAssetMatch = (url) =>
  url.pathname.startsWith('/_next/') ||
  url.pathname.startsWith('/icons/') ||
  url.pathname.endsWith('.css') ||
  url.pathname.endsWith('.js') ||
  url.pathname.endsWith('.woff2') ||
  url.pathname.endsWith('.png') ||
  url.pathname.endsWith('.svg');

const staleWhileRevalidate = async (request) => {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(request);
  try {
    const response = await fetch(request);
    cache.put(request, response.clone());
    return response;
  } catch (error) {
    return cached || Promise.reject(error);
  }
};

self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  if (request.method !== 'GET') return;
  if (url.pathname.startsWith('/api')) return;

  if (request.mode === 'navigate') {
    event.respondWith(
      fetch(request)
        .then((response) => {
          const copy = response.clone();
          caches.open(CACHE_NAME).then((cache) => cache.put(request, copy));
          return response;
        })
        .catch(() => caches.match(request).then((match) => match || caches.match('/offline.html')))
    );
    return;
  }

  if (staticAssetMatch(url)) {
    event.respondWith(staleWhileRevalidate(request));
  }
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 192
PATH: frontend\next-app\__tests__\bottom-sheet.test.ts
LANG: typescript
===== CONTENT START =====
import { clampShift, nextState } from '@/lib/bottomSheet';

describe('bottom sheet utils', () => {
  it('cycles states', () => {
    expect(nextState('collapsed')).toBe('half');
    expect(nextState('half')).toBe('full');
    expect(nextState('full')).toBe('collapsed');
  });

  it('clamps shift to bounds', () => {
    expect(clampShift(-10, 400)).toBe(0);
    expect(clampShift(999, 200)).toBeGreaterThan(0);
    expect(clampShift(50, 200)).toBe(50);
  });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 193
PATH: frontend\next-app\__tests__\chat-client.test.ts
LANG: typescript
===== CONTENT START =====
import { streamChatFromApi } from '@/lib/chatClient';
import type { ChatMessage } from '@/lib/aiProvider';

describe('streamChatFromApi', () => {
  beforeEach(() => {
    jest.restoreAllMocks();
  });

  it('posts chat messages and forwards reply to callback', async () => {
    const messages: ChatMessage[] = [
      { role: 'user', content: 'Hello' },
      { role: 'assistant', content: 'Hi!' }
    ];

    const mockFetch = jest.spyOn(global, 'fetch' as any).mockResolvedValue(
      new Response(JSON.stringify({ reply: 'ok' }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
    );

    const onChunk = jest.fn();

    await streamChatFromApi(messages, { onChunk });

    expect(mockFetch).toHaveBeenCalled();
    const requestInit = (mockFetch.mock.calls[0] as any)[1];
    expect(requestInit.method).toBe('POST');
    expect(onChunk).toHaveBeenCalledWith('ok');
  });

  it('throws when the API response is not ok', async () => {
    jest.spyOn(global, 'fetch' as any).mockResolvedValue(new Response(null, { status: 500, statusText: 'err' }));

    await expect(streamChatFromApi([{ role: 'user', content: 'test' }])).rejects.toThrow();
  });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 194
PATH: frontend\next-app\__tests__\conversation-list.test.tsx
LANG: tsx
===== CONTENT START =====
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ConversationList } from '@/components/chat/conversation-list';
import type { Conversation } from '@/components/chat/types';

describe('ConversationList', () => {
  const baseConversations: Conversation[] = [
    {
      id: 'one',
      title: 'First thread',
      updatedAt: Date.now() - 1000 * 60 * 5,
      messages: [{ id: 'm1', role: 'user', content: 'Hello', createdAt: Date.now() - 1000 * 60 * 5 }]
    },
    {
      id: 'two',
      title: 'Second thread',
      updatedAt: Date.now() - 1000 * 60 * 60,
      messages: [{ id: 'm2', role: 'assistant', content: 'Hi there', createdAt: Date.now() - 1000 * 60 * 60 }]
    }
  ];

  beforeEach(() => {
    jest.spyOn(window, 'prompt').mockReturnValue('Renamed thread');
    jest.spyOn(window, 'confirm').mockReturnValue(true);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('renders conversations and handles selection, rename, and deletion', async () => {
    const onSelect = jest.fn();
    const onCreate = jest.fn();
    const onRename = jest.fn();
    const onDelete = jest.fn();

    render(
      <ConversationList
        conversations={baseConversations}
        activeId={'one'}
        onSelect={onSelect}
        onCreate={onCreate}
        onRename={onRename}
        onDelete={onDelete}
      />
    );

    expect(screen.getByText('First thread')).toBeInTheDocument();
    expect(screen.getByText('Second thread')).toBeInTheDocument();

    await userEvent.click(screen.getByText('First thread'));
    expect(onSelect).toHaveBeenCalledWith('one');

    await userEvent.click(screen.getByText('Новый'));
    expect(onCreate).toHaveBeenCalled();

    const renameButton = screen.getAllByLabelText('Rename conversation')[0];
    await userEvent.click(renameButton);
    expect(onRename).toHaveBeenCalledWith('one', 'Renamed thread');

    const deleteButton = screen.getAllByLabelText('Delete conversation')[0];
    await userEvent.click(deleteButton);
    expect(onDelete).toHaveBeenCalledWith('one');
  });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 195
PATH: frontend\next-app\__tests__\social-login-buttons.test.tsx
LANG: tsx
===== CONTENT START =====
import { render, screen } from '@testing-library/react';
import SocialLoginButtons from '@/components/auth/SocialLoginButtons';

describe('SocialLoginButtons', () => {
  it('renders provider buttons', () => {
    render(<SocialLoginButtons />);
    expect(screen.getByText(/Sign in with Google/i)).toBeInTheDocument();
    expect(screen.getByText(/Войти через VK ID/i)).toBeInTheDocument();
    expect(screen.getByText(/Войти через Яндекс ID/i)).toBeInTheDocument();
  });
});

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 196
PATH: frontend\parkmate\parkmate.types.ts
LANG: typescript
===== CONTENT START =====
// frontend/parkmate/parkmate.types.ts

export interface ParkMateAI {
  voiceCommands: {
    booking: string;
    navigation: string;
    payment: string;
    support: string;
  };
  computerVision: {
    licensePlateRecognition: string;
    parkingSpotDetection: string;
    damageDetection: string;
    occupancyAnalytics: string;
  };
  predictions: {
    arrivalTime: string;
    priceForecast: string;
    availability: string;
  };
}

/**
 * Базовый конфиг ParkMate, который фронтенд может запросить с бэка.
 * На следующей фазе мы добавим endpoint вроде /api/ai/parkmate/config/.
 */
export const defaultParkMateConfig: ParkMateAI = {
  voiceCommands: {
    booking: "Забронируй ближайшее свободное место на 2 часа",
    navigation: "Построй маршрут до моего места парковки",
    payment: "Оплати мою текущую парковку",
    support: "Соедини с поддержкой ParkShare",
  },
  computerVision: {
    licensePlateRecognition: "/api/ai/cv/license-plate/",
    parkingSpotDetection: "/api/ai/cv/parking-spots/",
    damageDetection: "/api/ai/cv/damage/",
    occupancyAnalytics: "/api/ai/cv/occupancy/",
  },
  predictions: {
    arrivalTime: "/api/ai/predict/arrival-time/",
    priceForecast: "/api/ai/predict/pricing/",
    availability: "/api/ai/predict/availability/",
  },
};

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 197
PATH: k8s\beat-deployment.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: apps/v1
kind: Deployment
metadata:
  name: parkshare-beat
  labels:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: beat
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: parkshare
      app.kubernetes.io/component: beat
  template:
    metadata:
      labels:
        app.kubernetes.io/name: parkshare
        app.kubernetes.io/component: beat
    spec:
      containers:
        - name: beat
          image: parkshare/web:latest
          imagePullPolicy: IfNotPresent
          command: ["celery", "-A", "backend.backend.config", "beat", "-l", "info"]
          envFrom:
            - configMapRef:
                name: parkshare-config
            - secretRef:
                name: parkshare-secrets
          resources:
            requests:
              cpu: "100m"
              memory: "256Mi"
            limits:
              cpu: "400m"
              memory: "512Mi"
          livenessProbe:
            exec:
              command: ["bash", "-c", "celery -A backend.backend.config inspect ping -d self"]
            initialDelaySeconds: 30
            periodSeconds: 120
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            allowPrivilegeEscalation: false

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 198
PATH: k8s\configmap.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: v1
kind: ConfigMap
metadata:
  name: parkshare-config
  labels:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: web
data:
  DJANGO_SETTINGS_MODULE: backend.backend.settings.production
  PLATFORM_MODE: RU
  REGION_PROFILE: RU
  ENABLE_METRICS: "true"
  ENABLE_AB_VARIANTS: "true"
  MAINTENANCE_MODE: "false"
  REDIS_URL: redis://redis:6379/0
  CELERY_BROKER_URL: redis://redis:6379/0
  CELERY_RESULT_BACKEND: redis://redis:6379/0
  # Используйте Vault/Secrets Manager для подстановки чувствительных значений.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 199
PATH: k8s\hpa.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: parkshare-web
  labels:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: web
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: parkshare-web
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 65
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: parkshare-worker
  labels:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: worker
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: parkshare-worker
  minReplicas: 2
  maxReplicas: 8
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 120
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 200
PATH: k8s\ingress.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: parkshare
  labels:
    app.kubernetes.io/name: parkshare
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
spec:
  rules:
    - host: parkshare.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: parkshare-web
                port:
                  number: 80
  tls:
    - hosts:
        - parkshare.example.com
      secretName: parkshare-tls

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 201
PATH: k8s\secret-example.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: v1
kind: Secret
metadata:
  name: parkshare-secrets
  labels:
    app.kubernetes.io/name: parkshare
type: Opaque
stringData:
  SECRET_KEY: change-me
  DATABASE_URL: postgres://user:pass@postgres:5432/parkshare
  DATABASE_REPLICA_URL: ""
  YOOKASSA_SHOP_ID: ""
  YOOKASSA_SECRET_KEY: ""
  STRIPE_SECRET_KEY: ""
  STRIPE_WEBHOOK_SECRET: ""
  LLM_API_KEY: ""
  MAPBOX_TOKEN: ""
  YANDEX_MAP_API_KEY: ""
  SENTRY_DSN: ""

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 202
PATH: k8s\web-deployment.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: apps/v1
kind: Deployment
metadata:
  name: parkshare-web
  labels:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: web
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: parkshare
      app.kubernetes.io/component: web
  template:
    metadata:
      labels:
        app.kubernetes.io/name: parkshare
        app.kubernetes.io/component: web
      annotations:
        # При blue/green: создайте второй Deployment (parkshare-web-blue/green),
        # переключите сервисом или Ingress аннотацией.
        checksum/config: "{{ include \"configmap-hash\" . | default \"dev\" }}"
    spec:
      containers:
        - name: web
          image: parkshare/web:latest
          imagePullPolicy: IfNotPresent
          command: ["gunicorn", "backend.backend.config.wsgi:application", "--bind", "0.0.0.0:8000", "--workers", "4", "--timeout", "60"]
          envFrom:
            - configMapRef:
                name: parkshare-config
            - secretRef:
                name: parkshare-secrets
          ports:
            - name: http
              containerPort: 8000
          readinessProbe:
            httpGet:
              path: /readyz
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 20
          resources:
            requests:
              cpu: "250m"
              memory: "512Mi"
            limits:
              cpu: "1"
              memory: "1Gi"
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            allowPrivilegeEscalation: false
          volumeMounts:
            - mountPath: /app/staticfiles
              name: static-volume
      volumes:
        - name: static-volume
          emptyDir: {}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 203
PATH: k8s\web-service.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: v1
kind: Service
metadata:
  name: parkshare-web
  labels:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: web
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: web
  ports:
    - name: http
      port: 80
      targetPort: 8000

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 204
PATH: k8s\worker-deployment.yaml
LANG: yaml
===== CONTENT START =====
apiVersion: apps/v1
kind: Deployment
metadata:
  name: parkshare-worker
  labels:
    app.kubernetes.io/name: parkshare
    app.kubernetes.io/component: worker
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: parkshare
      app.kubernetes.io/component: worker
  template:
    metadata:
      labels:
        app.kubernetes.io/name: parkshare
        app.kubernetes.io/component: worker
    spec:
      containers:
        - name: worker
          image: parkshare/web:latest
          imagePullPolicy: IfNotPresent
          command: ["celery", "-A", "backend.backend.config", "worker", "-l", "info"]
          envFrom:
            - configMapRef:
                name: parkshare-config
            - secretRef:
                name: parkshare-secrets
          resources:
            requests:
              cpu: "200m"
              memory: "256Mi"
            limits:
              cpu: "800m"
              memory: "512Mi"
          livenessProbe:
            exec:
              command: ["bash", "-c", "celery -A backend.backend.config inspect ping -d self"]
            initialDelaySeconds: 30
            periodSeconds: 60
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            allowPrivilegeEscalation: false

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 205
PATH: nginx\nginx.conf
LANG: text
===== CONTENT START =====
user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    keepalive_timeout  65;
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml+rss;

    upstream django {
        server web:8000;
    }

    server {
        listen 80;
        server_name _;

        # Uncomment for HTTPS termination + Let's Encrypt
        # listen 443 ssl http2;
        # ssl_certificate /etc/letsencrypt/live/DOMAIN/fullchain.pem;
        # ssl_certificate_key /etc/letsencrypt/live/DOMAIN/privkey.pem;

        add_header X-Content-Type-Options "nosniff" always;
        add_header X-Frame-Options "DENY" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Permissions-Policy "geolocation=(), camera=(), microphone=(), payment=()" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; connect-src 'self' https: wss:;";

        location /static/ {
            alias /static/;
            expires 7d;
        }

        location /media/ {
            alias /media/;
            expires 1d;
        }

        location /embed {
            proxy_pass http://frontend:3000/embed;
        }

        location / {
            proxy_pass http://django;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location = /health/ {
            access_log off;
            return 200 'ok';
        }
    }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 206
PATH: parking\__init__.py
LANG: python
===== CONTENT START =====
# backend/parking/__init__.py

default_app_config = "parking.apps.ParkingConfig"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 207
PATH: parking\admin.py
LANG: python
===== CONTENT START =====
# backend/parking/admin.py

from django.contrib import admin

from .models import Booking, Complaint, ParkingLot, ParkingSpot, WaitlistEntry


@admin.register(ParkingLot)
class ParkingLotAdmin(admin.ModelAdmin):
    list_display = ("name", "city", "owner", "parking_type", "is_active", "is_approved")
    list_filter = ("city", "parking_type", "is_active", "is_approved")
    search_fields = ("name", "city", "address", "owner__username")
    autocomplete_fields = ("owner",)


@admin.register(ParkingSpot)
class ParkingSpotAdmin(admin.ModelAdmin):
    list_display = (
        "name",
        "lot",
        "vehicle_type",
        "is_covered",
        "has_ev_charging",
        "status",
        "hourly_price",
    )
    list_filter = (
        "vehicle_type",
        "is_covered",
        "has_ev_charging",
        "status",
        "lot__city",
    )
    search_fields = ("name", "lot__name", "lot__city")
    autocomplete_fields = ("lot",)


@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "spot",
        "user",
        "booking_type",
        "status",
        "start_at",
        "end_at",
        "total_price",
        "is_paid",
    )
    list_filter = ("booking_type", "status", "start_at", "spot__lot__city")
    search_fields = ("spot__name", "spot__lot__name", "user__username")
    autocomplete_fields = ("spot", "user", "vehicle")


@admin.register(WaitlistEntry)
class WaitlistEntryAdmin(admin.ModelAdmin):
    list_display = ("id", "user", "spot", "status", "auto_book", "created_at")
    list_filter = ("status", "auto_book", "created_at")
    search_fields = ("user__username", "spot__name")
    autocomplete_fields = ("user", "spot")


@admin.register(Complaint)
class ComplaintAdmin(admin.ModelAdmin):
    list_display = ("id", "author", "category", "status", "created_at")
    list_filter = ("category", "status", "created_at")
    search_fields = ("author__username", "description")
    autocomplete_fields = ("author", "booking", "spot")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 208
PATH: parking\apps.py
LANG: python
===== CONTENT START =====
# backend/parking/apps.py

from django.apps import AppConfig


class ParkingConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "parking"
    verbose_name = "Парковки и бронирования"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 209
PATH: parking\models.py
LANG: python
===== CONTENT START =====
# backend/parking/models.py

from __future__ import annotations

from datetime import timedelta
from decimal import Decimal, ROUND_UP
from typing import Optional

from django.conf import settings
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel
from .models_notification import NotificationSettings


# PointField с fallback для SQLite: храним JSON {"lat": ..., "lng": ...}
_db_settings = getattr(settings, "DATABASES", {})
_default_db = _db_settings.get("default") or {}
_default_engine = _default_db.get("ENGINE", "")


if _default_engine.endswith("sqlite3"):
    class PointField(models.JSONField):  # type: ignore[misc]
        def __init__(self, *args, **kwargs):
            kwargs.pop("geography", None)
            super().__init__(*args, **kwargs)
else:  # PostGIS / другие GIS-бэкенды
    from django.contrib.gis.db.models import PointField  # type: ignore[assignment]


class ParkingLot(TimeStampedModel):
    """
    Объект парковки (двор, подземный паркинг, офисный паркинг и т.д.).
    """

    class ParkingType(models.TextChoices):
        YARD = "yard", "Дворовая парковка"
        UNDERGROUND = "underground", "Подземная парковка"
        MULTILEVEL = "multilevel", "Многоуровневая парковка"
        STREET = "street", "Уличная парковка"
        OFFICE = "office", "Офисная парковка"
        HOME = "home", "Домашнее место"

    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="parking_lots",
        verbose_name="Владелец",
    )
    name = models.CharField("Название", max_length=255)
    city = models.CharField("Город", max_length=100)
    address = models.CharField("Адрес", max_length=255)
    parking_type = models.CharField(
        "Тип парковки",
        max_length=32,
        choices=ParkingType.choices,
        default=ParkingType.YARD,
    )
    description = models.TextField("Описание", blank=True)

    location = PointField("Точка на карте", geography=True, null=True, blank=True)
    latitude = models.FloatField("Широта", null=True, blank=True)
    longitude = models.FloatField("Долгота", null=True, blank=True)

    is_active = models.BooleanField("Активен", default=True)
    is_approved = models.BooleanField(
        "Одобрен модерацией",
        default=False,
        help_text="Одобряется администратором перед публикацией.",
    )
    is_private = models.BooleanField(
        "Приватный",
        default=False,
        help_text="Если включено, объект виден только по прямым ссылкам/владельцу.",
    )

    stress_index = models.FloatField(
        "Индекс загруженности (0..1)",
        default=0.0,
        help_text=(
            "Средняя загруженность мест за последние 7 дней. "
            "Обновляется фоновыми задачами AI."
        ),
    )

    class Meta:
        verbose_name = "Объект парковки"
        verbose_name_plural = "Объекты парковки"
        ordering = ("name",)

    def __str__(self) -> str:
        return f"{self.name} ({self.city})"

    @property
    def owner_username(self) -> str:
        return getattr(self.owner, "username", "")

    def set_coordinates(self, lat: Optional[float], lng: Optional[float]) -> None:
        """
        Устанавливает координаты и PointField (если доступен GeoDjango).
        """
        self.latitude = lat
        self.longitude = lng
        if lat is None or lng is None:
            self.location = None
            return

        try:
            from django.contrib.gis.geos import Point  # type: ignore[import]
        except Exception:
            # SQLite/JSON fallback
            self.location = {"lat": lat, "lng": lng}
        else:
            self.location = Point(lng, lat)


class ParkingSpot(TimeStampedModel):
    """
    Конкретное парковочное место внутри ParkingLot.
    """

    class SpotStatus(models.TextChoices):
        ACTIVE = "active", "Активно"
        INACTIVE = "inactive", "Неактивно"

    class VehicleType(models.TextChoices):
        CAR = "car", "Легковой автомобиль"
        MOTO = "moto", "Мотоцикл"
        COMMERCIAL = "commercial", "Коммерческий транспорт"

    lot = models.ForeignKey(
        ParkingLot,
        on_delete=models.CASCADE,
        related_name="spots",
        verbose_name="Объект парковки",
    )
    name = models.CharField("Название/номер места", max_length=64)
    description = models.TextField("Описание", blank=True)

    vehicle_type = models.CharField(
        "Тип транспорта",
        max_length=16,
        choices=VehicleType.choices,
        default=VehicleType.CAR,
    )

    is_covered = models.BooleanField("Крытое место", default=False)
    has_ev_charging = models.BooleanField("Есть зарядка", default=False)
    is_24_7 = models.BooleanField("Круглосуточно", default=True)
    max_height_m = models.DecimalField(
        "Максимальная высота (м)",
        max_digits=4,
        decimal_places=2,
        null=True,
        blank=True,
    )

    hourly_price = models.DecimalField(
        "Цена за час, ₽", max_digits=8, decimal_places=2
    )
    nightly_price = models.DecimalField(
        "Цена за ночь, ₽", max_digits=8, decimal_places=2, null=True, blank=True
    )
    daily_price = models.DecimalField(
        "Цена за сутки, ₽", max_digits=8, decimal_places=2, null=True, blank=True
    )
    monthly_price = models.DecimalField(
        "Цена за месяц, ₽", max_digits=9, decimal_places=2, null=True, blank=True
    )

    allow_dynamic_pricing = models.BooleanField(
        "Динамическая цена (AI)",
        default=False,
        help_text="Если включено, тариф может корректироваться рекомендациями AI.",
    )

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=SpotStatus.choices,
        default=SpotStatus.ACTIVE,
    )

    occupancy_7d = models.FloatField(
        "Загруженность за 7 дней (0..1)",
        default=0.0,
        help_text=(
            "Доля времени, когда место было занято за последние 7 дней. "
            "Обновляется фоновыми задачами AI."
        ),
    )

    class Meta:
        verbose_name = "Парковочное место"
        verbose_name_plural = "Парковочные места"
        ordering = ("lot__name", "name")

    def __str__(self) -> str:
        return f"{self.lot.name} — {self.name}"

    @property
    def owner(self):
        """
        Для IsOwnerObject из core.permissions: владелец места = владелец ParkingLot.
        """
        return self.lot.owner

    @property
    def city(self) -> str:
        return self.lot.city

    @property
    def is_active(self) -> bool:
        return (
            self.status == self.SpotStatus.ACTIVE
            and self.lot.is_active
            and self.lot.is_approved
        )


class Booking(TimeStampedModel):
    """
    Бронирование парковочного места.
    """

    class BillingMode(models.TextChoices):
        PAYG = "pay_as_you_go", "Поминутно/почасово"
        PREPAID_BLOCK = "prepaid_block", "Предоплата блоком"
        WALLET = "wallet", "Оплата кошельком"

    class BookingType(models.TextChoices):
        HOURLY = "hourly", "Почасовая"
        DAILY = "daily", "Суточная"
        NIGHT = "night", "Ночная"
        WEEKLY = "weekly", "Недельная"
        MONTHLY = "monthly", "Месячная"

    class Status(models.TextChoices):
        PENDING = "pending", "Ожидает оплаты"
        CONFIRMED = "confirmed", "Подтверждена"
        ACTIVE = "active", "Активна"
        COMPLETED = "completed", "Завершена"
        CANCELLED = "cancelled", "Отменена"
        EXPIRED = "expired", "Истекла"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="bookings",
        verbose_name="Пользователь",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.PROTECT,
        related_name="bookings",
        verbose_name="Парковочное место",
    )
    vehicle = models.ForeignKey(
        "vehicles.Vehicle",
        on_delete=models.SET_NULL,
        related_name="bookings",
        verbose_name="Транспорт",
        null=True,
        blank=True,
    )

    booking_type = models.CharField(
        "Тип бронирования",
        max_length=16,
        choices=BookingType.choices,
        default=BookingType.HOURLY,
    )
    billing_mode = models.CharField(
        "Режим биллинга",
        max_length=32,
        choices=BillingMode.choices,
        default=BillingMode.PAYG,
    )

    start_at = models.DateTimeField("Начало брони")
    end_at = models.DateTimeField("Окончание брони")

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.PENDING,
    )
    total_price = models.DecimalField(
        "Итоговая стоимость, ₽", max_digits=10, decimal_places=2
    )
    currency = models.CharField("Валюта", max_length=8, default="RUB")
    is_paid = models.BooleanField("Оплачено", default=False)
    dynamic_pricing_applied = models.BooleanField(
        "Динамическое ценообразование", default=False
    )
    ai_snapshot = models.JSONField(
        "AI snapshot",
        null=True,
        blank=True,
        help_text="Данные решений AI (цены, доступность, риски)",
    )

    external_payment_id = models.CharField(
        "ID платежа провайдера",
        max_length=64,
        blank=True,
        help_text="Связка с платежом у провайдера (например, YooKassa payment_id).",
    )

    class Meta:
        verbose_name = "Бронирование"
        verbose_name_plural = "Бронирования"
        ordering = ("-start_at",)

    def __str__(self) -> str:
        return f"Бронь #{self.pk} — {self.spot} ({self.start_at} → {self.end_at})"

    @property
    def owner(self):
        """
        Для удобства — владелец места, по которому идёт бронь.
        """
        return self.spot.lot.owner

    @staticmethod
    def is_spot_available(
        spot: ParkingSpot,
        start_at,
        end_at,
        exclude_booking_id: Optional[int] = None,
    ) -> bool:
        """
        Проверка пересечения интервалов с существующими бронями.
        """
        qs = Booking.objects.filter(spot=spot).exclude(
            status__in=[Booking.Status.CANCELLED, Booking.Status.EXPIRED]
        )
        if exclude_booking_id:
            qs = qs.exclude(id=exclude_booking_id)
        # Пересечение интервалов: (start1 < end2) и (end1 > start2)
        overlap = qs.filter(start_at__lt=end_at, end_at__gt=start_at).exists()
        return not overlap

    def calculate_price(self) -> Decimal:
        """
        Простая модель расчёта цены на основе тарифов ParkingSpot и типа брони.
        """

        if not self.spot:
            return Decimal("0.00")

        delta = self.end_at - self.start_at
        total_seconds = Decimal(delta.total_seconds())
        total_hours = total_seconds / Decimal(3600)
        total_days = total_seconds / Decimal(86400)

        billing_mode = getattr(self, "billing_mode", self.BillingMode.PAYG)
        if billing_mode == self.BillingMode.PAYG:
            # Округляем вверх до 15-минутных слотов для поминутной/почасовой оплаты
            slots = (total_seconds / Decimal(900)).to_integral_value(rounding=ROUND_UP)
            total_hours = (slots * Decimal("0.25")).quantize(Decimal("0.25"))
        elif billing_mode == self.BillingMode.PREPAID_BLOCK:
            hours = float(total_hours)
            if hours <= 2:
                total_hours = Decimal("2")
            elif hours <= 4:
                total_hours = Decimal("4")
            elif hours <= 24:
                total_hours = Decimal("24")
            else:
                days = (Decimal(hours) / Decimal("24")).to_integral_value(rounding=ROUND_UP)
                total_hours = days * Decimal("24")

        base_price = Decimal("0.00")

        if self.booking_type == self.BookingType.HOURLY:
            hourly = self.spot.hourly_price
            units = max(
                Decimal("1"),
                total_hours.to_integral_value(rounding=ROUND_UP),
            )
            base_price = hourly * units
        elif self.booking_type == self.BookingType.DAILY:
            daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
            units = max(
                Decimal("1"),
                total_days.to_integral_value(rounding=ROUND_UP),
            )
            base_price = daily * units
        elif self.booking_type == self.BookingType.NIGHT:
            nightly = self.spot.nightly_price or (
                self.spot.hourly_price * Decimal("10")
            )
            base_price = nightly
        elif self.booking_type == self.BookingType.WEEKLY:
            daily = self.spot.daily_price or (self.spot.hourly_price * Decimal("24"))
            units = max(
                Decimal("1"),
                (total_days / Decimal("7")).to_integral_value(rounding=ROUND_UP),
            )
            base_price = daily * Decimal("7") * units
        elif self.booking_type == self.BookingType.MONTHLY:
            monthly = self.spot.monthly_price or (
                (self.spot.daily_price or self.spot.hourly_price * Decimal("24"))
                * Decimal("30")
            )
            units = max(
                Decimal("1"),
                (total_days / Decimal("30")).to_integral_value(rounding=ROUND_UP),
            )
            base_price = monthly * units
        else:
            base_price = self.spot.hourly_price * max(
                Decimal("1"),
                total_hours.to_integral_value(rounding=ROUND_UP),
            )

        base_price = base_price.quantize(Decimal("0.01"))

        commission_percent = getattr(settings, "SERVICE_COMMISSION_PERCENT", 0)
        commission = (
            base_price * Decimal(commission_percent) / Decimal("100")
        ).quantize(Decimal("0.01"))
        total = (base_price + commission).quantize(Decimal("0.01"))
        self.total_price = total
        return total

    def mark_paid(self, payment_id: str | None = None) -> None:
        """
        Отметить бронь как оплаченную (вызывается из модуля payments по webhook).
        """
        self.is_paid = True
        self.status = self.Status.CONFIRMED
        if payment_id:
            self.external_payment_id = payment_id
        self.save(update_fields=["is_paid", "status", "external_payment_id"])

    @property
    def has_started(self) -> bool:
        return self.start_at <= timezone.now()

    @property
    def has_ended(self) -> bool:
        return self.end_at <= timezone.now()

    @property
    def duration(self) -> timedelta:
        return self.end_at - self.start_at


class WaitlistEntry(TimeStampedModel):
    """
    Запись в листе ожидания для занятого места.
    """

    class Status(models.TextChoices):
        WAITING = "waiting", "Ожидает"
        NOTIFIED = "notified", "Уведомлён"
        BOOKED = "booked", "Авто‑бронирование создано"
        CANCELLED = "cancelled", "Отменено"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="waitlist_entries",
        verbose_name="Пользователь",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.CASCADE,
        related_name="waitlist_entries",
        verbose_name="Парковочное место",
    )
    desired_start = models.DateTimeField("Желаемое начало")
    desired_end = models.DateTimeField("Желаемое окончание")
    auto_book = models.BooleanField(
        "Авто‑бронирование",
        default=False,
        help_text="Если включено, при освобождении места будет создана бронь автоматически.",
    )
    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.WAITING,
    )

    class Meta:
        verbose_name = "Запись в листе ожидания"
        verbose_name_plural = "Лист ожидания"
        ordering = ("-created_at",)
        unique_together = ("user", "spot", "desired_start", "desired_end")

    def __str__(self) -> str:
        return f"Waitlist #{self.pk} — {self.user} → {self.spot}"


class Complaint(TimeStampedModel):
    """
    Жалоба по бронированию/месту:
    - чужая машина;
    - пользователь не приехал;
    - частые отмены и т.п.
    """

    class Category(models.TextChoices):
        FOREIGN_CAR = "foreign_car", "Чужая машина на месте"
        NO_SHOW = "no_show", "Пользователь не приехал"
        NO_FREE_SPOT = "no_free_spot", "Не нашёл свободного места"
        OTHER = "other", "Другое"

    class Status(models.TextChoices):
        NEW = "new", "Новая"
        IN_PROGRESS = "in_progress", "В работе"
        RESOLVED = "resolved", "Решена"
        REJECTED = "rejected", "Отклонена"

    author = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="complaints",
        verbose_name="Автор",
    )
    booking = models.ForeignKey(
        Booking,
        on_delete=models.SET_NULL,
        related_name="complaints",
        null=True,
        blank=True,
        verbose_name="Бронирование",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.SET_NULL,
        related_name="complaints",
        null=True,
        blank=True,
        verbose_name="Парковочное место",
    )

    category = models.CharField(
        "Категория",
        max_length=32,
        choices=Category.choices,
        default=Category.OTHER,
    )
    description = models.TextField("Описание", blank=True)

    status = models.CharField(
        "Статус",
        max_length=16,
        choices=Status.choices,
        default=Status.NEW,
    )

    class Meta:
        verbose_name = "Жалоба"
        verbose_name_plural = "Жалобы"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Жалоба #{self.pk} ({self.get_category_display()})"


class FavoriteParkingSpot(TimeStampedModel):
    """Избранные парковочные места пользователя."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="favorite_spots",
    )
    spot = models.ForeignKey(
        ParkingSpot,
        on_delete=models.CASCADE,
        related_name="favorites",
    )
    note = models.CharField("Заметка", max_length=120, blank=True)

    class Meta:
        verbose_name = "Избранное место"
        verbose_name_plural = "Избранные места"
        ordering = ("-created_at",)
        unique_together = ("user", "spot")

    def __str__(self) -> str:
        return f"{self.user} → {self.spot}"


class SavedPlace(TimeStampedModel):
    """Сохранённые точки (дом/офис) для быстрого поиска."""

    class PlaceType(models.TextChoices):
        HOME = "home", "Дом"
        WORK = "work", "Офис"
        CUSTOM = "custom", "Другое"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="saved_places",
    )
    title = models.CharField("Название", max_length=64)
    place_type = models.CharField(
        "Тип точки",
        max_length=16,
        choices=PlaceType.choices,
        default=PlaceType.CUSTOM,
    )
    latitude = models.FloatField("Широта")
    longitude = models.FloatField("Долгота")

    class Meta:
        verbose_name = "Сохранённая точка"
        verbose_name_plural = "Сохранённые точки"
        ordering = ("title",)
        unique_together = ("user", "title")

    def __str__(self) -> str:
        return f"{self.title} ({self.user})"


class PushSubscription(TimeStampedModel):
    """Хранение WebPush‑подписок для уведомлений."""

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="push_subscriptions",
        null=True,
        blank=True,
    )
    endpoint = models.URLField(unique=True)
    p256dh = models.CharField(max_length=255)
    auth = models.CharField(max_length=255)
    platform = models.CharField(max_length=64, blank=True)
    user_agent = models.CharField(max_length=255, blank=True)

    class Meta:
        verbose_name = "Push-подписка"
        verbose_name_plural = "Push-подписки"
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"{self.user or 'guest'} {self.endpoint[:32]}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 210
PATH: parking\models_notification.py
LANG: python
===== CONTENT START =====
from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _


class NotificationSettings(models.Model):
    """Настройки уведомлений для пользователя."""

    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="notification_settings",
    )
    notify_booking_expiry = models.BooleanField(
        _("Напоминать о завершении брони"), default=True
    )
    notify_night_restrictions = models.BooleanField(
        _("Напоминать о ночных ограничениях"), default=False
    )

    class Meta:
        verbose_name = _("Настройки уведомлений")
        verbose_name_plural = _("Настройки уведомлений")

    def __str__(self) -> str:
        return f"Notifications({self.user})"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 211
PATH: parking\push.py
LANG: python
===== CONTENT START =====
"""Lightweight push notification service wrapper.

The module intentionally avoids binding to a specific provider. It validates
payloads and envelopes and provides a single entry point that backend code can
call without caring about transport details.
"""
from __future__ import annotations

import json
import logging
import os
from typing import Iterable, Optional

from parking.models import PushSubscription

logger = logging.getLogger(__name__)


class PushTransportError(Exception):
    """Raised when the configured push transport fails."""


def _vapid_keys() -> tuple[Optional[str], Optional[str]]:
    return os.getenv("PUSH_VAPID_PUBLIC_KEY"), os.getenv("PUSH_VAPID_PRIVATE_KEY")


def send_parking_notification(user, payload: dict, subscriptions: Optional[Iterable[PushSubscription]] = None) -> int:
    """Send a WebPush notification to the provided subscriptions.

    The function is transport-agnostic; actual integration with a provider
    (VAPID/FCM/etc.) should be added where marked. Returns number of successfully
    queued notifications.
    """

    public_key, private_key = _vapid_keys()
    if not public_key or not private_key:
        logger.info("Push skipped: VAPID keys are not configured")
        return 0

    subs = list(subscriptions or [])
    if not subs and user:
        subs = list(PushSubscription.objects.filter(user=user))
    if not subs:
        return 0

    # Normalize payload to expected shape consumed by service worker
    normalized = {
        "title": payload.get("title") or "ParkShare",
        "body": payload.get("body") or "Новые события по бронированиям",
        "data": payload.get("data") or {},
        "actions": payload.get("actions") or [],
    }

    delivered = 0
    for sub in subs:
        try:
            # TODO: plug in concrete push provider here (pywebpush/FCM/etc.)
            logger.debug("Would send push to %s", sub.endpoint)
            _ = json.dumps(normalized, ensure_ascii=False)  # payload validation
            delivered += 1
        except Exception as exc:  # pragma: no cover - integration placeholder
            logger.warning("Push delivery failed, dropping subscription %s: %s", sub.id, exc)
            sub.delete()
    return delivered

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 212
PATH: parking\serializers.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from django.utils import timezone
from rest_framework import serializers

from core.utils import haversine_distance_km
from ai.orchestrator import apply_ai_pricing
from .models import (
    Booking,
    Complaint,
    FavoriteParkingSpot,
    ParkingLot,
    ParkingSpot,
    PushSubscription,
    SavedPlace,
    WaitlistEntry,
)


class ParkingLotSerializer(serializers.ModelSerializer):
    owner = serializers.ReadOnlyField(source="owner.username")
    spots_count = serializers.SerializerMethodField()

    class Meta:
        model = ParkingLot
        fields = (
            "id",
            "name",
            "city",
            "address",
            "parking_type",
            "description",
            "latitude",
            "longitude",
            "is_active",
            "is_approved",
            "is_private",
            "owner",
            "spots_count",
        )
        read_only_fields = ("id", "is_approved", "owner", "spots_count")

    def get_spots_count(self, obj: ParkingLot) -> int:
        return obj.spots.filter(status=ParkingSpot.SpotStatus.ACTIVE).count()

    def create(self, validated_data):
        """
        При создании парковки автоматически подставляем owner из request
        и синхронизируем PointField / lat / lng, если координаты заданы.
        """
        request = self.context.get("request")
        owner = getattr(request, "user", None)
        if owner is not None and owner.is_authenticated:
            validated_data["owner"] = owner
        lot = super().create(validated_data)

        if lot.latitude is not None and lot.longitude is not None:
            lot.set_coordinates(lot.latitude, lot.longitude)
            lot.save(update_fields=["latitude", "longitude", "location"])
        return lot

    def update(self, instance: ParkingLot, validated_data):
        lat = validated_data.get("latitude", instance.latitude)
        lng = validated_data.get("longitude", instance.longitude)
        instance = super().update(instance, validated_data)
        instance.set_coordinates(lat, lng)
        instance.save(update_fields=["latitude", "longitude", "location"])
        return instance


class ParkingSpotSerializer(serializers.ModelSerializer):
    """
    Серилизатор спота для публичного API.

    Дополнительные read-only поля:
    - lot_name, city — для удобного отображения;
    - lot_latitude, lot_longitude, lot_address — чтобы рисовать маркеры на карте;
    - distance_km — расстояние от точки запроса (lat/lng) до лота.
    """

    lot_name = serializers.ReadOnlyField(source="lot.name")
    city = serializers.ReadOnlyField(source="lot.city")
    lot_latitude = serializers.ReadOnlyField(source="lot.latitude")
    lot_longitude = serializers.ReadOnlyField(source="lot.longitude")
    lot_address = serializers.ReadOnlyField(source="lot.address")
    distance_km = serializers.SerializerMethodField()

    class Meta:
        model = ParkingSpot
        fields = (
            "id",
            "lot",
            "lot_name",
            "city",
            "lot_latitude",
            "lot_longitude",
            "lot_address",
            "name",
            "description",
            "vehicle_type",
            "is_covered",
            "has_ev_charging",
            "is_24_7",
            "max_height_m",
            "hourly_price",
            "nightly_price",
            "daily_price",
            "monthly_price",
            "allow_dynamic_pricing",
            "status",
            "distance_km",
        )
        read_only_fields = (
            "id",
            "lot_name",
            "city",
            "lot_latitude",
            "lot_longitude",
            "lot_address",
            "distance_km",
        )

    def get_distance_km(self, obj: ParkingSpot):
        """
        Если атрибут distance_km уже повешен во viewset — используем его.
        Иначе считаем по lat/lng из query-параметров (если они заданы).
        """
        distance = getattr(obj, "distance_km", None)
        if distance is not None:
            return round(float(distance), 2)

        request = self.context.get("request")
        if not request:
            return None
        lat_param = request.query_params.get("lat")
        lng_param = request.query_params.get("lng")
        if not lat_param or not lng_param:
            return None
        if obj.lot.latitude is None or obj.lot.longitude is None:
            return None

        try:
            lat = float(lat_param)
            lng = float(lng_param)
        except (TypeError, ValueError):
            return None

        return round(
            haversine_distance_km(lat, lng, obj.lot.latitude, obj.lot.longitude), 2
        )


class BookingSerializer(serializers.ModelSerializer):
    user = serializers.ReadOnlyField(source="user.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")
    lot_name = serializers.ReadOnlyField(source="spot.lot.name")

    class Meta:
        model = Booking
        fields = (
            "id",
            "user",
            "spot",
            "spot_name",
            "lot_name",
            "vehicle",
            "booking_type",
            "start_at",
            "end_at",
            "status",
            "total_price",
            "currency",
            "is_paid",
            "created_at",
            "updated_at",
            "external_payment_id",
        )
        read_only_fields = (
            "id",
            "user",
            "status",
            "total_price",
            "currency",
            "is_paid",
            "created_at",
            "updated_at",
            "external_payment_id",
            "spot_name",
            "lot_name",
        )

    def validate(self, attrs):
        """
        Базовая валидация бронирования:
        - start < end
        - не в прошлом
        - место активно
        - нет пересечения с другими бронями.
        """
        request = self.context["request"]
        spot: ParkingSpot = attrs.get("spot", getattr(self.instance, "spot", None))
        start_at = attrs.get("start_at", getattr(self.instance, "start_at", None))
        end_at = attrs.get("end_at", getattr(self.instance, "end_at", None))
        booking_type = attrs.get(
            "booking_type",
            getattr(self.instance, "booking_type", Booking.BookingType.HOURLY),
        )

        if not spot or not start_at or not end_at:
            raise serializers.ValidationError(
                "Необходимо указать место и интервал бронирования."
            )

        if start_at >= end_at:
            raise serializers.ValidationError(
                "Дата начала должна быть меньше даты окончания."
            )

        if start_at < timezone.now():
            raise serializers.ValidationError(
                "Нельзя создавать бронирование в прошлом."
            )

        if not spot.is_active:
            raise serializers.ValidationError(
                "Выбранное место сейчас недоступно для бронирования."
            )

        exclude_id = self.instance.id if self.instance else None
        if not Booking.is_spot_available(
            spot, start_at, end_at, exclude_booking_id=exclude_id
        ):
            raise serializers.ValidationError(
                "На выбранный период это место уже забронировано."
            )

        attrs["spot"] = spot
        attrs["start_at"] = start_at
        attrs["end_at"] = end_at
        attrs["booking_type"] = booking_type
        return attrs

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        booking = Booking(
            user=user,
            **validated_data,
        )
        booking.total_price = booking.calculate_price()
        booking.currency = "RUB"
        booking.status = Booking.Status.PENDING
        apply_ai_pricing(booking)
        booking.save()
        return booking

    def update(self, instance, validated_data):
        for field in ("spot", "start_at", "end_at", "booking_type", "vehicle"):
            if field in validated_data:
                setattr(instance, field, validated_data[field])

        # Для простоты разрешаем редактировать только PENDING‑брони.
        if instance.status != Booking.Status.PENDING:
            raise serializers.ValidationError(
                "Можно редактировать только бронирования в статусе 'Ожидает оплаты'."
            )

        instance.total_price = instance.calculate_price()
        apply_ai_pricing(instance)
        instance.save()
        return instance


class WaitlistEntrySerializer(serializers.ModelSerializer):
    user = serializers.ReadOnlyField(source="user.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")

    class Meta:
        model = WaitlistEntry
        fields = (
            "id",
            "user",
            "spot",
            "spot_name",
            "desired_start",
            "desired_end",
            "auto_book",
            "status",
            "created_at",
            "updated_at",
        )
        read_only_fields = (
            "id",
            "user",
            "spot_name",
            "status",
            "created_at",
            "updated_at",
        )

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        entry = WaitlistEntry.objects.create(user=user, **validated_data)
        return entry


class ComplaintSerializer(serializers.ModelSerializer):
    author = serializers.ReadOnlyField(source="author.username")
    spot_name = serializers.ReadOnlyField(source="spot.name")
    booking_id = serializers.ReadOnlyField(source="booking.id")

    class Meta:
        model = Complaint
        fields = (
            "id",
            "author",
            "booking",
            "booking_id",
            "spot",
            "spot_name",
            "category",
            "description",
            "status",
            "created_at",
            "updated_at",
        )
        read_only_fields = (
            "id",
            "author",
            "status",
            "created_at",
            "updated_at",
            "spot_name",
            "booking_id",
        )

    def create(self, validated_data):
        request = self.context["request"]
        user = request.user
        complaint = Complaint.objects.create(author=user, **validated_data)
        return complaint


class FavoriteParkingSpotSerializer(serializers.ModelSerializer):
    spot_name = serializers.ReadOnlyField(source="spot.name")
    lot_name = serializers.ReadOnlyField(source="spot.lot.name")
    city = serializers.ReadOnlyField(source="spot.lot.city")

    class Meta:
        model = FavoriteParkingSpot
        fields = (
            "id",
            "spot",
            "spot_name",
            "lot_name",
            "city",
            "note",
            "created_at",
        )
        read_only_fields = ("id", "spot_name", "lot_name", "city", "created_at")

    def create(self, validated_data):
        request = self.context.get("request")
        if request and request.user.is_authenticated:
            validated_data["user"] = request.user
        return super().create(validated_data)


class SavedPlaceSerializer(serializers.ModelSerializer):
    class Meta:
        model = SavedPlace
        fields = (
            "id",
            "title",
            "place_type",
            "latitude",
            "longitude",
            "created_at",
        )
        read_only_fields = ("id", "created_at")

    def create(self, validated_data):
        request = self.context.get("request")
        if request and request.user.is_authenticated:
            validated_data["user"] = request.user
        return super().create(validated_data)


class PushSubscriptionSerializer(serializers.ModelSerializer):
    class Meta:
        model = PushSubscription
        fields = (
            "id",
            "endpoint",
            "p256dh",
            "auth",
            "platform",
            "user_agent",
            "created_at",
        )
        read_only_fields = ("id", "created_at")

    def create(self, validated_data):
        request = self.context.get("request")
        if request:
            validated_data.setdefault("user_agent", request.META.get("HTTP_USER_AGENT", ""))
            if request.user.is_authenticated:
                validated_data.setdefault("user", request.user)
        return super().create(validated_data)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 213
PATH: parking\tasks.py
LANG: python
===== CONTENT START =====
# backend/parking/tasks.py

from __future__ import annotations

from datetime import timedelta

from celery import shared_task
from django.utils import timezone

from .models import Booking


@shared_task
def expire_unpaid_bookings() -> str:
    """
    Фоновая задача: помечает как EXPIRED неоплаченные бронирования,
    у которых время начала уже давно прошло.

    Подключена в CELERY_BEAT_SCHEDULE как parking.tasks.expire_unpaid_bookings.
    """

    now = timezone.now()
    grace = timedelta(minutes=15)  # "льготный" период
    qs = Booking.objects.filter(
        status=Booking.Status.PENDING,
        is_paid=False,
        start_at__lt=now - grace,
    )
    count = qs.count()
    for booking in qs:
        booking.status = Booking.Status.EXPIRED
        booking.save(update_fields=["status"])
    return f"Expired {count} unpaid bookings"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 214
PATH: parking\urls.py
LANG: python
===== CONTENT START =====
# backend/parking/urls.py

from django.urls import path

app_name = "parking"

urlpatterns: list = [
    # На данный момент все HTML‑страницы подключаются напрямую из config.urls.
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 215
PATH: parking\views.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from typing import Any, Iterable, List
import uuid
import logging
import hashlib
import json

from django.contrib.auth.mixins import LoginRequiredMixin
from django.core.cache import cache
from django.db.models import Q
import math
import requests
from django.shortcuts import redirect, get_object_or_404
from django.urls import reverse
from django.views.generic import TemplateView
from django.utils import timezone
from django.http import HttpResponse
from rest_framework import permissions, status, viewsets
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.throttling import UserRateThrottle, AnonRateThrottle
from rest_framework.views import APIView

from core.metrics import record_booking_event
from core.permissions import IsAdminOrReadOnly
from core.utils import haversine_distance_km, parse_float
from vehicles.models import Vehicle
from payments.models import PaymentMethod
from ai import tools as ai_tools
from ai.models import DeviceProfile, UiEvent
from parking.models_notification import NotificationSettings
from parking.analytics import compute_funnel

logger = logging.getLogger(__name__)
from accounts.models import UserLevel, UserBadge, PromoReward

from .models import (
    Booking,
    Complaint,
    FavoriteParkingSpot,
    ParkingLot,
    ParkingSpot,
    PushSubscription,
    SavedPlace,
    WaitlistEntry,
)
from .serializers import (
    BookingSerializer,
    ComplaintSerializer,
    FavoriteParkingSpotSerializer,
    ParkingLotSerializer,
    ParkingSpotSerializer,
    PushSubscriptionSerializer,
    SavedPlaceSerializer,
    WaitlistEntrySerializer,
)


def api_error(code: str, message: str, status_code=status.HTTP_400_BAD_REQUEST, details=None):
    return Response({"code": code, "message": message, "details": details or {}}, status=status_code)


def wants_json(request):
    accept = request.headers.get("Accept", "")
    return "application/json" in accept or request.content_type == "application/json"


def serialize_booking_session(booking: "Booking") -> dict[str, Any]:
    """
    Унифицированный DTO активной сессии для ассистента и мобильных клиентов.
    """
    now = timezone.now()
    remaining = max(0, int((booking.end_at - now).total_seconds()))
    return {
        "id": str(booking.id),
        "spot_id": str(booking.spot_id),
        "spot_name": booking.spot.name,
        "lot_name": booking.spot.lot.name,
        "status": booking.status,
        "start_at": booking.start_at,
        "end_at": booking.end_at,
        "remaining_seconds": remaining,
        "is_paid": booking.is_paid,
        "can_extend": booking.status in (Booking.Status.ACTIVE, Booking.Status.CONFIRMED),
    }


# =======================
#   DRF ViewSets (API)
# =======================


class ParkingLotViewSet(viewsets.ModelViewSet):
    """
    CRUD по объектам парковки.

    - GET /api/parking/lots/ — список (фильтрация по городу/типу)
    - POST /api/parking/lots/ — создать (только владельцы/админы)
    """

    serializer_class = ParkingLotSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        qs = ParkingLot.objects.select_related("owner")
        user = self.request.user
        if not user.is_authenticated or (
            not user.is_staff and not getattr(user, "is_owner", False)
        ):
            qs = qs.filter(is_active=True, is_approved=True)

        city = self.request.query_params.get("city")
        if city:
            qs = qs.filter(city__iexact=city)

        parking_type = self.request.query_params.get("parking_type")
        if parking_type:
            qs = qs.filter(parking_type=parking_type)

        return qs

    def perform_create(self, serializer):
        user = self.request.user
        if not user.is_authenticated or not getattr(user, "is_owner", False):
            raise permissions.PermissionDenied(
                "Создавать объекты парковки могут только пользователи с ролью 'owner' или администраторы."
            )
        serializer.save(owner=user)


class ParkingSpotViewSet(viewsets.ModelViewSet):
    """
    CRUD по парковочным местам.

    - GET /api/parking/spots/?lat=.&lng=.&radius_km=2 — места рядом
    - Фильтры: ?city=, ?vehicle_type=, ?max_price=, ?has_ev=1, ?covered=1, ?is_24_7=1
    """

    serializer_class = ParkingSpotSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        qs = ParkingSpot.objects.select_related("lot", "lot__owner").all()
        user = self.request.user

        if self.request.method in ("GET", "HEAD", "OPTIONS"):
            qs = qs.filter(
                status=ParkingSpot.SpotStatus.ACTIVE,
                lot__is_active=True,
                lot__is_approved=True,
            )
        else:
            # Управлять местами может только владелец/админ
            if not user.is_authenticated or (
                not getattr(user, "is_owner", False) and not user.is_superuser
            ):
                return ParkingSpot.objects.none()
            qs = qs.filter(lot__owner=user)

        # Фильтрация
        params = self.request.query_params
        city = params.get("city")
        if city:
            qs = qs.filter(lot__city__iexact=city)

        vehicle_type = params.get("vehicle_type")
        if vehicle_type:
            qs = qs.filter(vehicle_type=vehicle_type)

        max_price = parse_float(params.get("max_price"))
        if max_price is not None:
            qs = qs.filter(hourly_price__lte=max_price)

        has_ev = params.get("has_ev")
        if has_ev == "1":
            qs = qs.filter(has_ev_charging=True)

        covered = params.get("covered")
        if covered == "1":
            qs = qs.filter(is_covered=True)

        is_24_7 = params.get("is_24_7")
        if is_24_7 == "1":
            qs = qs.filter(is_24_7=True)

        return qs

    def list(self, request, *args, **kwargs):
        """
        Список мест c опциональной фильтрацией по радиусу от точки (lat/lng).
        """
        queryset = self.filter_queryset(self.get_queryset())

        try:
            page_size = int(request.query_params.get("page_size") or 50)
        except (TypeError, ValueError):
            page_size = 50
        page_size = min(max(page_size, 1), 100)
        if hasattr(self, "paginator"):
            self.paginator.page_size = page_size

        lat = parse_float(request.query_params.get("lat"))
        lng = parse_float(request.query_params.get("lng"))
        radius_km = parse_float(request.query_params.get("radius_km")) or 5
        radius_km = min(radius_km, 25)

        if lat is not None and lng is not None and radius_km is not None:
            lat_delta = radius_km / 111  # приблизительно ~111 км на градус
            lng_delta = radius_km / max(1, 111 * math.cos(math.radians(lat)))
            queryset = queryset.filter(
                lot__latitude__gte=lat - lat_delta,
                lot__latitude__lte=lat + lat_delta,
                lot__longitude__gte=lng - lng_delta,
                lot__longitude__lte=lng + lng_delta,
            )
            # Python‑фильтрация по расстоянию (работает и без PostGIS)
            filtered: List[ParkingSpot] = []
            for spot in queryset:
                lot = spot.lot
                if lot.latitude is None or lot.longitude is None:
                    continue
                distance = haversine_distance_km(
                    lat, lng, lot.latitude, lot.longitude
                )
                if distance <= radius_km:
                    spot.distance_km = distance  # для сериализатора
                    filtered.append(spot)
            queryset = filtered

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            response = self.get_paginated_response(serializer.data)
            self._maybe_cache_response(request, response.data)
            return response

        serializer = self.get_serializer(queryset, many=True)
        data = serializer.data
        self._maybe_cache_response(request, data)
        return Response(data)

    def _maybe_cache_response(self, request, data):
        user = request.user
        if user.is_authenticated:
            return
        lat = parse_float(request.query_params.get("lat"))
        lng = parse_float(request.query_params.get("lng"))
        if lat is None or lng is None:
            return
        cache_key = "spots:{lat:.4f}:{lng:.4f}:{radius}:{page}:{size}".format(
            lat=lat,
            lng=lng,
            radius=request.query_params.get("radius_km") or "default",
            page=request.query_params.get("page") or "1",
            size=request.query_params.get("page_size") or "",
        )
        cache.set(cache_key, data, 60)


class BookingViewSet(viewsets.ModelViewSet):
    """
    Бронирования.

    - Пользователь видит свои бронирования.
    - Владелец видит свои бронирования и брони по своим местам.
    """

    serializer_class = BookingSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Booking.objects.select_related(
            "spot", "spot__lot", "user", "vehicle"
        ).all()
        if not user.is_authenticated:
            return Booking.objects.none()

        if user.is_superuser:
            return qs

        if getattr(user, "is_owner", False):
            return qs.filter(Q(user=user) | Q(spot__lot__owner=user))
        return qs.filter(user=user)

    def perform_create(self, serializer):
        booking = serializer.save()
        try:
            record_booking_event("created")
        except Exception:
            pass
        return booking

    def destroy(self, request, *args, **kwargs):
        """
        Отмена бронирования: помечаем как CANCELLED, если оно ещё не началось.
        """
        instance: Booking = self.get_object()
        if instance.has_started:
            return Response(
                {"detail": "Нельзя отменить уже начавшееся бронирование."},
                status=status.HTTP_400_BAD_REQUEST,
            )
        instance.status = Booking.Status.CANCELLED
        instance.save(update_fields=["status"])
        try:
            record_booking_event("cancelled")
        except Exception:
            pass
        return Response(status=status.HTTP_204_NO_CONTENT)


class ParkingSearchAPIView(APIView):
    permission_classes = [AllowAny]
    throttle_classes = [UserRateThrottle, AnonRateThrottle]

    def get(self, request, *args, **kwargs):
        params = request.query_params
        cache_key = "v1:search:" + hashlib.sha256(
            json.dumps(sorted(params.items()), ensure_ascii=True).encode("utf-8")
        ).hexdigest()
        if not request.user.is_authenticated:
            cached = cache.get(cache_key)
            if cached:
                return Response(cached)

        qs = (
            ParkingSpot.objects.filter(
                status=ParkingSpot.SpotStatus.ACTIVE,
                lot__is_active=True,
                lot__is_approved=True,
            )
            .select_related("lot")
        )

        query = (params.get("q") or "").strip()
        if query:
            qs = qs.filter(Q(lot__name__icontains=query) | Q(lot__address__icontains=query) | Q(name__icontains=query))

        city = params.get("city")
        if city:
            qs = qs.filter(lot__city__iexact=city)

        vehicle_type = params.get("vehicle_type")
        if vehicle_type:
            qs = qs.filter(vehicle_type=vehicle_type)

        max_price = parse_float(params.get("max_price"))
        if max_price is not None:
            qs = qs.filter(hourly_price__lte=max_price)

        has_ev = params.get("has_ev") == "1" or params.get("ev") == "true"
        if has_ev:
            qs = qs.filter(has_ev_charging=True)

        covered = params.get("covered") == "1" or params.get("covered") == "true"
        if covered:
            qs = qs.filter(is_covered=True)

        lat = parse_float(params.get("lat"))
        lng = parse_float(params.get("lng"))
        radius_km = parse_float(params.get("radius_km")) or 5
        radius_km = min(radius_km, 25)
        if lat is not None and lng is not None:
            lat_delta = radius_km / 111
            lng_delta = radius_km / max(1, 111 * math.cos(math.radians(lat)))
            qs = qs.filter(
                lot__latitude__gte=lat - lat_delta,
                lot__latitude__lte=lat + lat_delta,
                lot__longitude__gte=lng - lng_delta,
                lot__longitude__lte=lng + lng_delta,
            )

        try:
            limit = min(int(params.get("limit") or 50), 100)
        except (TypeError, ValueError):
            limit = 50

        results = list(qs[:limit])
        if params.get("format") == "geojson":
            features = []
            for spot in results:
                lat = getattr(spot.lot, "latitude", None)
                lng = getattr(spot.lot, "longitude", None)
                if lat is None or lng is None:
                    continue
                features.append(
                    {
                        "id": str(spot.id),
                        "type": "Feature",
                        "geometry": {"type": "Point", "coordinates": [lng, lat]},
                        "properties": {
                            "spot_id": str(spot.id),
                            "lot_id": str(spot.lot_id),
                            "lot_name": spot.lot.name,
                            "city": spot.lot.city,
                            "address": spot.lot.address,
                            "name": spot.name,
                            "vehicle_type": spot.vehicle_type,
                            "has_ev_charging": spot.has_ev_charging,
                            "is_covered": spot.is_covered,
                            "is_24_7": spot.is_24_7,
                            "hourly_price": float(spot.hourly_price),
                            "nightly_price": float(spot.nightly_price or 0),
                            "daily_price": float(spot.daily_price or 0),
                            "monthly_price": float(spot.monthly_price or 0),
                            "status": spot.status,
                            "allow_dynamic_pricing": spot.allow_dynamic_pricing,
                            "occupancy_7d": float(spot.occupancy_7d or 0.0),
                            "stress_index": float(spot.lot.stress_index or 0.0),
                        },
                    }
                )
            payload = {"type": "FeatureCollection", "features": features}
            if not request.user.is_authenticated:
                cache.set(cache_key, payload, 60)
            return Response(payload, status=status.HTTP_200_OK)

        data = ParkingSpotSerializer(results, many=True, context={"request": request}).data
        payload = {"count": len(data), "results": data}
        if not request.user.is_authenticated:
            cache.set(cache_key, payload, 60)
        return Response(payload, status=status.HTTP_200_OK)


class ParkingDetailsAPIView(APIView):
    permission_classes = [AllowAny]
    throttle_classes = [UserRateThrottle, AnonRateThrottle]

    def get(self, request, spot_id: uuid.UUID, *args, **kwargs):
        cache_key = f"v1:details:{spot_id}"
        if not request.user.is_authenticated:
            cached = cache.get(cache_key)
            if cached:
                return Response(cached)

        spot = get_object_or_404(
            ParkingSpot.objects.select_related("lot"),
            pk=spot_id,
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )
        data = ParkingSpotSerializer(spot, context={"request": request}).data
        payload = {"spot": data}
        if not request.user.is_authenticated:
            cache.set(cache_key, payload, 120)
        return Response(payload, status=status.HTTP_200_OK)


class BookingStartAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        spot_id = request.data.get("spot_id")
        try:
            duration_minutes = max(15, int(request.data.get("duration_minutes") or 60))
        except (TypeError, ValueError):
            duration_minutes = 60
        spot = get_object_or_404(
            ParkingSpot,
            pk=spot_id,
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )
        start_at = timezone.now()
        end_at = start_at + timezone.timedelta(minutes=duration_minutes)
        if not Booking.is_spot_available(spot, start_at, end_at):
            return api_error("spot_unavailable", "Место занято в выбранный период.", status.HTTP_409_CONFLICT)

        booking = Booking.objects.create(
            user=request.user,
            spot=spot,
            start_at=start_at,
            end_at=end_at,
            booking_type=Booking.BookingType.HOURLY,
            billing_mode=request.data.get("billing_mode") or Booking.BillingMode.PAYG,
            status=Booking.Status.ACTIVE,
            total_price=0,
            currency="RUB",
        )
        booking.calculate_price()
        booking.status = Booking.Status.ACTIVE
        booking.save(update_fields=["total_price", "status", "updated_at"])
        record_booking_event("started")
        payload = serialize_booking_session(booking)
        return Response({"booking": payload}, status=status.HTTP_201_CREATED)


class BookingExtendAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        booking_id = request.data.get("booking_id")
        try:
            extend_minutes = max(5, int(request.data.get("extend_minutes") or 30))
        except (TypeError, ValueError):
            extend_minutes = 30
        booking = get_object_or_404(
            Booking.objects.select_related("spot", "spot__lot"),
            pk=booking_id,
            user=request.user,
        )
        if booking.status not in (Booking.Status.ACTIVE, Booking.Status.CONFIRMED):
            return api_error("invalid_status", "Продление доступно только для активных броней.")

        new_end = booking.end_at + timezone.timedelta(minutes=extend_minutes)
        if not Booking.is_spot_available(booking.spot, booking.start_at, new_end, exclude_booking_id=booking.id):
            return api_error("spot_unavailable", "Место недоступно в новое время.", status.HTTP_409_CONFLICT)

        booking.end_at = new_end
        booking.status = Booking.Status.ACTIVE
        booking.calculate_price()
        booking.save(update_fields=["end_at", "total_price", "status", "updated_at"])
        record_booking_event("extended")
        return Response({"booking": serialize_booking_session(booking)}, status=status.HTTP_200_OK)


class BookingStopAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        booking_id = request.data.get("booking_id")
        booking = get_object_or_404(
            Booking.objects.select_related("spot", "spot__lot"),
            pk=booking_id,
            user=request.user,
        )
        if booking.status in (Booking.Status.COMPLETED, Booking.Status.CANCELLED, Booking.Status.EXPIRED):
            return api_error("invalid_status", "Бронь уже завершена или отменена.")

        booking.end_at = timezone.now()
        booking.status = Booking.Status.COMPLETED
        booking.save(update_fields=["end_at", "status", "updated_at"])
        record_booking_event("stopped")
        return Response({"booking": serialize_booking_session(booking)}, status=status.HTTP_200_OK)


class ActiveBookingAPIView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, *args, **kwargs):
        qs = (
            Booking.objects.filter(
                user=request.user,
                status__in=[Booking.Status.ACTIVE, Booking.Status.CONFIRMED],
            )
            .select_related("spot", "spot__lot")
            .order_by("end_at")
        )
        sessions = [serialize_booking_session(b) for b in qs]
        return Response({"count": len(sessions), "results": sessions}, status=status.HTTP_200_OK)


class WaitlistViewSet(viewsets.ModelViewSet):
    """
    Лист ожидания. Пользователь управляет только своими записями.
    Админ может видеть всё.
    """

    serializer_class = WaitlistEntrySerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = WaitlistEntry.objects.select_related("spot", "spot__lot", "user")
        if user.is_superuser:
            return qs
        return qs.filter(user=user)


class ComplaintViewSet(viewsets.ModelViewSet):
    """
    Жалобы. Создатель видит свои, админ — все.
    """

    serializer_class = ComplaintSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Complaint.objects.select_related("author", "spot", "booking")
        if user.is_superuser:
            return qs
        return qs.filter(author=user)

    def perform_create(self, serializer):
        serializer.save(author=self.request.user)


class FavoriteParkingSpotViewSet(viewsets.ModelViewSet):
    """API избранных парковочных мест."""

    serializer_class = FavoriteParkingSpotSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = FavoriteParkingSpot.objects.select_related("spot", "spot__lot")
        if user.is_superuser:
            return qs
        return qs.filter(user=user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class SavedPlaceViewSet(viewsets.ModelViewSet):
    """Сохранённые точки (дом/офис)."""

    serializer_class = SavedPlaceSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = SavedPlace.objects.all()
        if user.is_superuser:
            return qs
        return qs.filter(user=user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class PushSubscriptionViewSet(viewsets.ModelViewSet):
    """Регистрация WebPush подписок."""

    serializer_class = PushSubscriptionSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return PushSubscription.objects.none()
        return PushSubscription.objects.filter(user=user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user if self.request.user.is_authenticated else None)


# =======================
#   HTML-вьюхи
# =======================


class LandingPageView(TemplateView):
    """
    Лендинг с картой и списком парковок/мест.
    Поддерживает фильтры:
    - city
    - lat, lng, radius_km (поиск по радиусу)
    """

    template_name = "parking/landing.html"

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        city = (self.request.GET.get("city") or "").strip()
        ctx["lots"] = []  # данные отдаём через API, чтобы не дублировать шаблонную логику
        ctx["spots"] = []
        ctx["has_query"] = bool(city)
        ctx["spots_total"] = ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        ).count()
        return ctx


class MapPageView(LandingPageView):
    """Полноэкранная карта с теми же данными, что и лендинг."""

    template_name = "parking/map_fullscreen.html"


class PWAInstallGuideView(TemplateView):
    """Простая страница с инструкциями по установке PWA."""

    template_name = "parking/pwa_install.html"


class UserDashboardView(LoginRequiredMixin, TemplateView):
    """
    Личный кабинет водителя: его машины и бронирования.
    """

    template_name = "parking/user_dashboard.html"

    def _level_progress(self, user, completed_count: int):
        levels = list(UserLevel.objects.all().order_by("threshold"))
        current = None
        next_level = None
        for lvl in levels:
            if completed_count >= lvl.threshold:
                current = lvl
            elif completed_count < lvl.threshold and not next_level:
                next_level = lvl
        remaining = max(0, (next_level.threshold - completed_count)) if next_level else 0
        progress = 100
        if next_level and next_level.threshold:
            prev_threshold = current.threshold if current else 0
            span = next_level.threshold - prev_threshold
            progress = int(min(100, max(0, ((completed_count - prev_threshold) / span) * 100)))
        return current, next_level, remaining, progress

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        user = self.request.user
        vehicles = Vehicle.objects.filter(owner=user).order_by("-created_at")
        bookings = (
            Booking.objects.filter(user=user)
            .select_related("spot", "spot__lot")
            .order_by("-start_at")
        )
        completed_count = bookings.filter(status__in=[Booking.Status.COMPLETED, Booking.Status.CONFIRMED, Booking.Status.ACTIVE]).count()
        current_level, next_level, remaining, progress = self._level_progress(user, completed_count)
        ctx["vehicles"] = vehicles
        ctx["bookings"] = bookings
        ctx["badges"] = UserBadge.objects.filter(user=user)
        ctx["level"] = current_level
        ctx["next_level"] = next_level
        ctx["level_remaining"] = remaining
        ctx["level_progress"] = progress
        return ctx


class OwnerDashboardView(LoginRequiredMixin, TemplateView):
    """
    Кабинет владельца: его паркинги, места и бронирования по ним.
    """

    template_name = "parking/owner_dashboard.html"

    def dispatch(self, request, *args, **kwargs):
        user = request.user
        if not (getattr(user, "is_owner", False) or user.is_superuser):
            # Если не владелец — отправляем в обычный кабинет
            return redirect("user_dashboard")
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        user = self.request.user
        lots = (
            ParkingLot.objects.filter(owner=user)
            .prefetch_related("spots")
            .order_by("city", "name")
        )
        spots = (
            ParkingSpot.objects.filter(lot__owner=user)
            .select_related("lot")
            .order_by("lot__city", "lot__name", "name")
        )
        bookings = (
            Booking.objects.filter(spot__lot__owner=user)
            .select_related("spot", "spot__lot", "user")
            .order_by("-start_at")
        )
        ctx["lots"] = lots
        ctx["spots"] = spots
        ctx["bookings"] = bookings
        return ctx


class BookingConfirmView(LoginRequiredMixin, TemplateView):
    """
    Экран подтверждения бронирования с выбором интервала, оплаты и бизнес-флага.
    """

    template_name = "parking/booking_confirm.html"

    def _normalize_hours(self, hours: float, billing_mode: str) -> float:
        if billing_mode == Booking.BillingMode.PREPAID_BLOCK:
            blocks = max(1, math.ceil(hours / 2))
            return blocks * 2
        return hours

    def _estimate_price(self, spot: ParkingSpot, hours: float, billing_mode: str, booking_type=None):
        hours = self._normalize_hours(hours, billing_mode)
        start_at = timezone.now()
        end_at = start_at + timezone.timedelta(hours=hours)
        booking = Booking(
            user=self.request.user,
            spot=spot,
            start_at=start_at,
            end_at=end_at,
            booking_type=booking_type or Booking.BookingType.HOURLY,
            billing_mode=billing_mode or Booking.BillingMode.PAYG,
            total_price=0,
        )
        return float(booking.calculate_price())

    def get_spot(self):
        spot_id = self.request.GET.get("spot_id") or self.request.POST.get("spot_id")
        return get_object_or_404(
            ParkingSpot,
            pk=spot_id,
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        )

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        spot = self.get_spot()
        user = self.request.user
        vehicles = Vehicle.objects.filter(owner=user).order_by("-created_at")
        payment_methods = PaymentMethod.objects.filter(user=user).order_by("-is_default", "-created_at")
        billing_mode = self.request.POST.get("billing_mode") or self.request.GET.get("billing_mode") or Booking.BillingMode.PAYG
        ctx.update(
            {
                "spot": spot,
                "spot_estimates": {
                    "h1": self._estimate_price(spot, 1, billing_mode, Booking.BookingType.HOURLY),
                    "h3": self._estimate_price(spot, 3, billing_mode, Booking.BookingType.HOURLY),
                    "h24": self._estimate_price(spot, 24, billing_mode, Booking.BookingType.DAILY),
                },
                "vehicles": vehicles,
                "payment_methods": payment_methods,
                "default_vehicle": vehicles.first(),
                "default_payment": payment_methods.first(),
                "errors": kwargs.get("errors") or [],
                "success": kwargs.get("success"),
                "selected_hours": kwargs.get("selected_hours", 1),
                "billing_mode": billing_mode,
            }
        )
        return ctx

    def post(self, request, *args, **kwargs):
        spot = self.get_spot()
        user = request.user
        if getattr(settings, "MAINTENANCE_MODE", False):
            return api_error("maintenance", "Сервис временно недоступен для бронирования.", status.HTTP_503_SERVICE_UNAVAILABLE)
        hours = float(request.POST.get("hours") or 1)
        vehicle_id = request.POST.get("vehicle_id")
        payment_method_id = request.POST.get("payment_method_id")
        billing_mode = request.POST.get("billing_mode") or Booking.BillingMode.PAYG
        is_business = request.POST.get("is_business") == "on"

        hours_norm = self._normalize_hours(hours, billing_mode)
        start_at = timezone.now()
        end_at = start_at + timezone.timedelta(hours=hours_norm)
        booking_type = Booking.BookingType.DAILY if hours >= 24 else Booking.BookingType.HOURLY

        errors = []
        if not Booking.is_spot_available(spot, start_at, end_at):
            errors.append("Место занято в выбранный период. Выберите другой интервал.")

        if errors:
            return self.render_to_response(
                self.get_context_data(
                    errors=errors,
                    selected_hours=hours,
                )
            )

        booking = Booking.objects.create(
            user=user,
            spot=spot,
            vehicle_id=vehicle_id or None,
            booking_type=booking_type,
            billing_mode=billing_mode,
            start_at=start_at,
            end_at=end_at,
            status=Booking.Status.PENDING,
            total_price=0,
            ai_snapshot={"billing_mode": billing_mode, "business_trip": is_business},
        )
        booking.calculate_price()
        booking.status = Booking.Status.CONFIRMED
        booking.save(update_fields=["total_price", "status", "ai_snapshot"])

        # Статус оплаты — заглушка: интеграция с провайдером может обновить позже
        success_msg = f"Бронь #{booking.id} создана. Сумма: {booking.total_price} ₽."
        logger.info("Booking created", extra={"booking_id": booking.id, "user": user.id, "billing_mode": billing_mode})
        return self.render_to_response(
            self.get_context_data(
                success=success_msg,
                selected_hours=hours,
            )
        )


def _get_device_profile(request):
    device_id = request.COOKIES.get("ps_device_id") or f"ps_{uuid.uuid4().hex}"
    profile, _ = DeviceProfile.objects.get_or_create(
        device_id=device_id,
        user=request.user if request.user.is_authenticated else None,
        defaults={"layout_profile": DeviceProfile.LayoutProfile.COMPACT},
    )
    return profile


class ProfileSettingsView(LoginRequiredMixin, TemplateView):
    """Настройки профиля: предпочтения парковки и уведомления."""

    template_name = "parking/profile_settings.html"

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        profile = _get_device_profile(self.request)
        prefs = ai_tools.load_preferences(profile)
        notif, _ = NotificationSettings.objects.get_or_create(user=self.request.user)
        ctx.update(
            {
                "preferences": prefs,
                "success": kwargs.get("success"),
                "notifications": notif,
            }
        )
        return ctx

    def post(self, request, *args, **kwargs):
        profile = _get_device_profile(request)
        if "reset_prefs" in request.POST:
            UiEvent.objects.filter(device_profile=profile, event_type="preferences").delete()
            if wants_json(request):
                return Response({"message": "Предпочтения сброшены"}, status=status.HTTP_200_OK)
            return self.render_to_response(self.get_context_data(success="Предпочтения сброшены"))
        notif, _ = NotificationSettings.objects.get_or_create(user=request.user)
        notif.notify_booking_expiry = request.POST.get("notify_booking_expiry") == "on"
        notif.notify_night_restrictions = request.POST.get("notify_night_restrictions") == "on"
        notif.save(update_fields=["notify_booking_expiry", "notify_night_restrictions"])
        if wants_json(request):
            return Response({"message": "Настройки уведомлений обновлены"}, status=status.HTTP_200_OK)
        return self.render_to_response(self.get_context_data(success="Настройки уведомлений обновлены"))


class PaymentMethodsPageView(LoginRequiredMixin, TemplateView):
    """Страница управления способами оплаты (минимальная заглушка)."""

    template_name = "parking/payment_methods.html"

    def _detect_brand(self, card_number: str) -> str:
        if card_number.startswith("4"):
            return PaymentMethod.Brand.VISA
        if card_number.startswith("5"):
            return PaymentMethod.Brand.MASTERCARD
        if card_number.startswith("220"):
            return PaymentMethod.Brand.MIR
        if card_number.startswith("62"):
            return PaymentMethod.Brand.UNIONPAY
        return PaymentMethod.Brand.OTHER

    def post(self, request, *args, **kwargs):
        user = request.user
        if getattr(settings, "MAINTENANCE_MODE", False):
            if wants_json(request):
                return api_error("maintenance", "Сервис недоступен для изменения оплаты.", status.HTTP_503_SERVICE_UNAVAILABLE)
            return self.render_to_response(self.get_context_data(success="Сервис недоступен для изменения оплаты."))
        if "delete_id" in request.POST:
            PaymentMethod.objects.filter(user=user, id=request.POST.get("delete_id")).delete()
            if wants_json(request):
                return Response({"message": "Метод оплаты удалён"}, status=status.HTTP_200_OK)
            logger.info("Payment method deleted", extra={"user": user.id})
            return self.render_to_response(self.get_context_data(success="Метод оплаты удалён"))

        card = (request.POST.get("card_number") or "").replace(" ", "")
        if len(card) < 12:
            if wants_json(request):
                return api_error("invalid_card", "Некорректный номер карты")
            return self.render_to_response(self.get_context_data(success="Некорректный номер карты"))
        last4 = card[-4:] if len(card) >= 4 else "0000"
        exp = (request.POST.get("exp") or "").split("/")
        try:
            exp_month = int(exp[0]) if exp else 1
            exp_year = int(exp[1]) if len(exp) > 1 else 30
        except ValueError:
            exp_month, exp_year = 1, 30
        label = request.POST.get("label") or "Моя карта"
        brand = self._detect_brand(card)
        is_default = request.POST.get("is_default") == "on"
        PaymentMethod.objects.create(
            user=user,
            label=label,
            brand=brand,
            last4=last4,
            exp_month=exp_month,
            exp_year=exp_year,
            is_default=is_default,
            token_masked=f"stub_{last4}_{timezone.now().timestamp()}",
        )
        logger.info("Payment method added", extra={"user": user.id, "brand": brand, "last4": last4})
        if wants_json(request):
            return Response({"message": "Метод оплаты добавлен"}, status=status.HTTP_200_OK)
        return self.render_to_response(self.get_context_data(success="Метод оплаты добавлен"))

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        methods = PaymentMethod.objects.filter(user=self.request.user).order_by("-is_default", "-created_at")
        ctx["methods"] = methods
        ctx["success"] = kwargs.get("success")
        return ctx


class PromoActivateView(LoginRequiredMixin, TemplateView):
    """Простая активация промокода."""

    template_name = "parking/promo_activate.html"

    def post(self, request, *args, **kwargs):
        code = (request.POST.get("code") or "").strip()
        if len(code) > 64:
            if wants_json(request):
                return api_error("invalid_promo", "Промокод слишком длинный.", status.HTTP_400_BAD_REQUEST)
            code = code[:64]
        message = "Промокод недействителен или исчерпан."
        try:
            reward = PromoReward.objects.get(code__iexact=code, active=True)
            message = f"Промокод применён: {reward.description or 'бонус'}"
        except PromoReward.DoesNotExist:
            if wants_json(request):
                return api_error("invalid_promo", "Промокод недействителен или исчерпан.", status.HTTP_400_BAD_REQUEST)
            message = "Промокод недействителен или исчерпан."
            logger.warning("Promo activation failed", extra={"user": request.user.id, "code": code})
        if wants_json(request):
            return Response({"message": message}, status=status.HTTP_200_OK)
        return self.render_to_response({"message": message})

    def get(self, request, *args, **kwargs):
        return self.render_to_response({"message": None})


class BusinessReportsView(LoginRequiredMixin, TemplateView):
    """Отчёты по служебным поездкам с экспортом CSV."""

    template_name = "parking/business_reports.html"

    def get_queryset(self, start=None, end=None, city=None):
        user = self.request.user
        qs = (
            Booking.objects.filter(user=user)
            .select_related("spot", "spot__lot")
            .order_by("-start_at")
        )
        qs = [b for b in qs if (b.ai_snapshot or {}).get("business_trip")]
        if start:
            qs = [b for b in qs if b.start_at.date() >= start]
        if end:
            qs = [b for b in qs if b.start_at.date() <= end]
        if city:
            qs = [b for b in qs if b.spot.lot.city.lower() == city.lower()]
        return qs

    def get(self, request, *args, **kwargs):
        start_param = request.GET.get("start")
        end_param = request.GET.get("end")
        city = request.GET.get("city") or None
        start = end = None
        if start_param:
            try:
                start = timezone.datetime.fromisoformat(start_param).date()
            except ValueError:
                start = None
        if end_param:
            try:
                end = timezone.datetime.fromisoformat(end_param).date()
            except ValueError:
                end = None
        qs = self.get_queryset(start, end, city)
        if request.GET.get("export") == "csv":
            rows = [
                ["Дата", "Локация", "Адрес", "Длительность (ч)", "Стоимость", "Режим биллинга", "Бизнес"]
            ]
            for b in qs:
                duration_h = round((b.end_at - b.start_at).total_seconds() / 3600, 2)
                rows.append(
                    [
                        b.start_at.strftime("%Y-%m-%d %H:%M"),
                        b.spot.lot.name,
                        b.spot.lot.address,
                        duration_h,
                        float(b.total_price),
                        b.billing_mode,
                        (b.ai_snapshot or {}).get("business_trip", False),
                    ]
                )
            content = "\n".join([",".join(map(lambda x: str(x), row)) for row in rows])
            resp = HttpResponse(content, content_type="text/csv")
            resp["Content-Disposition"] = 'attachment; filename="business_bookings.csv"'
            return resp
        total_duration = sum((b.end_at - b.start_at).total_seconds() / 3600 for b in qs)
        total_cost = sum(float(b.total_price) for b in qs)
        return self.render_to_response(
            {
                "bookings": qs,
                "total_count": len(qs),
                "total_duration": round(total_duration, 2),
                "total_cost": round(total_cost, 2),
                "filters": {"start": start_param, "end": end_param, "city": city},
            }
        )


class MetricsDashboardView(LoginRequiredMixin, TemplateView):
    """Внутренний дашборд для метрик/воронок (staff only)."""

    template_name = "admin/metrics.html"

    def dispatch(self, request, *args, **kwargs):
        if not request.user.is_staff:
            return redirect("admin:login")
        return super().dispatch(request, *args, **kwargs)

    def get_context_data(self, **kwargs: Any):
        ctx = super().get_context_data(**kwargs)
        ctx["total_bookings"] = Booking.objects.count()
        ctx["business_bookings"] = Booking.objects.filter(ai_snapshot__business_trip=True).count()
        ctx["ai_sessions"] = UiEvent.objects.filter(event_type="preferences").count()
        ctx["last7"] = compute_funnel(7)
        ctx["last30"] = compute_funnel(30)
        return ctx

class ParkingMapAPIView(APIView):
    """
    Лёгкий эндпоинт для карты:
    - фильтры по цене/фичам;
    - возвращает GeoJSON‑подобную структуру (features).
    """

    permission_classes = [AllowAny]
    throttle_classes = [UserRateThrottle, AnonRateThrottle]

    def get(self, request, *args, **kwargs):
        params = request.query_params
        only_free = params.get("only_free") == "true"
        has_ev = params.get("ev") == "true"
        covered = params.get("covered") == "true"
        is_24_7 = params.get("is_24_7") == "true"
        ai_only = params.get("ai_recommended") == "true"
        cache_key = f"parking_map:{only_free}:{has_ev}:{covered}:{is_24_7}:{ai_only}:{params.get('min_price')}:{params.get('max_price')}"
        cached = cache.get(cache_key)
        if cached:
            return Response(cached)

        try:
            min_price = float(params.get("min_price") or 0)
        except ValueError:
            min_price = 0.0
        try:
            max_price = float(params.get("max_price") or 0)
        except ValueError:
            max_price = 0.0

        qs = ParkingSpot.objects.filter(
            status=ParkingSpot.SpotStatus.ACTIVE,
            lot__is_active=True,
            lot__is_approved=True,
        ).select_related("lot")

        if has_ev:
            qs = qs.filter(has_ev_charging=True)
        if covered:
            qs = qs.filter(is_covered=True)
        if is_24_7:
            qs = qs.filter(is_24_7=True)
        if min_price:
            qs = qs.filter(hourly_price__gte=min_price)
        if max_price:
            qs = qs.filter(hourly_price__lte=max_price)
        if ai_only:
            qs = qs.filter(allow_dynamic_pricing=True)

        features = []
        for spot in qs[:500]:  # safety limit
            lat = getattr(spot.lot, "latitude", None)
            lng = getattr(spot.lot, "longitude", None)
            if lat is None or lng is None:
                continue

            availability_score = 1.0 - float(spot.occupancy_7d or 0.0)
            is_free_like = availability_score > 0.3

            if only_free and not is_free_like:
                continue

            features.append(
                {
                    "id": str(spot.id),
                    "type": "Feature",
                    "geometry": {
                        "type": "Point",
                        "coordinates": [lng, lat],
                    },
                    "properties": {
                        "spot_id": str(spot.id),
                        "lot_id": str(spot.lot_id),
                        "lot_name": spot.lot.name,
                        "city": spot.lot.city,
                        "address": spot.lot.address,
                        "name": spot.name,
                        "vehicle_type": spot.vehicle_type,
                        "has_ev_charging": spot.has_ev_charging,
                        "is_covered": spot.is_covered,
                        "is_24_7": spot.is_24_7,
                        "hourly_price": float(spot.hourly_price),
                        "nightly_price": float(spot.nightly_price or 0),
                        "daily_price": float(spot.daily_price or 0),
                        "monthly_price": float(spot.monthly_price or 0),
                        "status": spot.status,
                        "allow_dynamic_pricing": spot.allow_dynamic_pricing,
                        "occupancy_7d": float(spot.occupancy_7d or 0.0),
                        "stress_index": float(spot.lot.stress_index or 0.0),
                    },
                }
            )

        payload = {
            "type": "FeatureCollection",
            "features": features,
        }
        cache.set(cache_key, payload, 30)
        return Response(payload)


class GeocodeAPIView(APIView):
    """Простой прокси к Nominatim с кешированием."""

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        query = (request.query_params.get("q") or "").strip()
        if not query:
            return Response({"detail": "q is required"}, status=status.HTTP_400_BAD_REQUEST)

        cache_key = f"geocode:{query}"
        cached = cache.get(cache_key)
        if cached:
            return Response(cached)

        url = "https://nominatim.openstreetmap.org/search"
        try:
            resp = requests.get(
                url,
                params={"q": query, "format": "json", "limit": 5, "addressdetails": 1},
                headers={"User-Agent": "ParkShare-RU/1.0"},
                timeout=5,
            )
            resp.raise_for_status()
            data = resp.json()
        except Exception:
            return api_error("geocode_unavailable", "Геокодер временно недоступен", status.HTTP_503_SERVICE_UNAVAILABLE)
        results = [
            {
                "title": item.get("display_name"),
                "lat": float(item.get("lat")),
                "lng": float(item.get("lon")),
            }
            for item in data
        ]
        payload = {"results": results}
        cache.set(cache_key, payload, 60 * 10)
        return Response(payload)


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 216
PATH: parking\analytics\__init__.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from datetime import timedelta
from collections import defaultdict
from typing import Dict

from django.utils import timezone
from django.contrib.auth import get_user_model
from django.core.cache import cache

from ai.models import UiEvent, ChatSession
from parking.models import Booking
from django.conf import settings

User = get_user_model()


def variant_for_user(user) -> str:
    if not getattr(settings, "ENABLE_AB_VARIANTS", True):
        return "A"
    return "B" if (hash(str(user.id)) % 2) else "A"


def _daterange(days: int):
    end = timezone.now().date()
    start = end - timedelta(days=days)
    return start, end


def compute_funnel(days: int = 7) -> Dict:
    cache_key = f"analytics:funnel:{days}"
    cached = cache.get(cache_key)
    if cached:
        return cached

    start, end = _daterange(days)
    events = UiEvent.objects.filter(created_at__date__gte=start, created_at__date__lte=end)
    funnel = {"map_open": 0, "spot_select": 0, "booking_confirm_open": 0, "booking_created": 0, "repeat_visit": 0}
    assistant_sessions = 0
    variant_counts = {"A": defaultdict(int), "B": defaultdict(int)}

    for ev in events.select_related("device_profile__user"):
        etype = ev.event_type
        if etype in funnel:
            funnel[etype] += 1
            v = variant_for_user(ev.device_profile.user) if ev.device_profile and ev.device_profile.user else "A"
            variant_counts[v][etype] += 1

    bookings = Booking.objects.filter(start_at__date__gte=start, start_at__date__lte=end).select_related("user")
    funnel["booking_created"] = bookings.count()
    for b in bookings:
        v = variant_for_user(b.user)
        variant_counts[v]["booking_created"] += 1

    repeat_users = [u for u in set(bookings.values_list("user", flat=True)) if bookings.filter(user_id=u).count() > 1]
    funnel["repeat_visit"] = len(repeat_users)
    for uid in repeat_users:
        user = User.objects.filter(id=uid).first()
        v = variant_for_user(user) if user else "A"
        variant_counts[v]["repeat_visit"] += 1

    assistant_sessions = ChatSession.objects.filter(created_at__date__gte=start, created_at__date__lte=end).count()

    def pct(n, d):
        return 0 if d == 0 else round((n / d) * 100, 1)

    conversions = {
        "map_to_spot": pct(funnel["spot_select"], funnel["map_open"]),
        "spot_to_confirm": pct(funnel["booking_confirm_open"], funnel["spot_select"]),
        "confirm_to_booking": pct(funnel["booking_created"], funnel["booking_confirm_open"]),
    }

    payload = {
        "range": {"start": start, "end": end},
        "funnel": funnel,
        "conversions": conversions,
        "assistant_sessions": assistant_sessions,
        "variants": variant_counts,
    }
    cache.set(cache_key, payload, 300)
    return payload

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 217
PATH: parking\management\commands\seed_demo_parking.py
LANG: python
===== CONTENT START =====
# parking/management/commands/seed_demo_parking.py

from __future__ import annotations

from decimal import Decimal

from django.contrib.auth import get_user_model
from django.core.management.base import BaseCommand
from django.db import transaction

from parking.models import ParkingLot, ParkingSpot


class Command(BaseCommand):
    help = "Создаёт демо-объект парковки и несколько мест для локальной разработки."

    def handle(self, *args, **options):
        User = get_user_model()

        # ---------- 1. Владелец парковки ----------
        role_cls = getattr(User, "Role", None)
        owner_role_value = getattr(role_cls, "OWNER", None) if role_cls else None

        owner_defaults = {
            "email": "demo-owner@example.com",
            "is_active": True,
        }
        if owner_role_value is not None:
            owner_defaults["role"] = owner_role_value

        owner, created_owner = User.objects.get_or_create(
            username="demo_owner",
            defaults=owner_defaults,
        )

        if created_owner:
            owner.set_password("demo_owner")
            owner.save(update_fields=["password"])
            self.stdout.write(
                self.style.SUCCESS(
                    "Создан пользователь-владелец demo_owner / пароль: demo_owner"
                )
            )
        else:
            self.stdout.write(
                self.style.SUCCESS(f"Найден владелец demo_owner (id={owner.pk})")
            )

        # ---------- 2. Объект парковки ----------
        with transaction.atomic():
            lot, created_lot = ParkingLot.objects.get_or_create(
                name="Демо-парковка ParkShare",
                city="Москва",
                address="ул. Примерная, д. 1",
                defaults={
                    "owner": owner,
                    "parking_type": "yard",  # см. choices в миграции
                    "latitude": 55.751244,
                    "longitude": 37.618423,
                    "is_active": True,
                    "is_approved": True,
                    "is_private": False,
                },
            )

            if not created_lot:
                # На всякий случай привязываем к нашему демо-владельцу
                if lot.owner_id != owner.id:
                    lot.owner = owner
                    lot.save(update_fields=["owner"])
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Используем существующую парковку (id={lot.pk})"
                    )
                )
            else:
                self.stdout.write(
                    self.style.SUCCESS(
                        f"Создана демо-парковка (id={lot.pk}) в Москве"
                    )
                )

            # ---------- 3. Парковочные места ----------
            spots_spec = [
                {
                    "name": "Место 1 — EV 24/7",
                    "description": "Рядом с въездом, есть зарядка для EV.",
                    "is_covered": False,
                    "has_ev_charging": True,
                    "is_24_7": True,
                    "hourly_price": Decimal("120.00"),
                    "allow_dynamic_pricing": True,
                    "occupancy_7d": 0.65,
                },
                {
                    "name": "Место 2 — крытое",
                    "description": "Крытое место на -1 этаже.",
                    "is_covered": True,
                    "has_ev_charging": False,
                    "is_24_7": True,
                    "hourly_price": Decimal("90.00"),
                    "allow_dynamic_pricing": False,
                    "occupancy_7d": 0.40,
                },
                {
                    "name": "Место 3 — бюджетное",
                    "description": "Самое дешёвое, но чуть дальше от выезда.",
                    "is_covered": False,
                    "has_ev_charging": False,
                    "is_24_7": True,
                    "hourly_price": Decimal("70.00"),
                    "allow_dynamic_pricing": True,
                    "occupancy_7d": 0.80,
                },
                {
                    "name": "Место 4 — премиум",
                    "description": "Широкое место, удобно для кроссоверов.",
                    "is_covered": True,
                    "has_ev_charging": True,
                    "is_24_7": True,
                    "hourly_price": Decimal("150.00"),
                    "allow_dynamic_pricing": True,
                    "occupancy_7d": 0.55,
                },
            ]

            created_count = 0
            for spec in spots_spec:
                spot, created_spot = ParkingSpot.objects.get_or_create(
                    lot=lot,
                    name=spec["name"],
                    defaults=spec,
                )
                if created_spot:
                    created_count += 1

            total_spots = ParkingSpot.objects.filter(lot=lot).count()
            self.stdout.write(
                self.style.SUCCESS(
                    f"Готово: мест в демо-парковке сейчас {total_spots} "
                    f"(создано за этот запуск {created_count})."
                )
            )

        self.stdout.write(self.style.SUCCESS("seed_demo_parking: демо-данные готовы."))

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 218
PATH: parking\management\commands\send_expiry_notifications.py
LANG: python
===== CONTENT START =====
from django.core.management.base import BaseCommand
from parking.notifications import send_booking_expiry_notifications


class Command(BaseCommand):
    help = "Send booking expiry push notifications to opted-in users."

    def add_arguments(self, parser):
        parser.add_argument("--minutes", type=int, default=30, help="Notify before N minutes to end")

    def handle(self, *args, **options):
        minutes = options["minutes"]
        sent = send_booking_expiry_notifications(minutes)
        self.stdout.write(self.style.SUCCESS(f"Sent {sent} notifications (trigger: {minutes}m before end)"))

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 219
PATH: parking\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
import parking.models
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('vehicles', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Booking',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('booking_type', models.CharField(choices=[('hourly', 'Почасовая'), ('daily', 'Суточная'), ('night', 'Ночная'), ('weekly', 'Недельная'), ('monthly', 'Месячная')], default='hourly', max_length=16, verbose_name='Тип бронирования')),
                ('start_at', models.DateTimeField(verbose_name='Начало брони')),
                ('end_at', models.DateTimeField(verbose_name='Окончание брони')),
                ('status', models.CharField(choices=[('pending', 'Ожидает оплаты'), ('confirmed', 'Подтверждена'), ('active', 'Активна'), ('completed', 'Завершена'), ('cancelled', 'Отменена'), ('expired', 'Истекла')], default='pending', max_length=16, verbose_name='Статус')),
                ('total_price', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Итоговая стоимость, ₽')),
                ('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
                ('is_paid', models.BooleanField(default=False, verbose_name='Оплачено')),
                ('external_payment_id', models.CharField(blank=True, help_text='Связка с платежом у провайдера (например, YooKassa payment_id).', max_length=64, verbose_name='ID платежа провайдера')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
                ('vehicle', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='bookings', to='vehicles.vehicle', verbose_name='Транспорт')),
            ],
            options={
                'verbose_name': 'Бронирование',
                'verbose_name_plural': 'Бронирования',
                'ordering': ('-start_at',),
            },
        ),
        migrations.CreateModel(
            name='ParkingLot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=255, verbose_name='Название')),
                ('city', models.CharField(max_length=100, verbose_name='Город')),
                ('address', models.CharField(max_length=255, verbose_name='Адрес')),
                ('parking_type', models.CharField(choices=[('yard', 'Дворовая парковка'), ('underground', 'Подземная парковка'), ('multilevel', 'Многоуровневая парковка'), ('street', 'Уличная парковка'), ('office', 'Офисная парковка'), ('home', 'Домашнее место')], default='yard', max_length=32, verbose_name='Тип парковки')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('location', parking.models.PointField(blank=True, null=True, verbose_name='Точка на карте')),
                ('latitude', models.FloatField(blank=True, null=True, verbose_name='Широта')),
                ('longitude', models.FloatField(blank=True, null=True, verbose_name='Долгота')),
                ('is_active', models.BooleanField(default=True, verbose_name='Активен')),
                ('is_approved', models.BooleanField(default=False, help_text='Одобряется администратором перед публикацией.', verbose_name='Одобрен модерацией')),
                ('is_private', models.BooleanField(default=False, help_text='Если включено, объект виден только по прямым ссылкам/владельцу.', verbose_name='Приватный')),
                ('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='parking_lots', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
            ],
            options={
                'verbose_name': 'Объект парковки',
                'verbose_name_plural': 'Объекты парковки',
                'ordering': ('name',),
            },
        ),
        migrations.CreateModel(
            name='ParkingSpot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('name', models.CharField(max_length=64, verbose_name='Название/номер места')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
                ('is_covered', models.BooleanField(default=False, verbose_name='Крытое место')),
                ('has_ev_charging', models.BooleanField(default=False, verbose_name='Есть зарядка')),
                ('is_24_7', models.BooleanField(default=True, verbose_name='Круглосуточно')),
                ('max_height_m', models.DecimalField(blank=True, decimal_places=2, max_digits=4, null=True, verbose_name='Максимальная высота (м)')),
                ('hourly_price', models.DecimalField(decimal_places=2, max_digits=8, verbose_name='Цена за час, ₽')),
                ('nightly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за ночь, ₽')),
                ('daily_price', models.DecimalField(blank=True, decimal_places=2, max_digits=8, null=True, verbose_name='Цена за сутки, ₽')),
                ('monthly_price', models.DecimalField(blank=True, decimal_places=2, max_digits=9, null=True, verbose_name='Цена за месяц, ₽')),
                ('allow_dynamic_pricing', models.BooleanField(default=False, help_text='Если включено, тариф может корректироваться рекомендациями AI.', verbose_name='Динамическая цена (AI)')),
                ('status', models.CharField(choices=[('active', 'Активно'), ('inactive', 'Неактивно')], default='active', max_length=16, verbose_name='Статус')),
                ('lot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='spots', to='parking.parkinglot', verbose_name='Объект парковки')),
            ],
            options={
                'verbose_name': 'Парковочное место',
                'verbose_name_plural': 'Парковочные места',
                'ordering': ('lot__name', 'name'),
            },
        ),
        migrations.CreateModel(
            name='Complaint',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('category', models.CharField(choices=[('foreign_car', 'Чужая машина на месте'), ('no_show', 'Пользователь не приехал'), ('no_free_spot', 'Не нашёл свободного места'), ('other', 'Другое')], default='other', max_length=32, verbose_name='Категория')),
                ('description', models.TextField(blank=True, verbose_name='Описание')),
                ('status', models.CharField(choices=[('new', 'Новая'), ('in_progress', 'В работе'), ('resolved', 'Решена'), ('rejected', 'Отклонена')], default='new', max_length=16, verbose_name='Статус')),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='complaints', to=settings.AUTH_USER_MODEL, verbose_name='Автор')),
                ('booking', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.booking', verbose_name='Бронирование')),
                ('spot', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='complaints', to='parking.parkingspot', verbose_name='Парковочное место')),
            ],
            options={
                'verbose_name': 'Жалоба',
                'verbose_name_plural': 'Жалобы',
                'ordering': ('-created_at',),
            },
        ),
        migrations.AddField(
            model_name='booking',
            name='spot',
            field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='bookings', to='parking.parkingspot', verbose_name='Парковочное место'),
        ),
        migrations.CreateModel(
            name='WaitlistEntry',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('desired_start', models.DateTimeField(verbose_name='Желаемое начало')),
                ('desired_end', models.DateTimeField(verbose_name='Желаемое окончание')),
                ('auto_book', models.BooleanField(default=False, help_text='Если включено, при освобождении места будет создана бронь автоматически.', verbose_name='Авто‑бронирование')),
                ('status', models.CharField(choices=[('waiting', 'Ожидает'), ('notified', 'Уведомлён'), ('booked', 'Авто‑бронирование создано'), ('cancelled', 'Отменено')], default='waiting', max_length=16, verbose_name='Статус')),
                ('spot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to='parking.parkingspot', verbose_name='Парковочное место')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='waitlist_entries', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
            ],
            options={
                'verbose_name': 'Запись в листе ожидания',
                'verbose_name_plural': 'Лист ожидания',
                'ordering': ('-created_at',),
                'unique_together': {('user', 'spot', 'desired_start', 'desired_end')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 220
PATH: parking\migrations\0002_parkinglot_stress_index_parkingspot_occupancy_7d.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-22 11:21

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('parking', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='parkinglot',
            name='stress_index',
            field=models.FloatField(default=0.0, help_text='Средняя загруженность мест за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Индекс загруженности (0..1)'),
        ),
        migrations.AddField(
            model_name='parkingspot',
            name='occupancy_7d',
            field=models.FloatField(default=0.0, help_text='Доля времени, когда место было занято за последние 7 дней. Обновляется фоновыми задачами AI.', verbose_name='Загруженность за 7 дней (0..1)'),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 221
PATH: parking\migrations\0003_booking_ai_fields.py
LANG: python
===== CONTENT START =====
from django.db import migrations, models


class Migration(migrations.Migration):
    dependencies = [
        ("parking", "0002_parkinglot_stress_index_parkingspot_occupancy_7d"),
    ]

    operations = [
        migrations.AddField(
            model_name="booking",
            name="ai_snapshot",
            field=models.JSONField(blank=True, help_text="Данные решений AI (цены, доступность, риски)", null=True, verbose_name="AI snapshot"),
        ),
        migrations.AddField(
            model_name="booking",
            name="dynamic_pricing_applied",
            field=models.BooleanField(default=False, verbose_name="Динамическое ценообразование"),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 222
PATH: parking\migrations\0004_favoriteparkingspot_savedplace.py
LANG: python
===== CONTENT START =====
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ('parking', '0003_booking_ai_fields'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='FavoriteParkingSpot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('note', models.CharField(blank=True, max_length=120, verbose_name='Заметка')),
                ('spot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='favorites', to='parking.parkingspot')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='favorite_spots', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Избранное место',
                'verbose_name_plural': 'Избранные места',
                'ordering': ('-created_at',),
                'unique_together': {('user', 'spot')},
            },
        ),
        migrations.CreateModel(
            name='SavedPlace',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('title', models.CharField(max_length=64, verbose_name='Название')),
                ('place_type', models.CharField(choices=[('home', 'Дом'), ('work', 'Офис'), ('custom', 'Другое')], default='custom', max_length=16, verbose_name='Тип точки')),
                ('latitude', models.FloatField(verbose_name='Широта')),
                ('longitude', models.FloatField(verbose_name='Долгота')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='saved_places', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Сохранённая точка',
                'verbose_name_plural': 'Сохранённые точки',
                'ordering': ('title',),
                'unique_together': {('user', 'title')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 223
PATH: parking\migrations\0005_pushsubscription.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-12-06 10:47

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("parking", "0004_favoriteparkingspot_savedplace"),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name="PushSubscription",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "created_at",
                    models.DateTimeField(
                        auto_now_add=True, verbose_name="Дата создания"
                    ),
                ),
                (
                    "updated_at",
                    models.DateTimeField(auto_now=True, verbose_name="Дата обновления"),
                ),
                ("endpoint", models.URLField(unique=True)),
                ("p256dh", models.CharField(max_length=255)),
                ("auth", models.CharField(max_length=255)),
                ("platform", models.CharField(blank=True, max_length=64)),
                ("user_agent", models.CharField(blank=True, max_length=255)),
                (
                    "user",
                    models.ForeignKey(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="push_subscriptions",
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
            ],
            options={
                "verbose_name": "Push-подписка",
                "verbose_name_plural": "Push-подписки",
                "ordering": ("-created_at",),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 224
PATH: parking\migrations\0006_booking_billing_mode.py
LANG: python
===== CONTENT START =====
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("parking", "0005_pushsubscription"),
    ]

    operations = [
        migrations.AddField(
            model_name="booking",
            name="billing_mode",
            field=models.CharField(
                choices=[
                    ("pay_as_you_go", "Поминутно/почасово"),
                    ("prepaid_block", "Предоплата блоком"),
                    ("wallet", "Оплата кошельком"),
                ],
                default="pay_as_you_go",
                max_length=32,
                verbose_name="Режим биллинга",
            ),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 225
PATH: parking\migrations\0007_notificationsettings.py
LANG: python
===== CONTENT START =====
from django.db import migrations, models
import django.db.models.deletion
from django.conf import settings


class Migration(migrations.Migration):

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
        ("parking", "0006_booking_billing_mode"),
    ]

    operations = [
        migrations.CreateModel(
            name="NotificationSettings",
            fields=[
                ("id", models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("notify_booking_expiry", models.BooleanField(default=True, verbose_name="Напоминать о завершении брони")),
                ("notify_night_restrictions", models.BooleanField(default=False, verbose_name="Напоминать о ночных ограничениях")),
                ("user", models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name="notification_settings", to=settings.AUTH_USER_MODEL)),
            ],
            options={
                "verbose_name": "Настройки уведомлений",
                "verbose_name_plural": "Настройки уведомлений",
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 226
PATH: parking\migrations\0008_indexes.py
LANG: python
===== CONTENT START =====
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("parking", "0007_notificationsettings"),
    ]

    operations = [
        migrations.AddIndex(
            model_name="parkinglot",
            index=models.Index(fields=["city"], name="parkinglot_city_idx"),
        ),
        migrations.AddIndex(
            model_name="parkingspot",
            index=models.Index(fields=["status", "has_ev_charging", "is_covered"], name="spot_status_ev_cov_idx"),
        ),
        migrations.AddIndex(
            model_name="booking",
            index=models.Index(fields=["start_at", "end_at"], name="booking_time_idx"),
        ),
        migrations.AddIndex(
            model_name="booking",
            index=models.Index(fields=["billing_mode"], name="booking_billing_mode_idx"),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 227
PATH: parking\migrations\0009_remove_booking_booking_time_idx_and_more.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-12-07 13:45

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('parking', '0008_indexes'),
    ]

    operations = [
        migrations.RemoveIndex(
            model_name='booking',
            name='booking_time_idx',
        ),
        migrations.RemoveIndex(
            model_name='booking',
            name='booking_billing_mode_idx',
        ),
        migrations.RemoveIndex(
            model_name='parkinglot',
            name='parkinglot_city_idx',
        ),
        migrations.RemoveIndex(
            model_name='parkingspot',
            name='spot_status_ev_cov_idx',
        ),
        migrations.AlterField(
            model_name='notificationsettings',
            name='id',
            field=models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID'),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 228
PATH: parking\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 229
PATH: parking\notifications\__init__.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import logging
from datetime import timedelta
from typing import Iterable, List

from django.conf import settings
from django.utils import timezone

from parking.models import Booking, PushSubscription
from parking.models_notification import NotificationSettings

logger = logging.getLogger(__name__)


def bookings_expiring_within(minutes: int = 30) -> List[Booking]:
    """Вернуть брони, заканчивающиеся в ближайшие X минут и требующие напоминания."""
    now = timezone.now()
    soon = now + timedelta(minutes=minutes)
    qs = (
        Booking.objects.filter(
            end_at__gte=now,
            end_at__lte=soon,
            status__in=[Booking.Status.CONFIRMED, Booking.Status.ACTIVE],
        )
        .select_related("user", "spot", "spot__lot")
    )
    eligible: list[Booking] = []
    for booking in qs:
        settings_obj = getattr(booking.user, "notification_settings", None)
        if settings_obj and not settings_obj.notify_booking_expiry:
            continue
        eligible.append(booking)
    return eligible


def target_subscriptions_for_user(user) -> Iterable[PushSubscription]:
    """Вернуть push-подписки пользователя для отправки уведомлений."""
    return PushSubscription.objects.filter(user=user)


def send_push(subscription: PushSubscription, title: str, body: str, data: dict | None = None) -> bool:
    """
    Отправка WebPush (stub-friendly). Реальная интеграция может использовать pywebpush или внешний сервис.
    """
    payload = {"title": title, "body": body, "data": data or {}}
    logger.info("Sending push", extra={"endpoint": subscription.endpoint, "payload": payload})
    return True


def send_booking_expiry_notifications(minutes: int = 30) -> int:
    """Обходит активные брони и отправляет напоминания за minutes до окончания."""
    count = 0
    for booking in bookings_expiring_within(minutes):
        subs = target_subscriptions_for_user(booking.user)
        for sub in subs:
            send_push(
                sub,
                title="Бронь скоро заканчивается",
                body=f"Парковка {booking.spot.lot.name} завершится в {booking.end_at.strftime('%H:%M')}",
                data={"booking_id": str(booking.id)},
            )
            count += 1
    return count


def night_restriction_stub() -> None:
    """Заглушка под ночные ограничения, сохраняет архитектурную точку входа."""
    if getattr(settings, "ENABLE_NIGHT_RESTRICTION_NOTICES", False):
        logger.info("Night restriction notifications not implemented; stub path invoked.")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 230
PATH: parking\tests\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 231
PATH: parking\tests\test_mobile_api.py
LANG: python
===== CONTENT START =====
from rest_framework.test import APITestCase

from accounts.models import User
from parking.models import ParkingLot, ParkingSpot


class MobileAPITest(APITestCase):
    def setUp(self):
        self.user = User.objects.create_user(username="mobile_user", password="secret123")
        lot = ParkingLot.objects.create(
            owner=self.user,
            name="Mobile Lot",
            city="Москва",
            address="Проверочная 1",
            latitude=55.75,
            longitude=37.61,
        )
        ParkingSpot.objects.create(
            lot=lot,
            name="M1",
            vehicle_type=ParkingSpot.VehicleType.CAR,
            hourly_price=150,
            status=ParkingSpot.SpotStatus.ACTIVE,
        )

    def test_search_geojson_cached_for_anonymous(self):
        url = "/api/v1/search/?format=geojson&city=Москва"
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertIn("features", response.data)
        cached = self.client.get(url)
        self.assertEqual(cached.data, response.data)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 232
PATH: parking\tests\test_pwa_endpoints.py
LANG: python
===== CONTENT START =====
import os

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.backend.settings.local")

import django
from django.conf import settings
from django.contrib.auth import get_user_model
from django.test import TestCase
from django.urls import reverse
from rest_framework.test import APIClient


class PushSubscriptionAPITest(TestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        django.setup()
        settings.ALLOWED_HOSTS.append("testserver")

    def setUp(self):
        self.client = APIClient()

    def test_requires_payload(self):
        url = reverse('push-subscription-list')
        resp = self.client.post(url, {}, format='json')
        self.assertEqual(resp.status_code, 403)

    def test_authenticated_create(self):
        User = get_user_model()
        user = User.objects.create_user(username='pwa-user', password='pw')
        self.client.force_authenticate(user)
        url = reverse('push-subscription-list')
        payload = {
            'endpoint': 'https://example.com/sub',
            'p256dh': 'key',
            'auth': 'auth',
        }
        resp = self.client.post(url, payload, format='json')
        self.assertEqual(resp.status_code, 201)
        self.assertEqual(resp.data['endpoint'], payload['endpoint'])

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 233
PATH: payments\__init__.py
LANG: python
===== CONTENT START =====
default_app_config = "payments.apps.PaymentsConfig"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 234
PATH: payments\admin.py
LANG: python
===== CONTENT START =====
from django.contrib import admin

from .models import Payment


@admin.register(Payment)
class PaymentAdmin(admin.ModelAdmin):
    list_display = (
        "id",
        "booking",
        "payer",
        "provider",
        "provider_payment_id",
        "amount",
        "currency",
        "status",
        "success",
        "failure",
        "created_at",
    )
    list_filter = (
        "provider",
        "status",
        "success",
        "failure",
        "created_at",
    )
    search_fields = ("provider_payment_id", "booking__id", "payer__username")
    autocomplete_fields = ("booking", "payer")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 235
PATH: payments\apps.py
LANG: python
===== CONTENT START =====
from django.apps import AppConfig


class PaymentsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "payments"
    verbose_name = "Платежи"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 236
PATH: payments\models.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from decimal import Decimal
from typing import Any, Optional

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


class Payment(TimeStampedModel):
    """
    Платёж за бронирование через внешнего провайдера (по умолчанию — YooKassa).

    Для простоты в текущей реализации у каждой брони может быть не более
    одного связанного платежа (OneToOne), который используется повторно
    при повторных попытках оплаты, пока не станет успешным или не будет
    отменён/завершён с ошибкой.
    """

    class Provider(models.TextChoices):
        YOOKASSA = "yookassa", "YooKassa"
        STRIPE = "stripe", "Stripe"

    class Status(models.TextChoices):
        CREATED = "created", _("Создан")
        PENDING = "pending", _("Ожидает оплаты")
        SUCCEEDED = "succeeded", _("Успешен")
        CANCELLED = "cancelled", _("Отменён")
        FAILED = "failed", _("Ошибка")

    booking = models.OneToOneField(
        "parking.Booking",
        on_delete=models.CASCADE,
        related_name="payment",
        verbose_name=_("Бронь"),
    )
    payer = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="payments",
        verbose_name=_("Плательщик"),
    )

    provider = models.CharField(
        _("Провайдер"),
        max_length=32,
        choices=Provider.choices,
        default=Provider.YOOKASSA,
    )
    provider_payment_id = models.CharField(
        _("ID платежа у провайдера"),
        max_length=128,
        blank=True,
        db_index=True,
    )

    amount = models.DecimalField(
        _("Сумма"),
        max_digits=10,
        decimal_places=2,
    )
    currency = models.CharField(
        _("Валюта"),
        max_length=8,
        default="RUB",
    )

    status = models.CharField(
        _("Статус"),
        max_length=16,
        choices=Status.choices,
        default=Status.CREATED,
        db_index=True,
    )
    success = models.BooleanField(_("Успешен"), default=False)
    failure = models.BooleanField(_("Ошибка"), default=False)

    raw_response = models.JSONField(
        _("Ответ провайдера"),
        null=True,
        blank=True,
        help_text=_("Сырые данные, вернувшиеся при создании платежа."),
    )
    raw_webhook = models.JSONField(
        _("Последний webhook"),
        null=True,
        blank=True,
        help_text=_("Последнее уведомление провайдера по этому платежу."),
    )

    class Meta:
        verbose_name = _("Платёж")
        verbose_name_plural = _("Платежи")
        ordering = ("-created_at",)

    def __str__(self) -> str:
        return f"Payment #{self.pk} for booking #{self.booking_id}"

    @property
    def is_active(self) -> bool:
        """
        "Активный" платёж — тот, который ещё может сменить состояние на успешное.
        """
        return self.status in {self.Status.CREATED, self.Status.PENDING}

    def _update_status(
        self,
        status: str,
        success: bool,
        failure: bool,
        webhook_data: Optional[dict[str, Any]] = None,
    ) -> None:
        self.status = status
        self.success = success
        self.failure = failure
        if webhook_data is not None:
            self.raw_webhook = webhook_data
        self.save(
            update_fields=[
                "status",
                "success",
                "failure",
                "raw_webhook",
                "updated_at",
            ]
        )

    def mark_succeeded(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как успешный и вызывает booking.mark_paid(...).

        Вызывается из обработчика вебхуков YooKassa после подтверждения
        успешного платежа.
        """
        self._update_status(
            status=self.Status.SUCCEEDED,
            success=True,
            failure=False,
            webhook_data=webhook_data,
        )

        # Обновляем связанную бронь.
        booking = self.booking
        if booking:
            booking.mark_paid(payment_id=self.provider_payment_id or "")

    def mark_failed(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как неуспешный (ошибка).
        """
        self._update_status(
            status=self.Status.FAILED,
            success=False,
            failure=True,
            webhook_data=webhook_data,
        )

    def mark_cancelled(self, webhook_data: Optional[dict[str, Any]] = None) -> None:
        """
        Помечает платёж как отменённый пользователем или провайдером.
        """
        self._update_status(
            status=self.Status.CANCELLED,
            success=False,
            failure=True,
            webhook_data=webhook_data,
        )


class PaymentMethod(TimeStampedModel):
    """
    Привязанный способ оплаты (карта/кошелёк), без хранения PAN.

    Данные карты хранятся в токенизированном виде у провайдера эквайринга,
    здесь остаётся только маска и метаданные для UI. Настоящий токен
    хранится в encrypted поле token_masked, чтобы можно было инициировать
    повторные списания в будущем.
    """

    class Brand(models.TextChoices):
        VISA = "visa", "VISA"
        MASTERCARD = "mc", "Mastercard"
        MIR = "mir", "Мир"
        UNIONPAY = "up", "UnionPay"
        OTHER = "other", "Другая"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="payment_methods",
        verbose_name=_("Пользователь"),
    )
    label = models.CharField(
        _("Название"),
        max_length=64,
        blank=True,
        help_text=_("Например: 'Личная', 'Для работы', 'Юрлицо'."),
    )
    brand = models.CharField(
        _("Бренд"),
        max_length=16,
        choices=Brand.choices,
        default=Brand.OTHER,
    )
    last4 = models.CharField(_("Последние 4 цифры"), max_length=4)
    exp_month = models.PositiveSmallIntegerField(_("Месяц окончания"))
    exp_year = models.PositiveSmallIntegerField(_("Год окончания"))
    is_default = models.BooleanField(_("По умолчанию"), default=False)
    token_masked = models.CharField(
        _("Токен/маска"),
        max_length=255,
        help_text=_("Служебный идентификатор платёжного провайдера."),
    )

    class Meta:
        verbose_name = _("Способ оплаты")
        verbose_name_plural = _("Способы оплаты")
        ordering = ("-is_default", "-created_at")
        unique_together = ("user", "token_masked")

    def __str__(self) -> str:
        return f"{self.get_brand_display()} ****{self.last4}"

    def save(self, *args, **kwargs):
        if self.is_default:
            PaymentMethod.objects.filter(user=self.user, is_default=True).exclude(
                pk=self.pk
            ).update(is_default=False)
        return super().save(*args, **kwargs)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 237
PATH: payments\providers.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import uuid
from decimal import Decimal
from typing import Any, Tuple

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

try:
    # Официальный синхронный SDK YooKassa
    from yookassa import Configuration, Payment as YooPayment  # type: ignore[import]
except ImportError:  # pragma: no cover - мягкий фолбэк
    Configuration = None
    YooPayment = None


class YooKassaError(Exception):
    """Базовая ошибка при работе с YooKassa."""


def _configure_yookassa() -> None:
    """
    Настраивает SDK YooKassa из Django settings.

    Требуются:
    - YOOKASSA_SHOP_ID
    - YOOKASSA_SECRET_KEY
    """
    if Configuration is None or YooPayment is None:
        raise ImproperlyConfigured(
            "Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
        )

    shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
    secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
    if not shop_id or not secret_key:
        raise ImproperlyConfigured(
            "Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
        )

    Configuration.account_id = shop_id
    Configuration.secret_key = secret_key


def create_yookassa_payment(booking) -> Tuple[str, str, dict[str, Any]]:
    """
    Создаёт платёж в YooKassa для указанной брони.

    Возвращает:
        (payment_url, provider_payment_id, raw_response_dict)

    Все сетевые вызовы инкапсулированы здесь.
    """
    _configure_yookassa()

    from parking.models import Booking  # локальный импорт, чтобы избежать циклов

    if not isinstance(booking, Booking):
        raise YooKassaError("create_yookassa_payment ожидает экземпляр Booking.")

    amount = booking.total_price
    if not isinstance(amount, Decimal):
        amount = Decimal(str(amount))

    amount_str = str(amount.quantize(Decimal("0.01")))
    currency = booking.currency or "RUB"
    return_url = getattr(settings, "YOOKASSA_RETURN_URL", "")

    description = f"Оплата брони #{booking.id} — {booking.spot}"

    payload: dict[str, Any] = {
        "amount": {
            "value": amount_str,
            "currency": currency,
        },
        "confirmation": {
            "type": "redirect",
            "return_url": return_url,
        },
        "capture": True,
        "description": description,
        "metadata": {
            "booking_id": str(booking.id),
            "user_id": str(booking.user_id),
        },
    }

    try:
        payment = YooPayment.create(payload, uuid.uuid4())
    except Exception as exc:  # noqa: BLE001
        raise YooKassaError(str(exc)) from exc

    confirmation = getattr(payment, "confirmation", None)
    payment_url = getattr(confirmation, "confirmation_url", None) if confirmation else None
    provider_payment_id = getattr(payment, "id", None)

    if not payment_url or not provider_payment_id:
        raise YooKassaError(
            "Некорректный ответ от YooKassa: не получены id или URL оплаты."
        )

    raw_response = {
        "id": provider_payment_id,
        "status": getattr(payment, "status", None),
    }

    return payment_url, provider_payment_id, raw_response

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 238
PATH: payments\serializers.py
LANG: python
===== CONTENT START =====
# payments/serializers.py

from __future__ import annotations

from typing import Any, Dict

from django.conf import settings
from django.urls import reverse
from rest_framework import serializers

from parking.models import Booking
from .models import Payment, PaymentMethod
from .providers import get_payment_provider


class PaymentSerializer(serializers.ModelSerializer):
    """
    Создание платежа для бронирования.

    Поток:
      - клиент вызывает POST /api/payments/ с booking_id;
      - сериализатор поднимает Booking, вызывает AI-ценообразование (если нужно – уже
        сделано при создании брони), берёт итоговую сумму;
      - выбирает провайдера по REGION/PLATFORM (YooKassa для RU, Stripe для GLOBAL);
      - создаёт payment в БД и у провайдера;
      - возвращает клиенту payment_url, по которому можно уйти на оплату.

    Важно: бизнес-логика расчёта цены (включая AI) находится в booking/ai,
    здесь только оркестрация и адаптеры к платёжным провайдерам.
    """

    booking_id = serializers.UUIDField(write_only=True)
    payment_url = serializers.SerializerMethodField(read_only=True)

    class Meta:
        model = Payment
        fields = (
            "id",
            "booking_id",
            "amount",
            "currency",
            "status",
            "provider",
            "provider_payment_id",
            "created_at",
            "updated_at",
            "payment_url",
        )
        read_only_fields = (
            "id",
            "amount",
            "currency",
            "status",
            "provider",
            "provider_payment_id",
            "created_at",
            "updated_at",
            "payment_url",
        )

    def validate_booking_id(self, value):
        try:
            booking = Booking.objects.select_related("spot", "spot__lot").get(pk=value)
        except Booking.DoesNotExist:
            raise serializers.ValidationError("Бронирование не найдено.")
        if booking.status not in (
            Booking.Status.PENDING,
            Booking.Status.CONFIRMED,
        ):
            raise serializers.ValidationError(
                "Платёж можно создать только для ожидающего/подтверждённого бронирования."
            )
        return value

    def _get_booking(self, booking_id) -> Booking:
        return Booking.objects.select_related("spot", "spot__lot").get(pk=booking_id)

    def create(self, validated_data: Dict[str, Any]) -> Payment:
        request = self.context.get("request")
        booking_id = validated_data["booking_id"]
        booking = self._get_booking(booking_id)

        # Сумма для оплаты – итоговая цена брони (уже с AI-ценообразованием, если применено)
        amount = booking.total_price
        currency = getattr(settings, "DEFAULT_CURRENCY", "RUB")

        # Выбор провайдера:
        #   - для RU профиль по умолчанию будет YooKassa (см. .env/.env.prod);
        #   - для GLOBAL можно выставить stripe в PAYMENT_PROVIDER/DEFAULT_PAYMENT_PROVIDER.
        provider = get_payment_provider()

        payment = Payment.objects.create(
            booking=booking,
            amount=amount,
            currency=currency,
            provider=provider.code,
            status=Payment.Status.CREATED,
        )

        # URL возврата пользователя после оплаты
        if request is not None:
            return_url = request.build_absolute_uri(
                reverse("payments:return")  # см. urls в payments/views
            )
            webhook_url = request.build_absolute_uri(
                reverse("payments:webhook", kwargs={"provider": provider.code})
            )
        else:
            # fallback для внутренних вызовов/тестов
            return_url = getattr(settings, "YOOKASSA_RETURN_URL", "/")
            webhook_url = ""

        # Вызов провайдера (адаптер)
        provider_response = provider.create_payment(
            payment=payment,
            return_url=return_url,
            webhook_url=webhook_url,
        )

        # Ожидаем, что адаптер вернёт структуру с provider_payment_id и
        # опциональным полем payment_url/confirmation_url.
        payment.provider_payment_id = provider_response.get("id") or provider_response.get(
            "provider_payment_id", ""
        )
        payment.raw_response = provider_response
        payment.save(update_fields=["provider_payment_id", "raw_response"])

        return payment

    def get_payment_url(self, obj: Payment) -> str | None:
        """
        Вытаскиваем URL для редиректа пользователя из raw_response.
        Для YooKassa это обычно confirmation.redirect_url,
        для Stripe – session.url и т.п.
        """
        data = obj.raw_response or {}
        # Общий подход: пытаемся найти наиболее очевидные поля
        return (
            data.get("payment_url")
            or data.get("confirmation_url")
            or (data.get("confirmation") or {}).get("confirmation_url")
            or (data.get("session") or {}).get("url")
        )


class PaymentMethodSerializer(serializers.ModelSerializer):
    """Сериализатор для сохранённых карт/кошельков."""

    mask = serializers.SerializerMethodField(read_only=True)

    class Meta:
        model = PaymentMethod
        fields = (
            "id",
            "label",
            "brand",
            "last4",
            "exp_month",
            "exp_year",
            "is_default",
            "token_masked",
            "mask",
            "created_at",
        )
        read_only_fields = ("id", "mask", "created_at")

    def get_mask(self, obj: PaymentMethod) -> str:
        return f"**** **** **** {obj.last4}"

    def create(self, validated_data):
        request = self.context.get("request")
        if request and request.user.is_authenticated:
            validated_data["user"] = request.user
        return super().create(validated_data)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 239
PATH: payments\tasks.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from celery import shared_task

from .models import Payment


@shared_task
def check_stale_payments() -> str:
    """
    Заготовка фоновой задачи для проверки "зависших" платежей.

    В будущей версии здесь можно реализовать:
    - поиск платежей в статусе PENDING слишком долго;
    - запрос их фактического состояния у YooKassa;
    - перевод в FAILED/CANCELLED при необходимости.
    """
    pending_count = Payment.objects.filter(status=Payment.Status.PENDING).count()
    return f"Pending payments count: {pending_count}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 240
PATH: payments\views.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from django.conf import settings
from rest_framework import mixins, permissions, status, viewsets
from rest_framework.response import Response
from rest_framework.views import APIView

from core.metrics import record_payment_event
from .models import Payment, PaymentMethod
from .serializers import PaymentMethodSerializer, PaymentSerializer
from .providers.registry import get_payment_provider


class PaymentViewSet(
    mixins.CreateModelMixin,
    mixins.ListModelMixin,
    mixins.RetrieveModelMixin,
    viewsets.GenericViewSet,
):
    """
    API платежей:

    - GET  /api/payments/       — список платежей текущего пользователя;
    - POST /api/payments/       — начать оплату для брони;
    - GET  /api/payments/{id}/  — детали платежа.

    Только владелец платежа видит свои платежи; админ — все.
    """

    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        qs = Payment.objects.select_related(
            "booking",
            "booking__spot",
            "booking__spot__lot",
            "payer",
        )
        if not user.is_authenticated:
            return Payment.objects.none()
        if user.is_superuser:
            return qs
        return qs.filter(payer=user)

    def perform_create(self, serializer: PaymentSerializer) -> None:
        payment = serializer.save()
        try:
            record_payment_event(getattr(payment, "provider", None), "created")
        except Exception:
            pass


class PaymentMethodViewSet(
    mixins.CreateModelMixin,
    mixins.ListModelMixin,
    mixins.UpdateModelMixin,
    mixins.DestroyModelMixin,
    viewsets.GenericViewSet,
):
    """
    Мини-API для управления сохранёнными картами в ЛК.

    POST /api/payment-methods/ — добавить карту (пока без реального токенизации);
    GET  /api/payment-methods/ — список карт пользователя;
    DELETE /api/payment-methods/{id}/ — удалить карту.
    """

    serializer_class = PaymentMethodSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return PaymentMethod.objects.none()
        if user.is_superuser:
            return PaymentMethod.objects.select_related("user").order_by("-is_default", "-created_at")
        return PaymentMethod.objects.filter(user=user).order_by("-is_default", "-created_at")

    def perform_create(self, serializer: PaymentMethodSerializer) -> None:
        serializer.save(user=self.request.user)

    def perform_update(self, serializer: PaymentMethodSerializer) -> None:
        serializer.save(user=self.request.user)


class YooKassaWebhookView(APIView):
    """
    Обработчик webhook‑уведомлений YooKassa.

    URL: /payments/webhook/yookassa/  (см. backend.config.urls)

    Ожидается JSON вида:

    {
        "event": "payment.succeeded",
        "object": {
            "id": "...",
            "status": "succeeded",
            ...
        }
    }

    Подпись/секрет проверяется по заголовку X-Yookassa-Signature
    (или X-Yookassa-Webhook-Secret), который совпадает с
    settings.YOOKASSA_WEBHOOK_SECRET. Если секрет не задан, проверка
    подписи пропускается.
    """

    authentication_classes: list = []
    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        secret_expected = getattr(settings, "YOOKASSA_WEBHOOK_SECRET", "")
        if secret_expected:
            signature = (
                request.headers.get("X-Yookassa-Signature")
                or request.headers.get("X-Yookassa-Webhook-Secret")
            )
            if not signature or signature != secret_expected:
                return Response(
                    {"detail": "Invalid webhook signature"},
                    status=status.HTTP_403_FORBIDDEN,
                )

        data = request.data or {}
        event = data.get("event")
        obj = data.get("object") or {}
        provider_payment_id = obj.get("id")

        if not provider_payment_id:
            return Response(
                {"detail": "Missing payment id"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            payment = Payment.objects.select_related("booking").get(
                provider_payment_id=provider_payment_id
            )
        except Payment.DoesNotExist:
            return Response(
                {"detail": "Payment not found"},
                status=status.HTTP_404_NOT_FOUND,
            )

        status_from_provider = obj.get("status")
        payment.raw_webhook = data

        if status_from_provider == "succeeded" or event == "payment.succeeded":
            payment.mark_succeeded(webhook_data=data)
        elif status_from_provider in ("canceled", "cancelled") or event == "payment.canceled":
            payment.mark_cancelled(webhook_data=data)
        else:
            # Любые промежуточные статусы считаем ожидающими
            payment.status = Payment.Status.PENDING
            payment.success = False
            payment.failure = False
            payment.save(
                update_fields=["status", "success", "failure", "raw_webhook", "updated_at"]
            )

        return Response({"detail": "ok"}, status=status.HTTP_200_OK)


class StripeWebhookView(APIView):
    """Простой webhook Stripe (stub)."""

    authentication_classes: list = []
    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        provider = get_payment_provider("stripe")
        payment = provider.handle_webhook(request)
        if not payment:
            return Response({"detail": "Payment not found"}, status=status.HTTP_404_NOT_FOUND)
        return Response({"detail": "ok"}, status=status.HTTP_200_OK)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 241
PATH: payments\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('parking', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Payment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('provider', models.CharField(choices=[('yookassa', 'YooKassa')], default='yookassa', max_length=32, verbose_name='Провайдер')),
                ('provider_payment_id', models.CharField(blank=True, db_index=True, max_length=128, verbose_name='ID платежа у провайдера')),
                ('amount', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Сумма')),
                ('currency', models.CharField(default='RUB', max_length=8, verbose_name='Валюта')),
                ('status', models.CharField(choices=[('created', 'Создан'), ('pending', 'Ожидает оплаты'), ('succeeded', 'Успешен'), ('cancelled', 'Отменён'), ('failed', 'Ошибка')], db_index=True, default='created', max_length=16, verbose_name='Статус')),
                ('success', models.BooleanField(default=False, verbose_name='Успешен')),
                ('failure', models.BooleanField(default=False, verbose_name='Ошибка')),
                ('raw_response', models.JSONField(blank=True, help_text='Сырые данные, вернувшиеся при создании платежа.', null=True, verbose_name='Ответ провайдера')),
                ('raw_webhook', models.JSONField(blank=True, help_text='Последнее уведомление провайдера по этому платежу.', null=True, verbose_name='Последний webhook')),
                ('booking', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='payment', to='parking.booking', verbose_name='Бронь')),
                ('payer', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payments', to=settings.AUTH_USER_MODEL, verbose_name='Плательщик')),
            ],
            options={
                'verbose_name': 'Платёж',
                'verbose_name_plural': 'Платежи',
                'ordering': ('-created_at',),
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 242
PATH: payments\migrations\0002_alter_payment_provider.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-23 12:00

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('payments', '0001_initial'),
    ]

    operations = [
        migrations.AlterField(
            model_name='payment',
            name='provider',
            field=models.CharField(choices=[('yookassa', 'YooKassa'), ('stripe', 'Stripe')], default='yookassa', max_length=32, verbose_name='Провайдер'),
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 243
PATH: payments\migrations\0003_paymentmethod.py
LANG: python
===== CONTENT START =====
from django.conf import settings
from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ('payments', '0002_alter_payment_provider'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='PaymentMethod',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('label', models.CharField(blank=True, help_text="Например: 'Личная', 'Для работы', 'Юрлицо'.", max_length=64, verbose_name='Название')),
                ('brand', models.CharField(choices=[('visa', 'VISA'), ('mc', 'Mastercard'), ('mir', 'Мир'), ('up', 'UnionPay'), ('other', 'Другая')], default='other', max_length=16, verbose_name='Бренд')),
                ('last4', models.CharField(max_length=4, verbose_name='Последние 4 цифры')),
                ('exp_month', models.PositiveSmallIntegerField(verbose_name='Месяц окончания')),
                ('exp_year', models.PositiveSmallIntegerField(verbose_name='Год окончания')),
                ('is_default', models.BooleanField(default=False, verbose_name='По умолчанию')),
                ('token_masked', models.CharField(help_text='Служебный идентификатор платёжного провайдера.', max_length=255, verbose_name='Токен/маска')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='payment_methods', to=settings.AUTH_USER_MODEL, verbose_name='Пользователь')),
            ],
            options={
                'verbose_name': 'Способ оплаты',
                'verbose_name_plural': 'Способы оплаты',
                'ordering': ('-is_default', '-created_at'),
                'unique_together': {('user', 'token_masked')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 244
PATH: payments\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 245
PATH: payments\providers\__init__.py
LANG: python
===== CONTENT START =====
# payments/providers/__init__.py

from __future__ import annotations

from typing import Dict, Type

from django.conf import settings

from .base import BasePaymentProvider
from .yookassa import YooKassaProvider
from .stripe import StripeProvider


# Реестр провайдеров по коду
_PROVIDER_REGISTRY: Dict[str, Type[BasePaymentProvider]] = {
    "yookassa": YooKassaProvider,
    "yoomoney": YooKassaProvider,  # на будущее – алиас
    "stripe": StripeProvider,
    # сюда же можно добавить Sber, Tinkoff, Mir Pay, QIWI и т.д.
}


def get_payment_provider(name: str | None = None) -> BasePaymentProvider:
    """
    Возвращает инстанс провайдера платежей по имени.

    name:
      - None     -> берём DEFAULT_PAYMENT_PROVIDER / PAYMENT_PROVIDER из настроек
      - "yookassa", "stripe" и т.п.

    Для RU-профиля по умолчанию используется YooKassa, для GLOBAL – Stripe,
    но это задаётся в .env / настройках.
    """
    # Совместимость с разными именами переменных
    configured = getattr(settings, "DEFAULT_PAYMENT_PROVIDER", None) or getattr(
        settings, "PAYMENT_PROVIDER", "yookassa"
    )

    provider_name = (name or configured or "yookassa").lower()
    provider_cls = _PROVIDER_REGISTRY.get(provider_name)

    if provider_cls is None:
        raise ValueError(
            f"Unknown payment provider '{provider_name}'. "
            f"Доступные: {', '.join(sorted(_PROVIDER_REGISTRY.keys()))}"
        )

    return provider_cls()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 246
PATH: payments\providers\base.py
LANG: python
===== CONTENT START =====
# payments/providers/base.py

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Any, Dict, Optional

from ..models import Payment  # относительный импорт, чтобы избежать циклов


class BasePaymentProvider(ABC):
    """
    Базовый интерфейс платёжного провайдера.

    Этот класс — единая точка расширения для YooKassa, Stripe, Сбера и т.д.
    """

    @abstractmethod
    def create_payment(
        self,
        payment: Payment,
        return_url: str,
        webhook_url: str,
    ) -> Dict[str, Any]:
        """
        Создать платёж у провайдера и вернуть его данные (включая URL для подтверждения/оплаты).
        Должен вернуть словарь с полями вроде:
            {
                "payment_url": "...",
                "provider_payment_id": "...",
                ...
            }
        """
        raise NotImplementedError

    @abstractmethod
    def handle_webhook(self, request) -> Optional[Payment]:
        """
        Обработать webhook от провайдера и обновить Payment/Booking.

        Должен:
        - найти Payment по данным из webhook;
        - обновить статус/флаги;
        - вернуть обновлённый Payment (или None, если не найден/игнорируем).
        """
        raise NotImplementedError

    @abstractmethod
    def refund(self, payment: Payment, amount: Optional[float] = None) -> None:
        """
        Инициировать возврат по платежу (полный или частичный).
        """
        raise NotImplementedError


# ---------------------------------------------------------
# Обратная совместимость:
# старый код может импортировать PaymentProvider или BasePaymentProvider.
# ---------------------------------------------------------
PaymentProvider = BasePaymentProvider

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 247
PATH: payments\providers\registry.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from typing import Dict, Type

from django.core.exceptions import ImproperlyConfigured

from .base import PaymentProvider
from .stripe import StripeProvider
from .yookassa import YooKassaProvider

REGISTRY: Dict[str, Type[PaymentProvider]] = {
    "yookassa": YooKassaProvider,
    "stripe": StripeProvider,
}


def get_payment_provider(provider_key: str) -> PaymentProvider:
    provider_cls = REGISTRY.get(provider_key)
    if not provider_cls:
        raise ImproperlyConfigured(f"Unknown payment provider: {provider_key}")
    return provider_cls()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 248
PATH: payments\providers\stripe.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

import uuid
from typing import Any, Dict, Optional

from django.conf import settings

from .base import PaymentProvider


class StripeProvider(PaymentProvider):
    key = "stripe"

    def create_payment(
        self, payment, return_url: str, webhook_url: str
    ) -> Dict[str, Any]:
        """Stub: эмуляция Stripe Checkout Session.

        В бою надо подключить stripe SDK и создать Checkout Session с
        success/cancel URL. Здесь формируется предсказуемая ссылка.
        """

        session_id = str(uuid.uuid4())
        confirmation_url = f"https://checkout.stripe.com/pay/{session_id}"
        return {
            "payment_url": confirmation_url,
            "provider_payment_id": session_id,
            "raw": {
                "mode": "payment",
                "return_url": return_url,
                "webhook": webhook_url,
            },
        }

    def handle_webhook(self, request) -> Optional["Payment"]:
        from payments.models import Payment

        payload = request.data or {}
        event_type = payload.get("type")
        data_object = payload.get("data", {}).get("object", {})
        provider_payment_id = data_object.get("id")
        if not provider_payment_id:
            return None

        try:
            payment = Payment.objects.select_related("booking").get(
                provider_payment_id=provider_payment_id
            )
        except Payment.DoesNotExist:
            return None

        if event_type == "checkout.session.completed":
            payment.mark_succeeded(webhook_data=payload)
        elif event_type == "payment_intent.payment_failed":
            payment.mark_failed(webhook_data=payload)
        return payment

    def refund(self, payment, amount: Optional[float] = None) -> None:
        # Заглушка — Stripe refund через SDK
        return None

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 249
PATH: payments\providers\yookassa.py
LANG: python
===== CONTENT START =====
from __future__ import annotations

from __future__ import annotations

import uuid
from decimal import Decimal
from typing import Any, Dict, Optional

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from .base import PaymentProvider

try:  # pragma: no cover - soft dependency
    from yookassa import Configuration, Payment as YooPayment  # type: ignore[import]
except ImportError:  # pragma: no cover - fallback
    Configuration = None
    YooPayment = None


class YooKassaError(Exception):
    """Базовая ошибка при работе с YooKassa."""


class YooKassaProvider(PaymentProvider):
    key = "yookassa"

    def _configure(self) -> None:
        if Configuration is None or YooPayment is None:
            raise ImproperlyConfigured(
                "Пакет 'yookassa' не установлен. Добавьте его в requirements.txt."
            )

        shop_id = getattr(settings, "YOOKASSA_SHOP_ID", "")
        secret_key = getattr(settings, "YOOKASSA_SECRET_KEY", "")
        if not shop_id or not secret_key:
            raise ImproperlyConfigured(
                "Не заданы YOOKASSA_SHOP_ID и/или YOOKASSA_SECRET_KEY в настройках."
            )

        Configuration.account_id = shop_id
        Configuration.secret_key = secret_key

    def create_payment(
        self, payment, return_url: str, webhook_url: str
    ) -> Dict[str, Any]:
        self._configure()
        from parking.models import Booking  # локальный импорт

        booking: Booking = payment.booking
        amount = booking.total_price
        if not isinstance(amount, Decimal):
            amount = Decimal(str(amount))

        amount_str = str(amount.quantize(Decimal("0.01")))
        currency = booking.currency or "RUB"
        description = f"Оплата брони #{booking.id} — {booking.spot}"

        payload: dict[str, Any] = {
            "amount": {
                "value": amount_str,
                "currency": currency,
            },
            "confirmation": {
                "type": "redirect",
                "return_url": return_url,
            },
            "capture": True,
            "description": description,
            "metadata": {
                "booking_id": str(booking.id),
                "user_id": str(booking.user_id),
                "webhook": webhook_url,
            },
        }

        try:
            provider_payment = YooPayment.create(payload, uuid.uuid4())
        except Exception as exc:  # noqa: BLE001
            raise YooKassaError(str(exc)) from exc

        confirmation = getattr(provider_payment, "confirmation", None)
        payment_url = (
            getattr(confirmation, "confirmation_url", None) if confirmation else None
        )
        provider_payment_id = getattr(provider_payment, "id", None)

        if not payment_url or not provider_payment_id:
            raise YooKassaError(
                "Некорректный ответ от YooKassa: не получены id или URL оплаты."
            )

        raw_response = {
            "id": provider_payment_id,
            "status": getattr(provider_payment, "status", None),
        }

        return {
            "payment_url": payment_url,
            "provider_payment_id": provider_payment_id,
            "raw": raw_response,
        }

    def handle_webhook(self, request) -> Optional[Payment]:
        from payments.models import Payment

        data = request.data or {}
        event = data.get("event")
        obj = data.get("object") or {}
        provider_payment_id = obj.get("id")

        if not provider_payment_id:
            return None

        try:
            payment = Payment.objects.select_related("booking").get(
                provider_payment_id=provider_payment_id
            )
        except Payment.DoesNotExist:
            return None

        status_from_provider = obj.get("status")
        payment.raw_webhook = data

        if status_from_provider == "succeeded" or event == "payment.succeeded":
            payment.mark_succeeded(webhook_data=data)
        elif status_from_provider in ("canceled", "cancelled") or event == "payment.canceled":
            payment.mark_cancelled(webhook_data=data)
        else:
            payment.status = Payment.Status.PENDING
            payment.success = False
            payment.failure = False
            payment.save(
                update_fields=["status", "success", "failure", "raw_webhook", "updated_at"]
            )

        return payment

    def refund(self, payment, amount: Optional[float] = None) -> None:
        # Неполная реализация для MVP
        raise NotImplementedError("YooKassa refunds are not implemented in this stub.")

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 250
PATH: regions\global.yml
LANG: yaml
===== CONTENT START =====
# Базовый глобальный профиль ParkShare (по умолчанию для не-RU регионов)

id: "global"
name: "ParkShare Global"

locale:
  default_language: "en"
  supported_languages:
    - "en"
    - "ru"

currency:
  default: "EUR"

maps:
  default_provider: "openstreetmap"
  fallback_provider: "none"

payments:
  gateways:
    - "stripe"
    - "paypal"

auth:
  providers:
    - "email-password"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 251
PATH: regions\ru.yml
LANG: yaml
===== CONTENT START =====
id: "ru"
name: "ParkShare RU"

locale:
  default_language: "ru"
  supported_languages:
    - "ru"
    - "en"

картография:
  основной_провайдер: "Яндекс.Карты API"
  резервный: "2GIS API"

платежные_системы:
  обязательные:
    - "Сбербанк Онлайн"
    - "Тинькофф"
    - "ЮMoney"
    - "Мир Pay"
    - "QIWI"

аутентификация:
  - "Госуслуги (ЕСИА)"
  - "ВК ID"
  - "Яндекс ID"
  - "Сбер ID"
  - "Email/Телефон (native)"

pricing:
  currency: "RUB"
  tax_included: true

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 252
PATH: services\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 253
PATH: services\llm.py
LANG: python
===== CONTENT START =====
# services/llm.py
"""Async client helpers for communicating with the LLM microservice."""
from __future__ import annotations

import logging
import os
import json
from typing import Any, Dict, Iterable, List

try:
    import httpx
except Exception:  # pragma: no cover - optional dependency
    httpx = None  # type: ignore

logger = logging.getLogger(__name__)

DEFAULT_TIMEOUT = 8.0
CONNECT_TIMEOUT = 3.0
OPENAI_DEFAULT_MODEL = "gpt-3.5-turbo"

# По умолчанию ожидаем локальный сервис на 8002 (см. docker-compose).
# 1) внутри docker-сети: llm_service:8002
# 2) с хоста: localhost:8002
DEFAULT_LLM_URLS: List[str] = [
    "http://llm_service:8002",
    "http://127.0.0.1:8002",
    "http://localhost:8002",
]

LEGACY_ENDPOINTS: List[str] = [
    "/parse",
    "/api/v1/llm/parse-search-query",
]

DEFAULT_RETRIES = 2


class LLMClientError(Exception):
    """Raised when the LLM service cannot process the request."""

    def __init__(self, message: str, *, retryable: bool = False) -> None:
        super().__init__(message)
        self.retryable = retryable


def _candidate_endpoints() -> Iterable[str]:
    """Return candidate base URLs to try for the LLM service.

    Priority: explicit env var, then defaults (llm_service, localhost).
    """
    env_url = os.getenv("LLM_SERVICE_URL")
    if env_url:
        yield env_url.rstrip("/")

    for url in DEFAULT_LLM_URLS:
        if not env_url or url.rstrip("/") != env_url.rstrip("/"):
            yield url.rstrip("/")


def _strip_code_fences(content: str) -> str:
    """Remove Markdown code fences if the model returns them."""

    text = (content or "").strip()
    if text.startswith("```"):
        lines = text.splitlines()
        if len(lines) >= 2:
            text = "\n".join(lines[1:-1])
        text = text.strip()
    return text.strip("` \n")


async def _call_llm_service(query: str, retries: int, timeout_value: float) -> Dict[str, Any]:
    """Call the LLM microservice with retries."""

    if httpx is None:
        raise LLMClientError("LLM client is disabled: httpx is not installed", retryable=False)

    timeout = httpx.Timeout(timeout_value, connect=CONNECT_TIMEOUT)

    last_error: Exception | None = None
    last_error_message: str | None = None
    retryable = False

    for base_url in _candidate_endpoints():
        for path in LEGACY_ENDPOINTS:
            endpoint = f"{base_url}{path}"
            logger.info(
                "Calling LLM service",
                extra={
                    "endpoint": endpoint,
                    "timeout": timeout_value,
                    "retries": retries,
                    "query_preview": query[:120],
                },
            )
            try:
                async with httpx.AsyncClient(timeout=timeout) as client:
                    for attempt in range(1, retries + 1):
                        try:
                            logger.debug(
                                "LLM HTTP request",
                                extra={
                                    "endpoint": endpoint,
                                    "attempt": attempt,
                                    "timeout": timeout_value,
                                },
                            )
                            response = await client.post(endpoint, json={"query": query})
                            response.raise_for_status()
                            data = response.json()
                            logger.debug(
                                "LLM service response",
                                extra={
                                    "endpoint": endpoint,
                                    "attempt": attempt,
                                    "response": data,
                                },
                            )
                            return data
                        except httpx.TimeoutException as exc:
                            logger.warning(
                                "llm_service_unavailable",
                                extra={"endpoint": endpoint, "attempt": attempt, "event": "llm_service_unavailable"},
                            )
                            last_error = exc
                            last_error_message = "timeout"
                            retryable = True
                        except httpx.HTTPStatusError as exc:
                            status_code = exc.response.status_code
                            event = "llm_service_5xx" if status_code >= 500 else "llm_service_http_error"
                            logger.log(
                                logging.ERROR if status_code >= 500 else logging.WARNING,
                                event,
                                extra={
                                    "status": status_code,
                                    "endpoint": endpoint,
                                    "attempt": attempt,
                                    "body": exc.response.text[:500],
                                    "event": event,
                                },
                            )
                            last_error = exc
                            last_error_message = f"HTTP {status_code}"
                            retryable = status_code >= 500 or status_code in {401, 403}
                            break
                        except httpx.RequestError as exc:
                            logger.error(
                                "llm_service_unavailable",
                                extra={
                                    "endpoint": endpoint,
                                    "attempt": attempt,
                                    "event": "llm_service_unavailable",
                                },
                                exc_info=exc,
                            )
                            last_error = exc
                            last_error_message = "network_error"
                            retryable = True
                        except ValueError as exc:
                            logger.warning(
                                "LLM service returned invalid JSON",
                                extra={"endpoint": endpoint, "attempt": attempt},
                                exc_info=exc,
                            )
                            last_error = exc
                            last_error_message = "invalid_json"
                            retryable = True
                            break
            except Exception as exc:
                last_error = exc
                retryable = True
                logger.exception(
                    "Unexpected LLM client error", extra={"endpoint": endpoint}
                )

    if last_error:
        raise LLMClientError(f"LLM service unreachable: {last_error_message or last_error}", retryable=retryable) from last_error

    raise LLMClientError("LLM service unreachable: no endpoints configured", retryable=True)


async def _call_openai_direct(query: str, timeout_value: float) -> Dict[str, Any]:
    """Call OpenAI GPT-3.5 directly as a fallback."""

    if httpx is None:
        raise LLMClientError("OpenAI client requires httpx", retryable=False)

    api_key = (
        os.getenv("OPENAI_API_KEY", "").strip()
        or os.getenv("LLM_OPENAI_API_KEY", "").strip()
    )
    if not api_key:
        logger.warning("llm_openai_unavailable", extra={"event": "llm_openai_unavailable"})
        raise LLMClientError("OpenAI is not configured", retryable=False)

    base_url = (
        os.getenv("OPENAI_BASE_URL")
        or os.getenv("LLM_OPENAI_BASE_URL")
        or "https://api.openai.com/v1"
    ).rstrip("/")
    model = (
        os.getenv("OPENAI_CHAT_MODEL")
        or os.getenv("LLM_DEFAULT_MODEL")
        or OPENAI_DEFAULT_MODEL
    ).strip() or OPENAI_DEFAULT_MODEL
    timeout = httpx.Timeout(timeout_value, connect=CONNECT_TIMEOUT)

    payload = {
        "model": model,
        "temperature": 0.2,
        "messages": [
            {
                "role": "system",
                "content": (
                    "You extract parking search parameters from user text and return ONLY compact JSON. "
                    "Schema: {\"city\": string|null, \"near_metro\": string|null, \"has_ev_charging\": bool, "
                    "\"covered\": bool, \"max_price_per_hour\": number|null, \"start_at\": string|null, "
                    "\"end_at\": string|null}. "
                    "city may be Russian. If unknown, use null/false. No explanations."
                ),
            },
            {"role": "user", "content": query},
        ],
    }

    url = f"{base_url}/chat/completions"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json",
    }

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            response = await client.post(url, headers=headers, json=payload)
    except httpx.TimeoutException as exc:
        logger.warning("llm_openai_unavailable", extra={"event": "llm_openai_unavailable"})
        raise LLMClientError("OpenAI timeout", retryable=False) from exc
    except httpx.RequestError as exc:
        logger.warning(
            "llm_openai_unavailable",
            extra={"event": "llm_openai_unavailable", "detail": str(exc)},
        )
        raise LLMClientError("OpenAI network error", retryable=False) from exc

    if response.status_code >= 500:
        logger.warning(
            "llm_openai_5xx",
            extra={
                "event": "llm_openai_5xx",
                "status": response.status_code,
                "body": response.text[:500],
            },
        )
        raise LLMClientError(f"OpenAI 5xx: {response.status_code}", retryable=False)
    if response.status_code >= 400:
        logger.warning(
            "llm_openai_4xx",
            extra={
                "event": "llm_openai_4xx",
                "status": response.status_code,
                "body": response.text[:500],
            },
        )
        raise LLMClientError(f"OpenAI error: HTTP {response.status_code}", retryable=False)

    try:
        data = response.json()
    except ValueError as exc:
        logger.warning("llm_openai_4xx", extra={"event": "llm_openai_4xx", "detail": "invalid_json"})
        raise LLMClientError("OpenAI returned invalid JSON", retryable=False) from exc

    try:
        content = data.get("choices", [{}])[0].get("message", {}).get("content") or ""
        parsed_text = _strip_code_fences(content)
        parsed = json.loads(parsed_text)
        if not isinstance(parsed, dict):
            raise ValueError("response is not an object")
        return parsed
    except Exception as exc:
        logger.warning(
            "llm_openai_parse_error",
            extra={"event": "llm_openai_parse_error", "body": str(data)[:500]},
        )
        raise LLMClientError("OpenAI response parse error", retryable=False) from exc


async def parse_search_query(query: str) -> Dict[str, Any]:
    """Parse a user parking search query via the LLM microservice.

    Args:
        query: Raw text query from the user.

    Returns:
        Structured dict with parking search attributes.

    Raises:
        LLMClientError: If the request fails or returns non-200 status.
        ValueError: If query is empty.
    """
    if not query or not query.strip():
        raise ValueError("query must be non-empty")
    retries = int(os.getenv("LLM_CLIENT_RETRIES", DEFAULT_RETRIES))
    timeout_value = float(os.getenv("LLM_CLIENT_TIMEOUT", DEFAULT_TIMEOUT))

    last_error: LLMClientError | None = None

    try:
        return await _call_llm_service(query, retries=retries, timeout_value=timeout_value)
    except LLMClientError as exc:
        last_error = exc
        if not exc.retryable:
            raise
        logger.warning(
            "llm_service_fallback_openai",
            extra={"event": "llm_service_fallback_openai", "reason": str(exc)},
        )

    # Fallback to direct OpenAI
    try:
        return await _call_openai_direct(query, timeout_value=timeout_value)
    except LLMClientError as exc:
        if last_error:
            raise LLMClientError(
                f"OpenAI fallback failed after LLM service error: {exc}"
            ) from exc
        raise


async def check_llm_health() -> Dict[str, Any]:
    """Check health endpoints of the LLM service for diagnostics."""
    if httpx is None:
        return {"ok": False, "detail": "httpx not installed"}

    timeout_value = float(os.getenv("LLM_CLIENT_TIMEOUT", DEFAULT_TIMEOUT))
    timeout = httpx.Timeout(timeout_value, connect=CONNECT_TIMEOUT)

    results: Dict[str, Any] = {"endpoints": []}

    for base_url in _candidate_endpoints():
        for path in ["/health", "/healthz"]:
            health_url = f"{base_url}{path}"
            try:
                async with httpx.AsyncClient(timeout=timeout) as client:
                    resp = await client.get(health_url)
                results["endpoints"].append(
                    {
                        "url": health_url,
                        "status": resp.status_code,
                        "body": resp.json()
                        if resp.headers.get("content-type", "").startswith(
                            "application/json"
                        )
                        else resp.text,
                    }
                )
                if resp.status_code == 200:
                    results["ok"] = True
                    results["active_url"] = health_url
                    return results
            except Exception as exc:
                logger.warning(
                    "LLM health check failed", extra={"url": health_url}, exc_info=exc
                )
                results["endpoints"].append({"url": health_url, "error": str(exc)})

    results["ok"] = False
    return results

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 254
PATH: services\llm_service\Dockerfile
LANG: text
===== CONTENT START =====
FROM python:3.11-slim

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1

WORKDIR /app

# Устанавливаем зависимости для FastAPI и LLM-клиента
RUN pip install --no-cache-dir fastapi uvicorn[standard] httpx pydantic

COPY services/llm_service /app

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8002"]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 255
PATH: services\llm_service\main.py
LANG: python
===== CONTENT START =====
"""Modern FastAPI-based LLM gateway for ParkShare.

Highlights
- OpenAI-compatible /v1/chat/completions endpoint with fallbacks (OpenAI/Anthropic/Groq/local via LiteLLM).
- In-memory caching and rate limiting to reduce latency and protect upstream APIs.
- Health probes and lightweight parking-aware helper endpoint for UI chat integrations.
- Context memory per conversation with TTL to keep replies coherent.
"""
from __future__ import annotations

import asyncio
import hashlib
import json
import logging
import time
import uuid
from functools import lru_cache
from collections import deque
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

from fastapi import Depends, FastAPI, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, ValidationError, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

try:  # lightweight optional cache backend
    from cachetools import TTLCache
except Exception:  # pragma: no cover - fallback when dependency is absent
    TTLCache = None  # type: ignore

try:  # optional Redis cache
    from redis import asyncio as aioredis
except Exception:  # pragma: no cover - optional dependency already in requirements
    aioredis = None  # type: ignore

try:
    from aiolimiter import AsyncLimiter
except Exception:  # pragma: no cover
    AsyncLimiter = None  # type: ignore

try:
    import litellm
except Exception as exc:  # pragma: no cover
    raise RuntimeError(
        "LiteLLM must be installed (requirements.txt) to start the LLM service"
    ) from exc

logger = logging.getLogger("parkshare.llm_service")
logging.basicConfig(level=logging.INFO)


# Env vars for GPT-3.5 (env_prefix LLM_):
# LLM_OPENAI_API_KEY, LLM_DEFAULT_MODEL, LLM_FALLBACK_MODELS,
# LLM_CACHE_ENABLED, LLM_CACHE_TTL_SECONDS, LLM_REQUESTS_PER_MINUTE,
# LLM_REQUEST_TIMEOUT, LLM_OPENAI_BASE_URL, LLM_CACHE_URL (optional).
class Settings(BaseSettings):
    """Service configuration loaded from environment/.env."""

    # Networking
    host: str = "0.0.0.0"
    port: int = 8002
    cors_allow_origins: list[str] = []

    # Provider configuration
    openai_api_key: str = ""
    openai_base_url: str = "https://api.openai.com/v1"
    anthropic_api_key: str = ""
    groq_api_key: str = ""
    default_model: str = "gpt-3.5-turbo"
    fallback_models: list[str] = ["gpt-3.5-turbo"]

    # Service features
    cache_enabled: bool = True
    cache_url: str | None = None
    cache_ttl_seconds: int = 30
    cache_size: int = 128
    max_history_messages: int = 16
    history_ttl_seconds: int = 3600
    requests_per_minute: int = 60
    rate_limit: str | None = None
    request_timeout: float = 20.0

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        env_prefix="LLM_",
        case_sensitive=False,
        extra="ignore",
    )

    @field_validator("fallback_models", mode="before")
    @classmethod
    def _parse_fallbacks(cls, value):
        """Позволяет передавать список в виде JSON или через запятую."""

        if value is None:
            return []
        if isinstance(value, list):
            return [str(item).strip() for item in value if str(item).strip()]
        if isinstance(value, str):
            text = value.strip()
            if not text:
                return []
            # Попробуем JSON
            try:
                parsed = json.loads(text)
                if isinstance(parsed, list):
                    cleaned = [str(item).strip() for item in parsed if str(item).strip()]
                    if cleaned:
                        return cleaned
            except json.JSONDecodeError:
                if text.startswith("["):
                    return [text]
            except Exception:
                return [text]
            if "," in text:
                items = [item.strip() for item in text.split(",") if item.strip()]
                if items:
                    return items
            return [text]
        return [str(value)]

    @field_validator("requests_per_minute", mode="before")
    @classmethod
    def _parse_rate_limit(cls, value, info):
        rate_limit_value = info.data.get("rate_limit")
        if rate_limit_value and isinstance(rate_limit_value, str) and "/" in rate_limit_value:
            try:
                count, window = rate_limit_value.split("/", 1)
                if window.lower() in {"m", "min", "minute", "hour"}:
                    divisor = 60 if window.lower().startswith("m") else 1
                    return int(int(count) / divisor)
            except Exception:
                pass
        return value


class ChatMessage(BaseModel):
    role: str = Field(..., description="system|user|assistant")
    content: str


class ChatCompletionRequest(BaseModel):
    model: Optional[str] = None
    messages: List[ChatMessage]
    temperature: float | None = 0.3
    max_tokens: Optional[int] = None
    user: Optional[str] = None
    conversation_id: Optional[str] = Field(
        default=None,
        description="Conversation key to keep lightweight context in memory",
    )


class CompletionChoice(BaseModel):
    index: int
    message: ChatMessage
    finish_reason: str | None = None


class CompletionUsage(BaseModel):
    prompt_tokens: int | None = None
    completion_tokens: int | None = None
    total_tokens: int | None = None


class ChatCompletionResponse(BaseModel):
    id: str
    object: str = "chat.completion"
    created: int
    model: str
    choices: List[CompletionChoice]
    usage: CompletionUsage | None = None


class ParkingChatRequest(BaseModel):
    query: str
    conversation_id: Optional[str] = None


class ParkingChatResponse(BaseModel):
    reply: str
    conversation_id: str
    provider: str


class RateLimiter:
    """Simple in-memory sliding window limiter."""

    def __init__(self, max_per_minute: int) -> None:
        self.max_per_minute = max_per_minute
        self.events: deque[float] = deque()
        self._lock = asyncio.Lock()

    async def acquire(self) -> None:
        async with self._lock:
            now = time.time()
            window_start = now - 60
            while self.events and self.events[0] < window_start:
                self.events.popleft()
            if len(self.events) >= self.max_per_minute:
                raise HTTPException(
                    status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                    detail="LLM rate limit exceeded",
                )
            self.events.append(now)


class BaseCache:
    async def get(self, key: str) -> Any:  # pragma: no cover - interface
        raise NotImplementedError

    async def set(self, key: str, value: Any) -> None:  # pragma: no cover - interface
        raise NotImplementedError


class MemoryCache(BaseCache):
    """TTL cache wrapper with graceful fallback."""

    def __init__(self, size: int, ttl: int) -> None:
        if TTLCache:
            self._cache = TTLCache(maxsize=size, ttl=ttl)
        else:  # pragma: no cover - simplified fallback
            self._cache: Dict[str, tuple[float, Any]] = {}
            self.ttl = ttl

    async def get(self, key: str) -> Any:
        if TTLCache:
            return self._cache.get(key)
        value = self._cache.get(key)
        if not value:
            return None
        expire_at, payload = value
        if expire_at < time.time():
            self._cache.pop(key, None)
            return None
        return payload

    async def set(self, key: str, value: Any) -> None:
        if TTLCache:
            self._cache[key] = value
        else:
            self._cache[key] = (time.time() + self.ttl, value)


class RedisCache(BaseCache):
    """Redis-based cache for shared workers."""

    def __init__(self, url: str, ttl: int) -> None:
        if not aioredis:
            raise RuntimeError("redis asyncio client is required for Redis cache")
        self.client = aioredis.from_url(url)
        self.ttl = ttl

    async def get(self, key: str) -> Any:
        raw = await self.client.get(key)
        if not raw:
            return None
        try:
            return json.loads(raw)
        except Exception:
            return None

    async def set(self, key: str, value: Any) -> None:
        payload = json.dumps(value, default=str)
        await self.client.set(key, payload, ex=self.ttl)


class ConversationMemory:
    """Keeps short-lived message history to provide context continuity."""

    def __init__(self, limit: int, ttl: int) -> None:
        self.limit = limit
        self.ttl = ttl
        self.storage: Dict[str, tuple[float, List[ChatMessage]]] = {}

    def get_history(self, conv_id: str) -> List[ChatMessage]:
        payload = self.storage.get(conv_id)
        if not payload:
            return []
        expires_at, messages = payload
        if expires_at < time.time():
            self.storage.pop(conv_id, None)
            return []
        return messages

    def append(self, conv_id: str, messages: List[ChatMessage]) -> None:
        history = self.get_history(conv_id)
        combined = (history + messages)[-self.limit :]
        self.storage[conv_id] = (time.time() + self.ttl, combined)


@lru_cache(maxsize=1)
def get_settings() -> Settings:
    return Settings()


@lru_cache(maxsize=1)
def get_rate_limiter(settings: Settings = Depends(get_settings)) -> RateLimiter:
    return RateLimiter(settings.requests_per_minute)


@lru_cache(maxsize=1)
def get_cache(settings: Settings = Depends(get_settings)) -> BaseCache:
    if settings.cache_enabled and settings.cache_url and aioredis:
        try:
            return RedisCache(settings.cache_url, settings.cache_ttl_seconds)
        except Exception:
            logger.warning("Redis cache недоступен, переключаемся на память")
    return MemoryCache(settings.cache_size, settings.cache_ttl_seconds)


@lru_cache(maxsize=1)
def get_history(settings: Settings = Depends(get_settings)) -> ConversationMemory:
    return ConversationMemory(settings.max_history_messages, settings.history_ttl_seconds)


app = FastAPI(title="ParkShare LLM Gateway", version="1.0.0")
_settings = get_settings()
app.add_middleware(
    CORSMiddleware,
    allow_origins=_settings.cors_allow_origins or ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

if AsyncLimiter:
    limiter = AsyncLimiter(_settings.requests_per_minute, time_period=60)
else:
    limiter = None


def _matches_exc(exc: Exception, names: tuple[str, ...]) -> bool:
    """Return True if exception is instance of any litellm-provided error classes."""

    for name in names:
        cls = getattr(litellm, name, None)
        if cls and isinstance(exc, cls):
            return True
    return False


def _extract_status_code(exc: Exception) -> int | None:
    """Try to pull an HTTP status code off a litellm/httpx-style exception."""

    for attr in ("status_code", "http_status"):
        value = getattr(exc, attr, None)
        if isinstance(value, int):
            return value
    response = getattr(exc, "response", None)
    status_code = getattr(response, "status_code", None)
    return status_code if isinstance(status_code, int) else None


async def _call_litellm(model: str, request: ChatCompletionRequest, settings: Settings) -> Dict[str, Any]:
    """Invoke LiteLLM with provider-specific credentials."""

    common_kwargs: Dict[str, Any] = {
        "model": model,
        "messages": [m.model_dump() for m in request.messages],
        "timeout": settings.request_timeout,
    }
    if request.temperature is not None:
        common_kwargs["temperature"] = request.temperature
    if request.max_tokens:
        common_kwargs["max_tokens"] = request.max_tokens
    if request.user:
        common_kwargs["user"] = request.user

    if model.startswith("claude") and settings.anthropic_api_key:
        common_kwargs["api_key"] = settings.anthropic_api_key
        common_kwargs["base_url"] = "https://api.anthropic.com"
    elif model.startswith("gpt"):
        if not settings.openai_api_key:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="LLM is not configured",
            )
        common_kwargs["api_key"] = settings.openai_api_key
        common_kwargs["base_url"] = settings.openai_base_url.rstrip("/")
    elif settings.groq_api_key and model.startswith("groq"):
        common_kwargs["api_key"] = settings.groq_api_key
        common_kwargs["base_url"] = "https://api.groq.com/openai/v1"

    try:
        response = await litellm.acompletion(**common_kwargs)
    except litellm.RateLimitError as exc:  # pragma: no cover - network-specific
        logger.warning("LLM rate limited", exc_info=exc)
        raise HTTPException(status_code=status.HTTP_429_TOO_MANY_REQUESTS, detail=str(exc)) from exc
    except litellm.BadRequestError as exc:  # pragma: no cover
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(exc)) from exc
    except Exception as exc:  # pragma: no cover
        status_code = _extract_status_code(exc)
        if status_code in {401, 403}:
            logger.exception("LLM authentication failed", exc_info=exc)
            raise HTTPException(
                status_code=status.HTTP_502_BAD_GATEWAY,
                detail="LLM upstream authentication failed",
            ) from exc
        if _matches_exc(exc, ("APIConnectionError", "APITimeoutError", "Timeout")) or isinstance(
            exc, (asyncio.TimeoutError, TimeoutError, ConnectionError)
        ):
            logger.exception("LLM upstream unavailable", exc_info=exc)
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="LLM upstream unavailable"
            ) from exc
        logger.exception("LLM provider error", exc_info=exc)
        raise HTTPException(status_code=status.HTTP_502_BAD_GATEWAY, detail="LLM upstream error") from exc

    return response  # type: ignore[no-any-return]


async def _make_response(
    provider_payload: Dict[str, Any],
    model: str,
    conversation_id: Optional[str],
    history: ConversationMemory,
) -> ChatCompletionResponse:
    first_choice = provider_payload["choices"][0]
    message_payload = first_choice["message"]
    message = ChatMessage(role=message_payload.get("role", "assistant"), content=message_payload.get("content", ""))

    if conversation_id:
        history.append(conversation_id, [message])

    usage = provider_payload.get("usage") or {}
    return ChatCompletionResponse(
        id=provider_payload.get("id") or f"chatcmpl-{uuid.uuid4().hex}",
        created=int(provider_payload.get("created") or time.time()),
        model=model,
        choices=[
            CompletionChoice(index=0, message=message, finish_reason=first_choice.get("finish_reason")),
        ],
        usage=CompletionUsage(
            prompt_tokens=usage.get("prompt_tokens"),
            completion_tokens=usage.get("completion_tokens"),
            total_tokens=usage.get("total_tokens"),
        ),
    )


def _cache_key(request: ChatCompletionRequest) -> str:
    payload = json.dumps(request.model_dump(), sort_keys=True, ensure_ascii=False)
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()


def _health_payload(settings: Settings) -> dict[str, Any]:
    base = {
        "provider": "litellm",
        "default_model": settings.default_model,
        "fallbacks": settings.fallback_models,
    }
    if not settings.openai_api_key:
        return {
            **base,
            "status": "degraded",
            "reason": "OpenAI API key is not configured",
        }
    if not settings.default_model:
        return {
            **base,
            "status": "degraded",
            "reason": "Default model is not configured",
        }
    return {**base, "status": "ok"}


async def _with_history(request: ChatCompletionRequest, history: ConversationMemory) -> ChatCompletionRequest:
    if not request.conversation_id:
        return request
    previous = history.get_history(request.conversation_id)
    if not previous:
        return request
    merged = previous + request.messages
    return ChatCompletionRequest(**{**request.model_dump(), "messages": merged})


@app.middleware("http")
async def guard_rate_limit(request: Request, call_next):
    if limiter:
        async with limiter:
            return await call_next(request)
    return await call_next(request)


@app.get("/health", tags=["health"])
async def health(settings: Settings = Depends(get_settings)) -> dict[str, Any]:
    return _health_payload(settings)


@app.get("/healthz", tags=["health"])
async def healthz(settings: Settings = Depends(get_settings)) -> dict[str, Any]:
    return _health_payload(settings)


@app.get("/v1/models")
async def list_models(settings: Settings = Depends(get_settings)) -> dict[str, Any]:
    models = list({settings.default_model, *settings.fallback_models})
    return {"data": [{"id": m, "object": "model"} for m in models], "object": "list"}


@app.post("/v1/chat/completions", response_model=ChatCompletionResponse)
async def chat_completions(
    payload: ChatCompletionRequest,
    settings: Settings = Depends(get_settings),
    cache: BaseCache = Depends(get_cache),
    history: ConversationMemory = Depends(get_history),
    limiter_dep: RateLimiter = Depends(get_rate_limiter),
) -> ChatCompletionResponse:
    models_chain = [
        payload.model or settings.default_model,
        *settings.fallback_models,
    ]
    models_chain = [m for m in models_chain if m]
    if not models_chain:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="LLM is not configured",
        )
    if any(m.startswith("gpt") for m in models_chain) and not settings.openai_api_key:
        logger.warning(
            "Rejecting chat request: OpenAI key is missing",
            extra={"models": models_chain},
        )
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="LLM is not configured",
        )

    await limiter_dep.acquire()
    payload = await _with_history(payload, history)
    cache_key = _cache_key(payload)
    cached = await cache.get(cache_key)
    if cached:
        try:
            return ChatCompletionResponse.model_validate(cached)
        except Exception:
            pass

    last_error: Optional[Exception] = None
    for model in models_chain:
        try:
            provider_payload = await _call_litellm(model, payload, settings)
            response = await _make_response(provider_payload, model, payload.conversation_id, history)
            await cache.set(cache_key, response.model_dump())
            return response
        except HTTPException as exc:
            last_error = exc
            if exc.status_code < 500:
                break
            continue
        except Exception as exc:  # pragma: no cover - unexpected fallback
            last_error = exc
            logger.exception("Unexpected LLM error for model %s", model)
            continue

    if last_error:
        raise last_error  # type: ignore[misc]
    raise HTTPException(status_code=502, detail="LLM provider unavailable")


@app.post("/v1/parkshare/chat", response_model=ParkingChatResponse)
async def parking_chat(
    payload: ParkingChatRequest,
    settings: Settings = Depends(get_settings),
    history: ConversationMemory = Depends(get_history),
) -> ParkingChatResponse:
    """Parking-aware helper endpoint to drive the web chat UI."""

    system_prompt = (
        "You are ParkShare's multilingual assistant. "
        "You help users book and discover parking spots with contextual hints from their history. "
        "Answer succinctly in the language of the user."
    )
    conversation_id = payload.conversation_id or uuid.uuid4().hex
    messages: List[ChatMessage] = [ChatMessage(role="system", content=system_prompt)]
    history_messages = history.get_history(conversation_id)
    messages.extend(history_messages[-6:])
    messages.append(ChatMessage(role="user", content=payload.query))

    request_payload = ChatCompletionRequest(
        model=settings.default_model,
        messages=messages,
        conversation_id=conversation_id,
        temperature=0.4,
    )
    response = await chat_completions(request_payload, settings, get_cache(settings), history, get_rate_limiter(settings))
    reply = response.choices[0].message.content
    return ParkingChatResponse(reply=reply, conversation_id=conversation_id, provider=response.model)


@app.exception_handler(ValidationError)
async def validation_exception_handler(_: Request, exc: ValidationError):  # pragma: no cover - FastAPI hook
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()},
    )


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host=_settings.host, port=_settings.port)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 256
PATH: services\llm_service\requirements.txt
LANG: text
===== CONTENT START =====
fastapi==0.115.0
uvicorn[standard]==0.32.1
httpx==0.27.2
pydantic==2.12.4
pydantic-settings==2.8.0
python-dotenv==1.2.1

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 257
PATH: static\manifest.webmanifest
LANG: text
===== CONTENT START =====
{
  "name": "ParkShare — умная парковка",
  "short_name": "ParkShare",
  "description": "Поиск, бронирование и оплата парковок рядом с вами. Работает как приложение, даже офлайн.",
  "start_url": "/?pwa=true",
  "scope": "/",
  "display": "standalone",
  "orientation": "portrait-primary",
  "background_color": "#020617",
  "theme_color": "#0f172a",
  "icons": [
    {
      "src": "/static/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/static/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/static/icons/icon-maskable-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/static/icons/icon-maskable-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "shortcuts": [
    {
      "name": "Найти парковку рядом",
      "short_name": "Найти рядом",
      "url": "/#search",
      "icons": [
        {
          "src": "/static/icons/shortcut-search.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Мои бронирования",
      "short_name": "Брони",
      "url": "/dashboard/#bookings"
    }
  ],
  "categories": ["navigation", "productivity", "travel"],
  "lang": "ru-RU"
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 258
PATH: static\service-worker.js
LANG: javascript
===== CONTENT START =====
// static/service-worker.js — production-grade PWA cache with app versioning
const APP_VERSION = '2024.09.1';
const CACHE_PREFIX = 'parkshare-';
const PUBLIC_STATIC_CACHE = `${CACHE_PREFIX}static-${APP_VERSION}`;
const PUBLIC_PAGE_CACHE = `${CACHE_PREFIX}pages-${APP_VERSION}`;
const PUBLIC_API_CACHE = `${CACHE_PREFIX}api-${APP_VERSION}`;
const PRIVATE_API_CACHE = `${CACHE_PREFIX}api-private-${APP_VERSION}`;
const MAP_CACHE = `${CACHE_PREFIX}map-${APP_VERSION}`;
const RUNTIME_CACHE = `${CACHE_PREFIX}runtime-${APP_VERSION}`;
const OFFLINE_URL = '/offline/';

const PRIVATE_TTL_MS = 5 * 60 * 1000;
const PRIVATE_MAX_ENTRIES = 30;
const SHELL_ROUTES = ['/map/', '/app/', '/личный-кабинет/', '/кабинет-владельца/'];
const APP_SHELL = [...SHELL_ROUTES, OFFLINE_URL, '/manifest.webmanifest'];

const STATIC_ASSETS = [
  '/static/css/app.css',
  '/static/js/app.js',
  '/static/js/map.js',
  '/static/js/quantum-theme-manager.js',
  '/static/icons/icon-192.png',
  '/static/icons/icon-512.png',
  '/static/icons/icon-72.png',
  '/static/pwa/app.js',
  '/static/pwa/api-client.js',
  '/static/pwa/state-store.js',
  '/static/pwa/router.js',
  '/static/pwa/spots-view.js',
  '/static/pwa/ui-kit.js',
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    Promise.all([
      caches.open(PUBLIC_PAGE_CACHE).then((cache) => cache.addAll(APP_SHELL)),
      caches.open(PUBLIC_STATIC_CACHE).then((cache) => cache.addAll(STATIC_ASSETS)),
    ]).catch((err) => {
      console.warn('[SW] install cache error', err);
    })
  );
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) =>
      Promise.all(
        keys
          .filter(
            (key) =>
              key.startsWith(CACHE_PREFIX) &&
              ![
                RUNTIME_CACHE,
                PUBLIC_STATIC_CACHE,
                PUBLIC_PAGE_CACHE,
                PUBLIC_API_CACHE,
                PRIVATE_API_CACHE,
                MAP_CACHE,
              ].includes(key)
          )
          .map((key) => caches.delete(key))
      )
    )
  );
  self.clients.claim();
});

self.addEventListener('message', (event) => {
  if (event.data === 'SW_APPLY_UPDATE') {
    self.skipWaiting();
    return;
  }
  if (event.data && event.data.type === 'PRIME_SHELL') {
    precacheShell();
  }
});

self.addEventListener('fetch', (event) => {
  const { request } = event;
  if (request.method !== 'GET') return;

  const url = new URL(request.url);
  const isSameOrigin = url.origin === self.location.origin;

  if (request.headers.get('accept')?.includes('text/html')) {
    if (isSameOrigin) {
      const targetCache = isPwaShell(url) ? PUBLIC_PAGE_CACHE : null;
      event.respondWith(handleHtmlRequest(request, targetCache));
      return;
    }
  }

  if (isApiRequest(url)) {
    if (isPrivateApi(url)) {
      event.respondWith(networkFirstPrivate(request, PRIVATE_API_CACHE));
      return;
    }
    event.respondWith(staleWhileRevalidate(request, PUBLIC_API_CACHE));
    return;
  }

  if (isMapTile(url)) {
    event.respondWith(limitCacheSize(cacheFirst(request, MAP_CACHE), 150));
    return;
  }

  if (isAsset(url)) {
    event.respondWith(cacheFirst(request, PUBLIC_STATIC_CACHE));
    return;
  }

  event.respondWith(staleWhileRevalidate(request, RUNTIME_CACHE));
});

self.addEventListener('sync', (event) => {
  if (event.tag === 'ps-sync-queue') {
    event.waitUntil(flushOfflineQueue());
  }
});

self.addEventListener('push', (event) => {
  const data = event.data ? event.data.json() : {};
  const title = data.title || 'ParkShare';
  const body = data.body || 'Новые события по вашим бронированиям';
  const url = data.data?.url || data.url || '/map/';
  const actions = data.actions || [];
  event.waitUntil(
    self.registration.showNotification(title, {
      body,
      data: { url, ...data.data },
      icon: '/static/icons/icon-192.png',
      badge: '/static/icons/icon-72.png',
      actions,
    })
  );
});

self.addEventListener('notificationclick', (event) => {
  const targetUrl = event.notification?.data?.url || '/map/';
  event.notification.close();
  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      for (const client of clientList) {
        if ('focus' in client) {
          client.navigate(targetUrl);
          return client.focus();
        }
      }
      return clients.openWindow(targetUrl);
    })
  );
});

async function precacheShell() {
  const cache = await caches.open(PUBLIC_PAGE_CACHE);
  await cache.addAll(APP_SHELL);
}

function isApiRequest(url) {
  return url.pathname.startsWith('/api/');
}

function isPrivateApi(url) {
  if (!isApiRequest(url)) return false;
  return (
    url.pathname.includes('/favorites/') ||
    url.pathname.includes('/saved-places/') ||
    url.pathname.includes('/push-subscriptions/') ||
    url.pathname.includes('/accounts/profile') ||
    url.pathname.includes('/ai/parkmate/config')
  );
}

function isPwaShell(url) {
  return SHELL_ROUTES.some((route) => url.pathname.startsWith(route));
}

function isMapTile(url) {
  return url.hostname.includes('tile') || url.pathname.includes('/tiles/') || url.pathname.match(/\/(\d+)\/(\d+)\/(\d+)\.png/);
}

function isAsset(url) {
  return (
    url.pathname.startsWith('/static/') ||
    url.pathname.match(/\.(?:js|css|png|svg|webp|jpg|jpeg|woff2?)$/)
  );
}

async function cacheFirst(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  if (cached) return cached;
  const response = await fetch(request);
  if (response && response.ok) {
    cache.put(request, response.clone());
  }
  return response;
}

async function networkFirstPrivate(request, cacheName) {
  const cache = await caches.open(cacheName);
  try {
    const response = await fetch(request);
    if (response && response.ok) {
      const stamped = stampResponse(response);
      await cache.put(request, stamped.clone());
      await trimCache(cacheName, PRIVATE_MAX_ENTRIES);
    }
    return response;
  } catch (err) {
    const cached = await cache.match(request);
    if (cached && !isExpired(cached, PRIVATE_TTL_MS)) return cached;
    throw err;
  }
}

async function staleWhileRevalidate(request, cacheName) {
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  const network = fetch(request)
    .then((response) => {
      if (response && response.ok) {
        cache.put(request, response.clone());
      }
      return response;
    })
    .catch(() => cached);
  return cached || network;
}

async function handleHtmlRequest(request, cacheName) {
  if (!cacheName) {
    return fetch(request).catch(async () => (await caches.match(OFFLINE_URL)) || Response.error());
  }
  const cache = await caches.open(cacheName);
  try {
    const response = await fetch(request);
    if (response && response.ok) {
      await cache.put(request, response.clone());
    }
    return response;
  } catch (_) {
    const cached = await cache.match(request);
    if (cached) return cached;
    const fallback = await caches.match(OFFLINE_URL);
    if (fallback) return fallback;
    return Response.error();
  }
}

async function limitCacheSize(responsePromise, maxEntries = 150) {
  const response = await responsePromise;
  const cache = await caches.open(MAP_CACHE);
  const keys = await cache.keys();
  if (keys.length > maxEntries) {
    await cache.delete(keys[0]);
  }
  return response;
}

async function flushOfflineQueue() {
  const queue = await loadQueue();
  const stillPending = [];
  for (const item of queue) {
    try {
      await fetch(item.url, item.options);
    } catch (err) {
      if ((item.attempts || 0) < 3) {
        stillPending.push({ ...item, attempts: (item.attempts || 0) + 1 });
      }
    }
  }
  await saveQueue(stillPending);
}

async function loadQueue() {
  try {
    const cache = await caches.open(RUNTIME_CACHE);
    const stored = await cache.match('ps-offline-queue');
    if (!stored) return [];
    const payload = await stored.json();
    const cutoff = Date.now() - 24 * 60 * 60 * 1000;
    return (payload || []).filter((item) => (item.created_at || 0) > cutoff).slice(-50);
  } catch (_) {
    return [];
  }
}

async function saveQueue(payload) {
  const cache = await caches.open(RUNTIME_CACHE);
  const limited = (payload || []).slice(-50);
  await cache.put('ps-offline-queue', new Response(JSON.stringify(limited)));
}

function stampResponse(response) {
  const headers = new Headers(response.headers);
  headers.set('X-SW-Timestamp', Date.now().toString());
  return new Response(response.clone().body, {
    status: response.status,
    statusText: response.statusText,
    headers,
  });
}

function isExpired(response, ttlMs) {
  const ts = Number(response.headers.get('X-SW-Timestamp') || 0);
  if (!ts) return true;
  return Date.now() - ts > ttlMs;
}

async function trimCache(cacheName, maxEntries) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  if (keys.length > maxEntries) {
    await cache.delete(keys[0]);
  }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 259
PATH: static\css\app.css
LANG: css
===== CONTENT START =====
/* ---------- Tokens ---------- */

:root {
    color-scheme: light;

    --ps-bg: #f4f6fb;
    --ps-bg-elevated: #ffffff;
    --ps-bg-card: #ffffff;
    --ps-bg-nav: rgba(246, 248, 252, 0.92);

    --ps-text-primary: #0b1628;
    --ps-text-secondary: #1f2b3c;
    --ps-text-muted: #6b7280;

    --ps-border-subtle: rgba(12, 18, 32, 0.08);
    --ps-border-strong: rgba(12, 18, 32, 0.14);

    --ps-accent: #4fc3ff;
    --ps-accent-soft: rgba(79, 195, 255, 0.16);
    --ps-accent-on-dark: #9fe2ff;
    --ps-brand-google: #4285f4;
    --ps-brand-vk: #4c75a3;
    --ps-brand-yandex: #ffcc00;

    --ps-success: #22c55e;
    --ps-warning: #f5a524;
    --ps-danger: #ef4444;

    --ps-radius-card: 24px;
    --ps-radius-soft: 16px;
    --ps-radius-pill: 999px;

    --ps-shadow-card: 0 14px 38px rgba(15, 23, 42, 0.12);
    --ps-shadow-nav: 0 10px 28px rgba(15, 23, 42, 0.12);

    --ps-font-family: "SF Pro Display", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;

    --ps-topbar-height: 68px;
    --ps-bottom-bar-height: 72px;
    --ps-safe-area-bottom: env(safe-area-inset-bottom);
}

[data-theme="dark"] {
    color-scheme: dark;

    --ps-bg: #050910;
    --ps-bg-elevated: #0a0f19;
    --ps-bg-card: #0f1624;
    --ps-bg-nav: rgba(6, 10, 18, 0.92);

    --ps-text-primary: #e9edf5;
    --ps-text-secondary: #cfd6e7;
    --ps-text-muted: #9aa3b8;

    --ps-border-subtle: rgba(255, 255, 255, 0.08);
    --ps-border-strong: rgba(255, 255, 255, 0.16);

    --ps-accent: #5dd6ff;
    --ps-accent-soft: rgba(93, 214, 255, 0.18);
    --ps-accent-on-dark: #b6e6ff;

    --ps-shadow-card: 0 18px 46px rgba(0, 0, 0, 0.5);
    --ps-shadow-nav: 0 12px 38px rgba(0, 0, 0, 0.45);
}

@media (min-width: 768px) {
    :root {
        --ps-topbar-height: 72px;
    }
}

/* ---------- Base ---------- */

*,
*::before,
*::after {
    box-sizing: border-box;
}

body.ps-body {
    margin: 0;
    min-height: 100vh;
    font-family: var(--ps-font-family);
    font-size: 15px;
    line-height: 1.6;
    color: var(--ps-text-primary);
    background: var(--ps-bg);
    -webkit-font-smoothing: antialiased;
    padding-bottom: calc(var(--ps-bottom-bar-height) + env(safe-area-inset-bottom));
}

.ps-app {
    min-height: 100vh;
    background: var(--ps-bg);
}

a {
    color: inherit;
    text-decoration: none;
}

.ps-icon {
    width: 20px;
    height: 20px;
    display: inline-block;
}

/* ---------- Top bar ---------- */

.ps-topbar {
    position: sticky;
    top: 0;
    z-index: 40;
    background: var(--ps-bg-nav);
    backdrop-filter: blur(16px);
    border-bottom: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-nav);
}

.ps-topbar__safe {
    padding-top: env(safe-area-inset-top);
}

.ps-topbar__row {
    height: var(--ps-topbar-height);
    padding: 0 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
}

.ps-brand {
    display: flex;
    flex-direction: column;
    gap: 2px;
    color: var(--ps-text-primary);
}

.ps-brand__title {
    font-weight: 800;
    font-size: 1.5rem;
    letter-spacing: -0.02em;
}

.ps-brand__region {
    display: inline-flex;
    align-items: center;
    width: fit-content;
    padding: 2px 10px;
    border-radius: var(--ps-radius-pill);
    background: var(--ps-accent-soft);
    color: var(--ps-text-secondary);
    border: 1px solid var(--ps-border-subtle);
    font-size: 0.78rem;
}

.ps-topbar__actions {
    display: inline-flex;
    align-items: center;
    gap: 10px;
}

.ps-icon-btn {
    width: 42px;
    height: 42px;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.08);
}

.ps-icon-btn:hover {
    transform: translateY(-1px);
    border-color: var(--ps-border-strong);
}

[data-theme="dark"] .ps-icon-btn {
    background: var(--ps-bg-elevated);
    box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
}

.ps-icon-btn--ghost {
    background: transparent;
    border-color: var(--ps-border-subtle);
    box-shadow: none;
    color: var(--ps-text-secondary);
}

.ps-icon-moon {
    display: none;
}

[data-theme="dark"] .ps-icon-sun {
    display: none;
}

[data-theme="dark"] .ps-icon-moon {
    display: inline-block;
}

/* ---------- Layout ---------- */

.ps-main {
    max-width: 1200px;
    margin: 0 auto;
    padding: 1rem 1rem 2rem;
}

@media (min-width: 960px) {
    .ps-main {
        padding: 1.25rem 1.5rem 2.5rem;
    }
}

.ps-section {
    margin-bottom: 1.8rem;
}

.ps-section--flush-top {
    margin-top: 0.4rem;
}

.ps-section--narrow {
    max-width: 680px;
    margin: 0 auto 1.8rem;
}

.ps-section-header {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    align-items: flex-start;
    margin-bottom: 0.9rem;
}

.ps-section-header--stack {
    flex-direction: column;
    align-items: flex-start;
}

.ps-section-title {
    margin: 0 0 0.2rem;
    font-size: 1.2rem;
    font-weight: 700;
    letter-spacing: -0.01em;
}

.ps-section-subtitle {
    margin: 0;
    color: var(--ps-text-muted);
    font-size: 0.92rem;
    line-height: 1.4;
}

.ps-section-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.ps-section-actions--link {
    margin-bottom: 0.6rem;
}

.ps-section-subheader {
    margin: 0.6rem 0 0.4rem;
}

.ps-section-title-sm {
    margin: 0;
    font-size: 1rem;
    font-weight: 700;
}

.ps-stack {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.ps-grid {
    display: grid;
    gap: 1rem;
}

.ps-grid--2col {
    grid-template-columns: repeat(2, minmax(0, 1fr));
}

.ps-grid--gap-lg {
    gap: 1.25rem;
}

@media (max-width: 768px) {
    .ps-section-header {
        flex-direction: column;
    }
    .ps-grid--2col {
        grid-template-columns: 1fr;
    }
}

.ps-landing {
    display: grid;
    gap: 1.1rem;
}

.ps-landing__head {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 0.85rem;
}

.ps-landing__title {
    margin: 0;
    font-size: 1.55rem;
    font-weight: 800;
    letter-spacing: -0.02em;
}

.ps-landing__subtitle {
    margin: 0.2rem 0 0;
    color: var(--ps-text-muted);
    font-size: 0.95rem;
}

@media (max-width: 768px) {
    .ps-landing__head {
        flex-direction: column;
        align-items: flex-start;
    }
    .ps-landing__title {
        font-size: 1.4rem;
    }
}

/* ---------- Typography helpers ---------- */

.ps-kicker {
    text-transform: uppercase;
    letter-spacing: 0.18em;
    font-size: 0.72rem;
    color: var(--ps-text-muted);
    margin: 0 0 0.3rem;
    font-weight: 700;
}

.ps-text-muted {
    color: var(--ps-text-muted);
}

.ps-label {
    color: var(--ps-text-muted);
    font-size: 0.86rem;
}

/* ---------- Buttons ---------- */

.ps-btn {
    border: 1px solid transparent;
    border-radius: var(--ps-radius-pill);
    padding: 0.58rem 1.25rem;
    font-weight: 600;
    font-size: 0.96rem;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.45rem;
    background: var(--ps-accent);
    color: #04121f;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12);
    transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease, filter 0.2s ease;
}

.ps-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 16px 36px rgba(0, 0, 0, 0.16);
}

.ps-btn:active {
    transform: translateY(0);
}

.ps-btn-primary {
    background: var(--ps-accent);
    color: #04121f;
}

.ps-btn-secondary {
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: none;
}

.ps-btn-ghost {
    background: transparent;
    color: var(--ps-text-secondary);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: none;
}

.ps-btn-sm {
    padding: 0.38rem 0.85rem;
    font-size: 0.85rem;
}

.ps-btn-xs {
    padding: 0.25rem 0.7rem;
    font-size: 0.78rem;
}

.ps-btn-lg {
    padding: 0.65rem 1.3rem;
    font-size: 1rem;
}

.ps-btn-full,
.ps-btn-block {
    width: 100%;
}

.ps-btn[disabled],
.ps-btn[aria-disabled="true"] {
    opacity: 0.6;
    cursor: not-allowed;
    box-shadow: none;
}

/* ---------- Inputs & forms ---------- */

.ps-form {
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
}

.ps-form-row {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.ps-form-label {
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

.ps-input {
    width: 100%;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    padding: 0.55rem 0.75rem;
    font-size: 0.95rem;
    transition: border-color 0.15s ease, box-shadow 0.2s ease, background-color 0.15s ease;
}

.ps-input:focus {
    outline: none;
    border-color: var(--ps-accent);
    box-shadow: 0 0 0 3px var(--ps-accent-soft);
}

.ps-input--pill {
    border-radius: var(--ps-radius-pill);
}

[data-theme="dark"] .ps-input {
    background: var(--ps-bg-elevated);
}

.ps-field-help {
    font-size: 0.8rem;
    color: var(--ps-text-muted);
}

.ps-field-error {
    font-size: 0.8rem;
    color: var(--ps-danger);
}

.ps-form-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.ps-checkbox {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    color: var(--ps-text-secondary);
    font-size: 0.9rem;
}

.ps-checkbox input {
    width: 18px;
    height: 18px;
}

.ps-checkbox--inline {
    justify-content: flex-end;
}

.ps-form-row--inline {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 0.5rem;
}

.ps-form-compact .ps-form-row {
    gap: 0.2rem;
}

@media (max-width: 640px) {
    .ps-form-row--inline {
        grid-template-columns: 1fr;
    }
}

/* ---------- Cards & badges ---------- */

.ps-card {
    background: var(--ps-bg-card);
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    padding: 1rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-card--elevated {
    box-shadow: 0 22px 48px rgba(0, 0, 0, 0.12);
}

.ps-card-header {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    align-items: center;
    margin-bottom: 0.6rem;
}

.ps-card-title {
    margin: 0;
    font-size: 1.05rem;
    font-weight: 700;
}

.ps-card-body {
    display: grid;
    gap: 0.35rem;
    font-size: 0.95rem;
}

.ps-card-body--spacing-lg {
    gap: 0.75rem;
}

.ps-card-line {
    margin: 0;
}

.ps-card-line--muted {
    color: var(--ps-text-muted);
}

.ps-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 0.15rem 0.55rem;
    border-radius: var(--ps-radius-pill);
    font-size: 0.78rem;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-secondary);
}

.ps-badge--success {
    background: rgba(34, 197, 94, 0.15);
    border-color: rgba(34, 197, 94, 0.35);
    color: var(--ps-text-primary);
}

.ps-badge--neutral {
    background: rgba(148, 163, 184, 0.16);
    border-color: rgba(148, 163, 184, 0.26);
}

.ps-badge--status-confirmed,
.ps-badge--status-active {
    background: rgba(34, 197, 94, 0.16);
    border-color: rgba(34, 197, 94, 0.4);
}

.ps-badge--status-cancelled {
    background: rgba(239, 68, 68, 0.14);
    border-color: rgba(239, 68, 68, 0.35);
}

/* ---------- Lists & table ---------- */

.ps-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.ps-list-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    padding: 0.65rem 0;
    border-bottom: 1px solid var(--ps-border-subtle);
}

.ps-list-title {
    font-weight: 600;
    font-size: 0.95rem;
}

.ps-list-subtitle {
    font-size: 0.85rem;
    color: var(--ps-text-muted);
}

.ps-list-empty {
    padding: 0.6rem 0;
    color: var(--ps-text-muted);
}

.ps-list-ordered {
    padding-left: 1.1rem;
    color: var(--ps-text-primary);
}

.ps-list-ordered li {
    margin-bottom: 0.35rem;
}

.ps-list--compact .ps-list-item {
    padding-block: 0.45rem;
}

.ps-payment-list {
    display: grid;
    gap: 0.6rem;
}

.ps-payment-card {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.6rem;
    padding: 0.65rem 0.75rem;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
}

.ps-payment-brand {
    font-weight: 700;
}

.ps-payment-meta {
    color: var(--ps-text-muted);
    font-size: 0.86rem;
}

.ps-payment-actions {
    display: flex;
    gap: 6px;
}

.ps-table-wrapper {
    overflow: auto;
}

.ps-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.94rem;
}

.ps-table th,
.ps-table td {
    padding: 0.65rem 0.5rem;
    text-align: left;
    border-bottom: 1px solid var(--ps-border-subtle);
}

.ps-table th {
    font-weight: 600;
    color: var(--ps-text-muted);
}

/* ---------- Progress ---------- */

.ps-progress {
    width: 100%;
    height: 8px;
    background: var(--ps-border-subtle);
    border-radius: 999px;
    overflow: hidden;
}

.ps-progress-bar {
    height: 100%;
    border-radius: inherit;
    background: linear-gradient(90deg, var(--ps-accent), #1c64f2);
    width: 40%;
}

.ps-progress-block {
    display: grid;
    gap: 0.4rem;
}

.ps-progress-header {
    display: flex;
    justify-content: space-between;
    color: var(--ps-text-muted);
    font-size: 0.86rem;
}

/* ---------- Search ---------- */

.ps-search-bar {
    display: flex;
    align-items: center;
    gap: 0.55rem;
    padding: 0.75rem 0.9rem;
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-pill);
    box-shadow: var(--ps-shadow-card);
}

.ps-search-bar--pill {
    border-radius: var(--ps-radius-pill);
}

.ps-search-icon {
    width: 42px;
    height: 42px;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: var(--ps-text-muted);
    cursor: pointer;
}

.ps-search-actions .ps-icon-btn {
    width: 42px;
    height: 42px;
}

.ps-search-input {
    border: none;
    background: transparent;
    font-size: 1rem;
    color: var(--ps-text-primary);
    width: 100%;
    outline: none;
}

.ps-search-actions {
    display: inline-flex;
    align-items: center;
    gap: 6px;
}

.ps-search-hint {
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

/* ---------- Map shell ---------- */

.ps-map-stack {
    display: grid;
    gap: 0.75rem;
}

@media (max-width: 768px) {
    .ps-map-stack {
        gap: 0.5rem;
        padding-bottom: 68vh;
    }
}

.ps-map-card {
    padding: 0.75rem 0.75rem 0.6rem;
    border-radius: var(--ps-radius-card);
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
    display: grid;
    gap: 0.6rem;
}

.ps-map-grid {
    display: grid;
    grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
    gap: 1rem;
}

.ps-map-hero {
    margin-top: 0.5rem;
}

@media (max-width: 960px) {
    .ps-map-grid {
        grid-template-columns: 1fr;
    }
}

.ps-map-panel {
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-card);
    padding: 0.5rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-map-card.ps-map-panel {
    padding: 0.75rem 0.75rem 0.6rem;
}

.ps-spots-panel {
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-card);
    padding: 0.9rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-spots-list {
    display: grid;
    gap: 0.75rem;
}

.ps-card--spot {
    padding: 0.9rem 1rem;
    position: relative;
}

.ps-card--spot.is-active {
    border-color: var(--ps-accent);
    box-shadow: 0 16px 36px rgba(79, 195, 255, 0.22);
}

.ps-card--spot::after {
    content: "›";
    position: absolute;
    right: 0.9rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--ps-text-muted);
    font-weight: 700;
}

.ps-spot-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
}

.ps-spot-price {
    font-weight: 700;
    font-size: 1rem;
}

.ps-spot-estimate {
    color: var(--ps-text-muted);
    font-size: 0.9rem;
}

.ps-map-wrapper {
    position: relative;
    overflow: hidden;
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
}

.ps-map {
    width: 100%;
    height: clamp(280px, 48vh, 420px);
    border-radius: inherit;
}

.ps-map-overlay {
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: linear-gradient(180deg, rgba(0, 0, 0, 0.05), transparent 32%, transparent 72%, rgba(0, 0, 0, 0.05));
}

.ps-map-floating-actions {
    position: absolute;
    top: 12px;
    right: 12px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 6px;
    border-radius: var(--ps-radius-soft);
    backdrop-filter: blur(12px);
    background: var(--ps-bg-nav);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
}

.ps-map-floating-actions.is-dimmed {
    opacity: 0.6;
}

.ps-map-action {
    width: 44px;
    height: 44px;
    border-radius: 14px;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    box-shadow: 0 10px 24px rgba(0, 0, 0, 0.08);
}

.ps-map-action:hover {
    transform: translateY(-1px);
    border-color: var(--ps-border-strong);
}

[data-theme="dark"] .ps-map-action {
    background: var(--ps-bg-card);
    box-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
}

.ps-map-action--spinning {
    animation: ps-spin 0.6s linear;
}

.ps-map-action--pulse {
    animation: ps-pulse 1.3s ease-out infinite;
}

.ps-map-loading {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.3);
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    letter-spacing: 0.02em;
}

.ps-map-topbar {
    position: absolute;
    top: 12px;
    left: 12px;
    right: 96px;
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 6px;
    border-radius: var(--ps-radius-soft);
    backdrop-filter: blur(12px);
    background: var(--ps-bg-nav);
    border: 1px solid var(--ps-border-subtle);
}

.ps-map-controls {
    display: grid;
    gap: 0.45rem;
}

.ps-map-chips {
    display: flex;
    gap: 8px;
    padding: 8px;
    overflow-x: auto;
    border-radius: var(--ps-radius-soft);
    background: var(--ps-bg-elevated);
    border: 1px solid var(--ps-border-subtle);
}

.ps-chip {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 0.35rem 0.75rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-secondary);
    cursor: pointer;
    font-size: 0.88rem;
    transition: border-color 0.15s ease, background-color 0.15s ease;
}

.ps-chip.is-active {
    background: var(--ps-accent-soft);
    border-color: var(--ps-accent);
}

.ps-chip--soft {
    background: var(--ps-accent-soft);
    border-color: transparent;
    color: var(--ps-text-secondary);
}

.ps-chip--ghost {
    background: transparent;
    border-style: dashed;
}

.ps-pill {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 0.25rem 0.6rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-secondary);
    font-size: 0.86rem;
}

.ps-pill svg {
    width: 16px;
    height: 16px;
}

.ps-pill--accent {
    border-color: var(--ps-accent);
    background: var(--ps-accent-soft);
}

.ps-pill--success {
    border-color: rgba(34, 197, 94, 0.4);
    background: rgba(34, 197, 94, 0.14);
}

.ps-map-filters {
    margin-top: 0.6rem;
}

.ps-map-filters-card {
    padding: 0.85rem;
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    display: grid;
    gap: 0.65rem;
}

.ps-map-filters-row {
    display: grid;
    gap: 0.5rem;
}

.ps-map-cta {
    margin-top: 0.75rem;
    display: flex;
    justify-content: flex-start;
}

.ps-map-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 0.4rem;
    color: var(--ps-text-muted);
    font-size: 0.86rem;
}

.ps-legend-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 0.35rem 0.55rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
}

.ps-legend-icon {
    width: 26px;
    height: 26px;
    border-radius: 10px;
    display: grid;
    place-items: center;
    background: var(--ps-accent-soft);
    color: var(--ps-text-primary);
}

.ps-legend-icon--allowed {
    background: var(--ps-accent-soft);
}

.ps-legend-icon--paid {
    background: rgba(79, 195, 255, 0.2);
}

.ps-legend-icon--forbidden {
    background: rgba(239, 68, 68, 0.18);
    color: var(--ps-danger);
}

.ps-legend-icon--covered {
    background: var(--ps-border-subtle);
    color: var(--ps-text-secondary);
}

.ps-legend-icon--ev {
    background: rgba(34, 197, 94, 0.18);
}

.ps-filter-slider {
    height: 6px;
    background: var(--ps-border-subtle);
    border-radius: 999px;
}

.ps-filter-price {
    font-size: 0.88rem;
    color: var(--ps-text-muted);
}

.ps-geocode-suggestions {
    margin-top: 0.4rem;
    display: grid;
    gap: 6px;
}

.ps-geocode-suggestions button {
    padding: 0.55rem 0.75rem;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    cursor: pointer;
    text-align: left;
}

.ps-route-hint {
    margin-top: 0.35rem;
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

.ps-map-popup {
    min-width: 240px;
    border-radius: 16px;
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
    padding: 0.75rem;
}

.ps-map-popup-title {
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 4px;
}

.ps-map-popup-meta {
    font-size: 0.82rem;
    color: var(--ps-text-muted);
}

.ps-map-popup-price {
    font-size: 0.95rem;
    margin: 8px 0;
    color: var(--ps-text-secondary);
}

.ps-map-popup-badges {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}

.ps-map-popup-meter {
    margin-top: 8px;
    background: var(--ps-border-subtle);
    height: 6px;
    border-radius: 999px;
    position: relative;
}

.ps-map-popup-meter span {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    border-radius: inherit;
    background: var(--ps-accent);
}

.ps-map-popup-actions {
    display: flex;
    gap: 6px;
    margin-top: 10px;
}

.ps-map-popup-meter-label {
    font-size: 0.8rem;
    color: var(--ps-text-muted);
    margin-top: 4px;
}

.ps-map-popup--list .ps-map-popup {
    margin-bottom: 8px;
}

.ps-map-marker {
    position: relative;
    width: 44px;
    height: 44px;
    display: grid;
    place-items: center;
}

.ps-map-marker__body {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    color: #0b1220;
    display: grid;
    place-items: center;
    font-weight: 800;
    font-size: 0.9rem;
    background: var(--ps-accent);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2);
}

.ps-map-marker__value {
    line-height: 1;
}

.ps-map-marker__halo {
    position: absolute;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: var(--ps-accent-soft);
    filter: blur(0.5px);
    z-index: -1;
}

.ps-map-marker--hot .ps-map-marker__body {
    background: var(--ps-success);
}

.ps-map-marker--active .ps-map-marker__body {
    transform: scale(1.05);
}

.ps-map-marker-wrap.is-active .ps-map-marker__body {
    transform: scale(1.08);
    box-shadow: 0 18px 40px rgba(34, 197, 94, 0.35);
}

.ps-map-cluster {
    width: 48px;
    height: 48px;
    border-radius: 16px;
    display: grid;
    place-items: center;
    background: var(--ps-accent);
    color: #0b1220;
    font-weight: 700;
    box-shadow: 0 16px 36px rgba(0, 0, 0, 0.25);
}

.ps-map-cluster--warn {
    background: var(--ps-warning);
}

.ps-map-cluster--danger {
    background: var(--ps-danger);
    color: #fff;
}

.ps-map-card .ps-map {
    border: none;
}


/* ---------- Recommendations & cards ---------- */

.ps-reco-list {
    display: grid;
    gap: 0.85rem;
}

.ps-reco-card {
    padding: 0.9rem 1rem;
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
}

.ps-reco-meta {
    color: var(--ps-text-muted);
    font-size: 0.9rem;
}

.ps-reco-title {
    font-size: 1rem;
    font-weight: 700;
    margin-bottom: 4px;
}

.ps-reco-actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
    margin-top: 0.35rem;
}

/* ---------- AI assistant ---------- */

.ps-ai-shell {
    background: linear-gradient(135deg, rgba(79, 139, 255, 0.08), rgba(10, 14, 24, 0.02));
    border-radius: var(--ps-radius-card);
    padding: 1.2rem;
    border: 1px solid var(--ps-border-subtle);
}

.ps-assistant-card {
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
}

.ps-ai-grid {
    display: grid;
    gap: 1rem;
    grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
}

@media (max-width: 960px) {
    .ps-ai-grid {
        grid-template-columns: 1fr;
    }
}

.ps-ai-chat {
    border-radius: var(--ps-radius-card);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    display: grid;
    grid-template-rows: auto 1fr auto;
    min-height: 420px;
    box-shadow: var(--ps-shadow-card);
}

.ps-ai-chat__header {
    padding: 0.9rem 1rem;
    border-bottom: 1px solid var(--ps-border-subtle);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
}

.ps-ai-actions {
    display: flex;
    gap: 0.4rem;
    align-items: center;
}

.ps-ai-prompts {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.ps-ai-prompts--inline {
    margin-top: 0;
    margin-bottom: 0.35rem;
}

.ps-ai-summary .ps-card {
    height: 100%;
}

.ps-ai-title {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 700;
}

.ps-ai-subtitle {
    margin: 0.15rem 0 0;
    color: var(--ps-text-muted);
}

.ps-ai-chat__body {
    padding: 0.9rem 1rem;
    overflow: auto;
    display: grid;
    gap: 0.65rem;
    background: linear-gradient(180deg, var(--ps-bg-card) 0%, var(--ps-bg-elevated) 100%);
}

.ps-ai-status {
    font-size: 0.85rem;
    color: var(--ps-text-muted);
}

.ps-ai-status.is-error {
    color: var(--ps-danger);
}

.ps-ai-messages {
    display: grid;
    gap: 0.65rem;
}

.ps-ai-bubble {
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    padding: 0.85rem;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.07);
}

.ps-ai-bubble--user {
    background: linear-gradient(135deg, var(--ps-accent-soft), var(--ps-bg-card));
    border-color: var(--ps-accent);
}

.ps-ai-meta {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    margin-bottom: 0.35rem;
    color: var(--ps-text-muted);
    font-size: 0.8rem;
}

.ps-ai-text {
    white-space: pre-wrap;
    line-height: 1.5;
    color: var(--ps-text-primary);
}

.ps-ai-actions-row {
    display: flex;
    gap: 0.4rem;
    margin-top: 0.4rem;
}

.ps-ai-input {
    padding: 0.9rem 1rem 1rem;
    border-top: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    display: grid;
    gap: 0.45rem;
}

.ps-ai-input__actions {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.75rem;
    flex-wrap: wrap;
}

.ps-ai-buttons {
    display: flex;
    gap: 0.4rem;
    align-items: center;
}

.ps-ai-hint {
    font-size: 0.82rem;
    color: var(--ps-text-muted);
}

/* ---------- Auth ---------- */

.ps-auth {
    min-height: calc(100vh - var(--ps-topbar-height) - 120px);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1.4rem;
}

.ps-auth-card {
    width: min(460px, 100%);
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: var(--ps-radius-card);
    padding: 1.25rem;
    box-shadow: var(--ps-shadow-card);
}

.ps-auth-title {
    margin: 0 0 0.35rem;
    font-size: 1.35rem;
}

.ps-auth-subtitle {
    margin: 0 0 1rem;
    color: var(--ps-text-muted);
}

.ps-auth-tabs {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    margin-bottom: 12px;
}

.ps-auth-tabs button {
    padding: 0.45rem 0.35rem;
    border-radius: 12px;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-primary);
    cursor: pointer;
    font-weight: 600;
}

.ps-auth-tabs button.is-active {
    border-color: var(--ps-accent);
    background: var(--ps-accent-soft);
    box-shadow: 0 8px 18px rgba(79, 139, 255, 0.15);
}

.ps-auth-panel {
    display: none;
}

.ps-auth-panel.is-active {
    display: block;
}

.ps-auth-placeholder {
    padding: 1rem;
    border: 1px dashed var(--ps-border-subtle);
    border-radius: var(--ps-radius-soft);
    color: var(--ps-text-muted);
    display: grid;
    gap: 0.5rem;
    text-align: center;
}

.ps-auth-footer {
    margin-top: 0.75rem;
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

.ps-social-banners {
    display: grid;
    gap: 0.65rem;
}

.ps-social-banner {
    position: relative;
    display: flex;
    align-items: center;
    gap: 14px;
    padding: 0.85rem 0.9rem 0.85rem 1.1rem;
    border-radius: 16px;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    box-shadow: 0 16px 36px rgba(15, 23, 42, 0.1);
    transition: transform 0.15s ease, box-shadow 0.2s ease, border-color 0.2s ease;
}

.ps-social-banner::after {
    content: "→";
    margin-left: auto;
    font-weight: 700;
    color: var(--ps-text-muted);
}

.ps-social-banner:hover {
    transform: translateY(-1px);
    box-shadow: 0 20px 44px rgba(15, 23, 42, 0.14);
    border-color: var(--ps-border-strong);
}

.ps-social-banner__stripe {
    width: 64px;
    min-width: 64px;
    height: 52px;
    border-radius: 14px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    color: #0b1628;
    background: #fff;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.05);
}

.ps-social-banner__text {
    display: grid;
    gap: 2px;
    line-height: 1.2;
}

.ps-social-banner__title {
    font-weight: 700;
    font-size: 0.98rem;
}

.ps-social-banner__hint {
    color: var(--ps-text-muted);
    font-size: 0.82rem;
}

.ps-social-banner--google {
    border-color: rgba(66, 133, 244, 0.16);
    background: linear-gradient(90deg, rgba(66, 133, 244, 0.06), rgba(255, 255, 255, 0.9));
}

.ps-social-banner--google .ps-social-banner__stripe {
    background: #fff;
}

.ps-social-banner--vk {
    border-color: rgba(76, 117, 163, 0.2);
    background: linear-gradient(90deg, rgba(76, 117, 163, 0.16), rgba(255, 255, 255, 0.92));
}

.ps-social-banner--vk .ps-social-banner__stripe {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.28));
    color: #fff;
}

.ps-social-banner--yandex {
    border-color: rgba(255, 204, 0, 0.18);
    background: linear-gradient(90deg, rgba(255, 204, 0, 0.22), rgba(255, 255, 255, 0.94));
}

.ps-social-banner--yandex .ps-social-banner__stripe {
    background: #ffcc00;
    color: #111;
    box-shadow: none;
}

.ps-social-banner svg {
    width: 26px;
    height: 26px;
}

.ps-social-banner.is-disabled {
    opacity: 0.65;
    pointer-events: none;
}

[data-theme="dark"] .ps-social-banner {
    background: linear-gradient(120deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
    border-color: var(--ps-border-subtle);
    box-shadow: 0 20px 44px rgba(0, 0, 0, 0.5);
}

[data-theme="dark"] .ps-social-banner::after {
    color: var(--ps-text-secondary);
}

[data-theme="dark"] .ps-social-banner__stripe {
    box-shadow: none;
}

/* ---------- Toast & banners ---------- */

.ps-update-banner {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: var(--ps-bg-card);
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    margin-bottom: 1rem;
}

.ps-update-banner__text {
    font-weight: 600;
}

.ps-toast-container {
    position: fixed;
    inset-inline: 0;
    bottom: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
    padding: 0 0.75rem;
    z-index: 120;
}

.ps-toast {
    width: min(380px, 100%);
    align-self: center;
    padding: 0.65rem 0.8rem;
    border-radius: var(--ps-radius-soft);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    box-shadow: var(--ps-shadow-card);
}

.ps-toast--success {
    border-color: rgba(34, 197, 94, 0.45);
}

.ps-toast--error {
    border-color: rgba(239, 68, 68, 0.5);
}

.ps-toast-message {
    flex: 1;
}

.ps-toast-close {
    background: transparent;
    border: none;
    color: var(--ps-text-muted);
    cursor: pointer;
}

.ps-install-banner {
    position: fixed;
    inset-inline: 0.75rem;
    bottom: calc(var(--ps-bottom-bar-height) + 12px);
    z-index: 110;
    display: flex;
    justify-content: center;
    opacity: 0;
    transform: translateY(12px);
    transition: opacity 0.2s ease, transform 0.2s ease;
}

.ps-install-banner.is-visible {
    opacity: 1;
    transform: translateY(0);
}

.ps-install-banner__inner {
    max-width: 440px;
    width: 100%;
    padding: 0.85rem 1rem;
    border-radius: var(--ps-radius-card);
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    box-shadow: var(--ps-shadow-card);
    display: grid;
    gap: 0.5rem;
}

.ps-install-banner__actions {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

/* ---------- Onboarding ---------- */

.ps-onboarding {
    position: fixed;
    inset: 0;
    z-index: 300;
    display: none;
}
.ps-onboarding.is-visible {
    display: block;
}
.ps-onboarding__backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.55);
    backdrop-filter: blur(4px);
}
.ps-onboarding__card {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: min(480px, 92vw);
    background: var(--ps-bg-card);
    border-radius: var(--ps-radius-card);
    padding: 1.25rem;
    box-shadow: var(--ps-shadow-card);
}
.ps-onboarding__slide {
    display: none;
    gap: 0.35rem;
}
.ps-onboarding__slide.is-active {
    display: grid;
}
.ps-onboarding__actions {
    margin-top: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

/* ---------- Footer ---------- */

.ps-footer {
    padding: 1rem;
    border-top: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
}

.ps-footer__inner {
    max-width: 1200px;
    margin: 0 auto;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    color: var(--ps-text-muted);
    font-size: 0.88rem;
}

.ps-footer__meta {
    color: var(--ps-text-muted);
}

/* ---------- Back to top ---------- */

.ps-back-to-top {
    position: fixed;
    right: 1rem;
    bottom: 1.1rem;
    width: 40px;
    height: 40px;
    border-radius: 12px;
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-card);
    color: var(--ps-text-primary);
    display: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: var(--ps-shadow-card);
    z-index: 115;
}

.ps-back-to-top.is-visible {
    display: flex;
}

/* ---------- Bottom tab bar ---------- */

.ps-tabbar {
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;
    height: var(--ps-bottom-bar-height);
    background: var(--ps-bg-nav);
    border-top: 1px solid var(--ps-border-subtle);
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    box-shadow: 0 -12px 32px rgba(0, 0, 0, 0.08);
    z-index: 130;
    padding-bottom: env(safe-area-inset-bottom);
    padding-inline: max(0.5rem, env(safe-area-inset-left));
    backdrop-filter: blur(14px);
}

[data-theme="dark"] .ps-tabbar {
    background: rgba(8, 12, 22, 0.95);
    border-top-color: var(--ps-border-subtle);
    box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.5);
}

.ps-tabbar__item {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 6px;
    color: var(--ps-text-muted);
    font-size: 0.86rem;
    position: relative;
    font-weight: 600;
}

.ps-tabbar__item::before {
    content: "";
    position: absolute;
    top: 0;
    left: 22%;
    right: 22%;
    height: 3px;
    border-radius: 999px;
    background: transparent;
    transition: background 0.15s ease;
}

.ps-tabbar__item.is-active {
    color: var(--ps-text-primary);
    font-weight: 700;
}

.ps-tabbar__item.is-active::before {
    background: linear-gradient(90deg, var(--ps-accent), #3a7bff);
}

.ps-tabbar__icon .ps-icon {
    width: 24px;
    height: 24px;
}

@media (min-width: 1025px) {
    .ps-tabbar {
        display: none;
    }
    body.ps-body {
        padding-bottom: 0;
    }
}

/* ---------- Skeleton ---------- */

.ps-card--skeleton {
    position: relative;
    overflow: hidden;
}

.ps-card--skeleton::after {
    display: none;
}

.ps-skeleton-line {
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, rgba(0, 0, 0, 0.04), rgba(0, 0, 0, 0.08), rgba(0, 0, 0, 0.04));
    background-size: 200% 100%;
    animation: ps-shimmer 1.2s linear infinite;
    margin-bottom: 0.4rem;
}

.ps-skeleton-line--lg {
    width: 70%;
}

.ps-skeleton-line--short {
    width: 40%;
}

@keyframes ps-shimmer {
    0% {
        background-position: 200% 0;
    }
    100% {
        background-position: -200% 0;
    }
}

/* ---------- Chips & pill helpers ---------- */

.ps-chip-row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

/* ---------- Utility ---------- */

.ps-empty {
    color: var(--ps-text-muted);
    font-size: 0.9rem;
}

.ps-link {
    color: var(--ps-text-secondary);
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    text-decoration: none;
}

.ps-link:hover {
    color: var(--ps-text-primary);
}

.ps-link-arrow::after {
    content: "›";
    font-size: 1rem;
    color: inherit;
}

.ps-hint {
    font-size: 0.86rem;
    color: var(--ps-text-muted);
}

.ps-animate-fade-up {
    animation: ps-fade-up 0.35s ease-out both;
}

@keyframes ps-fade-up {
    from {
        opacity: 0;
        transform: translateY(6px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.ps-connection {
    display: inline-flex;
    align-items: center;
    padding: 0.35rem 0.6rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-muted);
    font-size: 0.85rem;
}

@keyframes ps-spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

@keyframes ps-pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.06); }
    100% { transform: scale(1); }
}

/* ---------- Responsive tweaks ---------- */

@media (max-width: 640px) {
    .ps-main {
        padding-inline: 0.85rem;
    }
    .ps-map-topbar {
        position: static;
        flex-direction: column;
        width: 100%;
    }
.ps-map {
        height: clamp(240px, 46vh, 340px);
    }
}

/* ---------- Bottom sheet (mobile) ---------- */

.ps-bottom-sheet {
    position: relative;
    background: var(--ps-bg-card);
    border: 1px solid var(--ps-border-subtle);
    border-radius: 22px 22px 14px 14px;
    box-shadow: var(--ps-shadow-card);
    display: grid;
    grid-template-rows: auto 1fr;
    min-height: 220px;
}

.ps-bottom-sheet__handle {
    width: 56px;
    height: 6px;
    border-radius: 999px;
    background: var(--ps-border-subtle);
    margin: 10px auto 6px auto;
}

.ps-bottom-sheet__header {
    display: flex;
    justify-content: space-between;
    padding: 0 1rem 0.6rem;
    align-items: flex-start;
    gap: 0.75rem;
}

.ps-bottom-sheet__title {
    display: grid;
    gap: 4px;
}

.ps-bottom-sheet__actions {
    display: flex;
    gap: 0.4rem;
    align-items: center;
}

.ps-bottom-sheet__body {
    padding: 0 1rem 1rem;
    overflow: auto;
}

.ps-bottom-sheet__metrics {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    color: var(--ps-text-secondary);
    font-size: 0.9rem;
}

.ps-bottom-sheet__metric {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 0.3rem 0.55rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
}

.ps-sheet-back {
    display: none;
    align-items: center;
    gap: 6px;
    padding: 0.4rem 0.7rem;
    border-radius: var(--ps-radius-pill);
    border: 1px solid var(--ps-border-subtle);
    background: var(--ps-bg-elevated);
    color: var(--ps-text-secondary);
    font-weight: 600;
    cursor: pointer;
}

@media (max-width: 900px) {
    .ps-bottom-sheet--floating {
        position: fixed;
        left: max(0.5rem, env(safe-area-inset-left));
        right: max(0.5rem, env(safe-area-inset-right));
        bottom: calc(var(--ps-bottom-bar-height, 72px) - 10px);
        height: var(--ps-sheet-height, 82vh);
        max-height: calc(var(--ps-viewport-height, 100vh) - 32px);
        transform: translateY(var(--ps-sheet-shift, 0px));
        transition: transform 0.26s ease, height 0.18s ease, box-shadow 0.26s ease, border-color 0.2s ease;
        z-index: 90;
        padding-bottom: calc(var(--ps-safe-area-bottom, 0px) + 10px);
        box-shadow: 0 18px 44px rgba(0, 0, 0, 0.24);
    }

    .ps-bottom-sheet--floating[data-sheet-state="collapsed"] {
        --ps-sheet-shift: calc(var(--ps-sheet-height, 82vh) - var(--ps-sheet-collapsed, 86px));
        box-shadow: 0 14px 28px rgba(0, 0, 0, 0.22);
    }

    .ps-bottom-sheet--floating[data-sheet-state="half"] {
        --ps-sheet-shift: calc(var(--ps-sheet-height, 82vh) * 0.46);
    }

    .ps-bottom-sheet--floating[data-sheet-state="full"] {
        --ps-sheet-shift: 0px;
        height: calc(var(--ps-viewport-height, 100vh) - var(--ps-sheet-top-offset, 68px));
        max-height: calc(var(--ps-viewport-height, 100vh) - var(--ps-sheet-top-offset, 68px));
        border-radius: 18px 18px 0 0;
    }

    .ps-bottom-sheet--floating[data-sheet-state="collapsed"] .ps-bottom-sheet__body {
        pointer-events: none;
        opacity: 0.82;
    }

    .ps-bottom-sheet__body {
        padding-bottom: max(env(safe-area-inset-bottom, 0px) + 8px, 18px);
    }

    .ps-bottom-sheet--floating[data-sheet-state="full"] .ps-sheet-back {
        display: inline-flex;
    }
}

@media (max-height: 480px) {
    .ps-bottom-sheet--floating {
        height: var(--ps-sheet-height, 74vh);
    }
    .ps-bottom-sheet--floating[data-sheet-state="collapsed"] {
        --ps-sheet-collapsed: 64px;
    }
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 260
PATH: static\css\cinematic-ui.css
LANG: css
===== CONTENT START =====
:root {
  --cinematic-glow: radial-gradient(circle at center,
      rgba(100, 200, 255, 0.4) 0%,
      transparent 70%);
  --hologram-effect: linear-gradient(45deg,
      transparent 30%,
      rgba(255, 255, 255, 0.1) 50%,
      transparent 70%);
  --quantum-shadow: 0 0 40px rgba(100, 200, 255, 0.3),
      0 0 80px rgba(100, 200, 255, 0.2),
      0 0 120px rgba(100, 200, 255, 0.1);
  --hologram-glow: rgba(0, 255, 255, 0.8);
}

@property --hologram-glow {
  syntax: '<color>';
  inherits: false;
  initial-value: rgba(0, 255, 255, 0.8);
}

.cinematic-surface {
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, rgba(12, 19, 39, 0.9), rgba(6, 11, 25, 0.9));
  border: 1px solid rgba(255, 255, 255, 0.04);
  box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55), var(--quantum-shadow);
}

.cinematic-surface::before {
  content: "";
  position: absolute;
  inset: -1px;
  background: var(--cinematic-glow);
  filter: blur(38px);
  opacity: 0.55;
  pointer-events: none;
}

.cinematic-surface::after {
  content: "";
  position: absolute;
  inset: 0;
  background: var(--hologram-effect);
  opacity: 0.35;
  mix-blend-mode: screen;
  pointer-events: none;
}

.cinematic-button,
.quantum-toggle {
  background: radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.35), rgba(14, 165, 233, 0.12));
  box-shadow: 0 10px 30px rgba(14, 165, 233, 0.35), 0 20px 60px rgba(6, 182, 212, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.08);
  color: #e0f2fe;
  padding: 0.5rem 0.9rem;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.cinematic-button::after,
.quantum-toggle::after {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(120deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0));
  opacity: 0;
  transition: opacity 0.35s ease;
}

.cinematic-button:hover::after,
.quantum-toggle:hover::after {
  opacity: 1;
}

.cinematic-marker {
  animation: hologram-float 3s ease-in-out infinite;
  filter: drop-shadow(0 0 20px var(--hologram-glow));
}

.quantum-pulse {
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: inherit;
  background: radial-gradient(circle at 50% 45%, rgba(56, 189, 248, 0.15), transparent 60%);
  animation: quantum-breathe 6s ease-in-out infinite;
}

.ai-forecast {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 0.5rem;
  margin-top: 0.35rem;
}

.ai-forecast-metric {
  padding: 0.55rem 0.65rem;
  border-radius: 0.75rem;
  border: 1px solid rgba(59, 130, 246, 0.2);
  background: rgba(15, 23, 42, 0.8);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

.ai-forecast-label {
  font-size: 0.7rem;
  color: #cbd5e1;
  display: block;
  margin-bottom: 0.15rem;
}

.ai-forecast-value {
  font-weight: 700;
  font-size: 0.95rem;
  letter-spacing: 0.01em;
}

.ai-reasoning {
  margin-top: 0.5rem;
  padding: 0.55rem 0.6rem;
  border-radius: 0.75rem;
  border: 1px dashed rgba(255, 255, 255, 0.16);
  color: #e2e8f0;
  background: rgba(79, 70, 229, 0.08);
}

@keyframes hologram-float {
  0% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
  100% { transform: translateY(0); }
}

@keyframes quantum-breathe {
  0% { opacity: 0.2; }
  50% { opacity: 0.55; }
  100% { opacity: 0.2; }
}

[data-quantum-theme="dark"] body,
body[data-quantum-theme="dark"] {
  background: radial-gradient(circle at top left, #0b1224 0%, #030712 45%, #01030a 100%);
}

[data-quantum-theme="light"] body,
body[data-quantum-theme="light"] {
  background: radial-gradient(circle at top left, #f8fafc 0%, #e2e8f0 40%, #cbd5e1 100%);
  color: #0f172a;
}

.ai-crest {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  padding: 0.35rem 0.8rem;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.14);
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.18), rgba(16, 185, 129, 0.16));
  box-shadow: 0 18px 45px rgba(15, 23, 42, 0.5);
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 261
PATH: static\js\app.js
LANG: javascript
===== CONTENT START =====
(function () {
    "use strict";

    window.ParkShare = window.ParkShare || {};

    // ---------- Helpers ----------

    function qs(selector, scope) {
        return (scope || document).querySelector(selector);
    }

    function qsa(selector, scope) {
        return Array.prototype.slice.call((scope || document).querySelectorAll(selector));
    }

    function isMobileWidth() {
        return window.matchMedia("(max-width: 767px)").matches;
    }

    // ---------- Service worker (registration is idempotent, PWA layer can override) ----------

    if ("serviceWorker" in navigator && !window.__PS_PWA_REGISTERED__) {
        window.__PS_PWA_REGISTERED__ = true;
        window.addEventListener("load", function () {
            navigator.serviceWorker
                .register("/service-worker.js", {updateViaCache: "none"})
                .then(function (reg) {
                    console.log("[SW] registered (legacy entry)", reg.scope);
                })
                .catch(function (err) {
                    console.warn("[SW] registration failed", err);
                });
        });
    }

    // ---------- Mobile menu ----------

    function initMenu() {
        const toggle = qs("[data-menu-toggle]");
        const menu = qs("[data-menu]");

        if (!toggle || !menu) return;

        function syncAria(isOpen) {
            toggle.setAttribute("aria-expanded", String(isOpen));
            toggle.setAttribute("aria-label", isOpen ? "Закрыть меню" : "Открыть меню");
        }

        toggle.addEventListener("click", function () {
            const isOpen = toggle.classList.toggle("is-open");
            menu.classList.toggle("is-open", isOpen);
            document.body.classList.toggle("ps-menu-open", isOpen);
            syncAria(isOpen);
        });

        syncAria(toggle.classList.contains("is-open"));

        // закрывать по клику на ссылку (на мобиле)
        qsa(".ps-nav-link", menu).forEach(function (link) {
            link.addEventListener("click", function () {
                toggle.classList.remove("is-open");
                menu.classList.remove("is-open");
                document.body.classList.remove("ps-menu-open");
                syncAria(false);
            });
        });
    }

    // ---------- Smooth scroll ----------

    function initSmoothScroll() {
        qsa("[data-scroll-to]").forEach(function (el) {
            el.addEventListener("click", function (e) {
                const href = el.getAttribute("href");
                if (!href || !href.startsWith("#")) return;
                const target = qs(href);
                if (!target) return;
                e.preventDefault();
                window.scrollTo({
                    top: target.getBoundingClientRect().top + window.scrollY - 72,
                    behavior: "smooth"
                });
            });
        });
    }

    // ---------- Back to top ----------

    function initBackToTop() {
        const btn = qs("[data-back-to-top]");
        if (!btn) return;

        function onScroll() {
            if (window.scrollY > 300) {
                btn.classList.add("is-visible");
            } else {
                btn.classList.remove("is-visible");
            }
        }

        window.addEventListener("scroll", onScroll, {passive: true});
        onScroll();

        btn.addEventListener("click", function () {
            window.scrollTo({top: 0, behavior: "smooth"});
        });
    }

    // ---------- Toasts ----------

    function showToast(message, type) {
        type = type || "info";
        const container = qs(".ps-toast-container");
        if (!container) return;

        const toast = document.createElement("div");
        toast.className = "ps-toast ps-toast--" + type;

        const msg = document.createElement("div");
        msg.className = "ps-toast-message";
        msg.textContent = message;

        const close = document.createElement("button");
        close.className = "ps-toast-close";
        close.type = "button";
        close.innerHTML = "×";

        close.addEventListener("click", function () {
            toast.remove();
        });

        toast.appendChild(msg);
        toast.appendChild(close);
        container.appendChild(toast);

        setTimeout(function () {
            toast.remove();
        }, 4000);
    }

    function handleApiError(err) {
        var message = "Что-то пошло не так. Попробуйте позже.";
        function notify(msg) {
            showToast(msg || message, "error");
            try { document.dispatchEvent(new CustomEvent("ps-error", { detail: err })); } catch (_) {}
        }
        if (!err) return notify(message);
        if (typeof Response !== "undefined" && err instanceof Response) {
            err.json().then(function (data) {
                var msg = (data && (data.message || data.detail)) || message;
                notify(msg);
            }).catch(function () { notify(message); });
            return;
        }
        if (typeof err === "string") return notify(err);
        if (err.code && err.message) return notify(err.message);
        if (err.message) return notify(err.message);
        if (err.response && err.response.message) return notify(err.response.message);
        notify(message);
    }

    // ---------- PWA install banner ----------

    let deferredPrompt = null;
    const INSTALL_DISMISS_KEY = "pwaPromptDismissedUntil";
    const INSTALL_DISMISS_DAYS = 30;

    function isStandalone() {
        return window.matchMedia("(display-mode: standalone)").matches || window.navigator.standalone;
    }

    function isMobileDevice() {
        const ua = navigator.userAgent || "";
        const isIOS = /iPhone|iPad|iPod/i.test(ua);
        const isAndroid = /Android/i.test(ua);
        const isCoarse = window.matchMedia && window.matchMedia("(pointer:coarse)").matches;
        return isIOS || isAndroid || isCoarse;
    }

    function dismissedUntil() {
        try {
            const value = localStorage.getItem(INSTALL_DISMISS_KEY);
            return value ? parseInt(value, 10) : 0;
        } catch (_) {
            return 0;
        }
    }

    function markDismiss(days) {
        try {
            const until = Date.now() + days * 24 * 60 * 60 * 1000;
            localStorage.setItem(INSTALL_DISMISS_KEY, String(until));
        } catch (_) {}
    }

    function canShowBanner() {
        if (!isMobileDevice() || isStandalone()) return false;
        const until = dismissedUntil();
        if (until && until > Date.now()) return false;
        return true;
    }

    function initInstallBanner() {
        const banner = qs("[data-install-banner]");
        const btnAccept = qs("[data-install-accept]", banner);
        const btnDismiss = qs("[data-install-dismiss]", banner);
        const menuButton = qs("[data-nav-install-app]");
        const fallbackUrl = (menuButton && menuButton.getAttribute("data-install-href")) || "/pwa-install/";

        if (!banner || !btnAccept || !btnDismiss) return;

        function hideBanner() {
            banner.classList.remove("is-visible");
            setTimeout(function () { banner.hidden = true; }, 200);
        }

        function showBanner() {
            if (!canShowBanner()) return;
            banner.hidden = false;
            requestAnimationFrame(function () { banner.classList.add("is-visible"); });
        }

        function triggerInstall(source) {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice
                    .then(function (choiceResult) {
                        if (choiceResult.outcome === "accepted") {
                            showToast("Установка ParkShare RU запущена", "success");
                            markDismiss(365);
                        }
                    })
                    .finally(function () {
                        deferredPrompt = null;
                        hideBanner();
                    });
            } else {
                if (fallbackUrl) {
                    window.location.href = fallbackUrl;
                } else {
                    showToast("Откройте меню браузера и выберите «Добавить на экран»", "info");
                }
                hideBanner();
            }
        }

        if (menuButton) {
            if (!isMobileDevice() || isStandalone()) {
                menuButton.style.display = "none";
            }
            menuButton.addEventListener("click", function () { triggerInstall("menu"); });
        }

        window.addEventListener("beforeinstallprompt", function (e) {
            e.preventDefault();
            deferredPrompt = e;
            if (canShowBanner()) {
                showBanner();
            }
        });

        btnDismiss.addEventListener("click", function () {
            markDismiss(INSTALL_DISMISS_DAYS);
            hideBanner();
            deferredPrompt = null;
        });

        btnAccept.addEventListener("click", function () { triggerInstall("banner"); });

        window.addEventListener("appinstalled", function () {
            markDismiss(365);
            hideBanner();
        });

        if (canShowBanner()) {
            showBanner();
        }
    }

    // ---------- Skeleton removal ----------

    function initSkeletons() {
        const cards = qsa(".ps-card--skeleton");
        if (!cards.length) return;

        // Имитация загрузки данных — через небольшой таймаут
        window.setTimeout(function () {
            cards.forEach(function (card) {
                card.parentNode && card.parentNode.removeChild(card);
            });
        }, 350);
    }

    // ---------- Spots bottom sheet (mobile) ----------

    function initSpotsSheet() {
        const sheet = qs("[data-spots-sheet]") || qs("[data-spots-panel]");
        if (!sheet) return;
        const handle = qs("[data-sheet-handle]", sheet) || qs(".ps-bottom-sheet__handle", sheet);
        const backBtn = qs("[data-sheet-back]", sheet);
        const body = qs(".ps-bottom-sheet__body", sheet);
        let currentState = sheet.getAttribute("data-sheet-state") || "collapsed";
        let startY = 0;
        let startShift = 0;
        let baseHeight = 0;
        let activePointerId = null;
        const STATE_ORDER = ["collapsed", "half", "full"];

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function isFloating() {
            return isMobileWidth() && sheet.classList.contains("ps-bottom-sheet--floating");
        }

        function viewportHeight() {
            const vv = window.visualViewport;
            return vv ? vv.height : window.innerHeight;
        }

        function safeBottom() {
            const vv = window.visualViewport;
            if (!vv) return 0;
            return Math.max(0, window.innerHeight - vv.height - vv.offsetTop);
        }

        function topOffset() {
            const fromCss = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--ps-topbar-height"), 10) || 68;
            return Math.min(Math.max(fromCss + 8, 58), 110);
        }

        function apply(state, opts) {
            currentState = STATE_ORDER.indexOf(state) >= 0 ? state : "collapsed";
            sheet.setAttribute("data-sheet-state", currentState);
            if (!isFloating()) {
                sheet.style.removeProperty("--ps-sheet-shift");
                sheet.style.removeProperty("height");
                return;
            }
            const collapsed = parseFloat(getComputedStyle(sheet).getPropertyValue("--ps-sheet-collapsed")) || 86;
            const rawShift = currentState === "full" ? 0 : currentState === "half" ? baseHeight * 0.46 : baseHeight - collapsed;
            const shift = clamp(rawShift, 0, Math.max(baseHeight - 40, 0));
            sheet.style.height = baseHeight + "px";
            sheet.style.setProperty("--ps-sheet-shift", shift + "px");
            if (opts && opts.immediate) {
                sheet.style.transition = "none";
                requestAnimationFrame(function () {
                    sheet.style.transition = "";
                });
            }
        }

        function recalc(opts) {
            const vh = viewportHeight();
            const collapsed = Math.round(Math.min(Math.max(vh * 0.17, 62), 110));
            baseHeight = Math.round(Math.min(Math.max(vh * 0.9, 420), Math.max(vh - 32, 420)));
            sheet.style.setProperty("--ps-viewport-height", vh + "px");
            sheet.style.setProperty("--ps-safe-area-bottom", safeBottom() + "px");
            sheet.style.setProperty("--ps-sheet-collapsed", collapsed + "px");
            sheet.style.setProperty("--ps-sheet-height", baseHeight + "px");
            sheet.style.setProperty("--ps-sheet-top-offset", topOffset() + "px");
            apply(currentState, { immediate: opts && opts.immediate });
        }

        function releasePointer(id) {
            if (id !== null && sheet.hasPointerCapture && sheet.hasPointerCapture(id)) {
                sheet.releasePointerCapture(id);
            }
            sheet.style.transition = "";
            activePointerId = null;
        }

        function gestureStart(evt) {
            if (!isFloating()) return;
            if (!baseHeight) recalc({ immediate: true });
            activePointerId = evt.pointerId;
            startY = evt.clientY;
            startShift = parseFloat(getComputedStyle(sheet).getPropertyValue("--ps-sheet-shift")) || baseHeight * 0.6;
            sheet.style.transition = "none";
            if (sheet.setPointerCapture) {
                sheet.setPointerCapture(activePointerId);
            }
            window.addEventListener("pointermove", gestureMove, { passive: true });
            window.addEventListener("pointerup", gestureEnd);
            window.addEventListener("pointercancel", gestureEnd);
        }

        function gestureMove(evt) {
            if (!isFloating() || evt.pointerId !== activePointerId) return;
            const delta = evt.clientY - startY;
            const nextShift = clamp(startShift + delta, 8, Math.max(baseHeight - 56, 120));
            sheet.style.setProperty("--ps-sheet-shift", nextShift + "px");
        }

        function gestureEnd(evt) {
            if (!isFloating() || (evt && evt.pointerId !== activePointerId)) {
                releasePointer(activePointerId);
                return;
            }
            window.removeEventListener("pointermove", gestureMove);
            window.removeEventListener("pointerup", gestureEnd);
            window.removeEventListener("pointercancel", gestureEnd);
            const shift = parseFloat(getComputedStyle(sheet).getPropertyValue("--ps-sheet-shift")) || baseHeight * 0.6;
            const ratio = shift / baseHeight;
            if (ratio < 0.25) {
                apply("full");
            } else if (ratio < 0.6) {
                apply("half");
            } else {
                apply("collapsed");
            }
            releasePointer(activePointerId);
        }

        if (handle) {
            handle.addEventListener("pointerdown", gestureStart);
            handle.addEventListener("click", function () {
                if (!isFloating()) return;
                const idx = STATE_ORDER.indexOf(currentState);
                const next = STATE_ORDER[(idx + 1) % STATE_ORDER.length] || "half";
                apply(next);
            });
        }

        if (backBtn) {
            backBtn.addEventListener("click", function () {
                if (!isFloating()) return;
                apply(currentState === "full" ? "half" : "collapsed");
            });
        }

        window.addEventListener("resize", function () {
            recalc({ immediate: true });
        });

        if (window.visualViewport) {
            window.visualViewport.addEventListener("resize", function () {
                recalc({ immediate: true });
            });
        }

        document.addEventListener("ps:spot-selection", function () {
            if (!isFloating()) return;
            if (currentState === "collapsed") {
                apply("half");
            } else if (currentState === "half") {
                apply("half");
            }
            if (body) {
                body.scrollTo({ top: 0, behavior: "smooth" });
            }
        });

        recalc({ immediate: true });
    }

// ---------- Adaptive AI probe ----------
function initAdaptiveProbe() {
    const payload = {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: window.devicePixelRatio || 1,
        platform: document.documentElement.getAttribute("data-platform") || "RU",
    };

    fetch("/api/ai/parkmate/config/", {
        method: "POST",
        credentials: "include",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify({
            client: payload,
            action: "adaptive-profile",
        }),
        keepalive: true, // чтобы не блокировать навигацию, аналогично sendBeacon
    }).catch(function () {
        // молча игнорируем
    });
}





    // ---------- Geolocation helper ----------

    function initGeolocation() {
        const buttons = qsa("[data-fill-location]");
        if (!buttons.length) return;

        function fill(lat, lng) {
            const latInput = qs("#lat");
            const lngInput = qs("#lng");
            if (!latInput || !lngInput) return;
            latInput.value = lat.toFixed(5);
            lngInput.value = lng.toFixed(5);
            showToast("Координаты определены, нажмите «Найти места»", "success");
        }

        buttons.forEach(function (btn) {
            btn.addEventListener("click", function () {
                if (!("geolocation" in navigator)) {
                    showToast("Геолокация недоступна в этом браузере", "error");
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    function (pos) {
                        fill(pos.coords.latitude, pos.coords.longitude);
                    },
                    function () {
                        showToast("Не удалось получить местоположение", "error");
                    },
                    {
                        enableHighAccuracy: false,
                        timeout: 8000,
                        maximumAge: 60000
                    }
                );
            });
        });
    }

    // ---------- Voice search (Web Speech API) ----------

    function initVoiceInput() {
        const trigger = qs("[data-voice-input]");
        const inputs = qsa("[data-geocode-input]");
        if (!trigger || !inputs.length) return;

        const submit = qs("[data-geocode-submit]");
        const Recognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        if (!Recognition) {
            trigger.addEventListener("click", function () {
                showToast("Голосовой ввод недоступен на этом устройстве", "info");
            });
            trigger.setAttribute("aria-disabled", "true");
            return;
        }

        const recognition = new Recognition();
        recognition.lang = "ru-RU";
        recognition.continuous = false;
        recognition.interimResults = false;

        let listening = false;
        const defaultPlaceholder = inputs[0].getAttribute("placeholder") || "";

        function setListeningUi() {
            listening = true;
            trigger.classList.add("is-active");
            trigger.setAttribute("aria-pressed", "true");
            inputs.forEach(function (input) {
                input.placeholder = "Слушаю…";
            });
        }

        function clearListeningUi() {
            listening = false;
            trigger.classList.remove("is-active");
            trigger.setAttribute("aria-pressed", "false");
            inputs.forEach(function (input) {
                input.placeholder = defaultPlaceholder;
            });
        }

        function stopListening() {
            if (!listening) return;
            try {
                recognition.stop();
            } catch (_) {
                /* ignore */
            }
        }

        recognition.onstart = setListeningUi;
        recognition.onend = clearListeningUi;
        recognition.onerror = function () {
            clearListeningUi();
            showToast("Не удалось распознать речь. Попробуйте ещё раз.", "error");
        };
        recognition.onresult = function (event) {
            const transcript = event.results && event.results[0] && event.results[0][0] ? event.results[0][0].transcript : "";
            if (transcript) {
                inputs.forEach(function (input) {
                    input.value = transcript;
                    input.dispatchEvent(new Event("input", { bubbles: true }));
                });
                if (submit) {
                    submit.click();
                }
            }
            stopListening();
        };

        trigger.addEventListener("click", function () {
            if (listening) {
                stopListening();
                return;
            }
            try {
                recognition.start();
            } catch (err) {
                clearListeningUi();
                showToast("Голосовой ввод недоступен сейчас", "info");
            }
        });
    }

    // ---------- Payment methods (ЛК) ----------

    const PAYMENT_METHODS_ENDPOINT = "/api/payments/methods/";

    function getCSRFToken() {
        const match = document.cookie.match(/csrftoken=([^;]+)/);
        return match ? match[1] : "";
    }

    function detectBrand(num) {
        if (!num) return "other";
        if (/^4/.test(num)) return "visa";
        if (/^5[1-5]/.test(num)) return "mc";
        if (/^220[0-4]/.test(num)) return "mir";
        if (/^62/.test(num)) return "up";
        return "other";
    }

    function renderPaymentMethods(methods, container) {
        if (!container) return;
        if (!methods || !methods.length) {
            container.innerHTML = "<div class='ps-empty'>Карты пока не добавлены.</div>";
            return;
        }
        container.innerHTML = methods
            .map(function (method) {
                const brand = method.brand ? method.brand.toUpperCase() : "CARD";
                const defaultBadge = method.is_default ? "<span class='ps-badge ps-badge--success'>По умолчанию</span>" : "";
                return (
                    "<div class='ps-payment-card'>" +
                    "<div>" +
                    "<div class='ps-payment-brand'>" + brand + " · " + (method.mask || ("**** " + method.last4)) + " " + defaultBadge + "</div>" +
                    "<div class='ps-payment-meta'>Срок: " + method.exp_month + "/" + method.exp_year + (method.label ? " · " + method.label : "") + "</div>" +
                    "</div>" +
                    "<div class='ps-payment-actions'>" +
                    "<button class='ps-btn ps-btn-ghost ps-btn-sm' data-payment-default='" + method.id + "'>Сделать осн.</button>" +
                    "<button class='ps-btn ps-btn-ghost ps-btn-sm' data-payment-delete='" + method.id + "'>Удалить</button>" +
                    "</div>" +
                    "</div>"
                );
            })
            .join("");
    }

    function initPaymentMethods() {
        const container = qs("[data-payment-methods]");
        const form = qs("[data-payment-method-form]");
        if (!container && !form) return;

        function loadMethods() {
            fetch(PAYMENT_METHODS_ENDPOINT, { credentials: "include" })
                .then(function (resp) { return resp.json(); })
                .then(function (data) { renderPaymentMethods(data.results || data, container); })
                .catch(function (err) {
                    if (window.ParkShare && window.ParkShare.handleApiError) window.ParkShare.handleApiError(err);
                });
        }

        if (form) {
            form.addEventListener("submit", function (evt) {
                evt.preventDefault();
                const fd = new FormData(form);
                const cardNumber = (fd.get("card_number") || "").replace(/\D/g, "");
                const exp = (fd.get("exp") || "").split("/");
                const expMonth = parseInt(exp[0], 10) || 1;
                const expYear = parseInt((exp[1] || "").replace(/[^0-9]/g, ""), 10) || 30;
                const payload = {
                    label: fd.get("label") || fd.get("provider") || "Моя карта",
                    brand: detectBrand(cardNumber),
                    last4: cardNumber.slice(-4) || "0000",
                    exp_month: expMonth,
                    exp_year: expYear,
                    is_default: fd.get("is_default") === "on",
                    token_masked: "tok_" + (cardNumber.slice(-6) || "card") + Date.now(),
                };

                fetch(PAYMENT_METHODS_ENDPOINT, {
                    method: "POST",
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCSRFToken(),
                    },
                    body: JSON.stringify(payload),
                })
                    .then(function (resp) { return resp.json(); })
                    .then(function () {
                        showToast("Карта сохранена", "success");
                        form.reset();
                        loadMethods();
                    })
                    .catch(function (err) { (window.ParkShare && window.ParkShare.handleApiError) ? window.ParkShare.handleApiError(err) : showToast("Не удалось сохранить карту", "error"); });
            });
        }

        if (container) {
            container.addEventListener("click", function (evt) {
                const defBtn = evt.target.closest("[data-payment-default]");
                const delBtn = evt.target.closest("[data-payment-delete]");
                if (defBtn) {
                    const id = defBtn.getAttribute("data-payment-default");
                    fetch(PAYMENT_METHODS_ENDPOINT + id + "/", {
                        method: "PATCH",
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json",
                            "X-CSRFToken": getCSRFToken(),
                        },
                        body: JSON.stringify({ is_default: true }),
                    })
                        .then(function (resp) { return resp.json(); })
                        .then(function () { showToast("Карта выбрана по умолчанию", "success"); loadMethods(); })
                        .catch(function (err) { (window.ParkShare && window.ParkShare.handleApiError) ? window.ParkShare.handleApiError(err) : showToast("Не удалось обновить карту", "error"); });
                }
                if (delBtn) {
                    const id = delBtn.getAttribute("data-payment-delete");
                    fetch(PAYMENT_METHODS_ENDPOINT + id + "/", {
                        method: "DELETE",
                        credentials: "include",
                        headers: { "X-CSRFToken": getCSRFToken() },
                    })
                        .then(function (resp) { if (!resp.ok) throw new Error(); })
                        .then(function () { showToast("Карта удалена", "info"); loadMethods(); })
                        .catch(function (err) { (window.ParkShare && window.ParkShare.handleApiError) ? window.ParkShare.handleApiError(err) : showToast("Не удалось удалить карту", "error"); });
                }
            });
        }

        loadMethods();
    }

    // ---------- Bottom navigation ----------



    function initBottomNav() {
        const nav = qs("[data-bottom-nav]");
        if (!nav) return;
        const items = qsa("[data-nav]", nav);

        const defaultKey = (function () {
            const path = window.location.pathname;
            if (window.location.hash === "#assistant") return "assistant";
            if (path.indexOf("/assistant") === 0 || path.indexOf("/ai") === 0) return "assistant";
            if (path.indexOf("/личный-кабинет") === 0) return "bookings";
            if (path.indexOf("/кабинет-владельца") === 0) return "parking";
            if (path.indexOf("/map") === 0) return "map";
            return "map";
        })();

        function setActive(key) {
            const target = key || defaultKey;
            items.forEach(function (item) {
                const current = item.getAttribute("data-nav");
                item.classList.toggle("is-active", current === target);
            });
        }

        items.forEach(function (item) {
            item.addEventListener("click", function () {
                const key = item.getAttribute("data-nav");
                if (key) setActive(key);
            });
        });

        setActive(defaultKey);
    }

    // ---------- Onboarding ----------

    function initOnboarding() {
        const root = qs("[data-onboarding]");
        if (!root) return;
        const slides = qsa("[data-onboarding-slides] .ps-onboarding__slide", root);
        const btnNext = qs("[data-onboarding-next]", root);
        const btnSkip = qs("[data-onboarding-skip]", root);
        const storageKey = "ps_onboarded";
        let index = 0;

        function isDone() {
            try {
                return localStorage.getItem(storageKey) === "1";
            } catch (_) {
                return false;
            }
        }
        function markDone() {
            try {
                localStorage.setItem(storageKey, "1");
            } catch (_) {}
        }
        function show() {
            root.hidden = false;
            root.classList.add("is-visible");
            render();
        }
        function hide() {
            root.classList.remove("is-visible");
            setTimeout(function () {
                root.hidden = true;
            }, 200);
        }
        function render() {
            slides.forEach(function (slide, i) {
                slide.classList.toggle("is-active", i === index);
            });
            if (btnNext) {
                btnNext.textContent = index >= slides.length - 1 ? "Готово" : "Далее";
            }
        }
        function finish() {
            markDone();
            hide();
        }
        if (isDone()) return;
        if (btnNext) {
            btnNext.addEventListener("click", function () {
                if (index < slides.length - 1) {
                    index += 1;
                    render();
                } else {
                    finish();
                }
            });
        }
        if (btnSkip) {
            btnSkip.addEventListener("click", finish);
        }
        show();
    }

    // ---------- Init ----------

    document.addEventListener("DOMContentLoaded", function () {
        initMenu();
        initSmoothScroll();
        initBackToTop();
        initInstallBanner();
        initSkeletons();
        initSpotsSheet();
        initAdaptiveProbe();
        initGeolocation();
        initOnboarding();
        initVoiceInput();
        initPaymentMethods();
        initBottomNav();

        const aiLauncher = document.querySelector(".ai-assistant-launcher");
        const aiPanel = document.querySelector(".ai-assistant-panel");
        const aiClose = document.querySelector(".ai-assistant-panel__close");

        if (aiLauncher && aiPanel) {
            aiLauncher.addEventListener("click", function () {
                aiPanel.classList.toggle("is-open");
            });
        }

        if (aiClose && aiPanel) {
            aiClose.addEventListener("click", function () {
                aiPanel.classList.remove("is-open");
            });
        }
    });

    // Экспортируем showToast в глобальную область на всякий
    window.ParkShare = window.ParkShare || {};
    window.ParkShare.showToast = showToast;
    window.ParkShare.handleApiError = handleApiError;
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 262
PATH: static\js\chat.js
LANG: javascript
===== CONTENT START =====
(function () {
  'use strict';

  function qs(selector, scope) {
    return (scope || document).querySelector(selector);
  }
  function qsa(selector, scope) {
    return Array.prototype.slice.call((scope || document).querySelectorAll(selector));
  }

  const encoder = new TextEncoder();
  const STORAGE_PREFIX = 'ps_ai_chat_v2:';

  function storageKey(userId, fallbackKey) {
    return STORAGE_PREFIX + (userId || 'guest') + ':' + (fallbackKey || 'default');
  }

  function loadState(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (_) {
      return null;
    }
  }

  function saveState(key, state) {
    try {
      localStorage.setItem(key, JSON.stringify(state));
    } catch (_) {
      // ignore quota errors
    }
  }

  function now() {
    return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }

  function createWelcomeMessage() {
    return {
      id: crypto.randomUUID(),
      role: 'assistant',
      content: 'Привет! Я ParkShare AI Concierge. Спроси про загрузку, цены, сценарии для гостей или подготовку персонала.',
      createdAt: Date.now()
    };
  }

  function renderMessage(message) {
    const bubble = document.createElement('div');
    bubble.className = 'ps-ai-bubble ' + (message.role === 'user' ? 'ps-ai-bubble--user' : 'ps-ai-bubble--assistant');
    bubble.dataset.messageId = message.id;

    const meta = document.createElement('div');
    meta.className = 'ps-ai-meta';
    meta.innerHTML = `<span class="ps-chip ${message.role === 'user' ? 'ps-chip--primary' : 'ps-chip--ghost'}">${message.role === 'user' ? 'Вы' : 'AI'}</span><span>${new Date(message.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>`;
    bubble.appendChild(meta);

    const text = document.createElement('div');
    text.className = 'ps-ai-text';
    text.textContent = message.content || '...';
    bubble.appendChild(text);

    if (message.role === 'assistant') {
      const actions = document.createElement('div');
      actions.className = 'ps-ai-actions-row';
      const copyBtn = document.createElement('button');
      copyBtn.type = 'button';
      copyBtn.className = 'ps-btn ps-btn-ghost ps-btn-xs';
      copyBtn.textContent = 'Копировать';
      copyBtn.dataset.aiCopy = 'true';
      actions.appendChild(copyBtn);

      const regenBtn = document.createElement('button');
      regenBtn.type = 'button';
      regenBtn.className = 'ps-btn ps-btn-ghost ps-btn-xs';
      regenBtn.textContent = 'Перегенерировать';
      regenBtn.dataset.aiRegenerate = 'true';
      actions.appendChild(regenBtn);

      actions.hidden = !message.content;
      bubble.appendChild(actions);
    }

    return bubble;
  }

  function setupChat() {
    const chatRoot = qs('[data-ai-chat]');
    if (!chatRoot) return;

    const messagesEl = qs('[data-ai-messages]', chatRoot);
    const suggestionsEl = qs('[data-ai-suggestions]', chatRoot);
    const actionsEl = qs('[data-ai-actions]', chatRoot);
    const sessionsEl = qs('[data-ai-sessions]', chatRoot);
    const alertsEl = qs('[data-ai-alerts]', chatRoot);
    const textarea = qs('#ai-input', chatRoot);
    const sendBtn = qs('[data-ai-send]', chatRoot);
    const clearBtn = qs('[data-ai-clear]', chatRoot);
    const statusEl = qs('[data-ai-status]', chatRoot);
    const regenerateBtn = qs('[data-ai-regenerate]', chatRoot);
    const promptButtons = qsa('[data-ai-prompt]');
    const userId = document.body.getAttribute('data-user-id') || 'guest';
    const historyKey = chatRoot.getAttribute('data-ai-history-key') || 'default';
    const storage = storageKey(userId, historyKey);

    let state = loadState(storage) || { messages: [createWelcomeMessage()] };
    let isLoading = false;

    function persist() {
      saveState(storage, state);
    }

  function render() {
    messagesEl.innerHTML = '';
    state.messages.forEach(function (msg) {
      messagesEl.appendChild(renderMessage(msg));
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
    if (regenerateBtn) {
      const hasUserMessages = state.messages.some(function (m) { return m.role === 'user'; });
      regenerateBtn.hidden = !hasUserMessages || isLoading;
    }
    persist();
  }

    function setStatus(text, tone) {
      if (!statusEl) return;
      statusEl.textContent = text;
      statusEl.classList.toggle('is-error', tone === 'error');
    }

  function lastUserMessage() {
      for (let i = state.messages.length - 1; i >= 0; i--) {
        if (state.messages[i].role === 'user') return state.messages[i];
      }
      return null;
  }

    function addMessage(role, content) {
      const msg = { id: crypto.randomUUID(), role, content, createdAt: Date.now() };
      state.messages.push(msg);
      return msg;
    }

    function updateMessage(id, updater) {
      state.messages = state.messages.map(function (msg) {
        return msg.id === id ? updater(msg) : msg;
      });
    }

    function renderSuggestions(payload) {
      if (!suggestionsEl) return;
      const suggestions = (payload && payload.suggestions) || [];
      if (!suggestions.length) {
        suggestionsEl.hidden = true;
        suggestionsEl.innerHTML = "";
        return;
      }
      suggestionsEl.hidden = false;
      suggestionsEl.innerHTML = suggestions
        .map(function (item) {
          const tags = (item.tags || []).map(function (t) {
            return '<span class="ps-pill ps-pill--ghost">' + t + "</span>";
          }).join("");
          const price = item.price ? "от " + item.price + " ₽/час" : "Цена уточняется";
          return (
            '<article class="ps-card ps-card--spot ps-animate-fade-up" data-ai-suggestion="' + item.spot_id + '">' +
            '<div class="ps-card-header"><div class="ps-card-title">' + (item.title || "Парковка") + '</div></div>' +
            '<div class="ps-card-body">' +
            '<div class="ps-spot-meta">' + tags + '</div>' +
            '<div class="ps-spot-price">' + price + '</div>' +
            '<div class="ps-card-actions">' +
            '<button class="ps-btn ps-btn-secondary ps-btn-sm" data-ai-map="' + item.spot_id + '">Показать на карте</button>' +
            '<button class="ps-btn ps-btn-primary ps-btn-sm" data-ai-book="' + item.spot_id + '">Забронировать</button>' +
            '</div>' +
            '</div>' +
            '</article>'
          );
        })
        .join("");
    }

    function renderAlerts(list) {
      if (!alertsEl) return;
      if (!list || !list.length) {
        alertsEl.hidden = true;
        alertsEl.innerHTML = '';
        return;
      }
      alertsEl.hidden = false;
      alertsEl.innerHTML = list
        .map(function (alert) {
          var minutes = alert.minutes_left || 0;
          return (
            '<div class="ps-card ps-card--spot ps-animate-fade-up ps-card-line--muted">' +
            '<div class="ps-card-body">' +
            '<div class="ps-spot-price">Сессия заканчивается через ~' + minutes + ' мин.</div>' +
            '<div class="ps-card-line ps-card-line--muted">' + (alert.spot || '') + '</div>' +
            '</div>' +
            '</div>'
          );
        })
        .join('');
    }

    function renderActions(list) {
      if (!actionsEl) return;
      if (!list || !list.length) {
        actionsEl.hidden = true;
        actionsEl.innerHTML = '';
        return;
      }
      actionsEl.hidden = false;
      actionsEl.innerHTML = list
        .map(function (action, idx) {
          var key = action.booking_id || action.spot_id || idx;
          var label = action.type === 'booking_start' ? 'Начать парковку' : action.type === 'booking_extend' ? 'Продлить' : action.type === 'booking_stop' ? 'Завершить' : 'Действие';
          return (
            '<button class="ps-chip" data-ai-action="' + action.type + '" data-action-key="' + key + '" data-spot-id="' + (action.spot_id || '') + '" data-booking-id="' + (action.booking_id || '') + '" data-extend-min="' + (action.extend_minutes || '') + '" data-duration="' + (action.duration_minutes || '') + '">' +
            label +
            '</button>'
          );
        })
        .join('');
    }

    function renderSessions(list) {
      if (!sessionsEl) return;
      if (!list || !list.length) {
        sessionsEl.hidden = true;
        sessionsEl.innerHTML = '';
        return;
      }
      sessionsEl.hidden = false;
      sessionsEl.innerHTML = list
        .map(function (session) {
          var minutes = Math.max(0, Math.floor((session.remaining_seconds || 0) / 60));
          return (
            '<div class="ps-card ps-card--spot ps-animate-fade-up">' +
            '<div class="ps-card-header"><div class="ps-card-title">' + session.spot_name + ' · ' + session.lot_name + '</div></div>' +
            '<div class="ps-card-body">' +
            '<div class="ps-spot-meta">Осталось ~' + minutes + ' мин</div>' +
            '<div class="ps-card-actions">' +
            '<button class="ps-btn ps-btn-secondary ps-btn-sm" data-ai-action="booking_extend" data-booking-id="' + session.id + '">+30 мин</button>' +
            '<button class="ps-btn ps-btn-primary ps-btn-sm" data-ai-action="booking_stop" data-booking-id="' + session.id + '">Завершить</button>' +
            '</div>' +
            '</div>' +
            '</div>'
          );
        })
        .join('');
    }

    function csrfToken() {
      const match = document.cookie.match(/csrftoken=([^;]+)/);
      return match ? match[1] : '';
    }

    async function performActionFromButton(btn) {
      const type = btn.getAttribute('data-ai-action');
      const spotId = btn.getAttribute('data-spot-id');
      const bookingId = btn.getAttribute('data-booking-id');
      const extendMin = parseInt(btn.getAttribute('data-extend-min') || '30', 10);
      const duration = parseInt(btn.getAttribute('data-duration') || '60', 10);
      try {
        if (type === 'booking_start' && spotId) {
          await fetch('/api/v1/booking/start/', {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken() },
            body: JSON.stringify({ spot_id: spotId, duration_minutes: duration })
          });
        } else if (type === 'booking_extend' && bookingId) {
          await fetch('/api/v1/booking/extend/', {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken() },
            body: JSON.stringify({ booking_id: bookingId, extend_minutes: extendMin || 30 })
          });
        } else if (type === 'booking_stop' && bookingId) {
          await fetch('/api/v1/booking/stop/', {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken() },
            body: JSON.stringify({ booking_id: bookingId })
          });
        } else if (type === 'focus_map' && spotId) {
          try { sessionStorage.setItem('ps_focus_spot', spotId); } catch (_) {}
          window.location.href = '/';
        } else if (type === 'book' && spotId) {
          window.location.href = '/booking/confirm/?spot_id=' + encodeURIComponent(spotId);
        }
        setStatus('Готово. Действие выполнено.', 'info');
      } catch (err) {
        setStatus('Не удалось выполнить действие', 'error');
      }
    }

  function handleSend() {
      if (!textarea || !textarea.value.trim() || isLoading) return;
      const text = textarea.value.trim();
      textarea.value = '';
      const userMsg = addMessage('user', text);
      const assistant = addMessage('assistant', '');
      render();
      const history = state.messages.filter(function (msg) { return msg.id !== assistant.id; });
      streamToApi(userMsg, assistant, history);
    }

    function handleRegenerate() {
      if (isLoading) return;
      let lastUserIndex = -1;
      for (let i = state.messages.length - 1; i >= 0; i--) {
        if (state.messages[i].role === 'user') {
          lastUserIndex = i;
          break;
        }
      }
      if (lastUserIndex === -1) return;
      // Оставляем историю до последнего пользовательского сообщения
      state.messages = state.messages.slice(0, lastUserIndex + 1);
      const userMsg = state.messages[lastUserIndex];
      const assistant = addMessage('assistant', '');
      const history = state.messages.filter(function (msg) { return msg.id !== assistant.id; });
      setStatus('Генерируем новый ответ…', 'info');
      render();
      streamToApi(userMsg, assistant, history);
    }

    function handleCopy(targetId) {
      const msg = state.messages.find(function (m) { return m.id === targetId; });
      if (!msg || !msg.content || !navigator.clipboard) return;
      navigator.clipboard.writeText(msg.content).catch(function () {});
    }

  async function streamToApi(userMsg, assistantMsg, historyOverride) {
      const baseHistory = (historyOverride && historyOverride.length ? historyOverride : state.messages).filter(function (msg) {
        return !(assistantMsg && msg.id === assistantMsg.id);
      });
      const payload = baseHistory.map(function (m) {
        return { role: m.role, content: m.content };
      });
      if (typeof navigator !== "undefined" && navigator.onLine === false) {
        if (window.ParkShare && window.ParkShare.handleApiError) {
          window.ParkShare.handleApiError({ message: 'Нет подключения. Попробуйте позже.' });
        }
        return;
      }
      isLoading = true;
      setStatus('Генерируем ответ…', 'info');
      try {
        const resp = await fetch('/api/v1/assistant/chat/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken(),
          },
          credentials: 'include',
          body: JSON.stringify({ messages: payload, structured: true })
        });

        if (!resp.ok) {
          let detail = '';
          try {
            const errJson = await resp.json();
            detail = errJson.detail || errJson.message || '';
          } catch (_) {
            try { detail = await resp.text(); } catch (__) { /* ignore */ }
          }
          if (window.ParkShare && window.ParkShare.handleApiError) {
            window.ParkShare.handleApiError({ message: detail || 'Ассистент недоступен.' });
          }
          throw new Error(detail || 'Ассистент недоступен.');
        }

        const data = await resp.json();
        updateMessage(assistantMsg.id, function (msg) {
          return { ...msg, content: data.reply || '' };
        });
        render();
        renderSuggestions(data);
        renderActions(data.actions || []);
        renderSessions(data.sessions || []);
        renderAlerts(data.alerts || []);
        setStatus('Готово. Можно задавать следующий вопрос.', 'info');
      } catch (error) {
        console.warn('Chat error', error);
        if (window.ParkShare && window.ParkShare.handleApiError) {
          window.ParkShare.handleApiError(error);
        }
        updateMessage(assistantMsg.id, function (msg) {
          return { ...msg, content: 'Сервис временно недоступен. Попробуйте позже.' };
        });
        setStatus('Ошибка сети или LLM. Попробуйте ещё раз.', 'error');
      } finally {
        isLoading = false;
        render();
      }
    }

    function handleClear() {
      state = { messages: [createWelcomeMessage()] };
      setStatus('История очищена. Новый диалог.', 'info');
      renderSuggestions({ suggestions: [] });
      renderActions([]);
      renderSessions([]);
      renderAlerts([]);
      render();
    }

    chatRoot.addEventListener('click', function (e) {
      const bubble = e.target.closest('[data-message-id]');
      if (!bubble) return;
      const id = bubble.getAttribute('data-message-id');
      if (e.target.matches('[data-ai-copy]')) {
        handleCopy(id);
      }
      if (e.target.matches('[data-ai-regenerate]')) {
        handleRegenerate();
      }
    });

    if (suggestionsEl) {
      suggestionsEl.addEventListener('click', function (e) {
        const mapBtn = e.target.closest('[data-ai-map]');
        const bookBtn = e.target.closest('[data-ai-book]');
        if (mapBtn) {
          const spotId = mapBtn.getAttribute('data-ai-map');
          try {
            sessionStorage.setItem('ps_focus_spot', spotId);
          } catch (_) {}
          window.location.href = '/';
        }
        if (bookBtn) {
          const spotId = bookBtn.getAttribute('data-ai-book');
          try {
            sessionStorage.setItem('ps_focus_spot', spotId);
          } catch (_) {}
          window.location.href = '/booking/confirm/?spot_id=' + encodeURIComponent(spotId);
        }
      });
    }

    if (actionsEl) {
      actionsEl.addEventListener('click', function (e) {
        const btn = e.target.closest('[data-ai-action]');
        if (!btn) return;
        performActionFromButton(btn);
      });
    }

    sendBtn && sendBtn.addEventListener('click', handleSend);
    clearBtn && clearBtn.addEventListener('click', handleClear);
    regenerateBtn && regenerateBtn.addEventListener('click', handleRegenerate);

    promptButtons.forEach(function (btn) {
      btn.addEventListener('click', function () {
        const prompt = btn.textContent || '';
        if (!textarea) return;
        textarea.value = prompt;
        textarea.focus();
      });
    });

    if (textarea) {
      textarea.addEventListener('keydown', function (evt) {
        if (evt.key === 'Enter' && !evt.shiftKey) {
          evt.preventDefault();
          handleSend();
        }
      });
    }

    render();
  }

  document.addEventListener('DOMContentLoaded', setupChat);
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 263
PATH: static\js\map.js
LANG: javascript
===== CONTENT START =====
// static/js/map.js
// Обновлённый модуль карты ParkShare: кастомные тёмные слои Яндекс.Карт,
// анимированные контролы, адаптивные балуны и мобильные шторки.

(function () {
    "use strict";

    function qs(sel, ctx) { return (ctx || document).querySelector(sel); }
    function qsa(sel, ctx) { return Array.prototype.slice.call((ctx || document).querySelectorAll(sel)); }

    var MAP_CONFIG = window.PARKSHARE_MAP_PROVIDER || {};
    var priceRange = [0, 1500];
    var prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    var dataTheme = document.documentElement.getAttribute("data-theme");
    var storedTheme = null;
    try { storedTheme = localStorage.getItem("ps-theme"); } catch (_) {}
    var isNight = (dataTheme || storedTheme || (prefersDark ? "dark" : "light")) === "dark";
    var lastFeatures = [];
    var featureIndex = {};
    var selectionSubscribers = [];
    var activeSpotId = null;
    var userLocation = null;

    function distanceKm(a, b) {
        if (!a || !b) return 0;
        var rad = Math.PI / 180;
        var lat1 = a[0] * rad, lat2 = b[0] * rad, lon1 = a[1] * rad, lon2 = b[1] * rad;
        var dlat = lat2 - lat1, dlon = lon2 - lon1;
        var h = Math.sin(dlat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlon / 2) ** 2;
        return 6371 * 2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
    }

    function applyMapTheme(theme, provider, container, silent) {
        var mode = theme === "dark" ? "dark" : "light";
        var mapEl = container || qs("#map");
        if (mapEl) {
            mapEl.classList.toggle("ps-map--dark", mode === "dark");
            mapEl.classList.toggle("ps-map--light", mode === "light");
        }

        if (!silent) {
            if (window.ThemeController && typeof window.ThemeController.setTheme === "function") {
                window.ThemeController.setTheme(mode);
            } else {
                document.documentElement.setAttribute("data-theme", mode);
                try { localStorage.setItem("ps-theme", mode); } catch (_) {}
            }
        }

        var btn = qs("[data-map-theme]");
        if (btn) {
            var isDark = mode === "dark";
            btn.setAttribute("aria-pressed", String(isDark));
            btn.classList.toggle("is-active", isDark);
        }

        isNight = mode === "dark";
        if (provider && provider.toggleTheme) provider.toggleTheme(isNight ? "night" : "day");
    }

    // ---------- Базовый интерфейс ----------
    function BaseMapProvider(options) { this.options = options || {}; }
    BaseMapProvider.prototype.init = function () {};
    BaseMapProvider.prototype.setFeatures = function () {};
    BaseMapProvider.prototype.setLoading = function () {};
    BaseMapProvider.prototype.drawRouteTo = function () {};
    BaseMapProvider.prototype.focusOn = function () {};
    BaseMapProvider.prototype.onInteraction = function () {};
    BaseMapProvider.prototype.toggleTheme = function () {};
    BaseMapProvider.prototype.showUserLocation = function () {};
    BaseMapProvider.prototype.setView = function () {};

    // ---------- Leaflet fallback ----------
    function LeafletMapProvider(options) {
        BaseMapProvider.call(this, options);
        this._map = null;
        this._markersLayer = null;
        this._tileLayers = {};
        this._currentTile = "day";
        this._activeRoute = null;
        this._highlight = null;
        this._markers = {};
        this._activeMarker = null;
    }
    LeafletMapProvider.prototype = Object.create(BaseMapProvider.prototype);

    LeafletMapProvider.prototype.init = function (container, center, zoom) {
        if (typeof L === "undefined") return;
        this._map = L.map(container, { center: center, zoom: zoom, scrollWheelZoom: false });
        this._tileLayers.day = this._createBaseLayer("light");
        this._tileLayers.night = this._createBaseLayer("dark");
        this._tileLayers.day.addTo(this._map);
        this._markersLayer = L.markerClusterGroup({ chunkedLoading: true, spiderfyOnMaxZoom: true }).addTo(this._map);
    };

    LeafletMapProvider.prototype._createBaseLayer = function (mode) {
        var url = mode === "dark"
            ? "https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png"
            : "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png";
        return L.tileLayer(url, { maxZoom: 20 });
    };

    LeafletMapProvider.prototype.setFeatures = function (fc) {
        if (!this._map || !this._markersLayer) return;
        var layer = this._markersLayer;
        layer.clearLayers();
        this._markers = {};
        var bounds = [];
        (fc.features || []).forEach(function (feature) {
            var coords = feature.geometry && feature.geometry.coordinates;
            if (!coords) return;
            var lng = coords[0], lat = coords[1];
            var p = feature.properties || {};
            var spotId = String(p.spot_id || feature.id || p.id || "");
            var stress = p.stress_index || 0;
            var color = stress >= 0.8 ? "#ef4444" : stress >= 0.6 ? "#f59e0b" : "#0ea5e9";
            var isHot = p.hourly_price && stress < 0.6;
            var freeLabel = (p.free_places === 0 || p.free_places) ? p.free_places : null;
            var label = freeLabel != null ? String(freeLabel) : "P";
            var textColor = (color === "#ef4444" || color === "#f59e0b") ? "#ffffff" : "#04121f";
            var markerHtml = [
                "<div class='ps-map-marker" + (isHot ? " ps-map-marker--hot" : "") + "'>",
                "  <div class='ps-map-marker__halo'></div>",
                "  <div class='ps-map-marker__body' style='background:" + color + "; color:" + textColor + "'>",
                "    <span class='ps-map-marker__value'>" + label + "</span>",
                "  </div>",
                "</div>"
            ].join("");
            var marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: "ps-map-marker-wrap",
                    html: markerHtml,
                    iconSize: [46, 46],
                    iconAnchor: [23, 23],
                })
            });
            marker.bindPopup(buildPopupHtml(p, color), { className: "ps-map-popup-card" });
            marker.addTo(layer);
            this._markers[spotId] = marker;
            marker.on("click", function () {
                notifySelection(spotId, { lat: lat, lng: lng });
            });
            bounds.push([lat, lng]);
        }, this);
        lastFeatures = fc.features || [];
        if (bounds.length) this._map.fitBounds(bounds, { padding: [72, 72] });
    };

    LeafletMapProvider.prototype.toggleTheme = function (mode) {
        if (!this._map) return;
        var next = mode === "night" ? "night" : mode === "day" ? "day" : (this._currentTile === "day" ? "night" : "day");
        this._map.removeLayer(this._tileLayers[this._currentTile]);
        this._tileLayers[next].addTo(this._map);
        this._currentTile = next;
    };

    LeafletMapProvider.prototype.setLoading = function (isLoading) {
        var el = qs("[data-map-loading]");
        if (el) el.style.display = isLoading ? "flex" : "none";
    };

    LeafletMapProvider.prototype.drawRouteTo = function (target, fromCoords, onHint) {
        if (!this._map || !target) return;
        if (this._activeRoute) this._activeRoute.remove();
        var origin = fromCoords ? L.latLng(fromCoords.lat, fromCoords.lng) : this._map.getCenter();
        var dest = target.lat != null ? L.latLng(target.lat, target.lng) : L.latLng(target[0], target[1]);
        this._activeRoute = L.polyline([origin, dest], { color: "#22c55e", weight: 4, opacity: 0.85 }).addTo(this._map);
        var km = distanceKm([origin.lat, origin.lng], [dest.lat, dest.lng]);
        if (onHint) onHint(km);
        this._map.fitBounds(this._activeRoute.getBounds(), { padding: [56, 56] });
    };

    LeafletMapProvider.prototype.focusOn = function (lat, lng) {
        if (!this._map) return;
        if (this._highlight) this._highlight.remove();
        this._highlight = L.circleMarker([lat, lng], { color: "#fbbf24", radius: 14, weight: 3 }).addTo(this._map);
        this._map.panTo([lat, lng], { animate: true, duration: 0.35, easeLinearity: 0.2 });
    };

    LeafletMapProvider.prototype.onInteraction = function (start, end) {
        if (!this._map) return;
        if (start) this._map.on("movestart zoomstart dragstart", start);
        if (end) this._map.on("moveend zoomend dragend", end);
    };

    LeafletMapProvider.prototype.showUserLocation = function (lat, lng) {
        if (!this._map) return;
        var radius = L.circle([lat, lng], { radius: 450, color: "#22c55e", weight: 2, fillOpacity: 0.12 }).addTo(this._map);
        radius.bringToBack();
    };

    LeafletMapProvider.prototype.setView = function (lat, lng, zoom) {
        if (!this._map) return;
        this._map.setView([lat, lng], zoom || this._map.getZoom());
    };

    LeafletMapProvider.prototype.setActiveMarkerById = function (spotId) {
        if (!this._markers) return;
        if (this._activeMarker && this._activeMarker._icon) {
            this._activeMarker._icon.classList.remove("is-active");
        }
        var marker = this._markers[spotId];
        if (marker && marker._icon) {
            marker._icon.classList.add("is-active");
            this._activeMarker = marker;
        }
    };

    // ---------- Yandex Maps ----------
    function YandexMapProvider(options) {
        BaseMapProvider.call(this, options);
        this._map = null;
        this._clusterer = null;
        this._activeRoute = null;
        this._highlight = null;
        this._ready = false;
        this._theme = options.theme || "day";
        this._mapTypesReady = false;
        this._heatLayer = null;
        this._markers = {};
        this._activePlacemark = null;
    }
    YandexMapProvider.prototype = Object.create(BaseMapProvider.prototype);

    YandexMapProvider.prototype._ensureMapTypes = function () {
        if (this._mapTypesReady || typeof ymaps === "undefined") return;
        var lightLayer = function () {
            return new ymaps.Layer("https://core-renderer-tiles.maps.yandex.net/tiles?l=map&theme=light&x=%x&y=%y&z=%z&scale=1&lang=ru_RU", { projection: ymaps.projection.sphericalMercator });
        };
        var darkLayer = function () {
            return new ymaps.Layer("https://core-renderer-tiles.maps.yandex.net/tiles?l=map&theme=dark&x=%x&y=%y&z=%z&scale=1&lang=ru_RU", { projection: ymaps.projection.sphericalMercator });
        };
        ymaps.mapType.storage.add("ps#light", new ymaps.MapType("ps#light", [lightLayer]));
        ymaps.mapType.storage.add("ps#dark", new ymaps.MapType("ps#dark", [darkLayer]));
        this._mapTypesReady = true;
    };

    YandexMapProvider.prototype._ensureLayouts = function () {
        if (this._markerLayout && this._clusterIconLayout && this._clusterBalloonLayout) return;

        var markerTpl = [
            "<div class='ps-map-marker {{properties.markerActive}} {{properties.markerHot ? \"ps-map-marker--hot\" : ''}}'>",
            "  <div class='ps-map-marker__halo'></div>",
            "  <div class='ps-map-marker__body' style='background: {{properties.markerColor}}; color: {{properties.markerTextColor}}'>",
            "    <span class='ps-map-marker__value'>{{properties.markerLabel}}</span>",
            "  </div>",
            "</div>"
        ].join("");
        this._markerLayout = ymaps.templateLayoutFactory.createClass(markerTpl, {
            getShape: function () { return new ymaps.shape.Circle(new ymaps.geometry.pixel.Point([28, 28]), 26); },
        });

        var clusterTpl = "<div class='ps-map-cluster'><div class='ps-map-cluster__count'>{{properties.geoObjects.length}}</div></div>";
        this._clusterIconLayout = ymaps.templateLayoutFactory.createClass(clusterTpl, {
            build: function () {
                this.constructor.superclass.build.call(this);
                var node = this.getParentElement() && this.getParentElement().firstChild;
                if (!node) return;
                var geoObjects = (this.getData().properties.get("geoObjects") || []).map(function (g) { return g.properties.getAll(); });
                var avg = geoObjects.reduce(function (acc, p) { return acc + (p.stress_index || 0); }, 0) / (geoObjects.length || 1);
                node.classList.add(avg >= 0.75 ? "ps-map-cluster--danger" : avg >= 0.45 ? "ps-map-cluster--warn" : "ps-map-cluster--ok");
            }
        });

        this._clusterBalloonLayout = ymaps.templateLayoutFactory.createClass("<div class='ps-map-popup ps-map-popup--list'></div>", {
            build: function () {
                this.constructor.superclass.build.call(this);
                var container = this.getParentElement() && this.getParentElement().querySelector(".ps-map-popup--list");
                if (!container) return;
                var items = this.getData().properties.get("geoObjects") || [];
                container.innerHTML = items.map(function (g) { return g.properties.get("balloonContent") || ""; }).join("");
            }
        });
    };

    YandexMapProvider.prototype.init = function (container, center, zoom) {
        var self = this;
        if (typeof ymaps === "undefined") return;
        this._container = container;
        ymaps.ready(function () {
            self._ensureMapTypes();
            self._map = new ymaps.Map(container, { center: center, zoom: zoom, type: isNight ? "ps#dark" : "ps#light", controls: ["zoomControl"] });
            self._map.behaviors.disable("scrollZoom");
            self._ensureLayouts();
            self._clusterer = new ymaps.Clusterer({
                clusterIconLayout: self._clusterIconLayout,
                clusterIconOffset: [-28, -28],
                clusterIconShape: { type: "Circle", coordinates: [28, 28], radius: 28 },
                clusterNumbers: [50],
                groupByCoordinates: false,
                clusterDisableClickZoom: true,
                clusterBalloonContentLayout: self._clusterBalloonLayout,
                clusterBalloonPanelMaxMapArea: 0,
            });
            self._map.geoObjects.add(self._clusterer);
            self._ready = true;
            if (self._pending) { self.setFeatures(self._pending); self._pending = null; }
        });
    };

    YandexMapProvider.prototype._renderHeat = function (features) {
        if (!this._map) return;
        if (this._heatLayer) { this._map.geoObjects.remove(this._heatLayer); }
        var collection = new ymaps.GeoObjectCollection({}, { opacity: 0.35, fillOpacity: 0.18, strokeWidth: 0 });
        features.slice(0, 40).forEach(function (f) {
            var coords = f.geometry && f.geometry.coordinates; if (!coords) return;
            var stress = f.properties && (f.properties.stress_index || 0);
            if (!stress) return;
            var radius = 250 + stress * 1200;
            var color = stress > 0.75 ? "rgba(239,68,68,0.4)" : stress > 0.5 ? "rgba(245,158,11,0.4)" : "rgba(14,165,233,0.35)";
            collection.add(new ymaps.Circle([[coords[1], coords[0]], radius], {}, { fillColor: color }));
        });
        this._heatLayer = collection;
        this._map.geoObjects.add(collection);
    };

    YandexMapProvider.prototype.setFeatures = function (fc) {
        if (typeof ymaps === "undefined") return;
        if (!this._map || !this._ready) { this._pending = fc; return; }
        this._ensureLayouts();
        this._clusterer.removeAll();
        this._markers = {};
        var bounds = [];
        var features = fc.features || [];
        var prices = features.map(function (f) { return f.properties && f.properties.hourly_price; }).filter(function (v) { return typeof v === "number"; });
        var avgPrice = prices.length ? prices.reduce(function (a, b) { return a + b; }, 0) / prices.length : null;
        var self = this;

        features.forEach(function (feature) {
            var coords = feature.geometry && feature.geometry.coordinates; if (!coords) return;
            var lng = coords[0], lat = coords[1];
            var p = feature.properties || {};
            var spotId = String(p.spot_id || feature.id || p.id || "");
            var stress = p.stress_index || 0;
            var allowAi = !!p.allow_dynamic_pricing;
            var color = allowAi ? "#22c55e" : "#0ea5e9";
            if (stress > 0.7) color = "#ef4444"; else if (stress > 0.45) color = "#f59e0b";
            var isHot = avgPrice && p.hourly_price && p.hourly_price < avgPrice * 0.75;
            var freeLabel = (p.free_places === 0 || p.free_places) ? p.free_places : null;
            var label = freeLabel != null ? String(freeLabel) : "P";
            var textColor = (color === "#ef4444" || color === "#f59e0b") ? "#ffffff" : "#04121f";
            var popupHtml = buildPopupHtml(p, color);
            var placemark = new ymaps.Placemark([lat, lng], {
                hintContent: (p.lot_name || "") + (p.name ? " — " + p.name : ""),
                balloonContent: popupHtml,
                markerColor: color,
                markerLabel: label,
                markerHot: isHot,
                markerTextColor: textColor,
                stress_index: stress,
            }, {
                iconLayout: self._markerLayout,
                iconOffset: [-26, -26],
                hideIconOnBalloonOpen: false,
                balloonPanelMaxMapArea: 0,
            });
            placemark.events.add("balloonopen", function () {
                self._setActive(placemark);
                notifySelection(spotId, { lat: lat, lng: lng });
                self._map.panTo([lat, lng], { flying: true, duration: 400 });
            });
            placemark.events.add("click", function () {
                self._setActive(placemark);
                notifySelection(spotId, { lat: lat, lng: lng });
            });
            placemark.events.add("balloonclose", function () { self._setActive(null); });
            self._clusterer.add(placemark);
            self._markers[spotId] = placemark;
            bounds.push([lat, lng]);
        });

        if (bounds.length) this._map.setBounds(bounds, { checkZoomRange: true, zoomMargin: 48 });
        this._renderHeat(features);
    };

    YandexMapProvider.prototype._setActive = function (placemark) {
        if (this._activePlacemark && this._activePlacemark !== placemark) {
            this._activePlacemark.properties.set("markerActive", "");
            this._activePlacemark.options.unset("zIndex");
        }
        this._activePlacemark = placemark;
        if (placemark) { placemark.properties.set("markerActive", "ps-map-marker--active"); placemark.options.set("zIndex", 2200); }
    };

    YandexMapProvider.prototype.setActiveMarkerById = function (spotId) {
        if (!this._markers) return;
        var target = this._markers[spotId];
        if (target) {
            this._setActive(target);
        }
    };

    YandexMapProvider.prototype.toggleTheme = function (mode) {
        this._theme = mode || this._theme;
        if (!this._map || !this._ready) return;
        this._ensureMapTypes();
        this._map.setType(this._theme === "night" ? "ps#dark" : "ps#light");
    };

    YandexMapProvider.prototype.setLoading = LeafletMapProvider.prototype.setLoading;

    YandexMapProvider.prototype.drawRouteTo = function (target, fromCoords, onHint) {
        if (!this._map || !target) return;
        if (this._activeRoute) this._map.geoObjects.remove(this._activeRoute);
        var origin = fromCoords ? [fromCoords.lat, fromCoords.lng] : this._map.getCenter();
        var dest = target.lat != null ? [target.lat, target.lng] : target;
        this._activeRoute = new ymaps.Polyline([origin, dest], {}, { strokeColor: "#22c55e", strokeWidth: 4, opacity: 0.82 });
        this._map.geoObjects.add(this._activeRoute);
        var km = distanceKm(origin, dest);
        if (onHint) onHint(km);
        this._map.setBounds(this._activeRoute.geometry.getBounds(), { checkZoomRange: true, zoomMargin: 48 });
    };

    YandexMapProvider.prototype.focusOn = function (lat, lng) {
        if (!this._map || !this._ready) return;
        if (this._highlight) this._map.geoObjects.remove(this._highlight);
        this._highlight = new ymaps.Circle([[lat, lng], 120], {}, { strokeColor: "#fbbf24", strokeOpacity: 0.9, strokeWidth: 3, fillColor: "rgba(251,191,36,0.18)" });
        this._map.geoObjects.add(this._highlight);
        this._map.setCenter([lat, lng], 15, { duration: 300 });
    };

    YandexMapProvider.prototype.onInteraction = function (start, end) {
        var self = this;
        if (!this._map || !this._ready) {
            if (typeof ymaps !== "undefined") ymaps.ready(function () { self.onInteraction(start, end); });
            return;
        }
        ["actionbegin", "wheel", "mousedown", "touchstart"].forEach(function (ev) { if (start) self._map.events.add(ev, start); });
        if (end) self._map.events.add("actionend", end);
    };

    YandexMapProvider.prototype.showUserLocation = function (lat, lng) {
        if (!this._map || !this._ready) return;
        if (this._userMarker) this._map.geoObjects.remove(this._userMarker);
        if (this._userRadius) this._map.geoObjects.remove(this._userRadius);
        this._userRadius = new ymaps.Circle([[lat, lng], 500], {}, { fillColor: "rgba(34,197,94,0.15)", strokeColor: "#22c55e", strokeOpacity: 0.65, strokeWidth: 2, zIndex: 1500 });
        this._userMarker = new ymaps.Placemark([lat, lng], {}, { preset: "islands#circleDotIcon", iconColor: "#16a34a", zIndex: 2000 });
        this._map.geoObjects.add(this._userRadius); this._map.geoObjects.add(this._userMarker);
    };

    YandexMapProvider.prototype.setView = function (lat, lng, zoom) {
        if (!this._map || !this._ready) return;
        this._map.setCenter([lat, lng], zoom || this._map.getZoom(), { duration: 300 });
    };

    // ---------- Helpers ----------
    function buildPopupHtml(props, color) {
        var badges = [];
        if (props.allow_dynamic_pricing) badges.push("<span class='ps-badge ps-badge--success'>AI‑тариф</span>");
        if (props.has_ev_charging) badges.push("<span class='ps-badge'>EV</span>");
        if (props.is_covered) badges.push("<span class='ps-badge'>Крытая</span>");
        if (props.is_24_7) badges.push("<span class='ps-badge'>24/7</span>");
        var occupancy = Math.min(100, Math.round((props.occupancy_7d || 0) * 100));
        var stressTone = occupancy > 80 ? "danger" : occupancy > 60 ? "warn" : "ok";
        var estimate = estimatePricing(props);
        return [
            "<div class='ps-map-popup ps-map-popup--" + stressTone + "'>",
            "  <header class='ps-map-popup-head'>",
            "    <div class='ps-map-popup-title'>" + (props.city || "") + (props.lot_name ? ", " + props.lot_name : "") + (props.name ? " — " + props.name : "") + "</div>",
            "    <div class='ps-map-popup-meta'>" + (props.address || "Адрес уточняется") + "</div>",
            "  </header>",
            "  <div class='ps-map-popup-price'>от <strong>" + (props.hourly_price || "?") + " ₽/час</strong><div class='ps-map-popup-meta'>~" + estimate.h3 + " ₽ за 3 часа · ~" + estimate.h24 + " ₽/сутки</div></div>",
            "  <div class='ps-map-popup-badges'>" + badges.join(" ") + "</div>",
            "  <div class='ps-map-popup-meter'><span style='width:" + occupancy + "%; background:" + color + "'></span><div class='ps-map-popup-meter-label'>загруженность " + occupancy + "%</div></div>",
            "  <div class='ps-map-popup-actions'>",
            "    <button class='ps-btn ps-btn-primary ps-btn-sm' data-spot-id='" + (props.spot_id || props.id || "") + "'>Забронировать</button>",
            "    <button class='ps-btn ps-btn-ghost ps-btn-sm' data-focus-spot='" + (props.spot_id || props.id || "") + "'>Маршрут</button>",
            "  </div>",
            "</div>"
        ].join("");
    }

    function registerSelectionHandler(fn) {
        selectionSubscribers.push(fn);
    }

    function notifySelection(spotId, coords) {
        activeSpotId = spotId;
        try {
            document.dispatchEvent(new CustomEvent("ps:spot-selection", { detail: { spotId: spotId, coords: coords } }));
        } catch (_) {}
        selectionSubscribers.forEach(function (fn) { fn(spotId, coords); });
    }

    function indexFeatures(fc) {
        featureIndex = {};
        (fc.features || []).forEach(function (f) {
            var p = f.properties || {};
            var id = String(p.spot_id || f.id || p.id || "");
            if (id) featureIndex[id] = f;
        });
    }

    function findFeature(id) {
        if (!id) return null;
        return featureIndex[id] || (lastFeatures || []).find(function (f) {
            var pid = f.properties && (f.properties.spot_id || f.properties.id);
            return String(pid || f.id || "") === String(id);
        }) || null;
    }

    function estimatePricing(props) {
        var hourly = Number(props.hourly_price) || 0;
        var nightly = Number(props.nightly_price) || 0;
        var daily = Number(props.daily_price) || 0;
        var oneHour = hourly || Math.max(nightly / 10, daily / 24, 0);
        var threeHours = hourly ? hourly * 3 : oneHour * 3;
        var day = daily || (hourly ? hourly * 12 : threeHours * 2.5);
        return {
            h1: Math.round(oneHour),
            h3: Math.round(threeHours),
            h24: Math.round(day)
        };
    }

    function buildStressHint(props) {
        var stress = props.stress_index || 0;
        var occupancy = props.occupancy_7d || 0;
        if (stress > 0.7 || occupancy > 0.75) {
            return "Сейчас высокая загруженность, лучше рассмотреть альтернативы.";
        }
        if (stress > 0.45 || occupancy > 0.55) {
            var uplift = Math.round(Math.max(stress, occupancy) * 30);
            return "В этом районе обычно дороже на ~" + (uplift || 10) + "%.";
        }
        return "Обычно свободно, бронируйте без ожидания.";
    }

    function createProvider() {
        var id = (MAP_CONFIG.key || MAP_CONFIG.id || "yandex").toLowerCase();
        var fallback = (MAP_CONFIG.fallback || "leaflet").toLowerCase();
        var center = MAP_CONFIG.default_center || [55.75, 37.61];
        var zoom = MAP_CONFIG.default_zoom || 12;
        var container = qs("#map");
        if (!container) return { provider: null, center: center, zoom: zoom };
        var hasYandex = typeof ymaps !== "undefined";
        var hasLeaflet = typeof L !== "undefined";
        var provider = null;
        var opts = Object.assign({}, MAP_CONFIG, { theme: isNight ? "night" : "day" });
        if (id === "yandex" && hasYandex) provider = new YandexMapProvider(opts);
        else if (id === "leaflet" && hasLeaflet) provider = new LeafletMapProvider(opts);
        else if (fallback === "yandex" && hasYandex) provider = new YandexMapProvider(opts);
        else if (hasLeaflet) provider = new LeafletMapProvider(opts);
        if (!provider) return { provider: null, center: center, zoom: zoom };
        provider.init(container, center, zoom);
        return { provider: provider, center: center, zoom: zoom };
    }

    function readFilters() {
        var form = qs("[data-map-filters]");
        if (!form) return {};
        var fd = new FormData(form);
        return {
            only_free: fd.get("only_free") === "on",
            ev: fd.get("ev") === "on",
            covered: fd.get("covered") === "on",
            is_24_7: fd.get("is_24_7") === "on",
            ai_recommended: fd.get("ai_recommended") === "on",
            min_price: priceRange[0],
            max_price: priceRange[1]
        };
    }

    function buildQuery(params) {
        var q = [];
        Object.keys(params).forEach(function (k) {
            var v = params[k];
            if (v === "" || v === null || typeof v === "undefined") return;
            if (typeof v === "boolean") v = v ? "true" : "false";
            q.push(encodeURIComponent(k) + "=" + encodeURIComponent(v));
        });
        return q.length ? "?" + q.join("&") : "";
    }

    function fetchFeatures(provider) {
        if (!provider) return;
        provider.setLoading(true);
        var query = readFilters();
        query.format = "geojson";
        var url = "/api/v1/search/" + buildQuery(query);
        return fetch(url, { headers: { "Accept": "application/json" } })
            .then(function (resp) { if (!resp.ok) throw new Error("Map API error"); return resp.json(); })
            .then(function (data) {
                provider.setFeatures(data);
                indexFeatures(data);
                lastFeatures = data.features || [];
                updateSpotsList(data); updateStats(data);
                try {
                    var minimal = (data.features || []).slice(0, 20).map(function (f) {
                        var p = f.properties || {};
                        return { title: (p.city || "") + (p.lot_name ? ", " + p.lot_name : ""), address: p.address || "", spot_id: p.spot_id || f.id };
                    });
                    localStorage.setItem("ps_offline_spots", JSON.stringify(minimal));
                } catch (_) {}
                try {
                    var pendingFocus = sessionStorage.getItem("ps_focus_spot");
                    if (pendingFocus) {
                        sessionStorage.removeItem("ps_focus_spot");
                        var coords = featureCoordsById(pendingFocus);
                        if (coords) { notifySelection(pendingFocus, coords); }
                    }
                } catch (_) {}
            })
            .catch(function (err) {
                if (window.ParkShare && window.ParkShare.handleApiError) {
                    window.ParkShare.handleApiError(err);
                }
            })
            .finally(function () { provider.setLoading(false); });
    }

    function updateStats(fc) {
        var features = fc.features || [];
        var prices = features.map(function (f) { return f.properties && f.properties.hourly_price; }).filter(function (p) { return typeof p === "number"; });
        var avgEls = qsa("[data-avg-price]"); var countEls = qsa("[data-spots-count]");
        countEls.forEach(function (el) { el.textContent = String(features.length); });
        if (!avgEls.length) return; if (!prices.length) { avgEls.forEach(function (el) { el.textContent = "—"; }); return; }
        var sum = prices.reduce(function (acc, p) { return acc + p; }, 0);
        var value = (Math.round((sum / prices.length) / 10) * 10) + " ₽/час";
        avgEls.forEach(function (el) { el.textContent = value; });
    }

    function updateSpotsList(fc) {
        var container = qs("[data-spots-list]"); if (!container) return;
        var features = fc.features || [];
        if (!features.length) { container.innerHTML = "<div class='ps-empty'><p>Подходящих мест пока нет. Попробуйте изменить фильтры.</p></div>"; return; }
        container.innerHTML = features.map(function (f) {
            var p = f.properties || {};
            var spotId = p.spot_id || f.id || "";
            var badge = p.allow_dynamic_pricing ? "<span class='ps-badge ps-badge--success'>AI‑тариф</span>" : "";
            var estimate = estimatePricing(p);
            var statusIcon = (p.status && p.status !== "active") ? "#ps-ic-forbidden" : (p.hourly_price ? "#ps-ic-paid" : "#ps-ic-allowed");
            var statusLabel = (p.status && p.status !== "active") ? "Ограничена" : (p.hourly_price ? "Платная" : "Разрешена");
            var pills = [
                "<span class='ps-pill ps-pill--accent'><svg class='ps-icon' viewBox='0 0 24 24'><use href='" + statusIcon + "'></use></svg>" + statusLabel + "</span>"
            ];
            if (p.has_ev_charging) pills.push("<span class='ps-pill ps-pill--success'><svg class='ps-icon' viewBox='0 0 24 24'><use href='#ps-ic-ev'></use></svg>EV</span>");
            if (p.is_covered) pills.push("<span class='ps-pill'><svg class='ps-icon' viewBox='0 0 24 24'><use href='#ps-ic-covered'></use></svg>Крытая</span>");
            if (p.is_24_7) pills.push("<span class='ps-pill'>24/7</span>");
            return [
                "<article class='ps-card ps-card--spot ps-animate-fade-up ps-animate-stagger' data-spot-card='" + spotId + "'>",
                "  <div class='ps-card-header'><div class='ps-card-title'>" + (p.city || "") + (p.lot_name ? ", " + p.lot_name : "") + (p.name ? " — " + p.name : "") + "</div>" + badge + "</div>",
                "  <div class='ps-card-body'>",
                "    <div class='ps-spot-meta'>" + pills.join("") + "</div>",
                "    <div class='ps-spot-price'>от " + (p.hourly_price || "?") + " ₽/час</div>",
                "    <div class='ps-spot-estimate'>Оценка: ~" + estimate.h3 + " ₽ за 3 часа · ~" + estimate.h24 + " ₽/сутки</div>",
                "    <div class='ps-card-line ps-card-line--muted'>" + (p.address || "Адрес будет уточнён") + "</div>",
                "    <div class='ps-card-line ps-card-line--muted'>" + buildStressHint(p) + "</div>",
                "  </div>",
                "</article>"
            ].join("");
        }).join("");
        if (activeSpotId) {
            setActiveCard(activeSpotId);
        }
    }

    function featureCoordsById(spotId) {
        var match = findFeature(spotId);
        if (match && match.geometry && match.geometry.coordinates) {
            return { lat: match.geometry.coordinates[1], lng: match.geometry.coordinates[0] };
        }
        return null;
    }

    function setActiveCard(spotId) {
        var idStr = String(spotId || "");
        qsa("[data-spot-card]").forEach(function (card) {
            card.classList.toggle("is-active", card.getAttribute("data-spot-card") === idStr);
        });
        var activeCard = qs("[data-spot-card='" + idStr + "']");
        if (activeCard && typeof activeCard.scrollIntoView === "function") {
            activeCard.scrollIntoView({ behavior: "smooth", block: "center" });
        }
    }

    function initPriceSlider(onChange) {
        var slider = qs("[data-price-slider]"); var priceLabel = qs("[data-price-display]");
        if (!slider || typeof noUiSlider === "undefined") return;
        function render(values) { if (priceLabel) priceLabel.textContent = "Цена: от " + values[0] + " ₽ до " + values[1] + " ₽"; }
        noUiSlider.create(slider, { start: priceRange, connect: true, step: 50, range: { min: 0, max: 2000 } });
        slider.noUiSlider.on("update", function (values) { priceRange = values.map(function (v) { return Math.round(parseFloat(v)); }); render(priceRange); if (onChange) onChange(); });
        render(priceRange);
    }

    function updateRouteHint(km) {
        var hint = qs("[data-route-hint]"); if (!hint) return;
        if (!km) { hint.textContent = "Постройте мини-маршрут до выбранной точки."; return; }
        var timeMin = Math.max(2, Math.round(km / 0.4));
        hint.textContent = "~" + km.toFixed(1) + " км, " + timeMin + " мин пешком/авто.";
    }

    function drawRoute(provider, targetLatLng) {
        if (!provider || !targetLatLng || !provider.drawRouteTo) return;
        var from = userLocation ? { lat: userLocation.lat, lng: userLocation.lng } : null;
        provider.drawRouteTo({ lat: targetLatLng.lat || targetLatLng[0], lng: targetLatLng.lng || targetLatLng[1] }, from, function (km) { updateRouteHint(km); });
    }

    function initFloatingActions(provider) {
        var actions = qs(".ps-map-floating-actions"); if (!actions) return;
        var timer = null;
        function dim() { actions.classList.add("is-dimmed"); }
        function undim() { actions.classList.remove("is-dimmed"); startTimer(); }
        function startTimer() { clearTimeout(timer); timer = setTimeout(dim, 3000); }
        startTimer();
        qsa(".ps-map-action", actions).forEach(function (btn) {
            ["mouseenter", "touchstart", "click"].forEach(function (evt) { btn.addEventListener(evt, undim, { passive: true }); });
        });
        if (provider && provider.onInteraction) provider.onInteraction(undim, startTimer);
    }

    function initGeocode(provider) {
        var inputs = qsa("[data-geocode-input]");
        var primary = inputs.length ? inputs[0] : null;
        var submit = qs("[data-geocode-submit]"); var suggestions = qs("[data-geocode-suggestions]"); var timer = null;

        function syncInputs(value) {
            inputs.forEach(function (el) { el.value = value; });
        }

        function search(query) {
            if (typeof navigator !== "undefined" && navigator.onLine === false) {
                if (window.ParkShare && window.ParkShare.handleApiError) window.ParkShare.handleApiError({ message: "Нет подключения. Поиск недоступен оффлайн." });
                return;
            }
            if (!query) return;
            fetch("/api/geocode/?q=" + encodeURIComponent(query))
                .then(function (resp) { return resp.json(); })
                .then(function (data) {
                    var list = data.results || [];
                    if (suggestions) suggestions.innerHTML = list.map(function (item) { return "<button type='button' data-geocode-choice data-lat='" + item.lat + "' data-lng='" + item.lng + "'>" + item.title + "</button>"; }).join("");
                })
                .catch(function (err) {
                    if (window.ParkShare && window.ParkShare.handleApiError) window.ParkShare.handleApiError(err);
                });
        }

        inputs.forEach(function (input) {
            input.addEventListener("input", function () {
                clearTimeout(timer);
                var value = input.value.trim();
                timer = setTimeout(function () { search(value); }, 350);
            });
            input.addEventListener("keydown", function (evt) {
                if (evt.key === "Enter") { evt.preventDefault(); search(input.value.trim()); }
            });
        });

        if (submit) submit.addEventListener("click", function () { var value = primary ? primary.value : ""; search(value); });
        if (suggestions) {
            suggestions.addEventListener("click", function (e) {
                var btn = e.target.closest("[data-geocode-choice]"); if (!btn) return;
                var lat = parseFloat(btn.getAttribute("data-lat")); var lng = parseFloat(btn.getAttribute("data-lng"));
                suggestions.innerHTML = "";
                syncInputs(btn.textContent || "");
                if (provider && provider.setView) { provider.setView(lat, lng, 15); drawRoute(provider, { lat: lat, lng: lng }); }
            });
        }
    }

    document.addEventListener("DOMContentLoaded", function () {
        var mapContainer = qs("#map"); if (!mapContainer) return;
        var result = createProvider(); var provider = result.provider; if (!provider) return;
        initPriceSlider(function () { fetchFeatures(provider); });
        initGeocode(provider);
        fetchFeatures(provider);
        initFloatingActions(provider);
        applyMapTheme(isNight ? "dark" : "light", provider, mapContainer, true);

        var themeBtn = qs("[data-map-theme]");
        if (themeBtn) themeBtn.addEventListener("click", function () { var next = isNight ? "light" : "dark"; applyMapTheme(next, provider, mapContainer, false); });
        document.addEventListener("ps-theme-changed", function (e) {
            var next = e.detail && e.detail.theme;
            if (next) applyMapTheme(next, provider, mapContainer, true);
        });
        registerSelectionHandler(function (spotId, coords) {
            var point = coords || featureCoordsById(spotId);
            if (provider.setActiveMarkerById) provider.setActiveMarkerById(spotId);
            setActiveCard(spotId);
            if (point) {
                if (provider.focusOn) provider.focusOn(point.lat, point.lng);
                drawRoute(provider, point);
            }
        });

        var filtersForm = qs("[data-map-filters]");
        if (filtersForm) filtersForm.addEventListener("change", function () { fetchFeatures(provider); });

        qsa("[data-chip-toggle]").forEach(function (chip) {
            var input = qs("input", chip); if (!input) return; chip.classList.toggle("is-active", input.checked);
            chip.addEventListener("click", function (e) { if (e.target.tagName === "INPUT") return; input.checked = !input.checked; chip.classList.toggle("is-active", input.checked); input.dispatchEvent(new Event("change", { bubbles: true })); fetchFeatures(provider); });
        });

        var resetBtn = qs("[data-reset-filters]");
        if (resetBtn) {
            resetBtn.addEventListener("click", function () {
                resetBtn.classList.remove("ps-map-action--spinning");
                void resetBtn.offsetWidth;
                resetBtn.classList.add("ps-map-action--spinning");
                if (filtersForm) filtersForm.reset();
                priceRange = [0, 1500];
                var slider = qs("[data-price-slider]");
                if (slider && slider.noUiSlider) slider.noUiSlider.set(priceRange);
                qsa("[data-chip-toggle]").forEach(function (chip) { chip.classList.remove("is-active"); });
                fetchFeatures(provider);
            });
        }

function getCSRFToken() {
    var match = document.cookie.match(/csrftoken=([^;]+)/);
    return match ? match[1] : "";
}

function showToast(message, type) {
    var container = document.querySelector(".ps-toast-container");
    if (!container) return alert(message);
    var toast = document.createElement("div");
    toast.className = "ps-toast ps-toast--" + (type || "info");
    toast.textContent = message;
    container.appendChild(toast);
    setTimeout(function () { toast.remove(); }, 4200);
}

function createBooking(spotId) {
    var now = new Date();
    var end = new Date(now.getTime() + 60 * 60 * 1000);
    return fetch("/api/parking/bookings/", {
        method: "POST",
        credentials: "include",
        headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": getCSRFToken(),
        },
        body: JSON.stringify({
            spot: spotId,
            start_at: now.toISOString(),
            end_at: end.toISOString(),
            booking_type: "hourly",
        }),
    }).then(function (resp) {
        if (resp.status === 401 || resp.status === 403) {
            showToast("Войдите, чтобы бронировать места", "error");
            throw new Error("auth_required");
        }
        if (!resp.ok) {
            return resp.json().then(function (data) {
                var detail = typeof data === "object" ? JSON.stringify(data) : data;
                throw new Error(detail || "Ошибка бронирования");
            }).catch(function (err) { throw err; });
        }
        return resp.json();
    });
}

        qsa("[data-fill-location]").forEach(function (btn) {
            btn.addEventListener("click", function () {
                if (!navigator.geolocation) return; btn.classList.add("ps-map-action--pulse");
                navigator.geolocation.getCurrentPosition(function (pos) {
                    userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
                    if (provider.showUserLocation) provider.showUserLocation(userLocation.lat, userLocation.lng);
                    if (provider.setView) provider.setView(userLocation.lat, userLocation.lng, 14);
                    btn.classList.remove("ps-map-action--pulse");
                }, function () { btn.classList.remove("ps-map-action--pulse"); }, { timeout: 8000 });
            });
        });

        var mapPanel = qs("[data-map-panel]");
        if (mapPanel) {
            mapPanel.addEventListener("click", function (e) {
                var focusBtn = e.target.closest("[data-focus-spot]");
                var bookBtn = e.target.closest("[data-spot-id]");
                if (focusBtn) {
                    var id = focusBtn.getAttribute("data-focus-spot");
                    var coords = featureCoordsById(id);
                    notifySelection(id, coords);
                }
                if (bookBtn) {
                    var targetId = bookBtn.getAttribute("data-spot-id");
                    window.location.href = "/booking/confirm/?spot_id=" + encodeURIComponent(targetId);
                }
            });
        }

        qsa("[data-spots-list]").forEach(function (list) {
            list.addEventListener("click", function (e) {
                var card = e.target.closest("[data-spot-card]"); if (!card) return;
                var id = card.getAttribute("data-spot-card");
                var coords = featureCoordsById(id);
                notifySelection(id, coords);
            });
        });
    });
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 264
PATH: static\js\parkmate-ai.ts
LANG: typescript
===== CONTENT START =====
/**
 * ParkMate AI — фронтовый контракт мультимодального ассистента ParkShare.
 * Файл можно использовать как исходник для будущего SPA/PWA на TypeScript.
 *
 * Соответствует backend‑эндпоинтам:
 *  - GET  /api/ai/parkmate/config/
 *  - POST /api/ai/parkmate/price-forecast/
 *  - POST /api/ai/parkmate/availability/
 *  - POST /api/ai/departure-assistant/
 *  - POST /api/ai/cv/license-plate/        (через cv_service)
 *  - POST /api/ai/cv/parking-occupancy/    (через cv_service)
 */

export interface ParkMateVoiceCommands {
  booking: string;
  navigation: string;
  payment: string;
  support: string;
}

export interface ParkMateComputerVision {
  licensePlateRecognition: string;
  parkingSpotDetection: string;
  damageDetection: string;
  occupancyAnalytics: string;
}

export interface ParkMatePredictions {
  arrivalTime: string;
  priceForecast: string;
  availability: string;
}

export interface ParkMateAI {
  voiceCommands: ParkMateVoiceCommands;
  computerVision: ParkMateComputerVision;
  predictions: ParkMatePredictions;
}

/**
 * Базовый конфиг под RU‑профиль (ParkShare RU).
 * Значения URL должны совпадать с Django‑эндпоинтами.
 */
export const parkMateConfig: ParkMateAI = {
  voiceCommands: {
    booking: "Забронировать парковку рядом",
    navigation: "Построить маршрут до парковки",
    payment: "Оплатить текущую парковку",
    support: "Связаться с поддержкой ParkShare",
  },
  computerVision: {
    licensePlateRecognition: "/api/ai/cv/license-plate/",
    parkingSpotDetection: "/api/ai/cv/parking-occupancy/",
    damageDetection: "/api/ai/cv/vehicle-damage/", // зарезервировано на будущее
    occupancyAnalytics: "/api/ai/stress-index/",
  },
  predictions: {
    arrivalTime: "/api/ai/departure-assistant/",
    priceForecast: "/api/ai/parkmate/price-forecast/",
    availability: "/api/ai/parkmate/availability/",
  },
};

// --------- Типы для REST‑ответов ParkMate ---------

export interface PriceForecastRequestPayload {
  spotId: string;
}

export interface PriceForecastResponse {
  spot_id: string;
  lot_id: string;
  currency: string;
  base_price: number;
  recommended_price: number;
  min_price: number;
  max_price: number;
  discount_percent: number;
  is_discount: boolean;
  reason: string;
}

export interface AvailabilityForecastRequestPayload {
  spotId?: string;
  occupancy_7d?: number;
  stress_index?: number;
}

export interface AvailabilityForecastResponse {
  spot_id: string | null;
  occupancy_7d: number;
  stress_index: number;
  as_of: string;
  availability: {
    next_1h: number;
    next_3h: number;
    next_24h: number;
  };
}

// --------- Helper‑функции для фронта ---------

async function jsonFetch<T>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  const resp = await fetch(url, {
    credentials: "include",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...(options.headers || {}),
    },
  });

  if (!resp.ok) {
    const text = await resp.text();
    throw new Error(`Request failed ${resp.status}: ${text}`);
  }

  return (await resp.json()) as T;
}

export async function getPriceForecast(
  payload: PriceForecastRequestPayload
): Promise<PriceForecastResponse> {
  return jsonFetch<PriceForecastResponse>(
    parkMateConfig.predictions.priceForecast,
    {
      method: "POST",
      body: JSON.stringify({ spot_id: payload.spotId }),
    }
  );
}

export async function getAvailabilityForecast(
  payload: AvailabilityForecastRequestPayload
): Promise<AvailabilityForecastResponse> {
  return jsonFetch<AvailabilityForecastResponse>(
    parkMateConfig.predictions.availability,
    {
      method: "POST",
      body: JSON.stringify({
        spot_id: payload.spotId,
        occupancy_7d: payload.occupancy_7d,
        stress_index: payload.stress_index,
      }),
    }
  );
}
export async function fetchPriceForecast(
  payload: PriceForecastRequestPayload
): Promise<PriceForecastResponse> {
  return jsonFetch<PriceForecastResponse>(
    parkMateConfig.predictions.priceForecast,
    {
      method: "POST",
      body: JSON.stringify({ spot_id: payload.spotId }),
    }
  );
}

export async function fetchAvailabilityForecast(
  payload: AvailabilityForecastRequestPayload
): Promise<AvailabilityForecastResponse> {
  return jsonFetch<AvailabilityForecastResponse>(
    parkMateConfig.predictions.availability,
    {
      method: "POST",
      body: JSON.stringify({
        spot_id: payload.spotId,
        occupancy_7d: payload.occupancy_7d,
        stress_index: payload.stress_index,
      }),
    }
  );
}


===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 265
PATH: static\js\quantum-theme-manager.js
LANG: javascript
===== CONTENT START =====
class QuantumThemeManager {
  constructor(options = {}) {
    this.themes = options.themes || {
      dark: {
        map: "dark",
        css: "dark",
        effects: "hologram-dark",
        emotion: "calm",
      },
      light: {
        map: "standard",
        css: "light",
        effects: "hologram-light",
        emotion: "energetic",
      },
    };
    this.currentTheme = "dark";
    this.root = options.root || document.documentElement;
  }

  async switchTheme(theme) {
    const config = this.themes[theme];
    if (!config) return;

    this.currentTheme = theme;
    const tasks = [
      this.switchCSSTheme(config.css),
      this.switchEmotionalMode(config.emotion),
      this.switchCinematicEffects(config.effects),
    ];

    await Promise.all(tasks);
    this.triggerThemeTransitionAnimation();
  }

  switchCSSTheme(css) {
    this.root.dataset.quantumTheme = css;
    document.body.dataset.quantumTheme = css;
    return Promise.resolve();
  }

  switchEmotionalMode(emotion) {
    document.body.dataset.emotion = emotion;
    return Promise.resolve();
  }

  switchCinematicEffects(effects) {
    document.body.dataset.cinematic = effects;
    return Promise.resolve();
  }

  triggerThemeTransitionAnimation() {
    const flash = document.createElement("div");
    flash.className = "quantum-pulse";
    document.body.appendChild(flash);
    setTimeout(() => flash.remove(), 800);
  }

  bindToggle(buttonId) {
    const btn = document.getElementById(buttonId);
    if (!btn) return;

    btn.addEventListener("click", () => {
      const next = this.currentTheme === "dark" ? "light" : "dark";
      btn.dataset.theme = next;
      const label = btn.querySelector(".quantum-toggle__label");
      if (label) {
        label.textContent = next === "dark" ? "Dark Matter" : "Photon";
      }
      this.switchTheme(next);
    });
  }
}

window.initQuantumThemeManager = function initQuantumThemeManager() {
  const manager = new QuantumThemeManager();
  manager.bindToggle("themeToggle");
  manager.switchTheme("dark");
  return manager;
};

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 266
PATH: static\js\theme.js
LANG: javascript
===== CONTENT START =====
(function () {
  "use strict";

  var STORAGE_KEY = "ps-theme";

  function readInitialTheme() {
    var preset = document.documentElement.getAttribute("data-theme");
    if (preset === "dark" || preset === "light") return preset;
    try {
      var stored = localStorage.getItem(STORAGE_KEY);
      if (stored === "dark" || stored === "light") return stored;
    } catch (_) {
      /* ignore storage errors */
    }
    var prefersDark =
      window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    return prefersDark ? "dark" : "light";
  }

  function setMetaTheme(theme) {
    var meta = document.querySelector('meta[name="theme-color"]');
    if (meta) {
      meta.setAttribute("content", theme === "dark" ? "#050910" : "#f4f6fb");
    }
    try {
      document.documentElement.style.colorScheme = theme;
    } catch (_) {
      /* ignore */
    }
  }

  function updateToggle(theme) {
    var toggles = document.querySelectorAll("[data-theme-toggle]");
    toggles.forEach(function (btn) {
      btn.setAttribute("data-theme", theme);
      btn.setAttribute("aria-pressed", theme === "dark");
    });
  }

  function setTheme(theme) {
    var next = theme === "dark" ? "dark" : "light";
    if (document.documentElement.dataset.theme !== next) {
      document.documentElement.dataset.theme = next;
    }
    try {
      localStorage.setItem(STORAGE_KEY, next);
    } catch (_) {
      /* ignore */
    }
    updateToggle(next);
    setMetaTheme(next);
    document.dispatchEvent(new CustomEvent("ps-theme-changed", { detail: { theme: next } }));
    return next;
  }

  function toggleTheme() {
    var current = document.documentElement.getAttribute("data-theme") === "dark" ? "dark" : "light";
    return setTheme(current === "dark" ? "light" : "dark");
  }

  function initToggle() {
    var toggles = document.querySelectorAll("[data-theme-toggle]");
    var initial = setTheme(readInitialTheme());
    if (!toggles.length) return;
    toggles.forEach(function (btn) {
      btn.addEventListener("click", toggleTheme);
    });
  }

  window.ThemeController = {
    setTheme: setTheme,
    toggle: toggleTheme,
    current: function () {
      return document.documentElement.getAttribute("data-theme") || readInitialTheme();
    },
  };

  document.addEventListener("DOMContentLoaded", initToggle);
})();

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 267
PATH: static\pwa\api-client.js
LANG: javascript
===== CONTENT START =====
import {
  appendSpots,
  flushQueue,
  getState,
  queueAction,
  setConnectionStatus,
  setMapFeatures,
  setSavedPlaces,
  setFavorites,
  setSpots,
  setThemeConfig,
  updatePagination,
  markQueueItem,
} from './state-store.js';

const API_ROOT = '/api/parking';
const AI_ROOT = '/api/ai';
const datasetCache = new Map();
const aiCache = new Map();

async function apiFetch(path, { method = 'GET', body, params } = {}) {
  const url = new URL(path, window.location.origin);
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      if (value === undefined || value === null || value === '') return;
      url.searchParams.set(key, value);
    });
  }
  const headers = { 'Content-Type': 'application/json' };
  const options = { method, headers, credentials: 'include' };
  if (body) options.body = JSON.stringify(body);

  try {
    const response = await fetch(url.toString(), options);
    setConnectionStatus(true);
    if (!response.ok) throw new Error(`API ${response.status}`);
    return await response.json();
  } catch (err) {
    setConnectionStatus(false);
    throw err;
  }
}

export async function loadSpots({ append = false, filters = {}, page = 1, pageSize = 50 }) {
  const params = {
    page,
    page_size: Math.min(pageSize || 50, 100),
    ...filters,
  };
  const cacheKey = `spots:${JSON.stringify(params)}`;
  try {
    const payload = await cachedApiFetch(`${API_ROOT}/spots/`, { params }, cacheKey, 300000);
    const { results, next, previous, count } = payload;
    if (append) {
      appendSpots(results);
    } else {
      setSpots(results);
    }
    updatePagination({ next, previous, count, page_size: params.page_size });
    cacheDataset('spots', payload);
  } catch (err) {
    const cached = readDataset('spots') || datasetCache.get(cacheKey);
    if (cached) {
      const { results, next, previous, count } = cached;
      if (append) {
        appendSpots(results);
      } else {
        setSpots(results);
      }
      updatePagination({ next, previous, count, page_size: params.page_size });
    } else {
      console.warn('[PWA] failed to load spots and no cache', err);
    }
  }
}

export async function loadFavorites() {
  try {
    const payload = await apiFetch(`${API_ROOT}/favorites/`);
    setFavorites(payload.results ? payload.results.map((item) => item.spot) : payload.map((i) => i.spot));
    cacheDataset('favorites', payload);
  } catch (err) {
    const cached = readDataset('favorites');
    if (cached) {
      setFavorites(cached.results ? cached.results.map((i) => i.spot) : cached.map((i) => i.spot));
    }
  }
}

export async function saveFavorite(spotId) {
  if (!navigator.onLine) {
    queueAction({ type: 'favorite:toggle', payload: { spotId } });
    return toggleLocalFavorite(spotId);
  }
  await apiFetch(`${API_ROOT}/favorites/`, {
    method: 'POST',
    body: { spot: spotId },
  });
  toggleLocalFavorite(spotId);
}

function toggleLocalFavorite(spotId) {
  const current = getState().favorites || [];
  if (current.includes(spotId)) {
    setFavorites(current.filter((id) => id !== spotId));
  } else {
    setFavorites([...current, spotId]);
  }
}

export async function loadSavedPlaces() {
  try {
    const payload = await apiFetch(`${API_ROOT}/saved-places/`);
    const items = payload.results || payload;
    setSavedPlaces(items);
    cacheDataset('saved_places', payload);
  } catch (err) {
    const cached = readDataset('saved_places');
    if (cached) {
      setSavedPlaces(cached.results || cached);
    }
  }
}

export async function syncOfflineQueue() {
  const { offlineQueue } = getState();
  if (!offlineQueue.length || !navigator.onLine) return;
  for (const item of offlineQueue) {
    try {
      if (item.type === 'favorite:toggle') {
        await saveFavorite(item.payload.spotId);
        markQueueItem(item.id, { status: 'synced' });
      }
      if (item.type === 'saved_place:create') {
        await createSavedPlace(item.payload.place, { skipQueue: true });
        markQueueItem(item.id, { status: 'synced' });
      }
    } catch (err) {
      const attempts = (item.attempts || 0) + 1;
      if (attempts >= 3) {
        markQueueItem(item.id, { status: 'failed', attempts });
      } else {
        markQueueItem(item.id, { attempts });
      }
    }
  }
  flushQueue((item) => item.status === 'synced' || item.status === 'failed');
}

export async function loadProfile() {
  try {
    const payload = await apiFetch('/api/ai/parkmate/config/');
    setThemeConfig(payload);
  } catch (_) {
    /* ignore */
  }
}

export async function loadMapFeatures(filters = {}) {
  const params = { ...filters };
  const cacheKey = `map:${JSON.stringify(params)}`;
  try {
    const payload = await cachedApiFetch('/api/parking/map/', { params }, cacheKey, 300000);
    setMapFeatures(payload.features || []);
  } catch (err) {
    const cached = datasetCache.get(cacheKey) || readDataset('map_features');
    if (cached?.features) {
      setMapFeatures(cached.features);
    }
  }
}

export async function registerPushSubscription(subscription) {
  await apiFetch('/api/parking/push-subscriptions/', { method: 'POST', body: subscription });
}

export async function loadAiRecommendations(filters = {}) {
  const params = {
    city: filters.city,
    limit: Math.min(filters.limit || 20, 50),
  };
  const cacheKey = `ai:rec:${JSON.stringify(params)}`;
  try {
    const payload = await cachedAiFetch(`${AI_ROOT}/recommendations/`, { params }, cacheKey, 300000);
    return payload?.results || [];
  } catch (err) {
    const cached = readDataset(cacheKey) || aiCache.get(cacheKey)?.payload;
    if (cached) return cached.results || cached;
    throw err;
  }
}

export async function loadAiStressIndex(filters = {}) {
  const params = { city: filters.city };
  const cacheKey = `ai:stress:${JSON.stringify(params)}`;
  try {
    return await cachedAiFetch(`${AI_ROOT}/stress-index/`, { params }, cacheKey, 180000);
  } catch (err) {
    const cached = readDataset(cacheKey) || aiCache.get(cacheKey)?.payload;
    if (cached) return cached;
    throw err;
  }
}

export async function createSavedPlace(place, { skipQueue = false } = {}) {
  const body = {
    title: place.title,
    place_type: place.place_type || 'custom',
    latitude: place.latitude,
    longitude: place.longitude,
  };
  if (!navigator.onLine && !skipQueue) {
    queueAction({ type: 'saved_place:create', payload: { place: body } });
    setSavedPlaces([...(getState().savedPlaces || []), { ...body, id: `local-${Date.now()}` }]);
    return;
  }
  await apiFetch(`${API_ROOT}/saved-places/`, { method: 'POST', body });
  await loadSavedPlaces();
}

async function cachedApiFetch(path, opts, cacheKey, ttlMs = 120000) {
  if (datasetCache.has(cacheKey)) {
    const cached = datasetCache.get(cacheKey);
    if (cached.expires > Date.now()) {
      return cached.payload;
    }
  }
  const payload = await apiFetch(path, opts);
  datasetCache.set(cacheKey, { payload, expires: Date.now() + ttlMs });
  cacheDataset(cacheKey, payload);
  return payload;
}

function cacheDataset(name, payload) {
  try {
    localStorage.setItem(`ps.pwa.cache.${name}`, JSON.stringify(payload));
  } catch (_) {}
}

function readDataset(name) {
  try {
    const raw = localStorage.getItem(`ps.pwa.cache.${name}`);
    return raw ? JSON.parse(raw) : null;
  } catch (_) {
    return null;
  }
}

async function cachedAiFetch(path, opts, cacheKey, ttlMs = 180000) {
  if (aiCache.has(cacheKey)) {
    const cached = aiCache.get(cacheKey);
    if (cached.expires > Date.now()) {
      return cached.payload;
    }
  }
  const payload = await apiFetch(path, opts);
  aiCache.set(cacheKey, { payload, expires: Date.now() + ttlMs });
  cacheDataset(cacheKey, payload);
  return payload;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 268
PATH: static\pwa\app.js
LANG: javascript
===== CONTENT START =====
import { getState, setConnectionStatus, setMapView, subscribe } from './state-store.js';
import { loadFavorites, loadMapFeatures, loadProfile, loadSavedPlaces, syncOfflineQueue } from './api-client.js';
import { initPushUI, initLazyMedia } from './ui-kit.js';

const APP_VERSION = '2024.09.0';

function registerServiceWorker() {
  if (!('serviceWorker' in navigator)) return;
  navigator.serviceWorker
    .register('/service-worker.js', { updateViaCache: 'none' })
    .then((reg) => {
      console.log('[SW] registered', reg.scope);
      if (reg.waiting) {
        notifyUpdate(reg.waiting);
      }
      reg.addEventListener('updatefound', () => {
        const newWorker = reg.installing;
        if (!newWorker) return;
        newWorker.addEventListener('statechange', () => {
          if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
            notifyUpdate(newWorker);
          }
        });
      });
    })
    .catch((err) => console.warn('[SW] registration failed', err));
}

function notifyUpdate(worker) {
  const banner = document.querySelector('[data-sw-update]');
  if (!banner) {
    worker.postMessage('SW_APPLY_UPDATE');
    return;
  }
  banner.hidden = false;
  const btn = banner.querySelector('button');
  btn?.addEventListener('click', () => {
    worker.postMessage('SW_APPLY_UPDATE');
    worker.addEventListener('statechange', () => {
      if (worker.state === 'activated') {
        window.location.reload();
      }
    });
  });
}

async function hydrateUI() {
  initLazyMedia();
  loadFavorites();
  loadSavedPlaces();
  loadProfile();
  initPushUI();

  const needsMap = document.querySelector('[data-spots-list]') || document.querySelector('[data-route="map"]');
  if (needsMap) {
    const [{ initRouter, bindConnectionBanner }, { initSpotsView }] = await Promise.all([
      import('./router.js'),
      import('./spots-view.js'),
    ]);
    bindConnectionBanner();
    initRouter();
    initSpotsView();
    loadMapFeatures();
  }
}

function wireConnectivity() {
  window.addEventListener('online', () => {
    setConnectionStatus(true);
    syncOfflineQueue();
  });
  window.addEventListener('offline', () => setConnectionStatus(false));
}

function hydrateMeta() {
  const counter = document.querySelector('[data-spots-count]');
  subscribe((state) => {
    if (counter) counter.textContent = state.spots.length || state.pagination.count || 0;
  });
}

function init() {
  console.log('[PWA] booting', APP_VERSION);
  registerServiceWorker();
  hydrateUI();
  wireConnectivity();
  hydrateMeta();

  const map = getState().mapView;
  if (map?.center) {
    setMapView(map);
  }
}

document.addEventListener('DOMContentLoaded', init);

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 269
PATH: static\pwa\router.js
LANG: javascript
===== CONTENT START =====
import { subscribe } from './state-store.js';

const routes = {
  map: '[data-route="map"]',
  list: '[data-route="list"]',
  dashboard: '[data-route="dashboard"]',
};

export function initRouter() {
  document.addEventListener('click', (event) => {
    const link = event.target.closest('[data-route-link]');
    if (!link) return;
    const target = link.getAttribute('data-route-link');
    if (!target || !routes[target]) return;
    event.preventDefault();
    showRoute(target);
    history.pushState({ route: target }, '', `#${target}`);
  });

  window.addEventListener('popstate', (event) => {
    const route = event.state?.route || window.location.hash.replace('#', '') || 'map';
    showRoute(route);
  });

  const initial = window.location.hash.replace('#', '') || 'map';
  showRoute(initial);
}

function showRoute(name) {
  Object.entries(routes).forEach(([key, selector]) => {
    document.querySelectorAll(selector).forEach((node) => {
      node.hidden = key !== name;
      node.classList.toggle('is-active', key === name);
    });
  });
}

export function bindConnectionBanner() {
  const badge = document.querySelector('[data-connection-badge]');
  if (!badge) return;
  subscribe((state) => {
    badge.textContent = state.isOnline ? 'Онлайн' : 'Оффлайн режим';
    badge.classList.toggle('is-offline', !state.isOnline);
    badge.hidden = false;
  });
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 270
PATH: static\pwa\spots-view.js
LANG: javascript
===== CONTENT START =====
import { subscribe, toggleFavorite, setMapView } from './state-store.js';
import { loadSpots, saveFavorite, loadAiRecommendations } from './api-client.js';
import { renderSkeletonCards, renderSpotCard } from './ui-kit.js';

let loading = false;
let aiCacheKey = null;
let aiHints = new Map();

export function initSpotsView() {
  const list = document.querySelector('[data-spots-list]');
  if (!list) return;

  subscribe((state) => {
    renderSpots(list, state.spots, state.favorites);
  });

  const loadMoreBtn = document.querySelector('[data-spots-load-more]');
  if (loadMoreBtn) {
    loadMoreBtn.addEventListener('click', () => fetchMore());
  }

  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition((pos) => {
      const center = { lat: pos.coords.latitude, lng: pos.coords.longitude };
      setMapView({ center });
      fetchInitial({ lat: center.lat, lng: center.lng });
    }, () => fetchInitial({}));
  } else {
    fetchInitial({});
  }
}

async function fetchInitial(filters) {
  if (loading) return;
  loading = true;
  renderSkeletonCards(document.querySelector('[data-spots-list]'));
  await Promise.all([loadSpots({ filters, page: 1 }), primeAiHints(filters)]);
  loading = false;
}

async function fetchMore() {
  if (loading) return;
  loading = true;
  const next = document.querySelector('[data-spots-load-more]');
  const page = next?.dataset.page ? Number(next.dataset.page) : 1;
  await loadSpots({ append: true, page: page + 1 });
  if (next) next.dataset.page = page + 1;
  loading = false;
}

function renderSpots(container, spots, favorites) {
  if (!spots || !spots.length) {
    container.innerHTML = '<div class="ps-empty">Нет парковок поблизости или вы офлайн. Проверьте соединение или выберите другой район.</div>';
    return;
  }
  container.innerHTML = '';
  const scoredSpots = [...spots].sort((a, b) => getAiScore(b.id) - getAiScore(a.id));
  scoredSpots.forEach((spot) => {
    const aiHint = aiHints.get(spot.id);
    const card = renderSpotCard(spot, {
      favorite: favorites?.includes(spot.id),
      aiHint,
      onFavorite: () => handleFavorite(spot.id),
    });
    container.appendChild(card);
  });
}

async function handleFavorite(spotId) {
  toggleFavorite(spotId);
  try {
    await saveFavorite(spotId);
  } catch (err) {
    console.warn('[PWA] favorite queued', err);
  }
}

async function primeAiHints(filters) {
  const key = JSON.stringify(filters || {});
  if (aiCacheKey === key && aiHints.size) return;
  aiCacheKey = key;
  try {
    const recommendations = await loadAiRecommendations({ city: filters?.city, limit: 40 });
    aiHints = new Map();
    recommendations.forEach((rec, index) => {
      const spotId = Number(rec.spot_id || rec.spotId);
      if (!spotId) return;
      aiHints.set(spotId, {
        label: index < 3 ? 'Рекомендуем' : 'AI',
        score: 100 - index * 2 + (rec.ai_discount_percent || 0),
        reason: rec.ai_reason || rec.address || '',
      });
    });
  } catch (err) {
    aiHints = new Map();
    console.warn('[PWA] AI hints unavailable', err);
  }
}

function getAiScore(spotId) {
  const hint = aiHints.get(spotId);
  return hint ? hint.score || 0 : 0;
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 271
PATH: static\pwa\state-store.js
LANG: javascript
===== CONTENT START =====
const STORAGE_KEY = 'ps.pwa.state.v2';
const OFFLINE_QUEUE_LIMIT = 50;
const OFFLINE_QUEUE_TTL = 24 * 60 * 60 * 1000;

const initialState = {
  appVersion: '2024.09.0',
  isOnline: navigator.onLine,
  lastKnownPosition: null,
  mapView: { center: null, zoom: 11, features: [] },
  filters: {
    priceMax: null,
    onlyFree: false,
    ev: false,
    covered: false,
    is_24_7: false,
    ai_recommended: false,
    distance_km: 5,
  },
  pagination: {
    next: null,
    previous: null,
    count: 0,
    page_size: 20,
  },
  spots: [],
  favorites: [],
  savedPlaces: [],
  offlineQueue: [],
  profile: { id: null, role: 'guest', layout_profile: 'comfortable', theme: 'light', platform: 'web' },
  pushOptIn: false,
};

let state = loadState();
const subscribers = new Set();

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return { ...initialState };
    const parsed = JSON.parse(raw);
    const now = Date.now();
    const hydratedQueue = (parsed.offlineQueue || []).filter((item) =>
      item && item.created_at && now - item.created_at < OFFLINE_QUEUE_TTL
    );
    return {
      ...initialState,
      ...parsed,
      filters: { ...initialState.filters, ...(parsed.filters || {}) },
      mapView: { ...initialState.mapView, ...(parsed.mapView || {}) },
      profile: { ...initialState.profile, ...(parsed.profile || {}) },
      offlineQueue: hydratedQueue.slice(-OFFLINE_QUEUE_LIMIT),
    };
  } catch (err) {
    console.warn('[PWA] failed to load state', err);
    return { ...initialState };
  }
}

function persist() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (err) {
    console.warn('[PWA] failed to persist state', err);
  }
}

function setState(patch) {
  state = { ...state, ...patch };
  persist();
  subscribers.forEach((cb) => cb(state));
}

export function subscribe(callback) {
  subscribers.add(callback);
  callback(state);
  return () => subscribers.delete(callback);
}

export function getState() {
  return state;
}

export function updateFilters(patch) {
  setState({ filters: { ...state.filters, ...patch } });
}

export function updatePagination(meta) {
  setState({ pagination: { ...state.pagination, ...meta } });
}

export function setSpots(spots) {
  setState({ spots });
}

export function appendSpots(spots) {
  setState({ spots: [...state.spots, ...spots] });
}

export function setConnectionStatus(isOnline) {
  setState({ isOnline });
}

export function setMapView(patch) {
  setState({ mapView: { ...state.mapView, ...patch } });
}

export function setFavorites(favorites) {
  setState({ favorites });
}

export function toggleFavorite(id) {
  const exists = state.favorites.includes(id);
  const updated = exists ? state.favorites.filter((item) => item !== id) : [...state.favorites, id];
  setState({ favorites: updated });
}

export function setSavedPlaces(items) {
  setState({ savedPlaces: items });
}

export function queueAction(action) {
  const now = Date.now();
  const entry = {
    id: action.id || `${now}-${Math.random().toString(16).slice(2, 8)}`,
    type: action.type,
    payload: action.payload || {},
    status: 'pending',
    attempts: action.attempts || 0,
    created_at: action.created_at || now,
  };
  const freshQueue = state.offlineQueue.filter((item) => now - item.created_at < OFFLINE_QUEUE_TTL);
  const offlineQueue = [...freshQueue.slice(-(OFFLINE_QUEUE_LIMIT - 1)), entry];
  setState({ offlineQueue });
  return entry.id;
}

export function flushQueue(predicate) {
  const now = Date.now();
  const kept = state.offlineQueue
    .filter((item) => now - item.created_at < OFFLINE_QUEUE_TTL)
    .filter((item) => !(predicate ? predicate(item) : false));
  setState({ offlineQueue: kept });
}

export function markQueueItem(id, patch) {
  const queue = state.offlineQueue.map((item) => (item.id === id ? { ...item, ...patch } : item));
  setState({ offlineQueue: queue });
}

export function setProfile(profile) {
  setState({ profile: { ...state.profile, ...profile } });
}

export function setThemeConfig(config) {
  const profile = {
    ...state.profile,
    layout_profile: config.layout_profile || state.profile.layout_profile,
    theme: config.theme || state.profile.theme,
    platform: config.platform || state.profile.platform,
  };
  setState({ profile });
}

export function setMapFeatures(features) {
  setState({ mapView: { ...state.mapView, features } });
}

export function setPushOptIn(optIn) {
  setState({ pushOptIn: optIn });
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 272
PATH: static\pwa\ui-kit.js
LANG: javascript
===== CONTENT START =====
import { registerPushSubscription } from './api-client.js';
import { setConnectionStatus, subscribe } from './state-store.js';

export function createBadge(text, tone = 'info') {
  const span = document.createElement('span');
  span.className = `ps-badge ps-badge-${tone}`;
  span.textContent = text;
  return span;
}

export function renderSkeletonCards(container, count = 3) {
  if (!container) return;
  container.innerHTML = '';
  for (let i = 0; i < count; i += 1) {
    const card = document.createElement('article');
    card.className = 'ps-card ps-card--spot ps-card--skeleton';
    card.innerHTML = `
      <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
      <div class="ps-skeleton-line"></div>
      <div class="ps-skeleton-line ps-skeleton-line--short"></div>
    `;
    container.appendChild(card);
  }
}

export function renderSpotCard(spot, { favorite, onFavorite, aiHint } = {}) {
  const card = document.createElement('article');
  card.className = 'ps-card ps-card--spot';
  card.dataset.spotId = spot.id;
  const badge = aiHint
    ? `<span class="ps-badge ps-badge-success">${aiHint.label || 'AI'}</span>`
    : '';
  const priceHint = aiHint?.reason ? `<div class="ps-card-line ps-card-line--muted">${aiHint.reason}</div>` : '';
  card.innerHTML = `
    <div class="ps-card-header">
      <div class="ps-card-title">${spot.lot?.city || ''} ${spot.lot?.name || ''} — ${spot.name}</div>
      <button class="ps-icon-btn" type="button" aria-label="В избранное" data-fav-toggle>
        ${favorite ? '★' : '☆'}
      </button>
    </div>
    <div class="ps-card-body">
      <div class="ps-card-line">от ${spot.hourly_price} ₽/час ${badge}</div>
      <div class="ps-card-line ps-card-line--muted">${spot.lot?.address || 'Адрес уточняется'}</div>
      ${priceHint}
    </div>
  `;
  if (onFavorite) {
    card.querySelector('[data-fav-toggle]')?.addEventListener('click', onFavorite);
  }
  return card;
}

export function initLazyMedia() {
  document.querySelectorAll('img[loading="lazy"], source[loading="lazy"]').forEach((node) => {
    node.decoding = 'async';
  });
  const lazyNodes = document.querySelectorAll('[data-lazy-src]');
  if (!lazyNodes.length) return;
  const observer = new IntersectionObserver((entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const el = entry.target;
        el.src = el.dataset.lazySrc;
        observer.unobserve(el);
      }
    });
  });
  lazyNodes.forEach((node) => observer.observe(node));
}

export function initPushUI() {
  const toggle = document.querySelector('[data-push-optin]');
  if (!toggle || !('serviceWorker' in navigator) || !('PushManager' in window)) return;
  toggle.addEventListener('click', async () => {
    try {
      const permission = await Notification.requestPermission();
      if (permission !== 'granted') return;
      const reg = await navigator.serviceWorker.ready;
      const subscription = await reg.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: window.PARKSHARE_VAPID_KEY || undefined,
      });
      await registerPushSubscription(subscription.toJSON());
      toggle.setAttribute('disabled', 'disabled');
      toggle.textContent = 'Уведомления включены';
    } catch (err) {
      console.warn('[PWA] push subscribe failed', err);
    }
  });
}

export function initConnectionBadge() {
  const badge = document.querySelector('[data-connection-indicator]');
  if (!badge) return;
  subscribe((state) => {
    if (state.isOnline) {
      badge.textContent = 'Онлайн';
      badge.classList.remove('ps-badge-offline');
    } else {
      badge.textContent = 'Оффлайн';
      badge.classList.add('ps-badge-offline');
    }
  });
  window.addEventListener('online', () => setConnectionStatus(true));
  window.addEventListener('offline', () => setConnectionStatus(false));
}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 273
PATH: templates\base.html
LANG: html
===== CONTENT START =====
{% load static %}
<!doctype html>
<html lang="ru" data-platform="{{ PLATFORM_MODE|default:'RU' }}">
<head>
    <meta charset="utf-8">
    <title>{% block title %}ParkShare — smart parking{% endblock %}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

    <!-- PWA -->
    <meta name="theme-color" content="#050910">
    <link rel="manifest" href="{% url 'manifest' %}">
    <link rel="apple-touch-icon" sizes="192x192" href="{% static 'icons/icon-192.png' %}">
    <link rel="apple-touch-icon" sizes="512x512" href="{% static 'icons/icon-512.png' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'icons/icon-72.png' %}">

    <script>
        (function() {
            var storageKey = "ps-theme";
            var theme = "dark";
            try {
                var stored = localStorage.getItem(storageKey);
                var prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
                if (stored === "dark" || stored === "light") {
                    theme = stored;
                } else {
                    theme = prefersDark ? "dark" : "light";
                }
            } catch (_) {
                theme = "dark";
            }
            document.documentElement.dataset.theme = theme;
            try { document.documentElement.style.colorScheme = theme; } catch (_) {}
            var meta = document.querySelector('meta[name="theme-color"]');
            if (meta) {
                meta.setAttribute("content", theme === "dark" ? "#050910" : "#f4f6fb");
            }
        })();
    </script>

    <link rel="stylesheet" href="{% static 'css/app.css' %}">

    {% block extra_head %}{% endblock %}
</head>
<body class="ps-body" data-user-id="{% if user.is_authenticated %}{{ user.id }}{% endif %}">
<div class="ps-app">
    <svg aria-hidden="true" focusable="false" style="position:absolute;width:0;height:0;overflow:hidden">
        <symbol id="ps-ic-allowed" viewBox="0 0 24 24">
            <path d="M6 3.5h8.2a5.3 5.3 0 0 1 0 10.6H9.5v6.4H6V3.5Zm3.5 3v4.5h4.7a2.2 2.2 0 1 0 0-4.5H9.5Z" fill="currentColor"/>
        </symbol>
        <symbol id="ps-ic-paid" viewBox="0 0 24 24">
            <path d="M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm.9 5c1.6 0 2.6.9 2.6 2.3 0 1.3-1 2.2-2.6 2.2h-2v2.1H9V8h3.9Zm-2 .9v2.7h1.9c.8 0 1.3-.5 1.3-1.3 0-.8-.5-1.4-1.3-1.4H10.9Z" fill="currentColor"/>
        </symbol>
        <symbol id="ps-ic-forbidden" viewBox="0 0 24 24">
            <path d="M12 3.2a8.8 8.8 0 1 1 0 17.6A8.8 8.8 0 0 1 12 3.2Zm0 2a6.8 6.8 0 0 0-5.3 10.9l9.4-9.4A6.8 6.8 0 0 0 12 5.2Zm0 13.6a6.8 6.8 0 0 0 5.3-10.9l-9.4 9.4a6.8 6.8 0 0 0 4.1 1.5Z" fill="currentColor"/>
        </symbol>
        <symbol id="ps-ic-ev" viewBox="0 0 24 24">
            <path d="m13.4 2-7 12.5h4.7L10.6 22 18 9.5h-4.6L13.4 2Z" fill="currentColor"/>
        </symbol>
        <symbol id="ps-ic-covered" viewBox="0 0 24 24">
            <path d="M4 10.5 12 5l8 5.5V21h-5.5v-4h-5v4H4v-10.5Zm2 1.4V19h2.5v-4h5v4H16v-7.1L12 8.7l-4 3.2Z" fill="currentColor"/>
        </symbol>
        <symbol id="ps-ic-locate" viewBox="0 0 24 24">
            <path d="M12 4.8a7.2 7.2 0 1 1 0 14.4 7.2 7.2 0 0 1 0-14.4Zm0 2a5.2 5.2 0 1 0 0 10.4 5.2 5.2 0 0 0 0-10.4Zm0 2.7a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5Z" fill="currentColor"/>
        </symbol>
    </svg>
    <header class="ps-topbar">
        <div class="ps-topbar__safe">
            <div class="ps-topbar__row">
                <a href="{% url 'landing' %}" class="ps-brand">
                    <span class="ps-brand__title">ParkShare</span>
                    <span class="ps-brand__region">{{ REGION_PROFILE }}</span>
                </a>
                <div class="ps-topbar__actions">
                    {% if user.is_authenticated %}
                        <a href="{% url 'accounts:profile' %}" class="ps-icon-btn" aria-label="Профиль" title="{{ user.username }}">
                            <svg class="ps-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Zm0 11c-3.3 0-6 1.7-6 3.8V20h12v-1.7c0-2.1-2.7-3.8-6-3.8Z" fill="currentColor"/></svg>
                        </a>
                    {% else %}
                        <a href="{% url 'accounts:login' %}" class="ps-icon-btn" aria-label="Войти">
                            <svg class="ps-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3a7 7 0 0 0-7 7v3.5A4.5 4.5 0 0 0 9.5 18h.8l1.7 2.6c.4.6 1.3.6 1.7 0L15.5 18h.8A4.5 4.5 0 0 0 19 13.5V10a7 7 0 0 0-7-7Zm0 2a5 5 0 0 1 5 5v3.5a2.5 2.5 0 0 1-2.5 2.5h-1.4l-1.1 1.8-1.1-1.8H9.5A2.5 2.5 0 0 1 7 13.5V10a5 5 0 0 1 5-5Z" fill="currentColor"/></svg>
                        </a>
                    {% endif %}
                    <button type="button" class="ps-icon-btn" data-theme-toggle aria-label="Переключить тему">
                        <svg class="ps-icon ps-icon-sun" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM12 2v2m0 16v2m10-10h-2M4 12H2m16.95 6.95-1.41-1.41M6.46 7.46 5.05 6.05m13.9 0-1.41 1.41M6.46 16.54l-1.41 1.41" stroke="currentColor" stroke-width="1.6" fill="none" stroke-linecap="round"/></svg>
                        <svg class="ps-icon ps-icon-moon" viewBox="0 0 24 24" aria-hidden="true"><path d="M20 13.5A8.5 8.5 0 0 1 10.5 4 7 7 0 1 0 20 13.5Z" fill="currentColor"/></svg>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="ps-main">
        <div class="ps-update-banner" data-sw-update hidden>
            <div class="ps-update-banner__text">Доступно обновление PWA.</div>
            <button type="button" class="ps-btn ps-btn-primary ps-btn-sm">Обновить</button>
        </div>
        {% block content %}{% endblock %}
    </main>

    <footer class="ps-footer">
        <div class="ps-footer__inner">
            <span>© {% now "Y" %} ParkShare RU</span>
            <span class="ps-footer__meta">PWA · Offline-first · AI pricing</span>
        </div>
    </footer>

    <button class="ps-back-to-top" type="button" data-back-to-top aria-label="Наверх">↑</button>

    <div class="ps-toast-container" aria-live="polite" aria-atomic="true"></div>

    <nav class="ps-tabbar" data-bottom-nav>
        <a href="{% url 'landing' %}" class="ps-tabbar__item" data-nav="map" aria-label="Карта">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M9.5 4.2 4 6.3v13l5.5-2.1 5 2.1 5.5-2.1v-13l-5.5 2.1-5-2.1Zm0 2.3 5 2.1v9l-5-2.1v-9Zm-1 9.2-3.5 1.3v-9l3.5-1.3v9Zm11-7.7v9l-3.5 1.3v-9l3.5-1.3Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Карта</span>
        </a>
        <a href="{% url 'user_dashboard' %}" class="ps-tabbar__item" data-nav="bookings" aria-label="Брони">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M7 4.5h10c.8 0 1.5.7 1.5 1.5v12a1.5 1.5 0 0 1-1.5 1.5H7A1.5 1.5 0 0 1 5.5 18V6c0-.8.7-1.5 1.5-1.5Zm0 1.5V9h10V6H7Zm0 4v6h10v-6H7Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Брони</span>
        </a>
        <a href="{% url 'owner_dashboard' %}" class="ps-tabbar__item" data-nav="parking" aria-label="Моя парковка">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M7.5 4h7A3.5 3.5 0 0 1 18 7.5c0 1.9-1.6 3.5-3.5 3.5H9v6H7.5V4Zm7 6A2.5 2.5 0 0 0 17 7.5 2.5 2.5 0 0 0 14.5 5H9v5h5.5Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Моя парковка</span>
        </a>
        <a href="{% url 'ai_chat' %}" class="ps-tabbar__item" data-nav="assistant" aria-label="Ассистент">
            <span class="ps-tabbar__icon" aria-hidden="true">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a7 7 0 0 0-7 7v3.5A4.5 4.5 0 0 0 9.5 18h.8l1.7 2.6c.4.6 1.3.6 1.7 0L15.5 18h.8A4.5 4.5 0 0 0 19 13.5V10a7 7 0 0 0-7-7Zm0 2a5 5 0 0 1 5 5v3.5a2.5 2.5 0 0 1-2.5 2.5h-1.4l-1.1 1.8-1.1-1.8H9.5A2.5 2.5 0 0 1 7 13.5V10a5 5 0 0 1 5-5Z" fill="currentColor"/></svg>
            </span>
            <span class="ps-tabbar__label">Ассистент</span>
        </a>
    </nav>

    <div class="ps-install-banner" data-install-banner hidden>
        <div class="ps-install-banner__inner">
            <div class="ps-install-banner__text">
                Установите <strong>ParkShare RU</strong> как приложение
            </div>
            <div class="ps-install-banner__actions">
                <button type="button" class="ps-btn ps-btn-secondary" data-install-dismiss>Позже</button>
                <button type="button" class="ps-btn" data-install-accept>Установить</button>
            </div>
        </div>
    </div>

    <div class="ps-onboarding" data-onboarding hidden>
        <div class="ps-onboarding__backdrop"></div>
        <div class="ps-onboarding__card">
            <div class="ps-onboarding__slides" data-onboarding-slides>
                <article class="ps-onboarding__slide is-active">
                    <p class="ps-kicker">AI-консьерж</p>
                    <h2>Ищет парковку по маршруту</h2>
                    <p>Учитывает бюджет, EV и крытые места, запоминает предпочтения.</p>
                </article>
                <article class="ps-onboarding__slide">
                    <p class="ps-kicker">Прогнозы</p>
                    <h2>Подсказки по цене и загруженности</h2>
                    <p>Stress index, подсказки 1/3/24h и статус мест прямо в карточках.</p>
                </article>
                <article class="ps-onboarding__slide">
                    <p class="ps-kicker">PWA + оффлайн</p>
                    <h2>Работает без сети</h2>
                    <p>Кэширует недавние места, предлагает установить на экран, напоминает о завершении брони.</p>
                </article>
            </div>
            <div class="ps-onboarding__actions">
                <button type="button" class="ps-btn ps-btn-ghost" data-onboarding-skip>Пропустить</button>
                <button type="button" class="ps-btn" data-onboarding-next>Далее</button>
            </div>
        </div>
    </div>
</div>

<script src="{% static 'js/app.js' %}"></script>
<script src="{% static 'js/theme.js' %}"></script>
{% block extra_scripts %}{% endblock %}
</body>
</html>

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 274
PATH: templates\offline.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Оффлайн — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top ps-section--center">
    <div class="ps-card ps-card--elevated ps-card--compact">
        <div class="ps-card-header ps-card-header--center">
            <div class="ps-offline-icon">☁️</div>
            <h1 class="ps-section-title">Оффлайн-режим</h1>
            <p class="ps-section-subtitle">
                Показываем сохранённые места и избранное. Онлайн-цены обновятся при подключении.
            </p>
        </div>
        <div class="ps-card-body ps-card-body--spacing-lg" id="offline-cache">
            <div class="ps-empty">Загрузка сохранённых данных…</div>
        </div>
        <div class="ps-card-body ps-card-body--spacing-lg ps-card-body--center">
            <button type="button" class="ps-btn" onclick="location.reload()">Повторить попытку</button>
            <a href="{% url 'landing' %}" class="ps-btn ps-btn-secondary">На главную</a>
        </div>
    </div>
</section>
<script>
    (function() {
        const container = document.getElementById("offline-cache");
        if (!container) return;
        try {
            const cached = JSON.parse(localStorage.getItem("ps_offline_spots") || "[]");
            if (!cached.length) {
                container.innerHTML = '<div class="ps-empty">Нет сохранённых мест. Откройте карту при сети, чтобы они появились тут.</div>';
                return;
            }
            container.innerHTML = cached.map(function(item) {
                return '<div class="ps-card ps-card--spot"><div class="ps-card-title">' + (item.title || "Место") + '</div><div class="ps-card-line ps-card-line--muted">' + (item.address || "") + '</div></div>';
            }).join("");
        } catch (e) {
            container.innerHTML = '<div class="ps-empty">Не удалось загрузить сохранённые данные.</div>';
        }
    })();
</script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 275
PATH: templates\accounts\login.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Вход в ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Вход</h1>
        <p class="ps-auth-subtitle">
            Выберите удобный способ: пароль, одноразовый код или соцсети.
        </p>

        <div class="ps-auth-tabs" data-auth-switcher>
            <button type="button" class="is-active" data-auth-target="password">Пароль</button>
            <button type="button" data-auth-target="otp">SMS / Email</button>
            <button type="button" data-auth-target="social">VK / Яндекс / Google</button>
        </div>

        <div class="ps-auth-panels">
            <div class="ps-auth-panel is-active" data-auth-panel="password">
                <form method="post" class="ps-form">
                    {% csrf_token %}
                    {% if form.non_field_errors %}
                        <div class="ps-alert ps-alert--danger">
                            {{ form.non_field_errors }}
                        </div>
                    {% endif %}

                    {% for field in form.visible_fields %}
                        <div class="ps-form-row">
                            <label class="ps-form-label" for="{{ field.id_for_label }}">
                                {{ field.label }}
                            </label>

                            {{ field }}

                            {% if field.help_text %}
                                <div class="ps-field-help">{{ field.help_text }}</div>
                            {% endif %}
                            {% for error in field.errors %}
                                <div class="ps-field-error">{{ error }}</div>
                            {% endfor %}
                        </div>
                    {% endfor %}

                    <div class="ps-form-actions">
                        <button type="submit" class="ps-btn ps-btn-full">
                            Войти
                        </button>
                    </div>
                </form>
            </div>

            <div class="ps-auth-panel" data-auth-panel="otp">
                <div class="ps-auth-placeholder">
                    <p>Получите одноразовый код по SMS или email. Телефон вводите в формате +7.</p>
                    <div class="ps-form-row">
                        <label class="ps-form-label" for="otp-identifier">Телефон или email</label>
                        <input id="otp-identifier" type="text" data-otp-identifier class="ps-input" placeholder="+7 999 000 11 22">
                    </div>
                    <div class="ps-form-row ps-form-row--inline">
                        <button type="button" class="ps-btn ps-btn-secondary" data-otp-request>Запросить код</button>
                        <span class="ps-text-muted" data-otp-status></span>
                    </div>
                    <div class="ps-form-row">
                        <label class="ps-form-label" for="otp-code">Код из сообщения</label>
                        <input id="otp-code" type="text" class="ps-input" data-otp-code maxlength="6" inputmode="numeric">
                    </div>
                    <div class="ps-form-actions">
                        <button type="button" class="ps-btn ps-btn-full" data-otp-verify>Войти по коду</button>
                    </div>
                    <div class="ps-alert ps-alert--muted" data-otp-hint hidden></div>
                </div>
            </div>

            <div class="ps-auth-panel" data-auth-panel="social">
                <div class="ps-auth-placeholder">
                    <p class="ps-text-muted">Выберите провайдера. Мы запрашиваем только email и имя — ничего не публикуем.</p>
                    <div class="ps-social-banners">
                        <a class="ps-social-banner ps-social-banner--google" data-social="google" href="{% url 'oauth_start' 'google' %}?next={{ request.path }}">
                            <span class="ps-social-banner__stripe" aria-hidden="true">
                                <svg viewBox="0 0 24 24" role="presentation">
                                    <path fill="#4285F4" d="M21.6 12.23c0-.8-.07-1.6-.21-2.36H12v4.48h5.36a4.6 4.6 0 0 1-2 3.02v2.5h3.24c1.9-1.75 3-4.33 3-7.64Z"/>
                                    <path fill="#34A853" d="M12 22c2.7 0 4.96-.9 6.62-2.43l-3.24-2.5c-.9.6-2.06.96-3.38.96-2.6 0-4.8-1.76-5.58-4.12H3.08v2.59A10 10 0 0 0 12 22Z"/>
                                    <path fill="#FBBC05" d="M6.42 13.91c-.2-.6-.32-1.24-.32-1.91s.12-1.32.32-1.91V7.5H3.08A10 10 0 0 0 2 12c0 1.6.38 3.1 1.08 4.5l3.34-2.59Z"/>
                                    <path fill="#EA4335" d="M12 6.08c1.46 0 2.77.5 3.8 1.47l2.84-2.84C16.96 2.9 14.7 2 12 2 7.92 2 4.36 4.3 3.08 7.5l3.34 2.59C7.2 7.84 9.4 6.08 12 6.08Z"/>
                                </svg>
                            </span>
                            <span class="ps-social-banner__text">
                                <span class="ps-social-banner__title">Sign in with Google</span>
                                <span class="ps-social-banner__hint">Быстрый вход по аккаунту Google</span>
                            </span>
                        </a>
                        <a class="ps-social-banner ps-social-banner--vk" data-social="vk" href="{% url 'oauth_start' 'vk' %}?next={{ request.path }}">
                            <span class="ps-social-banner__stripe" aria-hidden="true">
                                <svg viewBox="0 0 24 24" role="presentation" fill="#fff">
                                    <path d="M3.5 7h2.7l2.2 4 2.1-4h2.4l-1.4 4.3 3.2-4.3h2.6l-4.2 5.3 3.8 5.7h-2.7l-2.3-3.5-2.3 3.5H8.9l3.8-5.4L7.6 7H3.5Z"/>
                                </svg>
                            </span>
                            <span class="ps-social-banner__text">
                                <span class="ps-social-banner__title">Войти через VK ID</span>
                                <span class="ps-social-banner__hint">Имя и email, без публикаций</span>
                            </span>
                        </a>
                        <a class="ps-social-banner ps-social-banner--yandex" data-social="yandex" href="{% url 'oauth_start' 'yandex' %}?next={{ request.path }}">
                            <span class="ps-social-banner__stripe" aria-hidden="true">
                                <svg viewBox="0 0 24 24" role="presentation">
                                    <path d="M8 3h3.6l2 6.3L15.6 3H19l-3.5 8V21h-2.6v-5.5L8 3Z" fill="#111"/>
                                </svg>
                            </span>
                            <span class="ps-social-banner__text">
                                <span class="ps-social-banner__title">Войти через Яндекс ID</span>
                                <span class="ps-social-banner__hint">Только профиль, без сторонних прав</span>
                            </span>
                        </a>
                    </div>
                    <p class="ps-text-muted">Если провайдер недоступен, попробуйте другой или войдите по коду/MFA.</p>
                </div>
            </div>
        </div>

        <div class="ps-auth-footer">
            Нет аккаунта?
            <a href="{% url 'accounts:register' %}">Зарегистрируйтесь</a>
            <br>
            <a href="{% url 'accounts:password_reset' %}">Забыли пароль?</a>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
<script>
    (function () {
        const root = document.querySelector('[data-auth-switcher]');
        if (!root) return;
        const buttons = Array.from(root.querySelectorAll('[data-auth-target]'));
        const panels = Array.from(document.querySelectorAll('[data-auth-panel]'));
        buttons.forEach(function (btn) {
            btn.addEventListener('click', function () {
                const target = btn.getAttribute('data-auth-target');
                buttons.forEach(function (b) { b.classList.toggle('is-active', b === btn); });
                panels.forEach(function (panel) {
                    panel.classList.toggle('is-active', panel.getAttribute('data-auth-panel') === target);
                });
            });
        });

        function csrf() {
            const m = document.cookie.match(/csrftoken=([^;]+)/);
            return m ? m[1] : "";
        }
        const idInput = document.querySelector('[data-otp-identifier]');
        const codeInput = document.querySelector('[data-otp-code]');
        const statusLabel = document.querySelector('[data-otp-status]');
        const hint = document.querySelector('[data-otp-hint]');
        const requestBtn = document.querySelector('[data-otp-request]');
        const verifyBtn = document.querySelector('[data-otp-verify]');
        function setStatus(text, isError) {
            if (!statusLabel) return;
            statusLabel.textContent = text || "";
            statusLabel.classList.toggle('ps-text-danger', !!isError);
        }
        if (requestBtn && idInput) {
            requestBtn.addEventListener('click', function () {
                setStatus("Отправляем...", false);
                fetch("{% url 'auth_otp_request' %}", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": csrf(),
                    },
                    body: JSON.stringify({ identifier: idInput.value, purpose: "login" }),
                }).then(function (resp) { return resp.json().then(function (data) { return { status: resp.status, data: data }; }); })
                    .then(function (payload) {
                        if (payload.status >= 400) throw payload.data;
                        setStatus("Код отправлен. Проверьте сообщения.", false);
                        if (hint) { hint.hidden = false; hint.textContent = "Код действует ограниченное время. Не сообщайте его никому."; }
                    })
                    .catch(function (err) {
                        const msg = (err && (err.detail || err.message)) || "Не удалось отправить код";
                        setStatus(msg, true);
                    });
            });
        }
        if (verifyBtn && idInput && codeInput) {
            verifyBtn.addEventListener('click', function () {
                setStatus("Проверяем...", false);
                fetch("{% url 'auth_otp_verify' %}", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": csrf(),
                    },
                    body: JSON.stringify({ identifier: idInput.value, code: codeInput.value, purpose: "login" }),
                }).then(function (resp) { return resp.json().then(function (data) { return { status: resp.status, data: data }; }); })
                    .then(function (payload) {
                        if (payload.status >= 400) throw payload.data;
                        setStatus("Готово! Перезагружаем страницу…", false);
                        window.location.href = "{{ request.GET.next|default:'/' }}";
                    })
                    .catch(function (err) {
                        const msg = (err && (err.detail || err.message)) || "Код не подошёл";
                        setStatus(msg, true);
                    });
            });
        }

        var socialLinks = document.querySelectorAll('[data-social]');
        socialLinks.forEach(function (link) {
            link.addEventListener('click', function () {
                socialLinks.forEach(function (l) { l.classList.add('is-disabled'); });
                var title = link.querySelector('.ps-social-banner__title');
                if (title) { title.textContent = 'Перенаправляем...'; }
                link.setAttribute('aria-busy', 'true');
            });
        });
    })();
</script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 276
PATH: templates\accounts\mfa_setup.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Настройка MFA{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Многофакторная аутентификация</h1>
        <p class="ps-auth-subtitle">Выберите метод: TOTP приложение, SMS или email. Второй фактор защитит ваш аккаунт.</p>

        {% if status %}
            <div class="ps-alert ps-alert--success">{{ status }}</div>
        {% endif %}
        {% if error %}
            <div class="ps-alert ps-alert--danger">{{ error }}</div>
        {% endif %}

        <div class="ps-auth-panels">
            <div class="ps-auth-panel is-active">
                <h3>1. Выбор метода</h3>
                <div class="ps-auth-social" style="gap: 10px;">
                    <form method="post" style="display:inline-block;">
                        {% csrf_token %}
                        <input type="hidden" name="action" value="start_totp" />
                        <button type="submit" class="ps-btn ps-btn-ghost">TOTP (Google Authenticator)</button>
                    </form>
                    <form method="post" style="display:inline-block;">
                        {% csrf_token %}
                        <input type="hidden" name="action" value="start_sms" />
                        <button type="submit" class="ps-btn ps-btn-ghost">SMS код</button>
                    </form>
                    <form method="post" style="display:inline-block;">
                        {% csrf_token %}
                        <input type="hidden" name="action" value="start_email" />
                        <button type="submit" class="ps-btn ps-btn-ghost">Email код</button>
                    </form>
                </div>
                <p class="ps-text-muted">TOTP самый надёжный: работает оффлайн и не зависит от доставки сообщений.</p>
            </div>
        </div>

        {% if secret %}
            <div class="ps-card ps-card--outlined" style="margin-top:16px;">
                <h3>2. Сканируйте QR</h3>
                {% if otpauth_url %}
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=220x220&data={{ otpauth_url|urlencode }}" alt="TOTP QR" />
                    <p class="ps-text-muted" style="margin-top:8px;">Если QR не сканируется, введите секрет вручную: <code>{{ secret }}</code></p>
                {% endif %}
                <form method="post" class="ps-form" style="margin-top:12px;">
                    {% csrf_token %}
                    <input type="hidden" name="action" value="verify" />
                    <label class="ps-form-label" for="code">Код из приложения</label>
                    <input id="code" name="code" type="text" class="ps-input" maxlength="6" placeholder="123456" />
                    <button class="ps-btn ps-btn-full" type="submit">Активировать MFA</button>
                </form>
            </div>
        {% elif method != "none" %}
            <div class="ps-card ps-card--outlined" style="margin-top:16px;">
                <h3>2. Подтвердите код</h3>
                <form method="post" class="ps-form">
                    {% csrf_token %}
                    <input type="hidden" name="action" value="verify" />
                    <label class="ps-form-label" for="code-otp">Код</label>
                    <input id="code-otp" name="code" type="text" class="ps-input" maxlength="6" placeholder="Код из SMS/Email" />
                    <button class="ps-btn ps-btn-full" type="submit">Активировать MFA</button>
                </form>
            </div>
        {% endif %}

        {% if mfa_enabled %}
            <div class="ps-card ps-card--outlined ps-alert--muted" style="margin-top:16px;">
                <p class="ps-text-muted">MFA уже включена ({{ method }}). Отключайте только при смене устройства.</p>
                <form method="post">
                    {% csrf_token %}
                    <input type="hidden" name="action" value="disable" />
                    <button class="ps-btn ps-btn-secondary">Отключить MFA</button>
                </form>
            </div>
        {% endif %}
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 277
PATH: templates\accounts\mfa_verify.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Подтверждение MFA{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Подтвердите вход</h1>
        <p class="ps-auth-subtitle">
            Введите код из приложения или сообщения, чтобы завершить авторизацию.
        </p>

        {% if error %}
            <div class="ps-alert ps-alert--danger">{{ error }}</div>
        {% endif %}
        {% if request.GET.status == "resend" %}
            <div class="ps-alert ps-alert--muted">Мы отправили новый код.</div>
        {% endif %}

        <form method="post" class="ps-form">
            {% csrf_token %}
            <div class="ps-form-row">
                <label class="ps-form-label" for="code">Код MFA</label>
                <input id="code" type="text" name="code" class="ps-input" maxlength="12" autofocus placeholder="123456" />
                {% if method == "totp" %}
                    <div class="ps-field-help">Откройте приложение-аутентификатор и введите 6-значный код.</div>
                {% elif channel == "sms" %}
                    <div class="ps-field-help">Мы отправили SMS с кодом. Не сообщайте его никому.</div>
                {% elif channel == "email" %}
                    <div class="ps-field-help">Код отправлен на ваш email. Проверьте входящие и спам.</div>
                {% endif %}
            </div>
            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">Подтвердить</button>
            </div>
        </form>
        {% if channel %}
            <form method="post" class="ps-form" style="margin-top: 12px;">
                {% csrf_token %}
                <input type="hidden" name="action" value="resend" />
                <button class="ps-btn ps-btn-secondary ps-btn-full" type="submit">Отправить код ещё раз</button>
            </form>
        {% endif %}
        <p class="ps-text-muted" style="margin-top: 12px;">Если доступ к устройству потерян — смените пароль и переиздайте MFA в профиле.</p>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 278
PATH: templates\accounts\password_change.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Смена пароля — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Смена пароля</h1>
        <p class="ps-auth-subtitle">
            Укажите текущий пароль и новый — мы проверим его надёжность.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Обновить пароль
                </button>
            </div>
        </form>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 279
PATH: templates\accounts\password_change_done.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Пароль обновлён — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Пароль успешно обновлён</h1>
    <p class="ps-section-subtitle">
        Ваш новый пароль сохранён. Используйте его для следующего входа.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'user_dashboard' %}" class="ps-btn">
            В личный кабинет
        </a>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 280
PATH: templates\accounts\password_reset.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Сброс пароля — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Сброс пароля</h1>
        <p class="ps-auth-subtitle">
            Укажите email, на который зарегистрирован аккаунт. Мы отправим ссылку
            для задания нового пароля.
        </p>

        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Отправить ссылку
                </button>
            </div>
        </form>

        <div class="ps-auth-footer">
            Вспомнили пароль?
            <a href="{% url 'accounts:login' %}">Вернуться ко входу</a>
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 281
PATH: templates\accounts\password_reset_complete.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Пароль изменён — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Пароль успешно изменён</h1>
    <p class="ps-section-subtitle">
        Теперь вы можете войти в свой аккаунт, используя новый пароль.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'accounts:login' %}" class="ps-btn">
            Перейти ко входу
        </a>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 282
PATH: templates\accounts\password_reset_confirm.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Новый пароль — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        {% if validlink %}
            <h1 class="ps-auth-title">Задайте новый пароль</h1>
            <p class="ps-auth-subtitle">
                Введите новый пароль дважды, чтобы исключить опечатки.
            </p>

            <form method="post" class="ps-form">
                {% csrf_token %}
                {% if form.non_field_errors %}
                    <div class="ps-alert ps-alert--danger">
                        {{ form.non_field_errors }}
                    </div>
                {% endif %}

                {% for field in form.visible_fields %}
                    <div class="ps-form-row">
                        <label class="ps-form-label" for="{{ field.id_for_label }}">
                            {{ field.label }}
                        </label>
                        {{ field }}
                        {% if field.help_text %}
                            <div class="ps-field-help">{{ field.help_text }}</div>
                        {% endif %}
                        {% for error in field.errors %}
                            <div class="ps-field-error">{{ error }}</div>
                        {% endfor %}
                    </div>
                {% endfor %}

                <div class="ps-form-actions">
                    <button type="submit" class="ps-btn ps-btn-full">
                        Сохранить новый пароль
                    </button>
                </div>
            </form>
        {% else %}
            <h1 class="ps-auth-title">Ссылка недействительна</h1>
            <p class="ps-auth-subtitle">
                Ссылка для сброса пароля устарела или уже была использована.
                Попробуйте запросить сброс ещё раз.
            </p>
            <div class="ps-offline-actions">
                <a href="{% url 'accounts:password_reset' %}" class="ps-btn">
                    Запросить новую ссылку
                </a>
            </div>
        {% endif %}
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 283
PATH: templates\accounts\password_reset_done.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Письмо отправлено — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--center ps-section--narrow ps-animate-fade-up">
    <h1 class="ps-section-title">Проверьте почту</h1>
    <p class="ps-section-subtitle">
        Если аккаунт с таким email существует, мы отправили на него письмо
        с дальнейшими инструкциями.
    </p>
    <div class="ps-offline-actions">
        <a href="{% url 'accounts:login' %}" class="ps-btn ps-btn-secondary">
            Вернуться ко входу
        </a>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 284
PATH: templates\accounts\password_reset_email.txt
LANG: text
===== CONTENT START =====
Вы получили это письмо, потому что на сайте {{ site_name }} был запрошен сброс пароля
для пользователя, использующего этот email.

Чтобы задать новый пароль, перейдите по ссылке:

{{ protocol }}://{{ domain }}{% url 'accounts:password_reset_confirm' uidb64=uid token=token %}

Если вы не запрашивали сброс пароля, просто проигнорируйте это письмо.

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 285
PATH: templates\accounts\password_reset_subject.txt
LANG: text
===== CONTENT START =====
Сброс пароля на ParkShare RU

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 286
PATH: templates\accounts\profile.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Профиль — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--narrow">
    <div class="ps-section-header">
        <h1 class="ps-section-title">Профиль</h1>
        <p class="ps-section-subtitle">
            Обновите контактные данные, чтобы получать уведомления по бронированиям.
        </p>
    </div>

    <div class="ps-card ps-card--elevated ps-animate-fade-up">
        <form method="post" class="ps-form">
            {% csrf_token %}
            {% if form.non_field_errors %}
                <div class="ps-alert ps-alert--danger">
                    {{ form.non_field_errors }}
                </div>
            {% endif %}

            {% for field in form.visible_fields %}
                <div class="ps-form-row">
                    <label class="ps-form-label" for="{{ field.id_for_label }}">
                        {{ field.label }}
                    </label>
                    {{ field }}
                    {% if field.help_text %}
                        <div class="ps-field-help">{{ field.help_text }}</div>
                    {% endif %}
                    {% for error in field.errors %}
                        <div class="ps-field-error">{{ error }}</div>
                    {% endfor %}
                </div>
            {% endfor %}

            <div class="ps-form-actions">
                <button type="submit" class="ps-btn ps-btn-full">
                    Сохранить изменения
                </button>
                <a href="{% url 'user_dashboard' %}" class="ps-btn ps-btn-secondary ps-btn-full">
                    Вернуться в кабинет
                </a>
            </div>
        </form>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 287
PATH: templates\accounts\register.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Регистрация в ParkShare RU{% endblock %}

{% block content %}
<section class="ps-auth">
    <div class="ps-auth-card ps-card ps-card--elevated ps-animate-fade-up">
        <h1 class="ps-auth-title">Регистрация</h1>
        <p class="ps-auth-subtitle">
            Создайте аккаунт, чтобы бронировать парковки и получать рекомендации.
        </p>

        <div class="ps-auth-tabs" data-auth-switcher>
            <button type="button" class="is-active" data-auth-target="form">По паролю</button>
            <button type="button" data-auth-target="social">VK / Яндекс / Google</button>
        </div>

        <div class="ps-auth-panels">
            <div class="ps-auth-panel is-active" data-auth-panel="form">
                <form method="post" class="ps-form">
                    {% csrf_token %}
                    {% if form.non_field_errors %}
                        <div class="ps-alert ps-alert--danger">
                            {{ form.non_field_errors }}
                        </div>
                    {% endif %}

                    {% for field in form.visible_fields %}
                        <div class="ps-form-row">
                            <label class="ps-form-label" for="{{ field.id_for_label }}">
                                {{ field.label }}
                            </label>
                            {{ field }}
                            {% if field.help_text %}
                                <div class="ps-field-help">{{ field.help_text }}</div>
                            {% endif %}
                            {% for error in field.errors %}
                                <div class="ps-field-error">{{ error }}</div>
                            {% endfor %}
                        </div>
                    {% endfor %}

                    <div class="ps-form-actions">
                        <button type="submit" class="ps-btn ps-btn-full">
                            Зарегистрироваться
                        </button>
                    </div>
                </form>
            </div>

            <div class="ps-auth-panel" data-auth-panel="social">
                <div class="ps-auth-placeholder">
                    <p>Создайте аккаунт через соцсеть — без пароля.</p>
                    <div class="ps-social-banners">
                        <a class="ps-social-banner ps-social-banner--vk" data-social="vk" href="{% url 'oauth_start' 'vk' %}?next={{ request.path }}">
                            <span class="ps-social-banner__stripe" aria-hidden="true">
                                <svg viewBox="0 0 24 24" role="presentation" fill="#fff">
                                    <path d="M3.5 7h2.7l2.2 4 2.1-4h2.4l-1.4 4.3 3.2-4.3h2.6l-4.2 5.3 3.8 5.7h-2.7l-2.3-3.5-2.3 3.5H8.9l3.8-5.4L7.6 7H3.5Z"/>
                                </svg>
                            </span>
                            <span class="ps-social-banner__text">
                                <span class="ps-social-banner__title">Войти через VK ID</span>
                                <span class="ps-social-banner__hint">Профиль VK, без публикаций</span>
                            </span>
                        </a>
                        <a class="ps-social-banner ps-social-banner--yandex" data-social="yandex" href="{% url 'oauth_start' 'yandex' %}?next={{ request.path }}">
                            <span class="ps-social-banner__stripe" aria-hidden="true">
                                <svg viewBox="0 0 24 24" role="presentation">
                                    <path d="M8 3h3.6l2 6.3L15.6 3H19l-3.5 8V21h-2.6v-5.5L8 3Z" fill="#111"/>
                                </svg>
                            </span>
                            <span class="ps-social-banner__text">
                                <span class="ps-social-banner__title">Войти через Яндекс ID</span>
                                <span class="ps-social-banner__hint">Email и имя с вашего разрешения</span>
                            </span>
                        </a>
                        <a class="ps-social-banner ps-social-banner--google" data-social="google" href="{% url 'oauth_start' 'google' %}?next={{ request.path }}">
                            <span class="ps-social-banner__stripe" aria-hidden="true">
                                <svg viewBox="0 0 24 24" role="presentation">
                                    <path fill="#4285F4" d="M21.6 12.23c0-.8-.07-1.6-.21-2.36H12v4.48h5.36a4.6 4.6 0 0 1-2 3.02v2.5h3.24c1.9-1.75 3-4.33 3-7.64Z"/>
                                    <path fill="#34A853" d="M12 22c2.7 0 4.96-.9 6.62-2.43l-3.24-2.5c-.9.6-2.06.96-3.38.96-2.6 0-4.8-1.76-5.58-4.12H3.08v2.59A10 10 0 0 0 12 22Z"/>
                                    <path fill="#FBBC05" d="M6.42 13.91c-.2-.6-.32-1.24-.32-1.91s.12-1.32.32-1.91V7.5H3.08A10 10 0 0 0 2 12c0 1.6.38 3.1 1.08 4.5l3.34-2.59Z"/>
                                    <path fill="#EA4335" d="M12 6.08c1.46 0 2.77.5 3.8 1.47l2.84-2.84C16.96 2.9 14.7 2 12 2 7.92 2 4.36 4.3 3.08 7.5l3.34 2.59C7.2 7.84 9.4 6.08 12 6.08Z"/>
                                </svg>
                            </span>
                            <span class="ps-social-banner__text">
                                <span class="ps-social-banner__title">Sign in with Google</span>
                                <span class="ps-social-banner__hint">Создать аккаунт за секунду</span>
                            </span>
                        </a>
                    </div>
                    <p class="ps-text-muted">Email и телефон будут запрошены только с вашего согласия.</p>
                </div>
            </div>
        </div>

        <div class="ps-auth-footer">
            Уже есть аккаунт?
            <a href="{% url 'accounts:login' %}">Войти</a>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
<script>
    (function () {
        const root = document.querySelector('[data-auth-switcher]');
        if (!root) return;
        const buttons = Array.from(root.querySelectorAll('[data-auth-target]'));
        const panels = Array.from(document.querySelectorAll('[data-auth-panel]'));
        buttons.forEach(function (btn) {
            btn.addEventListener('click', function () {
                const target = btn.getAttribute('data-auth-target');
                buttons.forEach(function (b) { b.classList.toggle('is-active', b === btn); });
                panels.forEach(function (panel) {
                    panel.classList.toggle('is-active', panel.getAttribute('data-auth-panel') === target);
                });
            });
        });
    })();
</script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 288
PATH: templates\admin\metrics.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% block title %}Метрики — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Внутренний дашборд</p>
            <h1 class="ps-section-title">Ключевые метрики</h1>
            <p class="ps-section-subtitle">Простой срез по бронированиям и AI-сессиям. Доступно только сотрудникам.</p>
        </div>
    </div>
    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header"><h2 class="ps-card-title">Воронка бронирований</h2></div>
            <div class="ps-card-body">
                <div class="ps-list-title">Всего бронирований: {{ total_bookings }}</div>
                <div class="ps-list-title">Служебные брони: {{ business_bookings }}</div>
            </div>
        </article>
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header"><h2 class="ps-card-title">AI/предпочтения</h2></div>
            <div class="ps-card-body">
                <div class="ps-list-title">Сессий с сохранёнными предпочтениями: {{ ai_sessions }}</div>
            </div>
        </article>
    </div>
    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card">
            <div class="ps-card-header"><h2 class="ps-card-title">Последние 7 дней</h2></div>
            <div class="ps-card-body">
                <div class="ps-list-title">map_open: {{ last7.funnel.map_open|default:0 }}</div>
                <div class="ps-list-title">spot_select: {{ last7.funnel.spot_select|default:0 }}</div>
                <div class="ps-list-title">booking_confirm_open: {{ last7.funnel.booking_confirm_open|default:0 }}</div>
                <div class="ps-list-title">booking_created: {{ last7.funnel.booking_created|default:0 }}</div>
                <div class="ps-list-title">repeat_visit: {{ last7.funnel.repeat_visit|default:0 }}</div>
                <div class="ps-list-title">map→spot: {{ last7.conversions.map_to_spot }}%</div>
                <div class="ps-list-title">spot→confirm: {{ last7.conversions.spot_to_confirm }}%</div>
                <div class="ps-list-title">confirm→booking: {{ last7.conversions.confirm_to_booking }}%</div>
                <div class="ps-list-title">A/B bookings: {{ last7.variants.A.booking_created|default:0 }} / {{ last7.variants.B.booking_created|default:0 }}</div>
            </div>
        </article>
        <article class="ps-card">
            <div class="ps-card-header"><h2 class="ps-card-title">Последние 30 дней</h2></div>
            <div class="ps-card-body">
                <div class="ps-list-title">map_open: {{ last30.funnel.map_open|default:0 }}</div>
                <div class="ps-list-title">spot_select: {{ last30.funnel.spot_select|default:0 }}</div>
                <div class="ps-list-title">booking_confirm_open: {{ last30.funnel.booking_confirm_open|default:0 }}</div>
                <div class="ps-list-title">booking_created: {{ last30.funnel.booking_created|default:0 }}</div>
                <div class="ps-list-title">repeat_visit: {{ last30.funnel.repeat_visit|default:0 }}</div>
                <div class="ps-list-title">map→spot: {{ last30.conversions.map_to_spot }}%</div>
                <div class="ps-list-title">spot→confirm: {{ last30.conversions.spot_to_confirm }}%</div>
                <div class="ps-list-title">confirm→booking: {{ last30.conversions.confirm_to_booking }}%</div>
                <div class="ps-list-title">A/B bookings: {{ last30.variants.A.booking_created|default:0 }} / {{ last30.variants.B.booking_created|default:0 }}</div>
            </div>
        </article>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 289
PATH: templates\ai\concierge.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}

{% block title %}Ассистент — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="assistant">
    <form style="display:none;">
        {% csrf_token %}
    </form>
    <div class="ps-landing__head">
        <div>
            <h1 class="ps-landing__title">Ассистент</h1>
            <p class="ps-landing__subtitle">Потоковый AI-консьерж для поиска парковки и скриптов поддержки.</p>
        </div>
        <div class="ps-chip-row">
            <span class="ps-chip ps-chip--soft">{% if user.is_authenticated %}{{ user.username }}{% else %}Гостевой режим{% endif %}</span>
            <span class="ps-chip ps-chip--soft">Реальный чат</span>
        </div>
    </div>

    <div class="ps-section-actions ps-section-actions--link">
        <a href="{% url 'landing' %}" class="ps-link ps-link-arrow">К карте</a>
    </div>

    <div class="ps-ai-grid">
        <div class="ps-ai-summary">
            <div class="ps-card ps-card--elevated">
                <h3 class="ps-card-title">Предустановленные подсказки</h3>
                <p class="ps-card-line ps-card-line--muted">Выберите и отправьте в один тап.</p>
                <div class="ps-ai-prompts" data-ai-prompts>
                    <button type="button" class="ps-chip" data-ai-prompt>Сформируй чат-скрипт для диспетчера парковки с VIP-клиентами.</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Собери сводку по пиковым часам и дай рекомендации по динамическим тарифам.</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Сценарий поддержки: клиент не может найти въезд. Какие шаги предложить?</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Что добавить в онбординг партнёра, чтобы повысить NPS?</button>
                    <button type="button" class="ps-chip" data-ai-prompt>Сделай контрольный чек-лист для запуска новой парковки на выходные.</button>
                </div>
                <div class="ps-hint">История сохраняется в браузере. Авторизация привяжет её к аккаунту.</div>
            </div>
        </div>

        <div class="ps-ai-chat" data-ai-chat data-ai-history-key="ps_ai_chat_v2">
            <div class="ps-ai-chat__header">
                <div>
                    <p class="ps-kicker">Concierge</p>
                    <p class="ps-ai-title">AI-чат ParkShare</p>
                    <p class="ps-ai-subtitle">Спроси про цены, маршруты и сценарии для гостей.</p>
                </div>
                <div class="ps-ai-actions">
                    <button type="button" class="ps-btn ps-btn-ghost ps-btn-sm" data-ai-clear>Очистить</button>
                    <button type="button" class="ps-btn ps-btn-secondary ps-btn-sm" data-ai-stop hidden>Остановить</button>
                </div>
            </div>

            <div class="ps-ai-chat__body">
                <div class="ps-ai-prompts ps-ai-prompts--inline" data-ai-prompts>
                    <button type="button" class="ps-chip ps-chip--ghost" data-ai-prompt>Где припарковаться рядом?</button>
                    <button type="button" class="ps-chip ps-chip--ghost" data-ai-prompt>Построй маршрут до центра</button>
                </div>
                <div class="ps-ai-status" data-ai-status>История сохраняется локально. Готов к диалогу.</div>
                <div class="ps-ai-alerts" data-ai-alerts hidden></div>
                <div class="ps-ai-actions" data-ai-actions hidden></div>
                <div class="ps-ai-sessions" data-ai-sessions hidden></div>
                <div class="ps-ai-suggestions" data-ai-suggestions hidden></div>
                <div class="ps-ai-messages" data-ai-messages></div>
            </div>

            <div class="ps-ai-input">
                <textarea id="ai-input" class="ps-input" rows="3" placeholder="Опиши задачу или попроси маршрут…"></textarea>
                <div class="ps-ai-input__actions">
                    <div class="ps-ai-hint">Enter — отправить, Shift+Enter — перенос строки</div>
                    <div class="ps-ai-buttons">
                        <button type="button" class="ps-btn ps-btn-secondary ps-btn-sm" data-ai-regenerate hidden>Перегенерировать</button>
                        <button type="button" class="ps-btn ps-btn-sm" data-ai-send>Отправить</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
    {% load static %}
    {% static 'js/chat.js' as chat_static %}
    <script src="{{ chat_static }}?v=2"></script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 290
PATH: templates\parking\booking_confirm.html
LANG: html
===== CONTENT START =====

{% extends "base.html" %}
{% load static %}

{% block title %}Подтверждение бронирования — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="bookings">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Бронирование</p>
            <h1 class="ps-section-title">Подтверждение</h1>
            <p class="ps-section-subtitle">Проверьте место, интервал, оплату и автомобиль перед созданием брони.</p>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'map_page' %}" class="ps-btn ps-btn-ghost ps-btn-sm">Назад к карте</a>
        </div>
    </div>

    {% if errors %}
        <div class="ps-alert ps-alert--danger">
            <ul class="ps-list ps-list--unstyled">
                {% for err in errors %}
                    <li>{{ err }}</li>
                {% endfor %}
            </ul>
        </div>
    {% endif %}
    {% if success %}
        <div class="ps-alert ps-alert--success">{{ success }}</div>
    {% endif %}

    <div class="ps-card ps-card--elevated">
        <form method="post" class="ps-form">
            {% csrf_token %}
            <input type="hidden" name="spot_id" value="{{ spot.id }}">
            <div class="ps-card-header">
                <div>
                    <h2 class="ps-card-title">{{ spot.lot.name }} — {{ spot.name }}</h2>
                    <div class="ps-card-line ps-card-line--muted">{{ spot.lot.city }}, {{ spot.lot.address }}</div>
                </div>
                <span class="ps-badge ps-badge--neutral">{{ spot.get_vehicle_type_display }}</span>
            </div>
            <div class="ps-card-body ps-card-body--spacing-lg">
                <div class="ps-grid ps-grid--2col ps-grid--gap-md">
                    <div>
                        <div class="ps-form-label">Интервал</div>
                        <div class="ps-chip-row">
                            <label class="ps-chip {% if selected_hours|floatformat:0 == '1' %}is-active{% endif %}">
                                <input type="radio" name="hours" value="1" {% if selected_hours|floatformat:0 == '1' %}checked{% endif %} hidden>
                                1 час · ~{{ spot_estimates.h1|floatformat:0 }} ₽
                            </label>
                            <label class="ps-chip {% if selected_hours|floatformat:0 == '3' %}is-active{% endif %}">
                                <input type="radio" name="hours" value="3" {% if selected_hours|floatformat:0 == '3' %}checked{% endif %} hidden>
                                3 часа · ~{{ spot_estimates.h3|floatformat:0 }} ₽
                            </label>
                            <label class="ps-chip {% if selected_hours|floatformat:0 == '24' %}is-active{% endif %}">
                                <input type="radio" name="hours" value="24" {% if selected_hours|floatformat:0 == '24' %}checked{% endif %} hidden>
                                24 часа · ~{{ spot_estimates.h24|floatformat:0 }} ₽
                            </label>
                        </div>
                        <p class="ps-card-line ps-card-line--muted">Стоимость будет уточнена при создании брони.</p>
                    </div>
                    <div>
                        <div class="ps-form-label">Режим биллинга</div>
                        <div class="ps-chip-row">
                            <label class="ps-chip {% if billing_mode == 'pay_as_you_go' %}is-active{% endif %}">
                                <input type="radio" name="billing_mode" value="pay_as_you_go" hidden {% if billing_mode == 'pay_as_you_go' %}checked{% endif %}>
                                Оплата по времени
                            </label>
                            <label class="ps-chip {% if billing_mode == 'prepaid_block' %}is-active{% endif %}">
                                <input type="radio" name="billing_mode" value="prepaid_block" hidden {% if billing_mode == 'prepaid_block' %}checked{% endif %}>
                                Пакет часов (предоплата)
                            </label>
                        </div>
                        <p class="ps-card-line ps-card-line--muted">
                            {% if billing_mode == 'prepaid_block' %}
                                Стоимость рассчитывается пакетами (минимум 2 часа).
                            {% else %}
                                Оплата по фактической длительности.
                            {% endif %}
                        </p>
                    </div>
                </div>

                <div class="ps-grid ps-grid--2col ps-grid--gap-md">
                    <div>
                        <label class="ps-form-label">Автомобиль</label>
                        <select class="ps-input" name="vehicle_id">
                            {% if vehicles %}
                                {% for vehicle in vehicles %}
                                    <option value="{{ vehicle.id }}" {% if vehicle.id == default_vehicle.id %}selected{% endif %}>
                                        {{ vehicle.label|default:"Мой авто" }} — {{ vehicle.get_vehicle_type_display }}
                                    </option>
                                {% endfor %}
                            {% else %}
                                <option value="">Нет сохранённых машин</option>
                            {% endif %}
                        </select>
                        <div class="ps-field-help">Машина используется для пропусков и квитанций.</div>
                    </div>
                    <div>
                        <label class="ps-form-label">Оплата</label>
                        <select class="ps-input" name="payment_method_id">
                            {% if payment_methods %}
                                {% for method in payment_methods %}
                                    <option value="{{ method.id }}" {% if default_payment and method.id == default_payment.id %}selected{% endif %}>
                                        {{ method.get_brand_display }} ****{{ method.last4 }} {% if method.is_default %}· осн.{% endif %}
                                    </option>
                                {% endfor %}
                            {% else %}
                                <option value="">Нет сохранённых карт — оформим как ожидание оплаты</option>
                            {% endif %}
                        </select>
                        <div class="ps-field-help"><a href="{% url 'payment_methods_page' %}">Обновить методы оплаты</a></div>
                    </div>
                </div>

                <label class="ps-checkbox">
                    <input type="checkbox" name="is_business">
                    <span>Служебная поездка</span>
                </label>

                <div class="ps-form-actions">
                    <button class="ps-btn ps-btn-primary ps-btn-full" type="submit">Подтвердить бронь</button>
                </div>
            </div>
        </form>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 291
PATH: templates\parking\business_reports.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% block title %}Служебные отчёты — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="bookings">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Бизнес</p>
            <h1 class="ps-section-title">Отчёты по служебным поездкам</h1>
            <p class="ps-section-subtitle">Скачайте CSV или просмотрите брони, отмеченные как служебные.</p>
        </div>
        <div class="ps-section-actions">
            <a class="ps-btn ps-btn-ghost ps-btn-sm" href="?export=csv">Скачать CSV</a>
        </div>
    </div>

    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header"><h2 class="ps-card-title">Фильтры</h2></div>
            <form class="ps-card-body ps-card-body--spacing-lg" method="get">
                <div class="ps-form-row ps-form-row--inline">
                    <label class="ps-form-label">Начало</label>
                    <input class="ps-input" type="date" name="start" value="{{ filters.start }}">
                </div>
                <div class="ps-form-row ps-form-row--inline">
                    <label class="ps-form-label">Окончание</label>
                    <input class="ps-input" type="date" name="end" value="{{ filters.end }}">
                </div>
                <div class="ps-form-row ps-form-row--inline">
                    <label class="ps-form-label">Город</label>
                    <input class="ps-input" type="text" name="city" value="{{ filters.city }}">
                </div>
                <div class="ps-form-actions">
                    <button class="ps-btn ps-btn-primary ps-btn-full" type="submit">Применить</button>
                </div>
            </form>
        </article>
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header"><h2 class="ps-card-title">Итоги</h2></div>
            <div class="ps-card-body">
                <div class="ps-list-title">Всего бронирований: {{ total_count|default:0 }}</div>
                <div class="ps-list-title">Общая длительность: {{ total_duration|default:0 }} ч</div>
                <div class="ps-list-title">Общая сумма: {{ total_cost|default:0 }} ₽</div>
            </div>
        </article>
    </div>

    <div class="ps-card ps-card--elevated">
        <div class="ps-card-body ps-card-body--spacing-lg">
            {% if bookings %}
                <ul class="ps-list ps-list--compact">
                    {% for booking in bookings %}
                        <li class="ps-list-item">
                            <div class="ps-list-main">
                                <div class="ps-list-title">{{ booking.start_at|date:"d.m H:i" }} · {{ booking.spot.lot.name }} — {{ booking.spot.name }}</div>
                                <div class="ps-list-subtitle">
                                    {{ booking.spot.lot.address }} · {{ booking.billing_mode }} · {{ booking.get_booking_type_display }}
                                </div>
                            </div>
                            <span class="ps-badge ps-badge--neutral">{{ booking.total_price }} ₽</span>
                        </li>
                    {% endfor %}
                </ul>
            {% else %}
                <div class="ps-empty">Нет служебных поездок. Отметьте бронирование как "Служебная поездка" при создании.</div>
            {% endif %}
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 292
PATH: templates\parking\landing.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}ParkShare RU — карта парковок{% endblock %}

{% block extra_head %}
    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
    <link rel="stylesheet" href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css">
    <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU{% if YANDEX_MAP_API_KEY %}&apikey={{ YANDEX_MAP_API_KEY }}{% endif %}"
            defer></script>
{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top ps-landing" data-route="map">
    <div class="ps-landing__head">
        <div>
            <h1 class="ps-landing__title">ParkShare</h1>
            <p class="ps-landing__subtitle">Умная парковка рядом с вами</p>
        </div>
        <div class="ps-chip-row">
            <span class="ps-chip ps-chip--soft">Свободно: <strong data-spots-count>{{ spots_total|default:0 }}</strong></span>
            <span class="ps-chip ps-chip--soft">Средняя цена: <strong data-avg-price>—</strong></span>
        </div>
    </div>

    <div class="ps-search-bar ps-search-bar--pill" data-search-bar>
        <div class="ps-search-icon" aria-hidden="true">
            <svg class="ps-icon" viewBox="0 0 24 24"><path d="M15.5 14h-.8l-.3-.3a6 6 0 1 0-.7.7l.3.3v.8l4.5 4.5 1.5-1.5-4.5-4.5Zm-5.5 0a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9Z" fill="currentColor"/></svg>
        </div>
        <input type="search" class="ps-search-input" placeholder="Адрес, метро или точка на маршруте" data-geocode-input>
        <div class="ps-search-actions">
            <button type="button" class="ps-icon-btn ps-icon-btn--ghost" data-geocode-submit aria-label="Найти">
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="m5 12.5 13.5-5.4a.5.5 0 0 1 .7.46L18 19.1a.5.5 0 0 1-.76.35l-4.34-3.07a1 1 0 0 0-1.16 0L7.4 18.9A.5.5 0 0 1 6.64 18L5 13.03a.5.5 0 0 1 0-.53Z" fill="currentColor"/></svg>
            </button>
            <button type="button" class="ps-icon-btn ps-icon-btn--ghost" title="Голосовой ввод" data-voice-input>
                <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a3 3 0 0 0-3 3v5a3 3 0 0 0 6 0V6a3 3 0 0 0-3-3Zm-1 15.9V21h2v-2.1a6.5 6.5 0 0 0 5-6.3h-2a4.5 4.5 0 1 1-9 0H5a6.5 6.5 0 0 0 5 6.3Z" fill="currentColor"/></svg>
            </button>
        </div>
    </div>

    <div class="ps-map-stack">
        <div class="ps-map-card ps-map-panel" data-map-panel>
            <div class="ps-map-wrapper">
                <div id="map" class="ps-map"></div>
                <div class="ps-map-overlay"></div>
                <div class="ps-map-loading" data-map-loading>Обновляем карту…</div>
                <div class="ps-map-floating-actions" aria-label="Действия карты">
                    <button class="ps-map-action" type="button" data-fill-location title="Моё местоположение" aria-label="Моё местоположение">
                        <svg class="ps-icon" viewBox="0 0 24 24"><use href="#ps-ic-locate"></use></svg>
                    </button>
                    <button class="ps-map-action" type="button" data-reset-filters title="Сбросить фильтры" aria-label="Сбросить фильтры">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 5a7 7 0 0 1 6.9 6H21l-2.7 3-2.7-3H17A5 5 0 1 0 7 12H5.5A6.5 6.5 0 0 1 12 5Zm6 4h-1.5a4.5 4.5 0 0 0-9 0H6a6 6 0 0 1 12 0Zm-6 10a7 7 0 0 1-6.9-6H3l2.7-3 2.7 3H7a5 5 0 0 0 10 0h1.5A6.5 6.5 0 0 1 12 19Z" fill="currentColor"/></svg>
                    </button>
                    <button class="ps-map-action" type="button" data-map-theme title="Светлая / тёмная карта" aria-pressed="false">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a9 9 0 0 0 0 18c2.9 0 5.5-1.4 7.1-3.5A7 7 0 0 1 12 4.9V3Zm0 2.9A7 7 0 0 1 17.8 17 7 7 0 1 1 12 5.9Z" fill="currentColor"/></svg>
                    </button>
                </div>
            </div>
            <div class="ps-map-controls">
                <div class="ps-map-chips" data-filter-chips>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="only_free" hidden>
                        <span>Только свободные</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="ai_recommended" hidden>
                        <span>AI-рекомендации</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="ev" hidden>
                        <span>EV-зарядка</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="covered" hidden>
                        <span>Крытая</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="is_24_7" hidden>
                        <span>24/7</span>
                    </label>
                </div>
                <div class="ps-map-filters" data-map-filters-container>
                    <form class="ps-map-filters-card" data-map-filters>
                        <div class="ps-map-filters-row ps-map-filters-row--slider">
                            <div class="ps-filter-slider" data-price-slider></div>
                            <div class="ps-filter-price" data-price-display>Цена: от 0 ₽ до 1500 ₽</div>
                        </div>
                    </form>
                </div>
                <div class="ps-geocode-suggestions" data-geocode-suggestions></div>
                <div class="ps-map-legend">
                    <div class="ps-legend-item"><span class="ps-legend-icon ps-legend-icon--allowed"><svg class="ps-icon" viewBox="0 0 24 24"><use href="#ps-ic-allowed"></use></svg></span>Свободно</div>
                    <div class="ps-legend-item"><span class="ps-legend-icon ps-legend-icon--paid"><svg class="ps-icon" viewBox="0 0 24 24"><use href="#ps-ic-paid"></use></svg></span>Платная</div>
                    <div class="ps-legend-item"><span class="ps-legend-icon ps-legend-icon--forbidden"><svg class="ps-icon" viewBox="0 0 24 24"><use href="#ps-ic-forbidden"></use></svg></span>Запрещена/закрыта</div>
                    <div class="ps-legend-item"><span class="ps-legend-icon ps-legend-icon--covered"><svg class="ps-icon" viewBox="0 0 24 24"><use href="#ps-ic-covered"></use></svg></span>Крытая</div>
                    <div class="ps-legend-item"><span class="ps-legend-icon ps-legend-icon--ev"><svg class="ps-icon" viewBox="0 0 24 24"><use href="#ps-ic-ev"></use></svg></span>EV-зарядка</div>
                </div>
                <div class="ps-map-cta">
                    <a class="ps-link ps-link-arrow" href="{% url 'map_page' %}">Открыть карту полностью</a>
                </div>
        </div>
    </div>
        <!-- Bottom sheet with three states: collapsed/half/full -->

        <div class="ps-bottom-sheet ps-bottom-sheet--floating" data-spots-panel data-spots-sheet data-sheet-state="collapsed">
            <div class="ps-bottom-sheet__handle" data-sheet-handle aria-label="Потянуть шторку"></div>
            <div class="ps-bottom-sheet__header">
                <div class="ps-bottom-sheet__title">
                    <div class="ps-section-title-sm">Парковки рядом с маршрутом</div>
                    <div class="ps-bottom-sheet__metrics" data-sheet-metrics>
                        <span class="ps-bottom-sheet__metric">
                            <svg class="ps-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 3.5h8.2a5.3 5.3 0 0 1 0 10.6H9.5v6.4H6V3.5Zm3.5 3v4.5h4.7a2.2 2.2 0 1 0 0-4.5H9.5Z" fill="currentColor"/></svg>
                            <strong data-spots-count>0</strong>
                            <span class="ps-text-muted">свободно</span>
                        </span>
                        <span class="ps-bottom-sheet__metric">
                            <svg class="ps-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm.9 5c1.6 0 2.6.9 2.6 2.3 0 1.3-1 2.2-2.6 2.2h-2v2.1H9V8h3.9Zm-2 .9v2.7h1.9c.8 0 1.3-.5 1.3-1.3 0-.8-.5-1.4-1.3-1.4H10.9Z" fill="currentColor"/></svg>
                            <strong data-avg-price>—</strong>
                            <span class="ps-text-muted">средняя цена</span>
                        </span>
                    </div>
                </div>
                <div class="ps-bottom-sheet__actions">
                    <button type="button" class="ps-sheet-back" data-sheet-back aria-label="Назад к карте">
                        <svg class="ps-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="m11 5-6 7 6 7h3l-6-7 6-7h-3Z" fill="currentColor"/></svg>
                        <span>К карте</span>
                    </button>
                    <button type="button" class="ps-btn ps-btn-ghost ps-btn-sm" data-reset-filters>Сбросить</button>
                </div>
            </div>
            <div class="ps-bottom-sheet__body">
                <div class="ps-spots-list" data-spots-list>
                    <div class="ps-empty">
                        <p>Подходящих мест пока нет. Попробуйте изменить фильтры.</p>
                    </div>
                </div>
                <div class="ps-route-hint" data-route-hint>Постройте мини-маршрут до выбранной точки.</div>
            </div>
        </div>


    <div class="ps-section">
        <div class="ps-card ps-card--elevated ps-assistant-card">
            <div class="ps-card-header">
                <div>
                    <p class="ps-kicker">AI Concierge</p>
                    <div class="ps-card-title">Ассистент на связи</div>
                    <p class="ps-card-line ps-card-line--muted">Диалог, поиск вдоль маршрута, быстрые брони и продление парковки.</p>
                </div>
                <span class="ps-badge ps-badge--neutral">Потоковый чат</span>
            </div>
            <div class="ps-card-body">
                <a class="ps-btn ps-btn-full" href="{% url 'ai_chat' %}">Открыть ассистента</a>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script>
        window.PARKSHARE_MAP_PROVIDER = {
            id: "{{ MAP_PROVIDER|default:'yandex' }}",
            fallback: "{{ MAP_PROVIDER_FALLBACK|default:'leaflet' }}",
            default_center: {{ MAP_DEFAULT_CENTER|safe }},
            default_zoom: {{ MAP_DEFAULT_ZOOM|default:11 }},
        };
    </script>
    {% load static %}
    {% static 'js/map.js' as map_static %}
    <script src="{{ map_static }}?v=44"></script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 293
PATH: templates\parking\map_fullscreen.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Полная карта — ParkShare{% endblock %}

{% block extra_head %}
    <link rel="stylesheet"
          href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
    <link rel="stylesheet" href="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.css">
    <script src="https://api-maps.yandex.ru/2.1/?lang=ru_RU{% if YANDEX_MAP_API_KEY %}&apikey={{ YANDEX_MAP_API_KEY }}{% endif %}"
            defer></script>
{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top ps-map-hero" data-route="map">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Карта</p>
            <h1 class="ps-section-title">Полноэкранный режим</h1>
            <p class="ps-section-subtitle">Поиск, фильтры, маршруты и live-темы.</p>
            <div class="ps-connection" data-connection-badge hidden>Проверяем сеть…</div>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'landing' %}" class="ps-btn ps-btn-ghost ps-btn-sm">На главную</a>
            <button type="button" class="ps-btn ps-btn-primary ps-btn-sm" data-fill-location>Рядом со мной</button>
        </div>
    </div>

    <div class="ps-map-grid">
        <div class="ps-map-panel" data-map-panel>
            <div class="ps-map-wrapper">
                <div id="map" class="ps-map"></div>
                <div class="ps-map-loading" data-map-loading>Обновляем карту…</div>
                <div class="ps-map-floating-actions" aria-label="Действия карты">
                    <button class="ps-map-action" type="button" data-fill-location title="Моё местоположение" aria-label="Моё местоположение">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3.5 9.6 10H4l5 4-2 6.5L12 16l5 4.5-2-6.5 5-4h-5.6L12 3.5Z" fill="currentColor"/></svg>
                    </button>
                    <button class="ps-map-action" type="button" data-reset-filters title="Сбросить фильтры" aria-label="Сбросить фильтры">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 5a7 7 0 0 1 6.9 6H21l-2.7 3-2.7-3H17A5 5 0 1 0 7 12H5.5A6.5 6.5 0 0 1 12 5Zm6 4h-1.5a4.5 4.5 0 0 0-9 0H6a6 6 0 0 1 12 0Zm-6 10a7 7 0 0 1-6.9-6H3l2.7-3 2.7 3H7a5 5 0 0 0 10 0h1.5A6.5 6.5 0 0 1 12 19Z" fill="currentColor"/></svg>
                    </button>
                    <button class="ps-map-action" type="button" data-map-theme title="Светлая / тёмная карта" aria-pressed="false">
                        <svg class="ps-icon" viewBox="0 0 24 24"><path d="M12 3a9 9 0 0 0 0 18c2.9 0 5.5-1.4 7.1-3.5A7 7 0 0 1 12 4.9V3Zm0 2.9A7 7 0 0 1 17.8 17 7 7 0 1 1 12 5.9Z" fill="currentColor"/></svg>
                    </button>
                </div>
                <div class="ps-map-topbar">
                    <input type="text" class="ps-input ps-input--pill" placeholder="Адрес, метро или место" data-geocode-input>
                    <button class="ps-btn ps-btn-primary ps-btn-sm" type="button" data-geocode-submit>Найти</button>
                </div>
                <div class="ps-map-chips" data-filter-chips>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="only_free" hidden>
                        <span>Только свободные</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="ai_recommended" hidden>
                        <span>AI-рекомендации</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="ev" hidden>
                        <span>EV-зарядка</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="covered" hidden>
                        <span>Крытая</span>
                    </label>
                    <label class="ps-chip" data-chip-toggle>
                        <input type="checkbox" name="is_24_7" hidden>
                        <span>24/7</span>
                    </label>
                </div>
                <div class="ps-geocode-suggestions" data-geocode-suggestions></div>
            </div>
            <div class="ps-map-filters" data-map-filters-container>
                <form class="ps-map-filters-card" data-map-filters>
                    <div class="ps-map-filters-row ps-map-filters-row--slider">
                        <div class="ps-filter-slider" data-price-slider></div>
                        <div class="ps-filter-price" data-price-display>Цена: от 0 ₽ до 1500 ₽</div>
                    </div>
                </form>
            </div>
            <div class="ps-route-hint" data-route-hint>Постройте мини-маршрут до выбранной точки.</div>
        </div>

        <div class="ps-bottom-sheet" data-spots-panel data-route="list">
            <div class="ps-bottom-sheet__handle"></div>
            <div class="ps-bottom-sheet__header">
                <div>
                    <div class="ps-section-title-sm">Доступные места</div>
                    <div class="ps-text-muted">Свободных: <span data-spots-count>{{ spots_total|default:0 }}</span>, ср. цена <span data-avg-price>—</span></div>
                </div>
                <div class="ps-bottom-sheet__actions">
                    <button type="button" class="ps-btn ps-btn-ghost ps-btn-sm" data-reset-filters>Сбросить</button>
                </div>
            </div>
            <div class="ps-bottom-sheet__body">
                <div class="ps-spots-list" data-spots-list>
                    <div class="ps-card ps-card--spot ps-card--skeleton">
                        <div class="ps-skeleton-line ps-skeleton-line--lg"></div>
                        <div class="ps-skeleton-line"></div>
                        <div class="ps-skeleton-line ps-skeleton-line--short"></div>
                    </div>
                </div>
                <div class="ps-bottom-sheet__footer">
                    <button class="ps-btn ps-btn-secondary ps-btn-block" type="button" data-spots-load-more data-route-link="list">Показать ещё</button>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block extra_scripts %}
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <script type="module" src="{% static 'pwa/app.js' %}?v=2024.09"></script>
    <script>
        window.PARKSHARE_MAP_PROVIDER = {
            id: "{{ MAP_PROVIDER|default:'yandex' }}",
            fallback: "{{ MAP_PROVIDER_FALLBACK|default:'leaflet' }}",
            default_center: {{ MAP_DEFAULT_CENTER|safe }},
            default_zoom: {{ MAP_DEFAULT_ZOOM|default:11 }},
        };
    </script>
    {% static 'js/map.js' as map_static %}
    <script src="{{ map_static }}?v=50"></script>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 294
PATH: templates\parking\owner_dashboard.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Владелец — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="parking">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Моя парковка</p>
            <h1 class="ps-section-title">Кабинет владельца</h1>
            <p class="ps-section-subtitle">
                Управляйте объектами, местами и бронированиями в одном мобильном интерфейсе.
            </p>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'map_page' %}" class="ps-btn ps-btn-secondary ps-btn-sm">К карте</a>
        </div>
    </div>
    <div class="ps-chip-row">
        <span class="ps-chip ps-chip--soft">Объектов: {{ lots|length }}</span>
        <span class="ps-chip ps-chip--soft">Мест: {{ spots|length }}</span>
        <span class="ps-chip ps-chip--soft">Брони: {{ bookings|length }}</span>
    </div>

    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Мои объекты</h2>
            </div>
            <ul class="ps-list">
                {% for lot in lots %}
                    <li class="ps-list-item">
                        <div class="ps-list-main">
                            <div class="ps-list-title">
                                {{ lot.city }}, {{ lot.name }}
                            </div>
                            <div class="ps-list-subtitle">
                                {{ lot.get_parking_type_display }} · мест: {{ lot.spots.count }}
                            </div>
                        </div>
                        <span class="ps-badge ps-badge--neutral">
                            {{ lot.created_at|date:"d.m.Y" }}
                        </span>
                    </li>
                {% empty %}
                    <li class="ps-list-empty">
                        Пока нет ни одного объекта. Добавьте парковку через web-интерфейс владельца.
                    </li>
                {% endfor %}
            </ul>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Места</h2>
            </div>
            <ul class="ps-list ps-list--compact">
                {% for spot in spots %}
                    <li class="ps-list-item">
                        <div class="ps-list-main">
                            <div class="ps-list-title">
                                {{ spot.lot.city }}, {{ spot.lot.name }} — {{ spot.name }}
                            </div>
                            <div class="ps-list-subtitle">
                                Тип: {{ spot.get_vehicle_type_display }} · {{ spot.hourly_price }} ₽/ч
                            </div>
                        </div>
                        <span class="ps-badge ps-badge--status-{{ spot.status }}">
                            {{ spot.get_status_display }}
                        </span>
                    </li>
                {% empty %}
                    <li class="ps-list-empty">
                        Мест пока нет.
                    </li>
                {% endfor %}
            </ul>
        </article>
    </div>

    <div class="ps-section">
        <div class="ps-section-header ps-section-header--stack">
            <div>
                <h2 class="ps-section-title">Бронирования по моим местам</h2>
                <p class="ps-section-subtitle">Кто сейчас бронирует и на какие суммы.</p>
            </div>
        </div>
        <div class="ps-reco-list">
            {% for booking in bookings %}
                <article class="ps-reco-card">
                    <div>
                        <div class="ps-reco-title">
                            {{ booking.spot.lot.city }}, {{ booking.spot.lot.name }} — {{ booking.spot.name }}
                        </div>
                        <div class="ps-reco-meta">
                            Пользователь: {{ booking.user.username }}
                        </div>
                        <div class="ps-reco-meta">
                            {{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
                        </div>
                        <div class="ps-reco-meta">
                            Сумма: {{ booking.total_price }} ₽
                        </div>
                    </div>
                    <span class="ps-chip ps-chip--soft">{{ booking.get_status_display }}</span>
                </article>
            {% empty %}
                <div class="ps-empty">
                    По вашим местам ещё не было бронирований.
                </div>
            {% endfor %}
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 295
PATH: templates\parking\payment_methods.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% block title %}Способы оплаты — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="bookings">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Оплата</p>
            <h1 class="ps-section-title">Способы оплаты</h1>
            <p class="ps-section-subtitle">Добавьте карту или кошелёк для быстрых бронирований. Apple/Google Pay поддерживается, если доступно в браузере.</p>
        </div>
        <div class="ps-section-actions">
            <a class="ps-btn ps-btn-ghost ps-btn-sm" href="{% url 'map_page' %}">К карте</a>
        </div>
    </div>

    {% if success %}
        <div class="ps-alert ps-alert--success">{{ success }}</div>
    {% endif %}

    <div class="ps-grid ps-grid--2col ps-grid--gap-lg">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Мои методы</h2>
            </div>
            <div class="ps-card-body ps-card-body--spacing-lg">
                {% if methods %}
                    <ul class="ps-list ps-list--compact">
                        {% for method in methods %}
                            <li class="ps-list-item">
                                <div class="ps-list-main">
                                    <div class="ps-list-title">{{ method.get_brand_display }} ****{{ method.last4 }}</div>
                                    <div class="ps-list-subtitle">Срок: {{ method.exp_month }}/{{ method.exp_year }} {% if method.is_default %}· осн.{% endif %}</div>
                                </div>
                                <form method="post" class="ps-inline-form">
                                    {% csrf_token %}
                                    <input type="hidden" name="delete_id" value="{{ method.id }}">
                                    <button type="submit" class="ps-btn ps-btn-ghost ps-btn-sm">Удалить</button>
                                </form>
                            </li>
                        {% endfor %}
                    </ul>
                {% else %}
                    <div class="ps-empty">Пока нет карт. Добавьте первую, чтобы оплачивать бронирования быстрее.</div>
                {% endif %}
            </div>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Добавить метод оплаты</h2>
            </div>
            <form method="post" class="ps-form ps-card-body ps-card-body--spacing-lg">
                {% csrf_token %}
                <div class="ps-form-row">
                    <label class="ps-form-label">Номер карты</label>
                    <input class="ps-input" type="text" name="card_number" placeholder="4111 1111 1111 1111" required>
                </div>
                <div class="ps-form-row ps-form-row--inline">
                    <input class="ps-input" type="text" name="exp" placeholder="MM/YY" required>
                    <input class="ps-input" type="text" name="label" placeholder="Личная / Работа">
                </div>
                <label class="ps-checkbox">
                    <input type="checkbox" name="is_default">
                    <span>Сделать основным</span>
                </label>
                <div class="ps-form-actions">
                    <button type="submit" class="ps-btn ps-btn-primary ps-btn-full">Сохранить</button>
                </div>
            </form>
        </article>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 296
PATH: templates\parking\profile_settings.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% block title %}Настройки профиля — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="bookings">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Профиль</p>
            <h1 class="ps-section-title">Предпочтения и уведомления</h1>
            <p class="ps-section-subtitle">Ассистент использует эти данные для персонализации поиска парковок.</p>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'user_dashboard' %}" class="ps-btn ps-btn-ghost ps-btn-sm">Назад в кабинет</a>
        </div>
    </div>

    {% if success %}
        <div class="ps-alert ps-alert--success">{{ success }}</div>
    {% endif %}

    <div class="ps-card ps-card--elevated">
        <div class="ps-card-header">
            <h2 class="ps-card-title">Предпочтения парковки</h2>
            <form method="post">
                {% csrf_token %}
                <button class="ps-btn ps-btn-ghost ps-btn-sm" name="reset_prefs" value="1" type="submit">Сбросить</button>
            </form>
        </div>
        <div class="ps-card-body ps-card-body--spacing-lg">
            {% if preferences %}
                <div class="ps-chip-row">
                    {% if preferences.budget_max %}<span class="ps-chip ps-chip--soft">Бюджет: до {{ preferences.budget_max }} ₽/ч</span>{% endif %}
                    {% if preferences.budget_tier %}<span class="ps-chip ps-chip--soft">Тариф: {{ preferences.budget_tier }}</span>{% endif %}
                    {% if preferences.prefers_ev %}<span class="ps-chip ps-chip--success">EV-зарядка</span>{% endif %}
                    {% if preferences.prefers_covered %}<span class="ps-chip">Крытая</span>{% endif %}
                    {% if preferences.prefers_night %}<span class="ps-chip ps-chip--ghost">Ночная парковка</span>{% endif %}
                </div>
            {% else %}
                <div class="ps-empty">Пока нет сохранённых предпочтений. Ассистент запомнит их из вашего диалога.</div>
            {% endif %}
        </div>
    </div>

    <div class="ps-card">
        <div class="ps-card-header">
            <h2 class="ps-card-title">Уведомления</h2>
        </div>
        <form method="post" class="ps-card-body ps-card-body--spacing-lg">
            {% csrf_token %}
            <label class="ps-checkbox">
                <input type="checkbox" name="notify_booking_expiry" {% if notifications.notify_booking_expiry %}checked{% endif %}>
                <span>Напоминать о завершении брони</span>
            </label>
            <label class="ps-checkbox">
                <input type="checkbox" name="notify_night_restrictions" {% if notifications.notify_night_restrictions %}checked{% endif %}>
                <span>Ночные ограничения парковки</span>
            </label>
            <div class="ps-form-actions">
                <button class="ps-btn ps-btn-primary" type="submit">Сохранить</button>
            </div>
        </form>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 297
PATH: templates\parking\promo_activate.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% block title %}Промокоды — ParkShare{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="bookings">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Бонусы</p>
            <h1 class="ps-section-title">Активация промокода</h1>
            <p class="ps-section-subtitle">Получите скидку или бесплатное время парковки.</p>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'user_dashboard' %}" class="ps-btn ps-btn-ghost ps-btn-sm">Личный кабинет</a>
        </div>
    </div>

    {% if message %}
        <div class="ps-alert ps-alert--info">{{ message }}</div>
    {% endif %}

    <div class="ps-card ps-card--elevated">
        <form method="post" class="ps-form ps-card-body ps-card-body--spacing-lg">
            {% csrf_token %}
            <div class="ps-form-row">
                <label class="ps-form-label">Промокод</label>
                <input class="ps-input" type="text" name="code" placeholder="PROMO2024">
            </div>
            <div class="ps-form-actions">
                <button class="ps-btn ps-btn-primary ps-btn-full" type="submit">Активировать</button>
            </div>
        </form>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 298
PATH: templates\parking\pwa_install.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Установить ParkShare как приложение{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <h1 class="ps-section-title">Установите ParkShare RU на главный экран</h1>
            <p class="ps-section-subtitle">PWA работает оффлайн, даёт быстрый доступ к брони и чату.</p>
        </div>
    </div>

    <div class="ps-grid ps-grid--2col@lg ps-grid--gap-lg ps-grid--mobile-stack">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h3 class="ps-card-title">Android / Chrome</h3>
            </div>
            <div class="ps-card-body">
                <ol class="ps-list-ordered">
                    <li>Нажмите <strong>⋮</strong> в правом верхнем углу браузера.</li>
                    <li>Выберите пункт <strong>«Установить приложение»</strong> или <strong>«Добавить на главный экран»</strong>.</li>
                    <li>Подтвердите установку — ярлык появится рядом с другими приложениями.</li>
                </ol>
                <p class="ps-card-line ps-card-line--muted">Если видите баннер установки — нажмите «Установить» прямо в нём.</p>
            </div>
        </article>

        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h3 class="ps-card-title">iOS / Safari</h3>
            </div>
            <div class="ps-card-body">
                <ol class="ps-list-ordered">
                    <li>Нажмите кнопку «Поделиться» (квадрат со стрелкой вверх).</li>
                    <li>Прокрутите список и выберите <strong>«На экран “Домой”»</strong>.</li>
                    <li>Нажмите «Добавить» — появится значок ParkShare.</li>
                </ol>
                <p class="ps-card-line ps-card-line--muted">После добавления приложение работает без адресной строки и занимает весь экран.</p>
            </div>
        </article>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 299
PATH: templates\parking\user_dashboard.html
LANG: html
===== CONTENT START =====
{% extends "base.html" %}
{% load static %}

{% block title %}Брони — ParkShare RU{% endblock %}

{% block content %}
<section class="ps-section ps-section--flush-top" data-route="bookings">
    <div class="ps-section-header ps-section-header--stack">
        <div>
            <p class="ps-kicker">Брони</p>
            <h1 class="ps-section-title">Личный кабинет</h1>
            <p class="ps-section-subtitle">
                Машины, способы оплаты и активные бронирования в одном месте.
            </p>
        </div>
        <div class="ps-section-actions">
            <a href="{% url 'map_page' %}" class="ps-btn ps-btn-secondary ps-btn-sm">Открыть карту</a>
        </div>
    </div>
    <div class="ps-chip-row">
        <span class="ps-chip ps-chip--soft">Роль: {{ user.get_role_display }}</span>
        <span class="ps-chip ps-chip--soft">Брони: {{ bookings|length }}</span>
        <a class="ps-chip ps-chip--ghost" href="{% url 'profile_settings' %}">Предпочтения</a>
    </div>

    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card ps-card--elevated">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Профиль</h2>
                <span class="ps-badge ps-badge--neutral">{{ user.get_role_display }}</span>
            </div>
            <div class="ps-card-body">
                <p class="ps-card-line">
                    <span class="ps-label">Логин:</span> {{ user.username }}
                </p>
                <div class="ps-progress-block">
                    <div class="ps-progress-header">
                        <span class="ps-badge">Уровень {{ level.threshold|default:0 }} · {{ level.name|default:"Новичок" }}</span>
                        {% if next_level %}
                            <span class="ps-progress-label">До следующего уровня: {{ level_remaining }} бронирования</span>
                        {% else %}
                            <span class="ps-progress-label">Максимальный уровень достигнут</span>
                        {% endif %}
                    </div>
                    <div class="ps-progress">
                        <div class="ps-progress-bar" style="width: {{ level_progress|default:0 }}%"></div>
                    </div>
                </div>
                <a href="{% url 'accounts:profile' %}" class="ps-btn ps-btn-full">
                    Настройки профиля
                </a>
            </div>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Способы оплаты</h2>
            </div>
            <div class="ps-card-body ps-card-body--spacing-lg">
                <p class="ps-card-line">Перейдите, чтобы добавить/удалить карту и настроить Apple/Google Pay.</p>
                <a class="ps-btn ps-btn-secondary ps-btn-full" href="{% url 'payment_methods' %}">Управлять способами оплаты</a>
            </div>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Мои машины</h2>
            </div>
            <ul class="ps-list">
                {% for vehicle in vehicles %}
                    <li class="ps-list-item">
                        <div class="ps-list-main">
                            <div class="ps-list-title">
                                {{ vehicle.label|default:"Без названия" }}
                            </div>
                            <div class="ps-list-subtitle">
                                {{ vehicle.get_vehicle_type_display }}
                            </div>
                        </div>
                        <span class="ps-badge ps-badge--neutral">
                            {{ vehicle.created_at|date:"d.m.Y" }}
                        </span>
                    </li>
                {% empty %}
                    <li class="ps-list-empty">
                        Пока ни одной машины. Добавьте машину через мобильный интерфейс ParkShare RU.
                    </li>
                {% endfor %}
            </ul>
        </article>
    </div>

    <div class="ps-grid ps-grid--gap-lg ps-grid--2col">
        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Бейджи</h2>
            </div>
            <div class="ps-card-body ps-card-body--spacing-lg">
                {% if badges %}
                    <div class="ps-chip-row">
                        {% for badge in badges %}
                            <span class="ps-chip ps-chip--soft">{{ badge.title }}</span>
                        {% endfor %}
                    </div>
                {% else %}
                    <div class="ps-empty">Пока без бейджей. Выполните бронирования, чтобы заработать их.</div>
                {% endif %}
            </div>
        </article>

        <article class="ps-card">
            <div class="ps-card-header">
                <h2 class="ps-card-title">Промокоды</h2>
            </div>
            <div class="ps-card-body ps-card-body--spacing-lg">
                <p class="ps-card-line ps-card-line--muted">Активируйте промокод для скидки или бонусного времени.</p>
                <a class="ps-btn ps-btn-primary ps-btn-full" href="{% url 'promo_activate' %}">Активировать промокод</a>
            </div>
        </article>
    </div>

    <div class="ps-section">
        <div class="ps-section-header ps-section-header--stack">
            <div>
                <h2 class="ps-section-title">Мои бронирования</h2>
                <p class="ps-section-subtitle">История и активные сессии с быстрыми действиями.</p>
            </div>
        </div>
        <div class="ps-reco-list">
            {% for booking in bookings %}
                <article class="ps-reco-card ps-animate-fade-up">
                    <div>
                        <div class="ps-reco-title">
                            {{ booking.spot.lot.city }}, {{ booking.spot.lot.name }} — {{ booking.spot.name }}
                        </div>
                        <div class="ps-reco-meta">
                            {{ booking.get_booking_type_display }} · {{ booking.start_at|date:"d.m H:i" }} → {{ booking.end_at|date:"d.m H:i" }}
                        </div>
                        <div class="ps-reco-meta">
                            Сумма: {{ booking.total_price }} ₽
                        </div>
                        <div class="ps-reco-actions">
                            <a href="{% url 'map_page' %}" class="ps-btn ps-btn-secondary ps-btn-sm">На карте</a>
                            <a href="{% url 'ai_chat' %}" class="ps-btn ps-btn-ghost ps-btn-sm">Спросить ассистента</a>
                        </div>
                    </div>
                    <span class="ps-chip ps-chip--soft">{{ booking.get_status_display }}</span>
                </article>
            {% empty %}
                <div class="ps-empty">У вас пока нет бронирований.</div>
            {% endfor %}
        </div>
    </div>
</section>
{% endblock %}

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 300
PATH: vehicles\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 301
PATH: vehicles\admin.py
LANG: python
===== CONTENT START =====
# vehicles/admin.py

from django.contrib import admin

from .models import Vehicle


@admin.register(Vehicle)
class VehicleAdmin(admin.ModelAdmin):
    list_display = ("label", "owner", "vehicle_type", "created_at")
    list_filter = ("vehicle_type", "created_at")
    search_fields = ("label", "owner__username")
    readonly_fields = ("plate_hash", "created_at")

    def has_view_or_change_permission(self, request, obj=None):
        """
        В админку по умолчанию имеет доступ только персонал,
        так что дополнительных ограничений не вводим.
        """
        return super().has_view_or_change_permission(request, obj)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 302
PATH: vehicles\apps.py
LANG: python
===== CONTENT START =====
# vehicles/apps.py

from django.apps import AppConfig


class VehiclesConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "vehicles"
    verbose_name = "Машины пользователей"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 303
PATH: vehicles\models.py
LANG: python
===== CONTENT START =====
import uuid

from django.conf import settings
from django.db import models
from django.utils.translation import gettext_lazy as _

from core.models import TimeStampedModel


class Vehicle(TimeStampedModel):
    """
    Машина пользователя.

    Важно:
    - реальный госномер нигде не хранится;
    - в БД есть только хэш цифр номера и произвольная метка (label).
    """

    class VehicleType(models.TextChoices):
        CAR = "car", _("Легковой автомобиль")
        MOTO = "moto", _("Мотоцикл")
        COMMERCIAL = "commercial", _("Коммерческий транспорт")

    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="vehicles",
        verbose_name=_("Владелец"),
    )
    label = models.CharField(
        _("Название/описание"),
        max_length=64,
        blank=True,
        help_text=_("Например: «Серая Toyota у дома»."),
    )
    vehicle_type = models.CharField(
        _("Тип транспорта"),
        max_length=16,
        choices=VehicleType.choices,
        default=VehicleType.CAR,
    )
    plate_hash = models.CharField(
        _("Хэш номера"),
        max_length=64,
        db_index=True,
        help_text=_("SHA‑256‑хэш цифр госномера с солью."),
    )

    class Meta:
        verbose_name = _("Машина")
        verbose_name_plural = _("Машины")
        unique_together = (("owner", "plate_hash"),)
        ordering = ("-created_at",)

    def __str__(self) -> str:
        if self.label:
            return f"{self.label} ({self.owner.username})"
        return f"Машина {self.pk}"

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 304
PATH: vehicles\serializers.py
LANG: python
===== CONTENT START =====
# vehicles/serializers.py

from django.utils.translation import gettext_lazy as _
from rest_framework import serializers

from core.utils import hash_plate_digits
from .models import Vehicle


class VehicleSerializer(serializers.ModelSerializer):
    """
    Сериализатор для машин.

    Вход:
    - plate_number (write_only) — строка номера, хэшируется на сервере;
    - label, vehicle_type.

    Выход:
    - id, label, vehicle_type, created_at.
    """

    plate_number = serializers.CharField(
        write_only=True,
        label=_("Госномер"),
        help_text=_(
            "Фактический номер будет преобразован в хэш и не будет храниться в открытом виде."
        ),
    )

    class Meta:
        model = Vehicle
        fields = ("id", "label", "vehicle_type", "plate_number", "created_at")
        read_only_fields = ("id", "created_at")

    def validate_plate_number(self, value: str) -> str:
        digits = "".join(ch for ch in value if ch.isdigit())
        if not digits:
            raise serializers.ValidationError(
                _("Нужно указать хотя бы одну цифру номера.")
            )
        return value

    def create(self, validated_data: dict) -> Vehicle:
        request = self.context["request"]
        user = request.user
        plate_number = validated_data.pop("plate_number")
        plate_hash = hash_plate_digits(plate_number)
        if Vehicle.objects.filter(owner=user, plate_hash=plate_hash).exists():
            raise serializers.ValidationError(
                {
                    "plate_number": _(
                        "Машина с таким номером уже добавлена в ваш список."
                    )
                }
            )
        vehicle = Vehicle.objects.create(
            owner=user,
            plate_hash=plate_hash,
            **validated_data,
        )
        return vehicle

    def update(self, instance: Vehicle, validated_data: dict) -> Vehicle:
        # Номер менять нельзя (потребует создания нового объекта),
        # поэтому игнорируем plate_number при обновлении.
        validated_data.pop("plate_number", None)
        return super().update(instance, validated_data)

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 305
PATH: vehicles\urls.py
LANG: python
===== CONTENT START =====
# vehicles/urls.py

from django.contrib.auth.decorators import login_required
from django.urls import path
from django.views.generic import TemplateView

app_name = "vehicles"

urlpatterns = [
    # Простая HTML-страница «Мои машины» (можно использовать в будущем).
    path(
        "my/",
        login_required(
            TemplateView.as_view(template_name="vehicles/my_vehicles.html")
        ),
        name="my_vehicles",
    ),
]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 306
PATH: vehicles\views.py
LANG: python
===== CONTENT START =====
# vehicles/views.py

from rest_framework import permissions, viewsets

from core.permissions import IsOwnerObject
from .models import Vehicle
from .serializers import VehicleSerializer


class VehicleViewSet(viewsets.ModelViewSet):
    """
    API для машин пользователя.

    - /api/vehicles/              (GET)   — список машин текущего пользователя
    - /api/vehicles/              (POST)  — создать машину (номер хэшируется)
    - /api/vehicles/{id}/         (GET)   — детали (только владелец)
    - /api/vehicles/{id}/         (PATCH/PUT/DELETE) — управление машиной (только владелец)
    """

    serializer_class = VehicleSerializer
    permission_classes = [permissions.IsAuthenticated, IsOwnerObject]

    def get_queryset(self):
        user = self.request.user
        if not user.is_authenticated:
            return Vehicle.objects.none()
        return Vehicle.objects.filter(owner=user).order_by("-created_at")

    def perform_create(self, serializer: VehicleSerializer) -> None:
        # owner устанавливается в serializer.create()
        serializer.save()

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 307
PATH: vehicles\migrations\0001_initial.py
LANG: python
===== CONTENT START =====
# Generated by Django 5.2.8 on 2025-11-21 21:34

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Vehicle',
            fields=[
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Дата создания')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Дата обновления')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('label', models.CharField(blank=True, help_text='Например: «Серая Toyota у дома».', max_length=64, verbose_name='Название/описание')),
                ('vehicle_type', models.CharField(choices=[('car', 'Легковой автомобиль'), ('moto', 'Мотоцикл'), ('commercial', 'Коммерческий транспорт')], default='car', max_length=16, verbose_name='Тип транспорта')),
                ('plate_hash', models.CharField(db_index=True, help_text='SHA‑256‑хэш цифр госномера с солью.', max_length=64, verbose_name='Хэш номера')),
                ('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='vehicles', to=settings.AUTH_USER_MODEL, verbose_name='Владелец')),
            ],
            options={
                'verbose_name': 'Машина',
                'verbose_name_plural': 'Машины',
                'ordering': ('-created_at',),
                'unique_together': {('owner', 'plate_hash')},
            },
        ),
    ]

===== CONTENT END =====
===== FILE END =====

===== FILE START =====
FILE_INDEX: 308
PATH: vehicles\migrations\__init__.py
LANG: python
===== CONTENT START =====

===== CONTENT END =====
===== FILE END =====

